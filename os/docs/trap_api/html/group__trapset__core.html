<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Trap API: CORE</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Trap API
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__trapset__core.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">CORE<div class="ingroups"><a class="el" href="group__api.html">Customer Trap API</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gafb642634557cf5ffb084d67405fb436b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#gafb642634557cf5ffb084d67405fb436b">AdcReadRequest</a> (<a class="el" href="message___8h.html#a51d7b6544fb734b892b35ce3f56a579a">Task</a> task, vm_adc_source_type adc_source, vm_adc_extra_flag extra_flag, uint16 delay)</td></tr>
<tr class="memdesc:gafb642634557cf5ffb084d67405fb436b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to ADC hardware.  <a href="#gafb642634557cf5ffb084d67405fb436b">More...</a><br /></td></tr>
<tr class="separator:gafb642634557cf5ffb084d67405fb436b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3e35c0656bfb571dfdae7b0e023ac99"><td class="memItemLeft" align="right" valign="top">uint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#gae3e35c0656bfb571dfdae7b0e023ac99">BootGetMode</a> (void)</td></tr>
<tr class="memdesc:gae3e35c0656bfb571dfdae7b0e023ac99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control booting BlueCore with different active settings.  <a href="#gae3e35c0656bfb571dfdae7b0e023ac99">More...</a><br /></td></tr>
<tr class="separator:gae3e35c0656bfb571dfdae7b0e023ac99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa693d6a69705350d809fc774ceba7ff"><td class="memItemLeft" align="right" valign="top">uint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#gafa693d6a69705350d809fc774ceba7ff">BootGetPreservedWord</a> (void)</td></tr>
<tr class="memdesc:gafa693d6a69705350d809fc774ceba7ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the (single) word preserved between boots.  <a href="#gafa693d6a69705350d809fc774ceba7ff">More...</a><br /></td></tr>
<tr class="separator:gafa693d6a69705350d809fc774ceba7ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ca590d41150774c4679511d07f1f7f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#ga2ca590d41150774c4679511d07f1f7f0">BootSetMode</a> (uint16 newBootmode)</td></tr>
<tr class="memdesc:ga2ca590d41150774c4679511d07f1f7f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the mode and force a reboot (warm reset) of the chip using the boot image bank.  <a href="#ga2ca590d41150774c4679511d07f1f7f0">More...</a><br /></td></tr>
<tr class="separator:ga2ca590d41150774c4679511d07f1f7f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga382b9b637395b616624b9092e09b25aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#ga382b9b637395b616624b9092e09b25aa">BootSetPreservedWord</a> (uint16 state)</td></tr>
<tr class="memdesc:ga382b9b637395b616624b9092e09b25aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the (single) word preserved between boots.  <a href="#ga382b9b637395b616624b9092e09b25aa">More...</a><br /></td></tr>
<tr class="separator:ga382b9b637395b616624b9092e09b25aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga143374b3a01ecc01a26475f8cb5f9bb0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#ga143374b3a01ecc01a26475f8cb5f9bb0">DormantConfigure</a> (dormant_config_key key, uint32 value)</td></tr>
<tr class="memdesc:ga143374b3a01ecc01a26475f8cb5f9bb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the dormant mode. All the configurable settings are defined in #dormant_config_key.  <a href="#ga143374b3a01ecc01a26475f8cb5f9bb0">More...</a><br /></td></tr>
<tr class="separator:ga143374b3a01ecc01a26475f8cb5f9bb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25121fb3858e082482d8c917b0235720"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#ga25121fb3858e082482d8c917b0235720">FeatureVerifyLicense</a> (feature_id feature)</td></tr>
<tr class="memdesc:ga25121fb3858e082482d8c917b0235720"><td class="mdescLeft">&#160;</td><td class="mdescRight">Related to licensing of new features.  <a href="#ga25121fb3858e082482d8c917b0235720">More...</a><br /></td></tr>
<tr class="separator:ga25121fb3858e082482d8c917b0235720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0eab47e690c54a8d8ccd258103642c28"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#ga0eab47e690c54a8d8ccd258103642c28">LoaderModeEnter</a> (void)</td></tr>
<tr class="memdesc:ga0eab47e690c54a8d8ccd258103642c28"><td class="mdescLeft">&#160;</td><td class="mdescRight">This API will reboot the firmware in "loader" mode. This trap can be used to trigger a DFU process based on an external event, for example: " A combination
 of keys being pressed at the device".  <a href="#ga0eab47e690c54a8d8ccd258103642c28">More...</a><br /></td></tr>
<tr class="separator:ga0eab47e690c54a8d8ccd258103642c28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ee6210afa6e7422698e4b769dc5f6c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#ga1ee6210afa6e7422698e4b769dc5f6c8">LoaderPerformDfuFromSqif</a> (uint16 partition)</td></tr>
<tr class="memdesc:ga1ee6210afa6e7422698e4b769dc5f6c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reboots the firmware in "loader" mode to perform DFU from SQIF operation This trap can be used to trigger the DFU process from SQIF after the VM application writes the DFU file onto one of the serial flash partitions. Partition type should be a raw partition type. Once the DFU process is over and the device reboots back into "stack" mode, the VM application's system task then receives MESSAGE_DFU_SQIF_STATUS message containing the status of DFU operation. If there is a power loss during the DFU process, the VM application will not receive the MESSAGE_DFU_SQIF_STATUS message.  <a href="#ga1ee6210afa6e7422698e4b769dc5f6c8">More...</a><br /></td></tr>
<tr class="separator:ga1ee6210afa6e7422698e4b769dc5f6c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6dcd584c07addfbbd068a0498c7c817d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#ga6dcd584c07addfbbd068a0498c7c817d">MessageCancelFirst</a> (<a class="el" href="message___8h.html#a51d7b6544fb734b892b35ce3f56a579a">Task</a> task, <a class="el" href="message___8h.html#aa135f64d9b1113995d9335c8e9314d95">MessageId</a> id)</td></tr>
<tr class="memdesc:ga6dcd584c07addfbbd068a0498c7c817d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel the first queued message with the given task and message id.  <a href="#ga6dcd584c07addfbbd068a0498c7c817d">More...</a><br /></td></tr>
<tr class="separator:ga6dcd584c07addfbbd068a0498c7c817d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e7e761f76a8dc42e40f6693514f3da0"><td class="memItemLeft" align="right" valign="top">uint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#ga5e7e761f76a8dc42e40f6693514f3da0">MessageFlushTask</a> (<a class="el" href="message___8h.html#a51d7b6544fb734b892b35ce3f56a579a">Task</a> task)</td></tr>
<tr class="memdesc:ga5e7e761f76a8dc42e40f6693514f3da0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel all queued messages (independent of id) for the given task. Normally used as part of the process of freeing a task. This function will also stop the task being registered with the firmware as the recipient of any system messages.  <a href="#ga5e7e761f76a8dc42e40f6693514f3da0">More...</a><br /></td></tr>
<tr class="separator:ga5e7e761f76a8dc42e40f6693514f3da0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab073d6e18fc7734b64b17adf1f36fece"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#gab073d6e18fc7734b64b17adf1f36fece">MessageFree</a> (<a class="el" href="message___8h.html#aa135f64d9b1113995d9335c8e9314d95">MessageId</a> id, <a class="el" href="message___8h.html#acc69ef471490ab4c4bfd1e511aba5c74">Message</a> data)</td></tr>
<tr class="memdesc:gab073d6e18fc7734b64b17adf1f36fece"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the memory pointer to by data.  <a href="#gab073d6e18fc7734b64b17adf1f36fece">More...</a><br /></td></tr>
<tr class="separator:gab073d6e18fc7734b64b17adf1f36fece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbb9fcff871c16cf57f12847e26abed4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#gadbb9fcff871c16cf57f12847e26abed4">MessagePendingFirst</a> (<a class="el" href="message___8h.html#a51d7b6544fb734b892b35ce3f56a579a">Task</a> task, <a class="el" href="message___8h.html#aa135f64d9b1113995d9335c8e9314d95">MessageId</a> id, int32 *first_due)</td></tr>
<tr class="memdesc:gadbb9fcff871c16cf57f12847e26abed4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search the message queue for the first specified message pending delivery to the specified task.  <a href="#gadbb9fcff871c16cf57f12847e26abed4">More...</a><br /></td></tr>
<tr class="separator:gadbb9fcff871c16cf57f12847e26abed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a491ae8deeebdcb69fc57f3c6f4d1cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="message___8h.html#a51d7b6544fb734b892b35ce3f56a579a">Task</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#ga3a491ae8deeebdcb69fc57f3c6f4d1cd">MessagePioTask</a> (<a class="el" href="message___8h.html#a51d7b6544fb734b892b35ce3f56a579a">Task</a> task)</td></tr>
<tr class="memdesc:ga3a491ae8deeebdcb69fc57f3c6f4d1cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a task to handle PIO changes.  <a href="#ga3a491ae8deeebdcb69fc57f3c6f4d1cd">More...</a><br /></td></tr>
<tr class="separator:ga3a491ae8deeebdcb69fc57f3c6f4d1cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa608780f111499c54dbde65797a25e82"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#gaa608780f111499c54dbde65797a25e82">MessageSendConditionally</a> (<a class="el" href="message___8h.html#a51d7b6544fb734b892b35ce3f56a579a">Task</a> t, <a class="el" href="message___8h.html#aa135f64d9b1113995d9335c8e9314d95">MessageId</a> id, <a class="el" href="message___8h.html#acc69ef471490ab4c4bfd1e511aba5c74">Message</a> m, const uint16 *c)</td></tr>
<tr class="memdesc:gaa608780f111499c54dbde65797a25e82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a message to be be delivered when the corresponding uint16 is zero.  <a href="#gaa608780f111499c54dbde65797a25e82">More...</a><br /></td></tr>
<tr class="separator:gaa608780f111499c54dbde65797a25e82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f39613be3d1455b29e6ed560e692c1c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#ga0f39613be3d1455b29e6ed560e692c1c">MessageSendLater</a> (<a class="el" href="message___8h.html#a51d7b6544fb734b892b35ce3f56a579a">Task</a> task, <a class="el" href="message___8h.html#aa135f64d9b1113995d9335c8e9314d95">MessageId</a> id, void *message, uint32 delay)</td></tr>
<tr class="memdesc:ga0f39613be3d1455b29e6ed560e692c1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a message to the corresponding task after the given delay in ms. The message will be passed to free after delivery.  <a href="#ga0f39613be3d1455b29e6ed560e692c1c">More...</a><br /></td></tr>
<tr class="separator:ga0f39613be3d1455b29e6ed560e692c1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb6312b84d032d71479a6894f092fa0b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#gadb6312b84d032d71479a6894f092fa0b">MessageSendMulticastConditionally</a> (<a class="el" href="message___8h.html#a51d7b6544fb734b892b35ce3f56a579a">Task</a> *tlist, <a class="el" href="message___8h.html#aa135f64d9b1113995d9335c8e9314d95">MessageId</a> id, <a class="el" href="message___8h.html#acc69ef471490ab4c4bfd1e511aba5c74">Message</a> m, const uint16 *c)</td></tr>
<tr class="memdesc:gadb6312b84d032d71479a6894f092fa0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a message to be be delivered when the corresponding uint16 is zero.  <a href="#gadb6312b84d032d71479a6894f092fa0b">More...</a><br /></td></tr>
<tr class="separator:gadb6312b84d032d71479a6894f092fa0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6c1dcd05bf9acf829d645a954d86964"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#gad6c1dcd05bf9acf829d645a954d86964">MessageSendMulticastLater</a> (<a class="el" href="message___8h.html#a51d7b6544fb734b892b35ce3f56a579a">Task</a> *tasks, <a class="el" href="message___8h.html#aa135f64d9b1113995d9335c8e9314d95">MessageId</a> id, void *message, uint32 delay)</td></tr>
<tr class="memdesc:gad6c1dcd05bf9acf829d645a954d86964"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a message to the corresponding tasks after the given delay in ms. The message will be passed to free after delivery.  <a href="#gad6c1dcd05bf9acf829d645a954d86964">More...</a><br /></td></tr>
<tr class="separator:gad6c1dcd05bf9acf829d645a954d86964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04c5032d8f7be7ce07da6ee9f41244b3"><td class="memItemLeft" align="right" valign="top">uint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#ga04c5032d8f7be7ce07da6ee9f41244b3">MessagesPendingForTask</a> (<a class="el" href="message___8h.html#a51d7b6544fb734b892b35ce3f56a579a">Task</a> task, int32 *first_due)</td></tr>
<tr class="memdesc:ga04c5032d8f7be7ce07da6ee9f41244b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search the message queue for all messages pending delivery to the specified task.  <a href="#ga04c5032d8f7be7ce07da6ee9f41244b3">More...</a><br /></td></tr>
<tr class="separator:ga04c5032d8f7be7ce07da6ee9f41244b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd1023998e25adee54f220a8d71736ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="message___8h.html#a51d7b6544fb734b892b35ce3f56a579a">Task</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#gabd1023998e25adee54f220a8d71736ae">MessageSystemTask</a> (<a class="el" href="message___8h.html#a51d7b6544fb734b892b35ce3f56a579a">Task</a> task)</td></tr>
<tr class="memdesc:gabd1023998e25adee54f220a8d71736ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a task to handle system-wide messages.  <a href="#gabd1023998e25adee54f220a8d71736ae">More...</a><br /></td></tr>
<tr class="separator:gabd1023998e25adee54f220a8d71736ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77b36f30530a6cd62a2e0f34a787063c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#ga77b36f30530a6cd62a2e0f34a787063c">MessageWait</a> (void *m)</td></tr>
<tr class="memdesc:ga77b36f30530a6cd62a2e0f34a787063c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block waiting for the next message. This function will either:  <a href="#ga77b36f30530a6cd62a2e0f34a787063c">More...</a><br /></td></tr>
<tr class="separator:ga77b36f30530a6cd62a2e0f34a787063c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f71ebda91fa4b2a1f9e536e6e93026e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#ga1f71ebda91fa4b2a1f9e536e6e93026e">OsInit</a> (void)</td></tr>
<tr class="memdesc:ga1f71ebda91fa4b2a1f9e536e6e93026e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialises the P1 Operating System. Must be called before doing anything else.  <a href="#ga1f71ebda91fa4b2a1f9e536e6e93026e">More...</a><br /></td></tr>
<tr class="separator:ga1f71ebda91fa4b2a1f9e536e6e93026e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e04428a714d6c8c97cb8685f96933ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#ga1e04428a714d6c8c97cb8685f96933ee">Panic</a> (void)</td></tr>
<tr class="memdesc:ga1e04428a714d6c8c97cb8685f96933ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Panics the application unconditionally.  <a href="#ga1e04428a714d6c8c97cb8685f96933ee">More...</a><br /></td></tr>
<tr class="separator:ga1e04428a714d6c8c97cb8685f96933ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad521eaeab7a57e2afcf52019a0e1670a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#gad521eaeab7a57e2afcf52019a0e1670a">PanicNotNull</a> (const void *)</td></tr>
<tr class="memdesc:gad521eaeab7a57e2afcf52019a0e1670a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Panics the application if the pointer passed is not NULL, otherwise returns.  <a href="#gad521eaeab7a57e2afcf52019a0e1670a">More...</a><br /></td></tr>
<tr class="separator:gad521eaeab7a57e2afcf52019a0e1670a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f213a19d903e302c9772792603d7874"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#ga5f213a19d903e302c9772792603d7874">PanicNull</a> (void *)</td></tr>
<tr class="memdesc:ga5f213a19d903e302c9772792603d7874"><td class="mdescLeft">&#160;</td><td class="mdescRight">Panics the application if the pointer passed is NULL, otherwise returns the pointer.  <a href="#ga5f213a19d903e302c9772792603d7874">More...</a><br /></td></tr>
<tr class="separator:ga5f213a19d903e302c9772792603d7874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2cbbcab5783657bfe528a818be2eaa4"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#gac2cbbcab5783657bfe528a818be2eaa4">PanicUnlessMalloc</a> (size_t sz)</td></tr>
<tr class="memdesc:gac2cbbcab5783657bfe528a818be2eaa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates sz words and returns a pointer to the memory if successful. If the memory allocation fails, the application is panicked.  <a href="#gac2cbbcab5783657bfe528a818be2eaa4">More...</a><br /></td></tr>
<tr class="separator:gac2cbbcab5783657bfe528a818be2eaa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae422dd475550e0305818cd7c0fd521f5"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#gae422dd475550e0305818cd7c0fd521f5">PioDebounce32</a> (uint32 mask, uint16 count, uint16 period)</td></tr>
<tr class="memdesc:gae422dd475550e0305818cd7c0fd521f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access BlueCore I/O lines.  <a href="#gae422dd475550e0305818cd7c0fd521f5">More...</a><br /></td></tr>
<tr class="separator:gae422dd475550e0305818cd7c0fd521f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab20a5012dcde3b261ac0c02ea315cc49"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#gab20a5012dcde3b261ac0c02ea315cc49">PioDebounce32Bank</a> (uint16 bank, uint32 mask, uint16 count, uint16 period)</td></tr>
<tr class="memdesc:gab20a5012dcde3b261ac0c02ea315cc49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure PIO monitoring. This function configures a simple debounce engine for PIO input pins. It can detect transitions on PIOs and return stabilised readings for them, filtering out glitches. When the engine detects a change in state of one or more of the monitored pins, it repeatedly reads the pin state. If the state of all the monitored pins remains unchanged for <em>count</em> successive samples, it is considered stable and a #MESSAGE_PIO_CHANGED message is sent to the task registered with <a class="el" href="group__trapset__core.html#ga3a491ae8deeebdcb69fc57f3c6f4d1cd" title="Register a task to handle PIO changes. ">MessagePioTask()</a>. Calling PioDebounce32Bank has the same behaviour as calling PioDebounceGroup32Bank using group 0.  <a href="#gab20a5012dcde3b261ac0c02ea315cc49">More...</a><br /></td></tr>
<tr class="separator:gab20a5012dcde3b261ac0c02ea315cc49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga824a46697f21bb2c9b9305b671dda178"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#ga824a46697f21bb2c9b9305b671dda178">PioDebounceGroup32Bank</a> (uint16 group, uint16 bank, uint32 mask, uint16 count, uint16 period)</td></tr>
<tr class="memdesc:ga824a46697f21bb2c9b9305b671dda178"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure PIO monitoring. This function configures a simple debounce engine for PIO input pins. It can detect transitions on PIOs and return stabilised readings for them, filtering out glitches. It supports two distinct groups of PIOs. The settings apply to all the selected PIOs in a group. A PIO can belong in both groups at the same time and will fulfill both functions. When the engine detects a change in state of one or more of the monitored pins, it repeatedly reads the pin state. If the state of all the monitored pins remains unchanged for <em>count</em> successive samples, it is considered stable and a #MESSAGE_PIO_CHANGED message is sent to the task registered with <a class="el" href="group__trapset__core.html#ga3a491ae8deeebdcb69fc57f3c6f4d1cd" title="Register a task to handle PIO changes. ">MessagePioTask()</a>.  <a href="#ga824a46697f21bb2c9b9305b671dda178">More...</a><br /></td></tr>
<tr class="separator:ga824a46697f21bb2c9b9305b671dda178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga331b12d7aded7665e97b71dd8bff2394"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#ga331b12d7aded7665e97b71dd8bff2394">PioGet32</a> (void)</td></tr>
<tr class="memdesc:ga331b12d7aded7665e97b71dd8bff2394"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the contents of the PIO data input register. For PIOs set as outputs, this function will return the value last written using <a class="el" href="group__trapset__core.html#gab8b6a9c39b5548acf9502dac2e3d0460" title="Modifies the contents of the PIO data output register. PIO pins must be set to outputs via PioSetDir3...">PioSet32()</a>.  <a href="#ga331b12d7aded7665e97b71dd8bff2394">More...</a><br /></td></tr>
<tr class="separator:ga331b12d7aded7665e97b71dd8bff2394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8923976e553cfccb3046dd83eec70b07"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#ga8923976e553cfccb3046dd83eec70b07">PioGet32Bank</a> (uint16 bank)</td></tr>
<tr class="memdesc:ga8923976e553cfccb3046dd83eec70b07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the contents of one of the PIO data input registers. For PIOs set as outputs, this function will return the value last written using <a class="el" href="group__trapset__core.html#ga075bb2aa0eb39cdcc3a79df1858dd9c5" title="Modifies the contents of the PIO data output register. PIO pins must be set to outputs via PioSetDir3...">PioSet32Bank()</a>.  <a href="#ga8923976e553cfccb3046dd83eec70b07">More...</a><br /></td></tr>
<tr class="separator:ga8923976e553cfccb3046dd83eec70b07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe5055c2acd1ff98af305445fd702b71"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#gafe5055c2acd1ff98af305445fd702b71">PioGetDir32</a> (void)</td></tr>
<tr class="memdesc:gafe5055c2acd1ff98af305445fd702b71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read whether PIOs are set as inputs or outputs.  <a href="#gafe5055c2acd1ff98af305445fd702b71">More...</a><br /></td></tr>
<tr class="separator:gafe5055c2acd1ff98af305445fd702b71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga073ee23b4eced6eca1c6d53096115766"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#ga073ee23b4eced6eca1c6d53096115766">PioGetDir32Bank</a> (uint16 bank)</td></tr>
<tr class="memdesc:ga073ee23b4eced6eca1c6d53096115766"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read whether PIOs are set as inputs or outputs.  <a href="#ga073ee23b4eced6eca1c6d53096115766">More...</a><br /></td></tr>
<tr class="separator:ga073ee23b4eced6eca1c6d53096115766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44a67a64875119f87e27484622a41597"><td class="memItemLeft" align="right" valign="top">pin_drive_strength_id&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#ga44a67a64875119f87e27484622a41597">PioGetDriveStrength</a> (uint16 pin)</td></tr>
<tr class="memdesc:ga44a67a64875119f87e27484622a41597"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the drive strength setting of a particular PIO pin.  <a href="#ga44a67a64875119f87e27484622a41597">More...</a><br /></td></tr>
<tr class="separator:ga44a67a64875119f87e27484622a41597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac90327f5c3f39279c06b090bcb17dc95"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#gac90327f5c3f39279c06b090bcb17dc95">PioGetMapPins32</a> (void)</td></tr>
<tr class="memdesc:gac90327f5c3f39279c06b090bcb17dc95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a 32 bit value showing which PIO lines have been mapped to chip pins (see documentation for <a class="el" href="group__trapset__core.html#ga7451bed3c1711348d8d7cf8abc3ff3fb" title="Maps PIOs as software or hardware controlled. Before using a PIO as a software controlled digital IO ...">PioSetMapPins32()</a> for more detail).  <a href="#gac90327f5c3f39279c06b090bcb17dc95">More...</a><br /></td></tr>
<tr class="separator:gac90327f5c3f39279c06b090bcb17dc95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8b6d38e1472f9ef2e2774fdb1f517c5"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#gaa8b6d38e1472f9ef2e2774fdb1f517c5">PioGetMapPins32Bank</a> (uint16 bank)</td></tr>
<tr class="memdesc:gaa8b6d38e1472f9ef2e2774fdb1f517c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a 32 bit value showing which PIO lines have been mapped to chip pins (see documentation for <a class="el" href="group__trapset__core.html#ga7451bed3c1711348d8d7cf8abc3ff3fb" title="Maps PIOs as software or hardware controlled. Before using a PIO as a software controlled digital IO ...">PioSetMapPins32()</a> for more detail).  <a href="#gaa8b6d38e1472f9ef2e2774fdb1f517c5">More...</a><br /></td></tr>
<tr class="separator:gaa8b6d38e1472f9ef2e2774fdb1f517c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad115c4b2f6289e82b479bed1e4a07214"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#gad115c4b2f6289e82b479bed1e4a07214">PioGetStrongBias32</a> (void)</td></tr>
<tr class="memdesc:gad115c4b2f6289e82b479bed1e4a07214"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read whether PIOs are set to use strong or weak pull.  <a href="#gad115c4b2f6289e82b479bed1e4a07214">More...</a><br /></td></tr>
<tr class="separator:gad115c4b2f6289e82b479bed1e4a07214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e986c442c71151c658ba595abb3f087"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#ga8e986c442c71151c658ba595abb3f087">PioGetStrongBias32Bank</a> (uint16 bank)</td></tr>
<tr class="memdesc:ga8e986c442c71151c658ba595abb3f087"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read whether PIOs are set to use strong or weak pull.  <a href="#ga8e986c442c71151c658ba595abb3f087">More...</a><br /></td></tr>
<tr class="separator:ga8e986c442c71151c658ba595abb3f087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54513e8eb01f7347c2f25f0fd88f2942"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#ga54513e8eb01f7347c2f25f0fd88f2942">PioGetUnusedPins32</a> (void)</td></tr>
<tr class="memdesc:ga54513e8eb01f7347c2f25f0fd88f2942"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine which physically existing PIOs are currently not in use by firmware or VM apps.  <a href="#ga54513e8eb01f7347c2f25f0fd88f2942">More...</a><br /></td></tr>
<tr class="separator:ga54513e8eb01f7347c2f25f0fd88f2942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa17c4d391f04896e8f34d0506d05b02e"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#gaa17c4d391f04896e8f34d0506d05b02e">PioGetUnusedPins32Bank</a> (uint16 bank)</td></tr>
<tr class="memdesc:gaa17c4d391f04896e8f34d0506d05b02e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine which physically existing PIOs are currently not in use by firmware or VM apps.  <a href="#gaa17c4d391f04896e8f34d0506d05b02e">More...</a><br /></td></tr>
<tr class="separator:gaa17c4d391f04896e8f34d0506d05b02e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8b6a9c39b5548acf9502dac2e3d0460"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#gab8b6a9c39b5548acf9502dac2e3d0460">PioSet32</a> (uint32 mask, uint32 bits)</td></tr>
<tr class="memdesc:gab8b6a9c39b5548acf9502dac2e3d0460"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifies the contents of the PIO data output register. PIO pins must be set to outputs via <a class="el" href="group__trapset__core.html#gac5d01f1a8a23db805b3062a2fd1e2ae7" title="Set PIOs as inputs or outputs. ">PioSetDir32()</a> before they can be driven high or low through this trap. This trap also sets pull direction for PIOs used as inputs.  <a href="#gab8b6a9c39b5548acf9502dac2e3d0460">More...</a><br /></td></tr>
<tr class="separator:gab8b6a9c39b5548acf9502dac2e3d0460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga075bb2aa0eb39cdcc3a79df1858dd9c5"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#ga075bb2aa0eb39cdcc3a79df1858dd9c5">PioSet32Bank</a> (uint16 bank, uint32 mask, uint32 bits)</td></tr>
<tr class="memdesc:ga075bb2aa0eb39cdcc3a79df1858dd9c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifies the contents of the PIO data output register. PIO pins must be set to outputs via <a class="el" href="group__trapset__core.html#gab1dbaf5222c281095fe8b0d02090af3a" title="Set PIOs as inputs or outputs. ">PioSetDir32Bank()</a> before they can be driven high or low through this trap. This trap also sets pull direction for PIOs used as inputs.  <a href="#ga075bb2aa0eb39cdcc3a79df1858dd9c5">More...</a><br /></td></tr>
<tr class="separator:ga075bb2aa0eb39cdcc3a79df1858dd9c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a73bc7aabc60037bc51e1bd45089c79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#ga7a73bc7aabc60037bc51e1bd45089c79">PioSetDeepSleepEitherLevelBank</a> (uint16 bank, uint32 mask, uint32 value)</td></tr>
<tr class="memdesc:ga7a73bc7aabc60037bc51e1bd45089c79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the chip to deep sleep irrespective of the level of the PIO lines.  <a href="#ga7a73bc7aabc60037bc51e1bd45089c79">More...</a><br /></td></tr>
<tr class="separator:ga7a73bc7aabc60037bc51e1bd45089c79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5d01f1a8a23db805b3062a2fd1e2ae7"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#gac5d01f1a8a23db805b3062a2fd1e2ae7">PioSetDir32</a> (uint32 mask, uint32 dir)</td></tr>
<tr class="memdesc:gac5d01f1a8a23db805b3062a2fd1e2ae7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set PIOs as inputs or outputs.  <a href="#gac5d01f1a8a23db805b3062a2fd1e2ae7">More...</a><br /></td></tr>
<tr class="separator:gac5d01f1a8a23db805b3062a2fd1e2ae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1dbaf5222c281095fe8b0d02090af3a"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#gab1dbaf5222c281095fe8b0d02090af3a">PioSetDir32Bank</a> (uint16 bank, uint32 mask, uint32 dir)</td></tr>
<tr class="memdesc:gab1dbaf5222c281095fe8b0d02090af3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set PIOs as inputs or outputs.  <a href="#gab1dbaf5222c281095fe8b0d02090af3a">More...</a><br /></td></tr>
<tr class="separator:gab1dbaf5222c281095fe8b0d02090af3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09b4b66d1e139080ef57eea9693ad2cc"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#ga09b4b66d1e139080ef57eea9693ad2cc">PioSetDriveStrength32Bank</a> (uint16 bank, uint32 mask, pin_drive_strength_id drive_strength)</td></tr>
<tr class="memdesc:ga09b4b66d1e139080ef57eea9693ad2cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the drive strength for given PIOs Depending on the PIO in question there may be several options for the drive strength. Please consult the datasheet to see which pins support which drive strength values.  <a href="#ga09b4b66d1e139080ef57eea9693ad2cc">More...</a><br /></td></tr>
<tr class="separator:ga09b4b66d1e139080ef57eea9693ad2cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93d107d956c1ac62d3b5807e0f18d661"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#ga93d107d956c1ac62d3b5807e0f18d661">PioSetFunction</a> (uint16 pin, pin_function_id function)</td></tr>
<tr class="memdesc:ga93d107d956c1ac62d3b5807e0f18d661"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a supported function for particular pio pin if a pin can be mapped as LED, UART, BITSERIAL, ANALOGUE etc, then this function can be used to set the pin for one of the supported functions. Consult the device's data sheet to understand what functions are supported for each PIO pins. A pin can support only few functions. Trying to set a function which is NOT supported by the pin will return FALSE without affecting/modifying the existing pin function. Before this trap can be used, it is necessary to use PioSetMapPins32Bank to put the PIO in HW mode. For functions corresponding to other susbystems the OTHER function ID must be used. This reverts the PIOs to the initial unmapped state. Any further use by the app needs remapping. <a class="el" href="group__trapset__core.html#ga93d107d956c1ac62d3b5807e0f18d661" title="Sets a supported function for particular pio pin if a pin can be mapped as LED, UART, BITSERIAL, ANALOGUE etc, then this function can be used to set the pin for one of the supported functions. Consult the device&#39;s data sheet to understand what functions are supported for each PIO pins. A pin can support only few functions. Trying to set a function which is NOT supported by the pin will return FALSE without affecting/modifying the existing pin function. Before this trap can be used, it is necessary to use PioSetMapPins32Bank to put the PIO in HW mode. For functions corresponding to other susbystems the OTHER function ID must be used. This reverts the PIOs to the initial unmapped state. Any further use by the app needs remapping. PioSetFunction() Usage Example: if PIO[20] can be mapped to UART/BITSERIAL/LED/PIO and currently PIO[20] is mapped as PIO, then App should call the PioSetMapPins32Bank() to unmap it from PIO and then call PioSetFunction() to map to (UART/BITSERIAL/LED/PIO) function. Unmap PIO[20] so that it can be mapped to a function PioSetMapPins32Bank(0, 1&lt;&lt;20, 0&lt;&lt;20); This will map PIO[20] line as UART_RX PioSetFunction(20, UART_RX);   To map back the PIO[20] as a PIO, PioSetMapPins32Bank() should be used. PioSetMapPins32Bank(0, 1&lt;&lt;20, 1&lt;&lt;20);. ">PioSetFunction()</a> Usage Example: if PIO[20] can be mapped to UART/BITSERIAL/LED/PIO and currently PIO[20] is mapped as PIO, then App should call the <a class="el" href="group__trapset__core.html#ga950a88ec1cd8ec2b916ef900ab95eb7b" title="Maps PIOs as software or hardware controlled. Before using a PIO as a software controlled digital IO ...">PioSetMapPins32Bank()</a> to unmap it from PIO and then call <a class="el" href="group__trapset__core.html#ga93d107d956c1ac62d3b5807e0f18d661" title="Sets a supported function for particular pio pin if a pin can be mapped as LED, UART, BITSERIAL, ANALOGUE etc, then this function can be used to set the pin for one of the supported functions. Consult the device&#39;s data sheet to understand what functions are supported for each PIO pins. A pin can support only few functions. Trying to set a function which is NOT supported by the pin will return FALSE without affecting/modifying the existing pin function. Before this trap can be used, it is necessary to use PioSetMapPins32Bank to put the PIO in HW mode. For functions corresponding to other susbystems the OTHER function ID must be used. This reverts the PIOs to the initial unmapped state. Any further use by the app needs remapping. PioSetFunction() Usage Example: if PIO[20] can be mapped to UART/BITSERIAL/LED/PIO and currently PIO[20] is mapped as PIO, then App should call the PioSetMapPins32Bank() to unmap it from PIO and then call PioSetFunction() to map to (UART/BITSERIAL/LED/PIO) function. Unmap PIO[20] so that it can be mapped to a function PioSetMapPins32Bank(0, 1&lt;&lt;20, 0&lt;&lt;20); This will map PIO[20] line as UART_RX PioSetFunction(20, UART_RX);   To map back the PIO[20] as a PIO, PioSetMapPins32Bank() should be used. PioSetMapPins32Bank(0, 1&lt;&lt;20, 1&lt;&lt;20);. ">PioSetFunction()</a> to map to (UART/BITSERIAL/LED/PIO) function. Unmap PIO[20] so that it can be mapped to a function PioSetMapPins32Bank(0, 1&lt;&lt;20, 0&lt;&lt;20); This will map PIO[20] line as UART_RX PioSetFunction(20, UART_RX); <br />
 To map back the PIO[20] as a PIO, <a class="el" href="group__trapset__core.html#ga950a88ec1cd8ec2b916ef900ab95eb7b" title="Maps PIOs as software or hardware controlled. Before using a PIO as a software controlled digital IO ...">PioSetMapPins32Bank()</a> should be used. PioSetMapPins32Bank(0, 1&lt;&lt;20, 1&lt;&lt;20);.  <a href="#ga93d107d956c1ac62d3b5807e0f18d661">More...</a><br /></td></tr>
<tr class="separator:ga93d107d956c1ac62d3b5807e0f18d661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7451bed3c1711348d8d7cf8abc3ff3fb"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#ga7451bed3c1711348d8d7cf8abc3ff3fb">PioSetMapPins32</a> (uint32 mask, uint32 bits)</td></tr>
<tr class="memdesc:ga7451bed3c1711348d8d7cf8abc3ff3fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps PIOs as software or hardware controlled. Before using a PIO as a software controlled digital IO a call to this function is required. Not mapping the PIO may cause other functions in the PIO trap API to return errors and not produce the required behaviour. To put a PIO under HW control the app needs to call this function first and then PioSetFunction to select the HW functionality needed. Please note that there is no default state, all PIOs should be considered unmapped and unusable until they are configured by a call to this function.  <a href="#ga7451bed3c1711348d8d7cf8abc3ff3fb">More...</a><br /></td></tr>
<tr class="separator:ga7451bed3c1711348d8d7cf8abc3ff3fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga950a88ec1cd8ec2b916ef900ab95eb7b"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#ga950a88ec1cd8ec2b916ef900ab95eb7b">PioSetMapPins32Bank</a> (uint16 bank, uint32 mask, uint32 bits)</td></tr>
<tr class="memdesc:ga950a88ec1cd8ec2b916ef900ab95eb7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps PIOs as software or hardware controlled. Before using a PIO as a software controlled digital IO a call to this function is required. Not mapping the PIO may cause other functions in the PIO trap API to return errors and not produce the required behaviour. To put a PIO under HW control the app needs to call this function first and then PioSetFunction to select the HW functionality needed. Please note that there is no default state, all PIOs should be considered unmapped and unusable until they are configured by a call to this function.  <a href="#ga950a88ec1cd8ec2b916ef900ab95eb7b">More...</a><br /></td></tr>
<tr class="separator:ga950a88ec1cd8ec2b916ef900ab95eb7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb2506f71cad70178cd2b03068c7b6a0"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#gabb2506f71cad70178cd2b03068c7b6a0">PioSetStrongBias32</a> (uint32 mask, uint32 bits)</td></tr>
<tr class="memdesc:gabb2506f71cad70178cd2b03068c7b6a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set PIOs to use strong or weak pull when used as inputs.  <a href="#gabb2506f71cad70178cd2b03068c7b6a0">More...</a><br /></td></tr>
<tr class="separator:gabb2506f71cad70178cd2b03068c7b6a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7753e1edbb0539bc14c4d41acf3560f7"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#ga7753e1edbb0539bc14c4d41acf3560f7">PioSetStrongBias32Bank</a> (uint16 bank, uint32 mask, uint32 bits)</td></tr>
<tr class="memdesc:ga7753e1edbb0539bc14c4d41acf3560f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set PIOs to use strong or weak pull when used as inputs.  <a href="#ga7753e1edbb0539bc14c4d41acf3560f7">More...</a><br /></td></tr>
<tr class="separator:ga7753e1edbb0539bc14c4d41acf3560f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f2761e3c373ed67224e5c6ad2bfb446"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#ga1f2761e3c373ed67224e5c6ad2bfb446">PioSetWakeupStateBank</a> (uint16 bank, uint32 mask, uint32 value)</td></tr>
<tr class="memdesc:ga1f2761e3c373ed67224e5c6ad2bfb446"><td class="mdescLeft">&#160;</td><td class="mdescRight">Controls the state for each PIO line that will wake the chip from deep sleep. The PIO lines must already have been configured to wake the chip.  <a href="#ga1f2761e3c373ed67224e5c6ad2bfb446">More...</a><br /></td></tr>
<tr class="separator:ga1f2761e3c373ed67224e5c6ad2bfb446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3745e8701fe6def6453aa66679b025e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#ga3745e8701fe6def6453aa66679b025e7">PsDefrag</a> (void)</td></tr>
<tr class="memdesc:ga3745e8701fe6def6453aa66679b025e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start PS store defragmentation in the background.  <a href="#ga3745e8701fe6def6453aa66679b025e7">More...</a><br /></td></tr>
<tr class="separator:ga3745e8701fe6def6453aa66679b025e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c21cf7e57edf43a3d540ef0f1ce1a0e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#ga7c21cf7e57edf43a3d540ef0f1ce1a0e">PsDefragBlocking</a> (void)</td></tr>
<tr class="memdesc:ga7c21cf7e57edf43a3d540ef0f1ce1a0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defragment the PS store Changing a key with <a class="el" href="group__trapset__core.html#ga023228f45d2cede814c9bed9dcef5680" title="Copy the specified memory buffer to persistent store. A Persistent store user key can be deleted by c...">PsStore()</a> trap adds a new instance of the key to PS store. After some time the store becomes filled with multiple instances of the same keys that consume space. To remove the old data and recover space in the store, defragmentation needs to be performed from time to time. Defragmentation is started automatically if after a PsStore request the store is more than 90% full or can be started manually at any time using this trap or the <a class="el" href="group__trapset__core.html#ga3745e8701fe6def6453aa66679b025e7" title="Start PS store defragmentation in the background. ">PsDefrag()</a> trap. For the reference with 64KB store, PsFreeCount(16) returns 142 when store is 90% full and 1055 when store is 90% empty. This trap will run defragmentation in a blocking manner, i.e. upon calling this trap, control will not be returned to the application until defragmentation is complete. Defragmentation is a time and memory intensive operation, it is recommended that this trap only be called if it's acceptable for the application to be blocked for several seconds. See <a class="el" href="group__trapset__core.html#ga3745e8701fe6def6453aa66679b025e7" title="Start PS store defragmentation in the background. ">PsDefrag()</a> for the non-blocking version of this trap.  <a href="#ga7c21cf7e57edf43a3d540ef0f1ce1a0e">More...</a><br /></td></tr>
<tr class="separator:ga7c21cf7e57edf43a3d540ef0f1ce1a0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b29378f646885e1becc6723e02184c8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#ga4b29378f646885e1becc6723e02184c8">PsDrop</a> (uint16 key)</td></tr>
<tr class="memdesc:ga4b29378f646885e1becc6723e02184c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the given key from the system cache. Only applicable to the PSKEY_READONLY key set, this call removes the specified key from the system cache, freeing up system memory. This also makes it unreadable until the next power-cycle, so the customer application should take care to not read the key again.  <a href="#ga4b29378f646885e1becc6723e02184c8">More...</a><br /></td></tr>
<tr class="separator:ga4b29378f646885e1becc6723e02184c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3131cc8f4279f63f535db41c4bbb9423"><td class="memItemLeft" align="right" valign="top">uint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#ga3131cc8f4279f63f535db41c4bbb9423">PsFreeCount</a> (uint16 words)</td></tr>
<tr class="memdesc:ga3131cc8f4279f63f535db41c4bbb9423"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return how many keys of this size in words we could write.  <a href="#ga3131cc8f4279f63f535db41c4bbb9423">More...</a><br /></td></tr>
<tr class="separator:ga3131cc8f4279f63f535db41c4bbb9423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24848f899c37a03f5ad510d66051faae"><td class="memItemLeft" align="right" valign="top">uint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#ga24848f899c37a03f5ad510d66051faae">PsFullRetrieve</a> (uint16 key, void *buff, uint16 words)</td></tr>
<tr class="memdesc:ga24848f899c37a03f5ad510d66051faae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read any persistent store key from the full range of supported keys. Note this function can be used to obtain values both for Bluecore PS keys and for Apps Subsystem PS keys. Unlike <a class="el" href="group__trapset__core.html#ga023228f45d2cede814c9bed9dcef5680" title="Copy the specified memory buffer to persistent store. A Persistent store user key can be deleted by c...">PsStore()</a> and <a class="el" href="group__trapset__core.html#ga41e5381ab0482e665e9d7d4ff8760e74" title="Copy to specified memory buffer from persistent store. ">PsRetrieve()</a> it does not use a PS key index in the range [0, 289]. It can be used for three different purposes.  <a href="#ga24848f899c37a03f5ad510d66051faae">More...</a><br /></td></tr>
<tr class="separator:ga24848f899c37a03f5ad510d66051faae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b1a86c9c80f7e8a46966ff4f3364afa"><td class="memItemLeft" align="right" valign="top">PsStores&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#ga8b1a86c9c80f7e8a46966ff4f3364afa">PsGetStore</a> (void)</td></tr>
<tr class="memdesc:ga8b1a86c9c80f7e8a46966ff4f3364afa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current PS store used for PS operations.  <a href="#ga8b1a86c9c80f7e8a46966ff4f3364afa">More...</a><br /></td></tr>
<tr class="separator:ga8b1a86c9c80f7e8a46966ff4f3364afa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8859a805b5bebaa5253777fc5ae1d838"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#ga8859a805b5bebaa5253777fc5ae1d838">PsNextAudioKey</a> (uint16 value, uint32 *key)</td></tr>
<tr class="memdesc:ga8859a805b5bebaa5253777fc5ae1d838"><td class="mdescLeft">&#160;</td><td class="mdescRight">Give the next Audio key stored in the PsStore.  <a href="#ga8859a805b5bebaa5253777fc5ae1d838">More...</a><br /></td></tr>
<tr class="separator:ga8859a805b5bebaa5253777fc5ae1d838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga980b769d87fe77a4c25aa1e486eb0a85"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#ga980b769d87fe77a4c25aa1e486eb0a85">PsNextKey</a> (uint16 value, uint16 *key)</td></tr>
<tr class="memdesc:ga980b769d87fe77a4c25aa1e486eb0a85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Give the next Apps key stored in PsStore.  <a href="#ga980b769d87fe77a4c25aa1e486eb0a85">More...</a><br /></td></tr>
<tr class="separator:ga980b769d87fe77a4c25aa1e486eb0a85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga975489202189811bf857457d694697e3"><td class="memItemLeft" align="right" valign="top">uint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#ga975489202189811bf857457d694697e3">PsReadAudioKey</a> (uint32 key, uint16 *buffer, uint16 words, uint16 offset, uint16 *key_length_addr)</td></tr>
<tr class="memdesc:ga975489202189811bf857457d694697e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy to specified memory buffer from audio persistent store. A Persistent store audio key can be read by the application by invoking this trap.  <a href="#ga975489202189811bf857457d694697e3">More...</a><br /></td></tr>
<tr class="separator:ga975489202189811bf857457d694697e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41e5381ab0482e665e9d7d4ff8760e74"><td class="memItemLeft" align="right" valign="top">uint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#ga41e5381ab0482e665e9d7d4ff8760e74">PsRetrieve</a> (uint16 key, void *buff, uint16 words)</td></tr>
<tr class="memdesc:ga41e5381ab0482e665e9d7d4ff8760e74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy to specified memory buffer from persistent store.  <a href="#ga41e5381ab0482e665e9d7d4ff8760e74">More...</a><br /></td></tr>
<tr class="separator:ga41e5381ab0482e665e9d7d4ff8760e74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga218eeae791e9c3b75eb200f825d3dad1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#ga218eeae791e9c3b75eb200f825d3dad1">PsSetStore</a> (PsStores store)</td></tr>
<tr class="memdesc:ga218eeae791e9c3b75eb200f825d3dad1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the PS Store that are used for subsequent PS operations.  <a href="#ga218eeae791e9c3b75eb200f825d3dad1">More...</a><br /></td></tr>
<tr class="separator:ga218eeae791e9c3b75eb200f825d3dad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga023228f45d2cede814c9bed9dcef5680"><td class="memItemLeft" align="right" valign="top">uint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#ga023228f45d2cede814c9bed9dcef5680">PsStore</a> (uint16 key, const void *buff, uint16 words)</td></tr>
<tr class="memdesc:ga023228f45d2cede814c9bed9dcef5680"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the specified memory buffer to persistent store. A Persistent store user key can be deleted by calling the <a class="el" href="group__trapset__core.html#ga023228f45d2cede814c9bed9dcef5680" title="Copy the specified memory buffer to persistent store. A Persistent store user key can be deleted by c...">PsStore()</a> function with <em>key</em> to be deleted and <em>words</em> argument being zero.  <a href="#ga023228f45d2cede814c9bed9dcef5680">More...</a><br /></td></tr>
<tr class="separator:ga023228f45d2cede814c9bed9dcef5680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf047136770ad108db893089f9a88b510"><td class="memItemLeft" align="right" valign="top">uint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#gaf047136770ad108db893089f9a88b510">PsUpdateAudioKey</a> (uint32 key, const uint16 *buffer, uint16 words, uint16 offset, uint16 key_length)</td></tr>
<tr class="memdesc:gaf047136770ad108db893089f9a88b510"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the specified memory buffer to audio persistent store. A Persistent store audio key can be changed by the application by invoking this trap.  <a href="#gaf047136770ad108db893089f9a88b510">More...</a><br /></td></tr>
<tr class="separator:gaf047136770ad108db893089f9a88b510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9f50ffe8d0d22dfede85d6f17c0e6b1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#gac9f50ffe8d0d22dfede85d6f17c0e6b1">UtilCompareByte</a> (const uint8 *a, const uint8 *b, size_t size)</td></tr>
<tr class="memdesc:gac9f50ffe8d0d22dfede85d6f17c0e6b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility routines.  <a href="#gac9f50ffe8d0d22dfede85d6f17c0e6b1">More...</a><br /></td></tr>
<tr class="separator:gac9f50ffe8d0d22dfede85d6f17c0e6b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10ab002ecb0b1660141b892cd61be208"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#ga10ab002ecb0b1660141b892cd61be208">UtilCompareWord</a> (const uint16 *a, const uint16 *b, size_t size)</td></tr>
<tr class="memdesc:ga10ab002ecb0b1660141b892cd61be208"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two blocks of memory of extent 'size', as uint16's.  <a href="#ga10ab002ecb0b1660141b892cd61be208">More...</a><br /></td></tr>
<tr class="separator:ga10ab002ecb0b1660141b892cd61be208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeab962f598a36bb777bb47f26064541a"><td class="memItemLeft" align="right" valign="top">uint8 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#gaeab962f598a36bb777bb47f26064541a">UtilFindByte</a> (uint8 mask, uint8 value, const uint8 *data_start, uint16 offset, uint16 size, uint16 count)</td></tr>
<tr class="memdesc:gaeab962f598a36bb777bb47f26064541a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two memory blocks. Conceptually we have a table in memory starting at 'data_start', with 'count' entries where each entry is 'size'. UtilFindByte searches for 'value', at 'offset' from the start of each entry, using bitmask 'mask'.  <a href="#gaeab962f598a36bb777bb47f26064541a">More...</a><br /></td></tr>
<tr class="separator:gaeab962f598a36bb777bb47f26064541a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6013ef492ba46f94fc0bf3388d18a927"><td class="memItemLeft" align="right" valign="top">uint16 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#ga6013ef492ba46f94fc0bf3388d18a927">UtilFindWord</a> (uint16 mask, uint16 value, const uint16 *data_start, uint16 offset, uint16 size, uint16 count)</td></tr>
<tr class="memdesc:ga6013ef492ba46f94fc0bf3388d18a927"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two memory blocks. Conceptually we have a table in memory starting at 'data_start', with 'count' entries where each entry is 'size'. UtilFindWord searches for 'value', at 'offset' from the start of each entry, using bitmask 'mask'.  <a href="#ga6013ef492ba46f94fc0bf3388d18a927">More...</a><br /></td></tr>
<tr class="separator:ga6013ef492ba46f94fc0bf3388d18a927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec0024ab0aa069db2a69e502556405fb"><td class="memItemLeft" align="right" valign="top">uint8 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#gaec0024ab0aa069db2a69e502556405fb">UtilGetNumber</a> (const uint8 *start, const uint8 *end, uint16 *result)</td></tr>
<tr class="memdesc:gaec0024ab0aa069db2a69e502556405fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a string into a number. Note that the string converted here will not include the character pointed to by 'end'. That is, to convert the string "123" you would need to call 'UtilGetNumber(start, start+3, &amp;result)'. The number is expected to be an unsigned decimal in the range 0 to 2^16-1.  <a href="#gaec0024ab0aa069db2a69e502556405fb">More...</a><br /></td></tr>
<tr class="separator:gaec0024ab0aa069db2a69e502556405fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5332498b655fe38db0208fdda040fbce"><td class="memItemLeft" align="right" valign="top">uint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#ga5332498b655fe38db0208fdda040fbce">UtilHash</a> (const uint8 *data, uint16 size, uint16 seed)</td></tr>
<tr class="memdesc:ga5332498b655fe38db0208fdda040fbce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a uint16 hash value for the memory at 'data', of extent 'size' uint16's, starting with the given 'seed'. This function is deprecated. Please use UtilHashWord instead <br />
  <a href="#ga5332498b655fe38db0208fdda040fbce">More...</a><br /></td></tr>
<tr class="separator:ga5332498b655fe38db0208fdda040fbce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1cb9d9e27d64c37203ca1bc883b5f11"><td class="memItemLeft" align="right" valign="top">uint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#gaa1cb9d9e27d64c37203ca1bc883b5f11">UtilHashByte</a> (const uint8 *data, uint16 size, uint8 seed)</td></tr>
<tr class="memdesc:gaa1cb9d9e27d64c37203ca1bc883b5f11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a uint8 hash value for the memory at 'data', of extent 'size' uint16's, starting with the given 'seed'.  <a href="#gaa1cb9d9e27d64c37203ca1bc883b5f11">More...</a><br /></td></tr>
<tr class="separator:gaa1cb9d9e27d64c37203ca1bc883b5f11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae36e8ea73ce8abf563e5155a26fa4e20"><td class="memItemLeft" align="right" valign="top">uint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#gae36e8ea73ce8abf563e5155a26fa4e20">UtilHashWord</a> (const uint16 *data, uint16 size, uint16 seed)</td></tr>
<tr class="memdesc:gae36e8ea73ce8abf563e5155a26fa4e20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a uint16 hash value for the memory at 'data', of extent 'size' uint16's, starting with the given 'seed'.  <a href="#gae36e8ea73ce8abf563e5155a26fa4e20">More...</a><br /></td></tr>
<tr class="separator:gae36e8ea73ce8abf563e5155a26fa4e20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48ec60b9c243c79070b96d519994b498"><td class="memItemLeft" align="right" valign="top">uint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#ga48ec60b9c243c79070b96d519994b498">UtilRandom</a> (void)</td></tr>
<tr class="memdesc:ga48ec60b9c243c79070b96d519994b498"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a 16-bit random number. Uses a numerical approach, but the state is shared with the BlueCore firmware which also makes calls into this function so predictability will be low.  <a href="#ga48ec60b9c243c79070b96d519994b498">More...</a><br /></td></tr>
<tr class="separator:ga48ec60b9c243c79070b96d519994b498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3716e288edcbffdc024ccc87fa145fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#gaf3716e288edcbffdc024ccc87fa145fc">UtilSwap</a> (uint16 *data, uint16 size)</td></tr>
<tr class="memdesc:gaf3716e288edcbffdc024ccc87fa145fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges the high and low bytes of 'size' words at 'data'.  <a href="#gaf3716e288edcbffdc024ccc87fa145fc">More...</a><br /></td></tr>
<tr class="separator:gaf3716e288edcbffdc024ccc87fa145fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3e62f3b97b056e1d10ec590f072f349"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#gaa3e62f3b97b056e1d10ec590f072f349">VmAdvertisePowerSetMaximum</a> (bool override, int16 power)</td></tr>
<tr class="memdesc:gaa3e62f3b97b056e1d10ec590f072f349"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the application to override the power for LE Adverts. If the override parameter is TRUE request that LE adverts are transmitted at the requested power level. Otherwise revert to the default for the Bluetooth controller. In most cases the controller will select the closest dBm value at or below the requested value, to ensure that max power limits are not exceeded. However, if the requested value is lower than the lowest supported transmit power then the Controller will instead use the lowest supported value.  <a href="#gaa3e62f3b97b056e1d10ec590f072f349">More...</a><br /></td></tr>
<tr class="separator:gaa3e62f3b97b056e1d10ec590f072f349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a1785ecca01fc9ebeb000252198ca36"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#ga9a1785ecca01fc9ebeb000252198ca36">VmDeepSleepEnable</a> (bool en)</td></tr>
<tr class="memdesc:ga9a1785ecca01fc9ebeb000252198ca36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables or disables deep sleep.  <a href="#ga9a1785ecca01fc9ebeb000252198ca36">More...</a><br /></td></tr>
<tr class="separator:ga9a1785ecca01fc9ebeb000252198ca36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b3943587bd8218a9ca0878aa4e983db"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#ga6b3943587bd8218a9ca0878aa4e983db">VmDeepSleepWakeSourcesEnable</a> (vm_wake_source_type wake_source, bool en)</td></tr>
<tr class="memdesc:ga6b3943587bd8218a9ca0878aa4e983db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables or disables some deep sleep wake sources.  <a href="#ga6b3943587bd8218a9ca0878aa4e983db">More...</a><br /></td></tr>
<tr class="separator:ga6b3943587bd8218a9ca0878aa4e983db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d9e41289da06caa7c3e2f025c53a12b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#ga6d9e41289da06caa7c3e2f025c53a12b">VmEnableSecurity</a> (security_bits enable)</td></tr>
<tr class="memdesc:ga6d9e41289da06caa7c3e2f025c53a12b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set chip wide security features in OTP memory. This trap takes a bitfield of security features to write to the OTP (One Time Program) memory in the bitfield format.  <a href="#ga6d9e41289da06caa7c3e2f025c53a12b">More...</a><br /></td></tr>
<tr class="separator:ga6d9e41289da06caa7c3e2f025c53a12b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02aaa28a27ec99b81a57cfda05500a72"><td class="memItemLeft" align="right" valign="top">uint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#ga02aaa28a27ec99b81a57cfda05500a72">VmGetAvailableAllocations</a> (void)</td></tr>
<tr class="memdesc:ga02aaa28a27ec99b81a57cfda05500a72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the maximum number of additional memory blocks which can be allocated.  <a href="#ga02aaa28a27ec99b81a57cfda05500a72">More...</a><br /></td></tr>
<tr class="separator:ga02aaa28a27ec99b81a57cfda05500a72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03af15948e7d1e33957f054880b91878"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#ga03af15948e7d1e33957f054880b91878">VmGetClock</a> (void)</td></tr>
<tr class="memdesc:ga03af15948e7d1e33957f054880b91878"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the current value of a 32-bit millisecond timer. Don't poll this; using MessageSendLater is much more efficient.  <a href="#ga03af15948e7d1e33957f054880b91878">More...</a><br /></td></tr>
<tr class="separator:ga03af15948e7d1e33957f054880b91878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb00022347383cdcc12acc1c4e6347c9"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#gadb00022347383cdcc12acc1c4e6347c9">VmGetFwVersion</a> (component_id id)</td></tr>
<tr class="memdesc:gadb00022347383cdcc12acc1c4e6347c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the firmware or application version.  <a href="#gadb00022347383cdcc12acc1c4e6347c9">More...</a><br /></td></tr>
<tr class="separator:gadb00022347383cdcc12acc1c4e6347c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee3dd147edcc2ea19d3ce2316ade376c"><td class="memItemLeft" align="right" valign="top">vm_pcm_clock_setting&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#gaee3dd147edcc2ea19d3ce2316ade376c">VmGetPcmClock</a> (void)</td></tr>
<tr class="memdesc:gaee3dd147edcc2ea19d3ce2316ade376c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the VM to check the current PCM_CLK frequency, when it is being generated from the 4MHz internal clock.  <a href="#gaee3dd147edcc2ea19d3ce2316ade376c">More...</a><br /></td></tr>
<tr class="separator:gaee3dd147edcc2ea19d3ce2316ade376c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0705e3271d59f90a2fe6f5437f37c6a"><td class="memItemLeft" align="right" valign="top">vm_reset_source&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#gac0705e3271d59f90a2fe6f5437f37c6a">VmGetResetSource</a> (void)</td></tr>
<tr class="memdesc:gac0705e3271d59f90a2fe6f5437f37c6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an enum value relating to the cause of the last reset. When a system reset occurs on BC7 chips a value is stored which relates to the cause of the reset. This value can be retrieved by a VM app and takes the enumerated values defined in the #vm_reset_source type. Any value not covered by this definition cannot be determined and is deemed an unexpected reset. See the type definition for more information.  <a href="#gac0705e3271d59f90a2fe6f5437f37c6a">More...</a><br /></td></tr>
<tr class="separator:gac0705e3271d59f90a2fe6f5437f37c6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaddc7b1642cb8ff29eaafae10af122ee9"><td class="memItemLeft" align="right" valign="top">int16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#gaddc7b1642cb8ff29eaafae10af122ee9">VmGetTemperature</a> (void)</td></tr>
<tr class="memdesc:gaddc7b1642cb8ff29eaafae10af122ee9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the internal temperature of BlueCore.  <a href="#gaddc7b1642cb8ff29eaafae10af122ee9">More...</a><br /></td></tr>
<tr class="separator:gaddc7b1642cb8ff29eaafae10af122ee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccca4dbfa25d3d5529c0b8ab36773b92"><td class="memItemLeft" align="right" valign="top">int16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#gaccca4dbfa25d3d5529c0b8ab36773b92">VmGetTemperatureBySensor</a> (vm_temp_sensor sensor)</td></tr>
<tr class="memdesc:gaccca4dbfa25d3d5529c0b8ab36773b92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the temperature sensors on BlueCore BC7+ chips.  <a href="#gaccca4dbfa25d3d5529c0b8ab36773b92">More...</a><br /></td></tr>
<tr class="separator:gaccca4dbfa25d3d5529c0b8ab36773b92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2e6477d6302bd1ff9012449b769e457"><td class="memItemLeft" align="right" valign="top">uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#gae2e6477d6302bd1ff9012449b769e457">VmGetTimerTime</a> (void)</td></tr>
<tr class="memdesc:gae2e6477d6302bd1ff9012449b769e457"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the current value of the 32-bit micro-second timer. The 32-bit value returned will wrap from 0xFFFFFFFF to 0x00000000 every 2**32 / 1e6 / 60 = 71.6 minutes. Don't poll this; using MessageSendLater is much more efficient.  <a href="#gae2e6477d6302bd1ff9012449b769e457">More...</a><br /></td></tr>
<tr class="separator:gae2e6477d6302bd1ff9012449b769e457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6174a6f6a49eaaf125ee06068a91d49"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#gab6174a6f6a49eaaf125ee06068a91d49">VmPutChar</a> (uint16 channel, uint16 c)</td></tr>
<tr class="memdesc:gab6174a6f6a49eaaf125ee06068a91d49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output a character on the given channel.  <a href="#gab6174a6f6a49eaaf125ee06068a91d49">More...</a><br /></td></tr>
<tr class="separator:gab6174a6f6a49eaaf125ee06068a91d49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab55a7127c95c583e769574f57bdd943a"><td class="memItemLeft" align="right" valign="top">uint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#gab55a7127c95c583e769574f57bdd943a">VmReadSecurity</a> (security_bits read_mask)</td></tr>
<tr class="memdesc:gab55a7127c95c583e769574f57bdd943a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the application to read the Security features from OTP memory. This trap takes a bitfield of security features to read and returns the settings read from the OTP (One Time Program) memory in the same bitfield format.  <a href="#gab55a7127c95c583e769574f57bdd943a">More...</a><br /></td></tr>
<tr class="separator:gab55a7127c95c583e769574f57bdd943a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8d197784f84effbe11f38ceb3692a44"><td class="memItemLeft" align="right" valign="top">uint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#gae8d197784f84effbe11f38ceb3692a44">VmReadVrefConstant</a> (void)</td></tr>
<tr class="memdesc:gae8d197784f84effbe11f38ceb3692a44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the absolute value for Vref on this version of BlueCore This is a constant value for a given version of BlueCore. See <a class="el" href="adc_8h.html">adc.h</a> for the intended use of this function. In ADK6 firmware, <a class="el" href="group__trapset__core.html#gafb642634557cf5ffb084d67405fb436b" title="Access to ADC hardware. ">AdcReadRequest()</a> will return reading for Vref (#adcsel_vref_hq_buff) without scaling it to a nominal voltage. This function provides the information that the battery library needs to adjust its readings appropriately.  <a href="#gae8d197784f84effbe11f38ceb3692a44">More...</a><br /></td></tr>
<tr class="separator:gae8d197784f84effbe11f38ceb3692a44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed39856160114a494bda22e8c5ea782c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#gaed39856160114a494bda22e8c5ea782c">VmSetPcmClock</a> (vm_pcm_clock_setting frequency)</td></tr>
<tr class="memdesc:gaed39856160114a494bda22e8c5ea782c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the VM to set the PCM_CLK frequency when using the 4 mHz internal clock.  <a href="#gaed39856160114a494bda22e8c5ea782c">More...</a><br /></td></tr>
<tr class="separator:gaed39856160114a494bda22e8c5ea782c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga269b447dc709fad74a31b0c794c9cf20"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#ga269b447dc709fad74a31b0c794c9cf20">VmSoftwareWdKick</a> (uint16 timeout)</td></tr>
<tr class="memdesc:ga269b447dc709fad74a31b0c794c9cf20"><td class="mdescLeft">&#160;</td><td class="mdescRight">By default, the VM software watchdog is disabled. Calling this trap with a valid timeout value will initiate/reset the VM software watchdog timer. If the VM software watchdog timer expires, then a VM Panic will be raised with Panic code PANIC_VM_SW_WD_EXPIRED and it will reset the chip.  <a href="#ga269b447dc709fad74a31b0c794c9cf20">More...</a><br /></td></tr>
<tr class="separator:ga269b447dc709fad74a31b0c794c9cf20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7dfd59c130bc32c9ebd19d60f6f4e88"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#gac7dfd59c130bc32c9ebd19d60f6f4e88">VmTransmitEnable</a> (bool enabled)</td></tr>
<tr class="memdesc:gac7dfd59c130bc32c9ebd19d60f6f4e88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request that the radio transmitter be enabled or disabled.  <a href="#gac7dfd59c130bc32c9ebd19d60f6f4e88">More...</a><br /></td></tr>
<tr class="separator:gac7dfd59c130bc32c9ebd19d60f6f4e88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf4606391ecb5d811f8abf0de8a8c7f6"><td class="memItemLeft" align="right" valign="top">int16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#gabf4606391ecb5d811f8abf0de8a8c7f6">VmTransmitPowerGetDefault</a> (void)</td></tr>
<tr class="memdesc:gabf4606391ecb5d811f8abf0de8a8c7f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current default power setting.  <a href="#gabf4606391ecb5d811f8abf0de8a8c7f6">More...</a><br /></td></tr>
<tr class="separator:gabf4606391ecb5d811f8abf0de8a8c7f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b7466c263ec7f89013baf6dc81c8291"><td class="memItemLeft" align="right" valign="top">int16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#ga8b7466c263ec7f89013baf6dc81c8291">VmTransmitPowerGetMaximum</a> (void)</td></tr>
<tr class="memdesc:ga8b7466c263ec7f89013baf6dc81c8291"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current maximum power setting.  <a href="#ga8b7466c263ec7f89013baf6dc81c8291">More...</a><br /></td></tr>
<tr class="separator:ga8b7466c263ec7f89013baf6dc81c8291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7ce051e2f5da01808c83502a9a4f5f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#gac7ce051e2f5da01808c83502a9a4f5f4">VmTransmitPowerMessagesEnable</a> (bool enable)</td></tr>
<tr class="memdesc:gac7ce051e2f5da01808c83502a9a4f5f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows one #MESSAGE_TX_POWER_CHANGE_EVENT to be sent to the system task. This is a one-shot enable, i.e., it allows exactly one power change message to be sent to the task registered with <a class="el" href="group__trapset__core.html#gabd1023998e25adee54f220a8d71736ae" title="Register a task to handle system-wide messages. ">MessageSystemTask()</a>. Once that message has been sent, <a class="el" href="group__trapset__core.html#gac7ce051e2f5da01808c83502a9a4f5f4" title="Allows one #MESSAGE_TX_POWER_CHANGE_EVENT to be sent to the system task. This is a one-shot enable...">VmTransmitPowerMessagesEnable()</a> must be called again to allow the next power change message to be sent. This gives the application the opportunity to limit the rate at which power change messages arrive, which can be quite frequent if unchecked. Calling VmTransmitPowerMessagesEnable(TRUE) again before a power change message has been received has no effect.  <a href="#gac7ce051e2f5da01808c83502a9a4f5f4">More...</a><br /></td></tr>
<tr class="separator:gac7ce051e2f5da01808c83502a9a4f5f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa318c8d5fba4619c0029a91cc04af672"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#gaa318c8d5fba4619c0029a91cc04af672">VmTransmitPowerSetDefault</a> (int16 power)</td></tr>
<tr class="memdesc:gaa318c8d5fba4619c0029a91cc04af672"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the application to override the default specified by PSKEY_LC_DEFAULT_TX_POWER. The default transmit power is used for paging, inquiry, and their responses, and as the initial power for new acl links. The value passed is rounded down to the next available value when set, so the value returned by a call to VmTransmitPowerGetDefault may be less than that previously passed to VmTransmitPowerSetDefault.  <a href="#gaa318c8d5fba4619c0029a91cc04af672">More...</a><br /></td></tr>
<tr class="separator:gaa318c8d5fba4619c0029a91cc04af672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf609631fa386bd0a2dcd0a182d7e0f37"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__trapset__core.html#gaf609631fa386bd0a2dcd0a182d7e0f37">VmTransmitPowerSetMaximum</a> (int16 power)</td></tr>
<tr class="memdesc:gaf609631fa386bd0a2dcd0a182d7e0f37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the application to override the maximum specified by PSKEY_LC_MAX_TX_POWER. The maximum transmit power is only referenced when increasing the transmit power, so if the transmit power on a link is already above this level the new value will not take effect until an attempt is made to increase the power. The value passed is rounded down to the next available value when set, so the value returned by a call to VmTransmitPowerGetMaximum may be less than that previously passed to VmTransmitPowerSetMaximum.  <a href="#gaf609631fa386bd0a2dcd0a182d7e0f37">More...</a><br /></td></tr>
<tr class="separator:gaf609631fa386bd0a2dcd0a182d7e0f37"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="gafb642634557cf5ffb084d67405fb436b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafb642634557cf5ffb084d67405fb436b">&#9670;&nbsp;</a></span>AdcReadRequest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AdcReadRequest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="message___8h.html#a51d7b6544fb734b892b35ce3f56a579a">Task</a>&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vm_adc_source_type&#160;</td>
          <td class="paramname"><em>adc_source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vm_adc_extra_flag&#160;</td>
          <td class="paramname"><em>extra_flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>delay</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access to ADC hardware. </p>
<p>fileBlueCore has an analogue-to-digital converter (ADC) which can be used to read the voltage at a number of locations, such as:</p><ul>
<li>At AIO pins #adcsel_aio0 to #adcsel_aio3.</li>
<li>From #adcsel_vref - the internal voltage in the chip.</li>
<li>From #adcsel_vdd_bat - the battery.</li>
</ul>
<p>(Note that this hardware is distinct from the ADCs that form part of the analogue audio codec.)</p>
<p>Note that not all sources are available on all BlueCores.</p>
<p>The voltage (in mV) from a source is given by:</p>
<p>(reading) * VrefConstant / (vref_reading)</p>
<p><em>reading</em> comes from the #MESSAGE_ADC_RESULT for the source in question. <em>vref_reading</em> is a corresponding reading for #adcsel_vref that has been taken relatively recently. <a class="el" href="group__trapset__core.html#gae8d197784f84effbe11f38ceb3692a44" title="Get the absolute value for Vref on this version of BlueCore This is a constant value for a given vers...">VmReadVrefConstant()</a> should be used to determine <em>VrefConstant</em>. This calculation determines how many mV each bit of <em>reading</em> corresponds to, correcting for natural variation and systematic errors in the ADC reading process.</p>
<p>For example, on CSR8670 <a class="el" href="group__trapset__core.html#gae8d197784f84effbe11f38ceb3692a44" title="Get the absolute value for Vref on this version of BlueCore This is a constant value for a given vers...">VmReadVrefConstant()</a> returns 700 (which is in mV, and therefore represents 0.7 V). A reading of #adcsel_vref might return 531 (this number will vary slightly with process and temperature). In which case, 1 bit of ADC reading corresponds to a real value of 700/531 mV. Hence, if a reading of 100 is obtained from #adcsel_aio0, this corresponds to a true voltage of</p>
<p>100 * 700/531 = 132 mV on AIO0.</p>
<p>The underlying hardware has 8 bits of resolution on older BlueCores, and 10 bits of resolution from BlueCore 5 onwards. The raw reading may be conditioned by the firmware before being returned to the application. Send a request to the ADC to make a reading from adc_source. When the reading is made, a #MESSAGE_ADC_RESULT message will be sent to the task passed. See <a class="el" href="adc_8h.html">adc.h</a> for how to interpret the result. Note that this trap replaces trap AdcRequest(). This is because it has to support queuing multiple request calls with different task, ADC source, extra flag and delay parameters. So far the extra_flag parameter only supports enabling/disabling the 10uA internal current source from HQ_REF during the reading. Adc readings for various analogue sources may require a delay to let external circuitry settle and not impact the reading (for example external capacitors need time to charge when the internal current source is enabled). This delay needs to be provided by customer where they see appropriate. PIO setup is not handled by this trap but can be done at any point. XIO pads need to be configured as analogue pins. This is done by using PioSetMapPins32Bank to put the PIO under HW control and then PioSetFunction to set the function to XIO_ANALOGUE. LED pads are handled internally by the Curator so we just need to make sure those pins are not used by something else. This is done by using PioSetMapPins32Bank to put the PIO under HW control and then PioSetFunction to set the function to OTHER. Application can't schedule more than #MAX_ADC_READ_REQUESTS concurrent requests. If this limit is reached, the trap will start returning FALSE until some of the pending requests complete. Application shall monitor number of #MESSAGE_ADC_RESULT messages received and balance number of submitted requests against it. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>The task which will receive the ADC result message. </td></tr>
    <tr><td class="paramname">adc_source</td><td>The source (#vm_adc_source_type) to take readings from. </td></tr>
    <tr><td class="paramname">extra_flag</td><td>The flags (#vm_adc_extra_flag) to be used for readings </td></tr>
    <tr><td class="paramname">delay</td><td>Delay in millisconds to use for internal current source </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if request is accepted, else FALSE. Request is not accepted if either #adc_source or #extra_flag is not correct or if there are #MAX_ADC_READ_REQUESTS pending requests already. </dd></dl>

</div>
</div>
<a id="gae3e35c0656bfb571dfdae7b0e023ac99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3e35c0656bfb571dfdae7b0e023ac99">&#9670;&nbsp;</a></span>BootGetMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16 BootGetMode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Control booting BlueCore with different active settings. </p>
<p>fileThese functions control the BlueCore bootmode on unified firmware. Each bootmode has a unique view of the persistent store, and so a single device could boot up as (for example) an HCI dongle using USB in one bootmode and a HID dongle using BCSP in another bootmode.</p>
<p>Incorrect use of these functions could produce a non-functional module, and so caution should be exercised.</p>
<p>BootGetPreservedWord and BootSetPreservedWord can be used to preserve a single word of state between boots. Read the current boot mode. </p>

</div>
</div>
<a id="gafa693d6a69705350d809fc774ceba7ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa693d6a69705350d809fc774ceba7ff">&#9670;&nbsp;</a></span>BootGetPreservedWord()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16 BootGetPreservedWord </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the (single) word preserved between boots. </p>
<p>WARNING: This trap is UNIMPLEMENTED </p>

</div>
</div>
<a id="ga2ca590d41150774c4679511d07f1f7f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ca590d41150774c4679511d07f1f7f0">&#9670;&nbsp;</a></span>BootSetMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BootSetMode </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>newBootmode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the mode and force a reboot (warm reset) of the chip using the boot image bank. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newBootmode</td><td>The new boot mode to use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga382b9b637395b616624b9092e09b25aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga382b9b637395b616624b9092e09b25aa">&#9670;&nbsp;</a></span>BootSetPreservedWord()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BootSetPreservedWord </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write the (single) word preserved between boots. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The word of state to preserve.</td></tr>
  </table>
  </dd>
</dl>
<p>WARNING: This trap is UNIMPLEMENTED </p>

</div>
</div>
<a id="ga143374b3a01ecc01a26475f8cb5f9bb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga143374b3a01ecc01a26475f8cb5f9bb0">&#9670;&nbsp;</a></span>DormantConfigure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DormantConfigure </td>
          <td>(</td>
          <td class="paramtype">dormant_config_key&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configures the dormant mode. All the configurable settings are defined in #dormant_config_key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>Which aspect of dormant to configure. </td></tr>
    <tr><td class="paramname">value</td><td>Which value to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the key is valid and the input value corresponding to the key is valid, else FALSE. Please note that if the request to go into dormant mode is successful the trap will never return. </dd></dl>

</div>
</div>
<a id="ga25121fb3858e082482d8c917b0235720"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25121fb3858e082482d8c917b0235720">&#9670;&nbsp;</a></span>FeatureVerifyLicense()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FeatureVerifyLicense </td>
          <td>(</td>
          <td class="paramtype">feature_id&#160;</td>
          <td class="paramname"><em>feature</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Related to licensing of new features. </p>
<p>file This trap checks whether a feature is licensed for a device. </p><pre class="fragment">This trap verifies whether a device is licensed to use a given feature.
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">feature</td><td>Identifier for a given feature. Refer #feature_id </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if device has valid license for feature, else FALSE. </dd></dl>

</div>
</div>
<a id="ga0eab47e690c54a8d8ccd258103642c28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0eab47e690c54a8d8ccd258103642c28">&#9670;&nbsp;</a></span>LoaderModeEnter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LoaderModeEnter </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This API will reboot the firmware in "loader" mode. This trap can be used to trigger a DFU process based on an external event, for example: " A combination
 of keys being pressed at the device". </p>
<p>WARNING: This trap is UNIMPLEMENTED </p>

</div>
</div>
<a id="ga1ee6210afa6e7422698e4b769dc5f6c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ee6210afa6e7422698e4b769dc5f6c8">&#9670;&nbsp;</a></span>LoaderPerformDfuFromSqif()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LoaderPerformDfuFromSqif </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>partition</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reboots the firmware in "loader" mode to perform DFU from SQIF operation This trap can be used to trigger the DFU process from SQIF after the VM application writes the DFU file onto one of the serial flash partitions. Partition type should be a raw partition type. Once the DFU process is over and the device reboots back into "stack" mode, the VM application's system task then receives MESSAGE_DFU_SQIF_STATUS message containing the status of DFU operation. If there is a power loss during the DFU process, the VM application will not receive the MESSAGE_DFU_SQIF_STATUS message. </p>
<dl class="section note"><dt>Note</dt><dd>This trap will only work if the loader supports the DFU process from SQIF. If the "loader" does not have the knowledge of the DFU process from SQIF, then this trap will reboot the device into "loader" mode and the loader will wait for wired DFU command from the host. </dd>
<dd>
This trap performs basic validation of the partition number and the DFU file and reboots the device into the "loader" mode. Hence, the control does not comes back to the VM application. If the device is not rebooted into the "loader" mode due to validation failure, then the controls returns back to the VM application and appropriate action should be taken by the VM application. </dd>
<dd>
A value of 0xFFFD, 0xFFFE and 0xFFFF MUST not be used for partition number since these values are reserved for internal use. If these values are passed, then trap will return to the VM application without any impact. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">partition</td><td>A valid SQIF partition containing the DFU file</td></tr>
  </table>
  </dd>
</dl>
<p>WARNING: This trap is UNIMPLEMENTED </p>

</div>
</div>
<a id="ga6dcd584c07addfbbd068a0498c7c817d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6dcd584c07addfbbd068a0498c7c817d">&#9670;&nbsp;</a></span>MessageCancelFirst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MessageCancelFirst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="message___8h.html#a51d7b6544fb734b892b35ce3f56a579a">Task</a>&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="message___8h.html#aa135f64d9b1113995d9335c8e9314d95">MessageId</a>&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cancel the first queued message with the given task and message id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>The task whose messages will be searched. </td></tr>
    <tr><td class="paramname">id</td><td>The message identifier to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if such a message was found and cancelled. </dd></dl>

</div>
</div>
<a id="ga5e7e761f76a8dc42e40f6693514f3da0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e7e761f76a8dc42e40f6693514f3da0">&#9670;&nbsp;</a></span>MessageFlushTask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16 MessageFlushTask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="message___8h.html#a51d7b6544fb734b892b35ce3f56a579a">Task</a>&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cancel all queued messages (independent of id) for the given task. Normally used as part of the process of freeing a task. This function will also stop the task being registered with the firmware as the recipient of any system messages. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>The task to flush all message for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of messages removed from the queue. </dd></dl>

</div>
</div>
<a id="gab073d6e18fc7734b64b17adf1f36fece"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab073d6e18fc7734b64b17adf1f36fece">&#9670;&nbsp;</a></span>MessageFree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MessageFree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="message___8h.html#aa135f64d9b1113995d9335c8e9314d95">MessageId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="message___8h.html#acc69ef471490ab4c4bfd1e511aba5c74">Message</a>&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees the memory pointer to by data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The message identifier. </td></tr>
    <tr><td class="paramname">data</td><td>A pointer to the memory to free. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadbb9fcff871c16cf57f12847e26abed4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadbb9fcff871c16cf57f12847e26abed4">&#9670;&nbsp;</a></span>MessagePendingFirst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MessagePendingFirst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="message___8h.html#a51d7b6544fb734b892b35ce3f56a579a">Task</a>&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="message___8h.html#aa135f64d9b1113995d9335c8e9314d95">MessageId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32 *&#160;</td>
          <td class="paramname"><em>first_due</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search the message queue for the first specified message pending delivery to the specified task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>The task whose messages will be searched. </td></tr>
    <tr><td class="paramname">id</td><td>The message id to seek. </td></tr>
    <tr><td class="paramname">first_due</td><td>The relative time at which the first message pending is due for delivery. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if a message was found pending delivery. </dd></dl>

</div>
</div>
<a id="ga3a491ae8deeebdcb69fc57f3c6f4d1cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a491ae8deeebdcb69fc57f3c6f4d1cd">&#9670;&nbsp;</a></span>MessagePioTask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="message___8h.html#a51d7b6544fb734b892b35ce3f56a579a">Task</a> MessagePioTask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="message___8h.html#a51d7b6544fb734b892b35ce3f56a579a">Task</a>&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a task to handle PIO changes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>This task will receive #MESSAGE_PIO_CHANGED messages when the pins configured by <a class="el" href="group__trapset__core.html#gae422dd475550e0305818cd7c0fd521f5" title="Access BlueCore I/O lines. ">PioDebounce32()</a>, <a class="el" href="group__trapset__core.html#gab20a5012dcde3b261ac0c02ea315cc49" title="Configure PIO monitoring. This function configures a simple debounce engine for PIO input pins...">PioDebounce32Bank()</a> and <a class="el" href="group__trapset__core.html#ga824a46697f21bb2c9b9305b671dda178" title="Configure PIO monitoring. This function configures a simple debounce engine for PIO input pins...">PioDebounceGroup32Bank()</a> change. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The old task (or zero). </dd></dl>

</div>
</div>
<a id="gaa608780f111499c54dbde65797a25e82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa608780f111499c54dbde65797a25e82">&#9670;&nbsp;</a></span>MessageSendConditionally()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MessageSendConditionally </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="message___8h.html#a51d7b6544fb734b892b35ce3f56a579a">Task</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="message___8h.html#aa135f64d9b1113995d9335c8e9314d95">MessageId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="message___8h.html#acc69ef471490ab4c4bfd1e511aba5c74">Message</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16 *&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a message to be be delivered when the corresponding uint16 is zero. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The task to deliver the message to. </td></tr>
    <tr><td class="paramname">id</td><td>The message identifier. </td></tr>
    <tr><td class="paramname">m</td><td>The message data. </td></tr>
    <tr><td class="paramname">c</td><td>The condition that must be zero for the message to be delivered. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0f39613be3d1455b29e6ed560e692c1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f39613be3d1455b29e6ed560e692c1c">&#9670;&nbsp;</a></span>MessageSendLater()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MessageSendLater </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="message___8h.html#a51d7b6544fb734b892b35ce3f56a579a">Task</a>&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="message___8h.html#aa135f64d9b1113995d9335c8e9314d95">MessageId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>delay</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a message to the corresponding task after the given delay in ms. The message will be passed to free after delivery. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>The task to deliver the message to. </td></tr>
    <tr><td class="paramname">id</td><td>The message type identifier. </td></tr>
    <tr><td class="paramname">message</td><td>The message data (if any). </td></tr>
    <tr><td class="paramname">delay</td><td>The delay in ms before the message will be sent. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadb6312b84d032d71479a6894f092fa0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb6312b84d032d71479a6894f092fa0b">&#9670;&nbsp;</a></span>MessageSendMulticastConditionally()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MessageSendMulticastConditionally </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="message___8h.html#a51d7b6544fb734b892b35ce3f56a579a">Task</a> *&#160;</td>
          <td class="paramname"><em>tlist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="message___8h.html#aa135f64d9b1113995d9335c8e9314d95">MessageId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="message___8h.html#acc69ef471490ab4c4bfd1e511aba5c74">Message</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16 *&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a message to be be delivered when the corresponding uint16 is zero. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tlist</td><td>Pointer to the NULL-terminated table of tasks to deliver the message to. You must not include a task more than once in the list, and the maximum number of recipient tasks is 15. </td></tr>
    <tr><td class="paramname">id</td><td>The message identifier. </td></tr>
    <tr><td class="paramname">m</td><td>The message data. </td></tr>
    <tr><td class="paramname">c</td><td>The condition that must be zero for the message to be delivered. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad6c1dcd05bf9acf829d645a954d86964"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6c1dcd05bf9acf829d645a954d86964">&#9670;&nbsp;</a></span>MessageSendMulticastLater()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MessageSendMulticastLater </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="message___8h.html#a51d7b6544fb734b892b35ce3f56a579a">Task</a> *&#160;</td>
          <td class="paramname"><em>tasks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="message___8h.html#aa135f64d9b1113995d9335c8e9314d95">MessageId</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>delay</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a message to the corresponding tasks after the given delay in ms. The message will be passed to free after delivery. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tasks</td><td>Pointer to the NULL-terminated table of tasks to deliver the message to. You must not include a task more than once in the list, and the maximum number of recipient tasks is 15. </td></tr>
    <tr><td class="paramname">id</td><td>The message type identifier. </td></tr>
    <tr><td class="paramname">message</td><td>The message data (if any). </td></tr>
    <tr><td class="paramname">delay</td><td>The delay in ms before the message will be sent. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga04c5032d8f7be7ce07da6ee9f41244b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga04c5032d8f7be7ce07da6ee9f41244b3">&#9670;&nbsp;</a></span>MessagesPendingForTask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16 MessagesPendingForTask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="message___8h.html#a51d7b6544fb734b892b35ce3f56a579a">Task</a>&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32 *&#160;</td>
          <td class="paramname"><em>first_due</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search the message queue for all messages pending delivery to the specified task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>The task whose messages will be searched. </td></tr>
    <tr><td class="paramname">first_due</td><td>The relative time at which the first message pending is due for delivery. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of messages pending delivery. </dd></dl>

</div>
</div>
<a id="gabd1023998e25adee54f220a8d71736ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd1023998e25adee54f220a8d71736ae">&#9670;&nbsp;</a></span>MessageSystemTask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="message___8h.html#a51d7b6544fb734b892b35ce3f56a579a">Task</a> MessageSystemTask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="message___8h.html#a51d7b6544fb734b892b35ce3f56a579a">Task</a>&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a task to handle system-wide messages. </p>
<p>Currently the system-wide messages are:</p><ul>
<li>#MESSAGE_USB_ENUMERATED</li>
<li>#MESSAGE_USB_SUSPENDED</li>
<li>#MESSAGE_USB_DECONFIGURED</li>
<li>#MESSAGE_USB_ALT_INTERFACE</li>
<li>#MESSAGE_USB_ATTACHED</li>
<li>#MESSAGE_USB_DETACHED</li>
<li>#MESSAGE_PSFL_FAULT</li>
<li>#MESSAGE_TX_POWER_CHANGE_EVENT</li>
<li>#MESSAGE_SD_MMC_INSERTED</li>
<li>#MESSAGE_SD_MMC_REMOVED Other such messages may be added. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>The task which will receive the messages. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The old task (or zero). </dd></dl>
</li>
</ul>

</div>
</div>
<a id="ga77b36f30530a6cd62a2e0f34a787063c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77b36f30530a6cd62a2e0f34a787063c">&#9670;&nbsp;</a></span>MessageWait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MessageWait </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Block waiting for the next message. This function will either: </p>
<ul>
<li>Fill out 'm' if a message is ready for delivery.</li>
<li>Send the VM to sleep until message delivery time if a message exists but is not ready for delivery.</li>
<li>Send the VM to sleep for the range of a uint32 if no message exists. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>This will be filled out if a message is ready to be delivered.</td></tr>
  </table>
  </dd>
</dl>
WARNING: This trap is UNIMPLEMENTED </li>
</ul>

</div>
</div>
<a id="ga1f71ebda91fa4b2a1f9e536e6e93026e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f71ebda91fa4b2a1f9e536e6e93026e">&#9670;&nbsp;</a></span>OsInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OsInit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialises the P1 Operating System. Must be called before doing anything else. </p>

</div>
</div>
<a id="ga1e04428a714d6c8c97cb8685f96933ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e04428a714d6c8c97cb8685f96933ee">&#9670;&nbsp;</a></span>Panic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Panic </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Panics the application unconditionally. </p>

</div>
</div>
<a id="gad521eaeab7a57e2afcf52019a0e1670a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad521eaeab7a57e2afcf52019a0e1670a">&#9670;&nbsp;</a></span>PanicNotNull()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PanicNotNull </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Panics the application if the pointer passed is not NULL, otherwise returns. </p>

</div>
</div>
<a id="ga5f213a19d903e302c9772792603d7874"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f213a19d903e302c9772792603d7874">&#9670;&nbsp;</a></span>PanicNull()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* PanicNull </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Panics the application if the pointer passed is NULL, otherwise returns the pointer. </p>

</div>
</div>
<a id="gac2cbbcab5783657bfe528a818be2eaa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac2cbbcab5783657bfe528a818be2eaa4">&#9670;&nbsp;</a></span>PanicUnlessMalloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* PanicUnlessMalloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates sz words and returns a pointer to the memory if successful. If the memory allocation fails, the application is panicked. </p>

</div>
</div>
<a id="gae422dd475550e0305818cd7c0fd521f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae422dd475550e0305818cd7c0fd521f5">&#9670;&nbsp;</a></span>PioDebounce32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 PioDebounce32 </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>period</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access BlueCore I/O lines. </p>
<p>fileBlueCore variants from BlueCore2 onwards have twelve Programmable Input/Output(PIO) pins and a further three or four pins (dependant on BlueCore variant) may be available if they are not being used as AIO pins.</p>
<p>Some BlueCore variants from BlueCore5-MM onwards have 16 PIO pins and can also control some of the chips UART/PCM lines by mapping them in as PIO pins 16 and greater. Mapping a UART/PCM line as a PIO line stops the line performing its original function, so these lines should only be used as PIOs when these interfaces are not required.</p>
<p>Attempts to configure the upper 16 PIOs will be rejected if these pins have not been mapped first.</p>
<p>Persistent Store keys may be set to hand control of certain PIO pins over to the BlueCore firmware. Examples include PSKEY_USB_PIO_WAKEUP, PSKEY_USB_PIO_DETACH, PSKEY_USB_PIO_PULLUP and PSKEY_USB_PIO_VBUS. In such configurations the VM should not attempt to use these pins.</p>
<p>Various other hardware and software configurations make use of specific PIO pins. Examples include</p><ul>
<li>Pio[1:0] Used to control external hardware on Class 1 modules.</li>
<li>Pio[7:6] Used for I2C. Configure PIO monitoring. This function configures a simple debounce engine for PIO input pins. It can detect transitions on PIOs and return stabilised readings for them, filtering out glitches. When the engine detects a change in state of one or more of the monitored pins, it repeatedly reads the pin state. If the state of all the monitored pins remains unchanged for <em>count</em> successive samples, it is considered stable and a #MESSAGE_PIO_CHANGED message is sent to the task registered with <a class="el" href="group__trapset__core.html#ga3a491ae8deeebdcb69fc57f3c6f4d1cd" title="Register a task to handle PIO changes. ">MessagePioTask()</a>. Calling PioDebounce has the same behaviour as calling PioDebounce32Bank using bank 0 or as calling PioDebounceGroup32Bank using group 0 and bank 0. <dl class="section note"><dt>Note</dt><dd>It is not possible to configure different debounce settings for different pins or groups of pins, or to debounce pins independently of each other. Examples: To enable events on PIO2 and PIO3, with 4 reads 2ms apart (6ms total): <div class="fragment"><div class="line"><a class="code" href="group__trapset__core.html#gae422dd475550e0305818cd7c0fd521f5">PioDebounce32</a>(1u&lt;&lt;2 | 1u&lt;&lt;3, 4, 2);</div></div><!-- fragment --> To enable events on any transition on PIO5 with no debouncing: <div class="fragment"><div class="line"><a class="code" href="group__trapset__core.html#gae422dd475550e0305818cd7c0fd521f5">PioDebounce32</a>(1u&lt;&lt;5, 1, 0);</div></div><!-- fragment --> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>Bitmask indicating which pins to monitor. Setting this to zero disables PIO monitoring. </td></tr>
    <tr><td class="paramname">count</td><td>How many times the monitored pins' state must be observed to be consistent before it is considered stable. Zero and one have special significance. If <em>count</em> is 1, then no debouncing is performed - any perceived change of the pins will raise the event. If <em>count</em> is 0, any transition raises the event, even if no change in pin state can be detected; in this case, the "state" members of #MessagePioChanged may show no change in state. </td></tr>
    <tr><td class="paramname">period</td><td>The delay in milliseconds between successive reads of the pins. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 32 bit mask. If any bit in this mask is high then monitoring could not be set up for that PIO; no action will have been taken on any PIOs (any previously set up monitoring will remain in force). The most likely reasons for a non-zero return are attempting to debounce nonexistent PIOs, or attempting to debounce unmapped PIOs. See the <a class="el" href="group__trapset__core.html#ga7451bed3c1711348d8d7cf8abc3ff3fb" title="Maps PIOs as software or hardware controlled. Before using a PIO as a software controlled digital IO ...">PioSetMapPins32()</a> documentation for information on which PIOs can be mapped. </dd></dl>
</li>
</ul>

</div>
</div>
<a id="gab20a5012dcde3b261ac0c02ea315cc49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab20a5012dcde3b261ac0c02ea315cc49">&#9670;&nbsp;</a></span>PioDebounce32Bank()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 PioDebounce32Bank </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>bank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>period</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure PIO monitoring. This function configures a simple debounce engine for PIO input pins. It can detect transitions on PIOs and return stabilised readings for them, filtering out glitches. When the engine detects a change in state of one or more of the monitored pins, it repeatedly reads the pin state. If the state of all the monitored pins remains unchanged for <em>count</em> successive samples, it is considered stable and a #MESSAGE_PIO_CHANGED message is sent to the task registered with <a class="el" href="group__trapset__core.html#ga3a491ae8deeebdcb69fc57f3c6f4d1cd" title="Register a task to handle PIO changes. ">MessagePioTask()</a>. Calling PioDebounce32Bank has the same behaviour as calling PioDebounceGroup32Bank using group 0. </p>
<dl class="section note"><dt>Note</dt><dd>It is not possible to configure different debounce settings for different pins or groups of pins, or to debounce pins independently of each other. Examples: To enable events on PIO2 and PIO3, with 4 reads 2ms apart (6ms total): <div class="fragment"><div class="line"><a class="code" href="group__trapset__core.html#gab20a5012dcde3b261ac0c02ea315cc49">PioDebounce32Bank</a>(1u&lt;&lt;2 | 1u&lt;&lt;3, 4, 2);</div></div><!-- fragment --> To enable events on any transition on PIO5 with no debouncing: <div class="fragment"><div class="line"><a class="code" href="group__trapset__core.html#gab20a5012dcde3b261ac0c02ea315cc49">PioDebounce32Bank</a>(1u&lt;&lt;5, 1, 0);</div></div><!-- fragment --> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bank</td><td>PIO bank number. </td></tr>
    <tr><td class="paramname">mask</td><td>Bitmask indicating which pins to monitor. Setting this to zero disables PIO monitoring. </td></tr>
    <tr><td class="paramname">count</td><td>How many times the monitored pins' state must be observed to be consistent before it is considered stable. Zero and one have special significance. If <em>count</em> is 1, then no debouncing is performed - any perceived change of the pins will raise the event. If <em>count</em> is 0, any transition raises the event, even if no change in pin state can be detected; in this case, the "state" members of #MessagePioChanged may show no change in state. </td></tr>
    <tr><td class="paramname">period</td><td>The delay in milliseconds between successive reads of the pins. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 32 bit mask. If any bit in this mask is high then monitoring could not be set up for that PIO; no action will have been taken on any PIOs (any previously set up monitoring will remain in force). The most likely reasons for a non-zero return are attempting to debounce nonexistent PIOs, or attempting to debounce unmapped PIOs. See the <a class="el" href="group__trapset__core.html#ga7451bed3c1711348d8d7cf8abc3ff3fb" title="Maps PIOs as software or hardware controlled. Before using a PIO as a software controlled digital IO ...">PioSetMapPins32()</a> documentation for information on which PIOs can be mapped. </dd></dl>

</div>
</div>
<a id="ga824a46697f21bb2c9b9305b671dda178"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga824a46697f21bb2c9b9305b671dda178">&#9670;&nbsp;</a></span>PioDebounceGroup32Bank()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 PioDebounceGroup32Bank </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>bank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>period</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure PIO monitoring. This function configures a simple debounce engine for PIO input pins. It can detect transitions on PIOs and return stabilised readings for them, filtering out glitches. It supports two distinct groups of PIOs. The settings apply to all the selected PIOs in a group. A PIO can belong in both groups at the same time and will fulfill both functions. When the engine detects a change in state of one or more of the monitored pins, it repeatedly reads the pin state. If the state of all the monitored pins remains unchanged for <em>count</em> successive samples, it is considered stable and a #MESSAGE_PIO_CHANGED message is sent to the task registered with <a class="el" href="group__trapset__core.html#ga3a491ae8deeebdcb69fc57f3c6f4d1cd" title="Register a task to handle PIO changes. ">MessagePioTask()</a>. </p>
<dl class="section note"><dt>Note</dt><dd>It is not possible to configure different debounce settings for different pins within the same group. If a pin is used in more than one group it will generate one message for each group after each group's conditions have been met. Examples: On group 0, enable events on PIO2 and PIO3, with 4 reads 2ms apart (6ms total): <div class="fragment"><div class="line"><a class="code" href="group__trapset__core.html#ga824a46697f21bb2c9b9305b671dda178">PioDebounceGroup32Bank</a>(0, 0, 1u&lt;&lt;2 | 1u&lt;&lt;3, 4, 2);</div></div><!-- fragment --> On group 1, enable events on any transition on PIO5 with no debouncing: <div class="fragment"><div class="line"><a class="code" href="group__trapset__core.html#ga824a46697f21bb2c9b9305b671dda178">PioDebounceGroup32Bank</a>(1, 0, 1u&lt;&lt;5, 1, 0);</div></div><!-- fragment --> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group</td><td>PIO group number, 0 or 1. </td></tr>
    <tr><td class="paramname">bank</td><td>PIO bank number. </td></tr>
    <tr><td class="paramname">mask</td><td>Bitmask indicating which pins to monitor. Setting this to zero disables PIO monitoring. </td></tr>
    <tr><td class="paramname">count</td><td>How many times the monitored pins' state must be observed to be consistent before it is considered stable. Zero and one have special significance. If <em>count</em> is 1, then no debouncing is performed - any perceived change of the pins will raise the event. If <em>count</em> is 0, any transition raises the event, even if no change in pin state can be detected; in this case, the "state" members of #MessagePioChanged may show no change in state. </td></tr>
    <tr><td class="paramname">period</td><td>The delay in milliseconds between successive reads of the pins. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 32 bit mask. If any bit in this mask is high then monitoring could not be set up for that PIO; no action will have been taken on any PIOs (any previously set up monitoring will remain in force). The most likely reasons for a non-zero return are attempting to debounce nonexistent PIOs, or attempting to debounce unmapped PIOs. See the <a class="el" href="group__trapset__core.html#ga7451bed3c1711348d8d7cf8abc3ff3fb" title="Maps PIOs as software or hardware controlled. Before using a PIO as a software controlled digital IO ...">PioSetMapPins32()</a> documentation for information on which PIOs can be mapped. If the selected group is not supported then the full mask is returned. </dd></dl>

</div>
</div>
<a id="ga331b12d7aded7665e97b71dd8bff2394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga331b12d7aded7665e97b71dd8bff2394">&#9670;&nbsp;</a></span>PioGet32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 PioGet32 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the contents of the PIO data input register. For PIOs set as outputs, this function will return the value last written using <a class="el" href="group__trapset__core.html#gab8b6a9c39b5548acf9502dac2e3d0460" title="Modifies the contents of the PIO data output register. PIO pins must be set to outputs via PioSetDir3...">PioSet32()</a>. </p>

</div>
</div>
<a id="ga8923976e553cfccb3046dd83eec70b07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8923976e553cfccb3046dd83eec70b07">&#9670;&nbsp;</a></span>PioGet32Bank()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 PioGet32Bank </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>bank</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the contents of one of the PIO data input registers. For PIOs set as outputs, this function will return the value last written using <a class="el" href="group__trapset__core.html#ga075bb2aa0eb39cdcc3a79df1858dd9c5" title="Modifies the contents of the PIO data output register. PIO pins must be set to outputs via PioSetDir3...">PioSet32Bank()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bank</td><td>PIO bank number. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafe5055c2acd1ff98af305445fd702b71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe5055c2acd1ff98af305445fd702b71">&#9670;&nbsp;</a></span>PioGetDir32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 PioGetDir32 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read whether PIOs are set as inputs or outputs. </p>
<dl class="section return"><dt>Returns</dt><dd>Each bit in the return value corresponds to a PIO line. Bits set to 1 mean that PIO line is configured as an output. Bits set to 0 mean it is configured as an input. </dd></dl>

</div>
</div>
<a id="ga073ee23b4eced6eca1c6d53096115766"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga073ee23b4eced6eca1c6d53096115766">&#9670;&nbsp;</a></span>PioGetDir32Bank()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 PioGetDir32Bank </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>bank</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read whether PIOs are set as inputs or outputs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bank</td><td>PIO bank number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Each bit in the return value corresponds to a PIO line. Bits set to 1 mean that PIO line is configured as an output. Bits set to 0 mean it is configured as an input. </dd></dl>

</div>
</div>
<a id="ga44a67a64875119f87e27484622a41597"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga44a67a64875119f87e27484622a41597">&#9670;&nbsp;</a></span>PioGetDriveStrength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pin_drive_strength_id PioGetDriveStrength </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>pin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the drive strength setting of a particular PIO pin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pin</td><td>- Pin that requires a drive strength read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- Supported drive strength configured for the specified pin. </dd></dl>

</div>
</div>
<a id="gac90327f5c3f39279c06b090bcb17dc95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac90327f5c3f39279c06b090bcb17dc95">&#9670;&nbsp;</a></span>PioGetMapPins32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 PioGetMapPins32 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a 32 bit value showing which PIO lines have been mapped to chip pins (see documentation for <a class="el" href="group__trapset__core.html#ga7451bed3c1711348d8d7cf8abc3ff3fb" title="Maps PIOs as software or hardware controlled. Before using a PIO as a software controlled digital IO ...">PioSetMapPins32()</a> for more detail). </p>

</div>
</div>
<a id="gaa8b6d38e1472f9ef2e2774fdb1f517c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8b6d38e1472f9ef2e2774fdb1f517c5">&#9670;&nbsp;</a></span>PioGetMapPins32Bank()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 PioGetMapPins32Bank </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>bank</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a 32 bit value showing which PIO lines have been mapped to chip pins (see documentation for <a class="el" href="group__trapset__core.html#ga7451bed3c1711348d8d7cf8abc3ff3fb" title="Maps PIOs as software or hardware controlled. Before using a PIO as a software controlled digital IO ...">PioSetMapPins32()</a> for more detail). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bank</td><td>PIO bank number. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad115c4b2f6289e82b479bed1e4a07214"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad115c4b2f6289e82b479bed1e4a07214">&#9670;&nbsp;</a></span>PioGetStrongBias32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 PioGetStrongBias32 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read whether PIOs are set to use strong or weak pull. </p>

</div>
</div>
<a id="ga8e986c442c71151c658ba595abb3f087"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8e986c442c71151c658ba595abb3f087">&#9670;&nbsp;</a></span>PioGetStrongBias32Bank()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 PioGetStrongBias32Bank </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>bank</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read whether PIOs are set to use strong or weak pull. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bank</td><td>PIO bank number. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga54513e8eb01f7347c2f25f0fd88f2942"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga54513e8eb01f7347c2f25f0fd88f2942">&#9670;&nbsp;</a></span>PioGetUnusedPins32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 PioGetUnusedPins32 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine which physically existing PIOs are currently not in use by firmware or VM apps. </p>
<dl class="section return"><dt>Returns</dt><dd>Those PIOs which are available for use. b31 = PIO31 thru b0 = PIO0. A '1' indicates available. </dd></dl>

</div>
</div>
<a id="gaa17c4d391f04896e8f34d0506d05b02e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa17c4d391f04896e8f34d0506d05b02e">&#9670;&nbsp;</a></span>PioGetUnusedPins32Bank()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 PioGetUnusedPins32Bank </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>bank</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine which physically existing PIOs are currently not in use by firmware or VM apps. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bank</td><td>PIO bank number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Those PIOs which are available for use. b31 = PIO31 thru b0 = PIO0. A '1' indicates available. </dd></dl>

</div>
</div>
<a id="gab8b6a9c39b5548acf9502dac2e3d0460"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab8b6a9c39b5548acf9502dac2e3d0460">&#9670;&nbsp;</a></span>PioSet32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 PioSet32 </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>bits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modifies the contents of the PIO data output register. PIO pins must be set to outputs via <a class="el" href="group__trapset__core.html#gac5d01f1a8a23db805b3062a2fd1e2ae7" title="Set PIOs as inputs or outputs. ">PioSetDir32()</a> before they can be driven high or low through this trap. This trap also sets pull direction for PIOs used as inputs. </p>
<p>Note that all PIOs must be mapped in before they can be used. See the <a class="el" href="group__trapset__core.html#ga7451bed3c1711348d8d7cf8abc3ff3fb" title="Maps PIOs as software or hardware controlled. Before using a PIO as a software controlled digital IO ...">PioSetMapPins32()</a> documentation for information on valid PIO directions and PIO mapping. <br />
 BlueCore has internal resistors which can be configured to either pull-up or pull-down the pins used for input. This is controlled by the value written to the output register using <a class="el" href="group__trapset__core.html#gab8b6a9c39b5548acf9502dac2e3d0460" title="Modifies the contents of the PIO data output register. PIO pins must be set to outputs via PioSetDir3...">PioSet32()</a>. The resistors pull-down if the value is zero, and pull-up otherwise, so the following fragment sets pins 1 and 2 to inputs with pin 1 configured to pull-up and pin 2 configured to pull-down. </p><div class="fragment"><div class="line"><a class="code" href="group__trapset__core.html#gab8b6a9c39b5548acf9502dac2e3d0460">PioSet32</a>(2|4, 2);</div><div class="line"><a class="code" href="group__trapset__core.html#gac5d01f1a8a23db805b3062a2fd1e2ae7">PioSetDir32</a>(2|4, 0);</div></div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>Each bit in the mask corresponds to a PIO line. Bits set to 1 in this mask will be modified. Bits set to 0 in this mask will not be modified. </td></tr>
    <tr><td class="paramname">bits</td><td>Each bit in the "bits" value corresponds to a PIO line. Bits set to 1 in this value will result in that PIO line being driven high. Bits set to 0 in this value will result in that PIO line being driven low. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 32 bit mask. If any bit in this mask is high then that PIO could not be driven to the level specified; note that no action will have been taken on any PIOs. </dd></dl>

</div>
</div>
<a id="ga075bb2aa0eb39cdcc3a79df1858dd9c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga075bb2aa0eb39cdcc3a79df1858dd9c5">&#9670;&nbsp;</a></span>PioSet32Bank()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 PioSet32Bank </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>bank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>bits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modifies the contents of the PIO data output register. PIO pins must be set to outputs via <a class="el" href="group__trapset__core.html#gab1dbaf5222c281095fe8b0d02090af3a" title="Set PIOs as inputs or outputs. ">PioSetDir32Bank()</a> before they can be driven high or low through this trap. This trap also sets pull direction for PIOs used as inputs. </p>
<p>Note that all PIOs must be mapped in before they can be used. See the <a class="el" href="group__trapset__core.html#ga950a88ec1cd8ec2b916ef900ab95eb7b" title="Maps PIOs as software or hardware controlled. Before using a PIO as a software controlled digital IO ...">PioSetMapPins32Bank()</a> documentation for information on valid PIO directions and PIO mapping. <br />
 BlueCore has internal resistors which can be configured to either pull-up or pull-down the pins used for input. This is controlled by the value written to the output register using <a class="el" href="group__trapset__core.html#ga075bb2aa0eb39cdcc3a79df1858dd9c5" title="Modifies the contents of the PIO data output register. PIO pins must be set to outputs via PioSetDir3...">PioSet32Bank()</a>. The resistors pull-down if the value is zero, and pull-up otherwise, so the following fragment sets pins 1 and 2 to inputs with pin 1 configured to pull-up and pin 2 configured to pull-down. </p><div class="fragment"><div class="line"><a class="code" href="group__trapset__core.html#ga075bb2aa0eb39cdcc3a79df1858dd9c5">PioSet32Bank</a>(0, 2|4, 2);</div><div class="line"><a class="code" href="group__trapset__core.html#gab1dbaf5222c281095fe8b0d02090af3a">PioSetDir32Bank</a>(0, 2|4, 0);</div></div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bank</td><td>PIO bank number. </td></tr>
    <tr><td class="paramname">mask</td><td>Each bit in the mask corresponds to a PIO line. Bits set to 1 in this mask will be modified. Bits set to 0 in this mask will not be modified. </td></tr>
    <tr><td class="paramname">bits</td><td>Each bit in the "bits" value corresponds to a PIO line. Bits set to 1 in this value will result in that PIO line being driven high. Bits set to 0 in this value will result in that PIO line being driven low. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 32 bit mask. If any bit in this mask is high then that PIO could not be driven to the level specified; note that no action will have been taken on any PIOs. </dd></dl>

</div>
</div>
<a id="ga7a73bc7aabc60037bc51e1bd45089c79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a73bc7aabc60037bc51e1bd45089c79">&#9670;&nbsp;</a></span>PioSetDeepSleepEitherLevelBank()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PioSetDeepSleepEitherLevelBank </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>bank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows the chip to deep sleep irrespective of the level of the PIO lines. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bank</td><td>The bank index of the PIO lines. </td></tr>
    <tr><td class="paramname">mask</td><td>Bitmask to select the PIO lines to update within the given bank. </td></tr>
    <tr><td class="paramname">value</td><td>Each bit corresponds to a PIO line in the selected bank. Traditionally BlueCore chips will stay out of deep sleep when any PIO line configured as an input is high. This behaviour can be modified with <a class="el" href="group__trapset__core.html#ga1f2761e3c373ed67224e5c6ad2bfb446" title="Controls the state for each PIO line that will wake the chip from deep sleep. The PIO lines must alre...">PioSetWakeupStateBank()</a> Setting a bit high will result in the chip waking when that line goes high, setting the bit low will cause the chip to wake when the line goes low. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac5d01f1a8a23db805b3062a2fd1e2ae7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5d01f1a8a23db805b3062a2fd1e2ae7">&#9670;&nbsp;</a></span>PioSetDir32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 PioSetDir32 </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>dir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set PIOs as inputs or outputs. </p>
<p>Note that all PIOs must be mapped in before they can be used. See the <a class="el" href="group__trapset__core.html#ga7451bed3c1711348d8d7cf8abc3ff3fb" title="Maps PIOs as software or hardware controlled. Before using a PIO as a software controlled digital IO ...">PioSetMapPins32()</a> documentation for information on valid PIO directions and PIO mapping. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>Each bit in the mask corresponds to a PIO line. Bits set to 1 in this mask will be modified. Bits set to 0 in this mask will not be modified. </td></tr>
    <tr><td class="paramname">dir</td><td>Each bit in the "dir" value corresponds to a PIO line. Bits set to 1 in this value will result in that PIO line being configured as an output. Bits set to 0 in this value will result in that PIO line being configured as an input. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 32 bit mask. If any bit in this mask is high then that PIO could not be set to the direction specified; note that no action will have been taken on any PIOs. </dd></dl>

</div>
</div>
<a id="gab1dbaf5222c281095fe8b0d02090af3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab1dbaf5222c281095fe8b0d02090af3a">&#9670;&nbsp;</a></span>PioSetDir32Bank()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 PioSetDir32Bank </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>bank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>dir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set PIOs as inputs or outputs. </p>
<p>Note that all PIOs must be mapped in before they can be used. See the <a class="el" href="group__trapset__core.html#ga950a88ec1cd8ec2b916ef900ab95eb7b" title="Maps PIOs as software or hardware controlled. Before using a PIO as a software controlled digital IO ...">PioSetMapPins32Bank()</a> documentation for information on valid PIO directions and PIO mapping. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bank</td><td>PIO bank number. </td></tr>
    <tr><td class="paramname">mask</td><td>Each bit in the mask corresponds to a PIO line. Bits set to 1 in this mask will be modified. Bits set to 0 in this mask will not be modified. </td></tr>
    <tr><td class="paramname">dir</td><td>Each bit in the "dir" value corresponds to a PIO line. Bits set to 1 in this value will result in that PIO line being configured as an output. Bits set to 0 in this value will result in that PIO line being configured as an input. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 32 bit mask. If any bit in this mask is high then that PIO could not be set to the direction specified; note that no action will have been taken on any PIOs. </dd></dl>

</div>
</div>
<a id="ga09b4b66d1e139080ef57eea9693ad2cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga09b4b66d1e139080ef57eea9693ad2cc">&#9670;&nbsp;</a></span>PioSetDriveStrength32Bank()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 PioSetDriveStrength32Bank </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>bank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pin_drive_strength_id&#160;</td>
          <td class="paramname"><em>drive_strength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the drive strength for given PIOs Depending on the PIO in question there may be several options for the drive strength. Please consult the datasheet to see which pins support which drive strength values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bank</td><td>PIO bank number. </td></tr>
    <tr><td class="paramname">mask</td><td>Each bit in the mask corresponds to a PIO line. Bits set to 1 in this mask will be modified. Bits set to 0 in this mask will not be modified. </td></tr>
    <tr><td class="paramname">drive_strength</td><td>Supported drive strength that needs to be set for the specified PIOs. Refer to #pin_drive_strength_id . </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 32 bit mask. If any bit in this mask is high then that PIO could not be set to use the given drive strength ID; note that no action will have been taken on any PIOs. </dd></dl>

</div>
</div>
<a id="ga93d107d956c1ac62d3b5807e0f18d661"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga93d107d956c1ac62d3b5807e0f18d661">&#9670;&nbsp;</a></span>PioSetFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PioSetFunction </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>pin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pin_function_id&#160;</td>
          <td class="paramname"><em>function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a supported function for particular pio pin if a pin can be mapped as LED, UART, BITSERIAL, ANALOGUE etc, then this function can be used to set the pin for one of the supported functions. Consult the device's data sheet to understand what functions are supported for each PIO pins. A pin can support only few functions. Trying to set a function which is NOT supported by the pin will return FALSE without affecting/modifying the existing pin function. Before this trap can be used, it is necessary to use PioSetMapPins32Bank to put the PIO in HW mode. For functions corresponding to other susbystems the OTHER function ID must be used. This reverts the PIOs to the initial unmapped state. Any further use by the app needs remapping. <a class="el" href="group__trapset__core.html#ga93d107d956c1ac62d3b5807e0f18d661" title="Sets a supported function for particular pio pin if a pin can be mapped as LED, UART, BITSERIAL, ANALOGUE etc, then this function can be used to set the pin for one of the supported functions. Consult the device&#39;s data sheet to understand what functions are supported for each PIO pins. A pin can support only few functions. Trying to set a function which is NOT supported by the pin will return FALSE without affecting/modifying the existing pin function. Before this trap can be used, it is necessary to use PioSetMapPins32Bank to put the PIO in HW mode. For functions corresponding to other susbystems the OTHER function ID must be used. This reverts the PIOs to the initial unmapped state. Any further use by the app needs remapping. PioSetFunction() Usage Example: if PIO[20] can be mapped to UART/BITSERIAL/LED/PIO and currently PIO[20] is mapped as PIO, then App should call the PioSetMapPins32Bank() to unmap it from PIO and then call PioSetFunction() to map to (UART/BITSERIAL/LED/PIO) function. Unmap PIO[20] so that it can be mapped to a function PioSetMapPins32Bank(0, 1&lt;&lt;20, 0&lt;&lt;20); This will map PIO[20] line as UART_RX PioSetFunction(20, UART_RX);   To map back the PIO[20] as a PIO, PioSetMapPins32Bank() should be used. PioSetMapPins32Bank(0, 1&lt;&lt;20, 1&lt;&lt;20);. ">PioSetFunction()</a> Usage Example: if PIO[20] can be mapped to UART/BITSERIAL/LED/PIO and currently PIO[20] is mapped as PIO, then App should call the <a class="el" href="group__trapset__core.html#ga950a88ec1cd8ec2b916ef900ab95eb7b" title="Maps PIOs as software or hardware controlled. Before using a PIO as a software controlled digital IO ...">PioSetMapPins32Bank()</a> to unmap it from PIO and then call <a class="el" href="group__trapset__core.html#ga93d107d956c1ac62d3b5807e0f18d661" title="Sets a supported function for particular pio pin if a pin can be mapped as LED, UART, BITSERIAL, ANALOGUE etc, then this function can be used to set the pin for one of the supported functions. Consult the device&#39;s data sheet to understand what functions are supported for each PIO pins. A pin can support only few functions. Trying to set a function which is NOT supported by the pin will return FALSE without affecting/modifying the existing pin function. Before this trap can be used, it is necessary to use PioSetMapPins32Bank to put the PIO in HW mode. For functions corresponding to other susbystems the OTHER function ID must be used. This reverts the PIOs to the initial unmapped state. Any further use by the app needs remapping. PioSetFunction() Usage Example: if PIO[20] can be mapped to UART/BITSERIAL/LED/PIO and currently PIO[20] is mapped as PIO, then App should call the PioSetMapPins32Bank() to unmap it from PIO and then call PioSetFunction() to map to (UART/BITSERIAL/LED/PIO) function. Unmap PIO[20] so that it can be mapped to a function PioSetMapPins32Bank(0, 1&lt;&lt;20, 0&lt;&lt;20); This will map PIO[20] line as UART_RX PioSetFunction(20, UART_RX);   To map back the PIO[20] as a PIO, PioSetMapPins32Bank() should be used. PioSetMapPins32Bank(0, 1&lt;&lt;20, 1&lt;&lt;20);. ">PioSetFunction()</a> to map to (UART/BITSERIAL/LED/PIO) function. Unmap PIO[20] so that it can be mapped to a function PioSetMapPins32Bank(0, 1&lt;&lt;20, 0&lt;&lt;20); This will map PIO[20] line as UART_RX PioSetFunction(20, UART_RX); <br />
 To map back the PIO[20] as a PIO, <a class="el" href="group__trapset__core.html#ga950a88ec1cd8ec2b916ef900ab95eb7b" title="Maps PIOs as software or hardware controlled. Before using a PIO as a software controlled digital IO ...">PioSetMapPins32Bank()</a> should be used. PioSetMapPins32Bank(0, 1&lt;&lt;20, 1&lt;&lt;20);. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pin</td><td>Pin that requires a function change; the pin value ranges from 0 to 95. </td></tr>
    <tr><td class="paramname">function</td><td>Supported function that needs to be set for the specified pin. Refer #pin_function_id </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if successful, else FALSE. </dd></dl>

</div>
</div>
<a id="ga7451bed3c1711348d8d7cf8abc3ff3fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7451bed3c1711348d8d7cf8abc3ff3fb">&#9670;&nbsp;</a></span>PioSetMapPins32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 PioSetMapPins32 </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>bits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps PIOs as software or hardware controlled. Before using a PIO as a software controlled digital IO a call to this function is required. Not mapping the PIO may cause other functions in the PIO trap API to return errors and not produce the required behaviour. To put a PIO under HW control the app needs to call this function first and then PioSetFunction to select the HW functionality needed. Please note that there is no default state, all PIOs should be considered unmapped and unusable until they are configured by a call to this function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>Each bit in the mask corresponds to a PIO line. Bits set to 1 in this mask will be modified. Bits set to 0 in this mask will not be modified. </td></tr>
    <tr><td class="paramname">bits</td><td>Each bit corresponds to a PIO line. A bit set to 1 will cause a PIO to be behave as a software controlled pin. A bit set to 0 will result in the pio being marked as controlled by a hardware peripheral. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 32 bit mask. If any bit in this mask is high then that PIO could not be mapped or unmapped; note that no action will have been taken on any PIOs. </dd></dl>

</div>
</div>
<a id="ga950a88ec1cd8ec2b916ef900ab95eb7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga950a88ec1cd8ec2b916ef900ab95eb7b">&#9670;&nbsp;</a></span>PioSetMapPins32Bank()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 PioSetMapPins32Bank </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>bank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>bits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps PIOs as software or hardware controlled. Before using a PIO as a software controlled digital IO a call to this function is required. Not mapping the PIO may cause other functions in the PIO trap API to return errors and not produce the required behaviour. To put a PIO under HW control the app needs to call this function first and then PioSetFunction to select the HW functionality needed. Please note that there is no default state, all PIOs should be considered unmapped and unusable until they are configured by a call to this function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bank</td><td>PIO bank number. </td></tr>
    <tr><td class="paramname">mask</td><td>Each bit in the mask corresponds to a PIO line. Bits set to 1 in this mask will be modified. Bits set to 0 in this mask will not be modified. </td></tr>
    <tr><td class="paramname">bits</td><td>Each bit corresponds to a PIO line. A bit set to 1 will cause a PIO to be behave as a software controlled pin. A bit set to 0 will result in the pio being marked as controlled by a hardware peripheral. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 32 bit mask. If any bit in this mask is high then that PIO could not be mapped or unmapped; note that no action will have been taken on any PIOs. </dd></dl>

</div>
</div>
<a id="gabb2506f71cad70178cd2b03068c7b6a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb2506f71cad70178cd2b03068c7b6a0">&#9670;&nbsp;</a></span>PioSetStrongBias32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 PioSetStrongBias32 </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>bits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set PIOs to use strong or weak pull when used as inputs. </p>
<div class="fragment"><div class="line"><a class="code" href="group__trapset__core.html#gac5d01f1a8a23db805b3062a2fd1e2ae7">PioSetDir32</a>((1&lt;&lt;4)|(1&lt;&lt;5), 0);</div><div class="line"><a class="code" href="group__trapset__core.html#gab8b6a9c39b5548acf9502dac2e3d0460">PioSet32</a>((1&lt;&lt;4)|(1&lt;&lt;5), (1&lt;&lt;4));</div><div class="line"><a class="code" href="group__trapset__core.html#gabb2506f71cad70178cd2b03068c7b6a0">PioSetStrongBias32</a>((1&lt;&lt;4)|(1&lt;&lt;5), (1&lt;&lt;5));</div></div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>Each bit in the mask corresponds to a PIO line. Bits set to 1 in this mask will be modified. Bits set to 0 in this mask will not be modified. </td></tr>
    <tr><td class="paramname">bits</td><td>Each bit in the "bits" value corresponds to a PIO line. Bits set to 1 in this value will result in that PIO line being configured as having strong bias. Bits set to 0 in this value will result in that PIO line being configured as not having strong bias. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 32 bit mask. If any bit in this mask is high then that PIO could not be set to use strong bias; note that no action will have been taken on any PIOs. BlueCore includes weak internal pull-ups or pull-downs on pins which are being used as inputs (see <a class="el" href="group__trapset__core.html#gab8b6a9c39b5548acf9502dac2e3d0460" title="Modifies the contents of the PIO data output register. PIO pins must be set to outputs via PioSetDir3...">PioSet32()</a>). This function allows the pull-up or pull-down to be made stronger on a per-pin basis. So to set pin 4 and 5 as inputs, 4 pulled up weakly, 5 pulled down strongly </dd></dl>

</div>
</div>
<a id="ga7753e1edbb0539bc14c4d41acf3560f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7753e1edbb0539bc14c4d41acf3560f7">&#9670;&nbsp;</a></span>PioSetStrongBias32Bank()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 PioSetStrongBias32Bank </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>bank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>bits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set PIOs to use strong or weak pull when used as inputs. </p>
<div class="fragment"><div class="line"><a class="code" href="group__trapset__core.html#gac5d01f1a8a23db805b3062a2fd1e2ae7">PioSetDir32</a>((1&lt;&lt;4)|(1&lt;&lt;5), 0);</div><div class="line"><a class="code" href="group__trapset__core.html#gab8b6a9c39b5548acf9502dac2e3d0460">PioSet32</a>((1&lt;&lt;4)|(1&lt;&lt;5), (1&lt;&lt;4));</div><div class="line"><a class="code" href="group__trapset__core.html#gabb2506f71cad70178cd2b03068c7b6a0">PioSetStrongBias32</a>((1&lt;&lt;4)|(1&lt;&lt;5), (1&lt;&lt;5));</div></div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bank</td><td>PIO bank number. </td></tr>
    <tr><td class="paramname">mask</td><td>Each bit in the mask corresponds to a PIO line. Bits set to 1 in this mask will be modified. Bits set to 0 in this mask will not be modified. </td></tr>
    <tr><td class="paramname">bits</td><td>Each bit in the "bits" value corresponds to a PIO line. Bits set to 1 in this value will result in that PIO line being configured as having strong bias. Bits set to 0 in this value will result in that PIO line being configured as not having strong bias. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 32 bit mask. If any bit in this mask is high then that PIO could not be set to use strong bias; note that no action will have been taken on any PIOs. BlueCore includes weak internal pull-ups or pull-downs on pins which are being used as inputs (see <a class="el" href="group__trapset__core.html#gab8b6a9c39b5548acf9502dac2e3d0460" title="Modifies the contents of the PIO data output register. PIO pins must be set to outputs via PioSetDir3...">PioSet32()</a>). This function allows the pull-up or pull-down to be made stronger on a per-pin basis. So to set pin 4 and 5 as inputs, 4 pulled up weakly, 5 pulled down strongly </dd></dl>

</div>
</div>
<a id="ga1f2761e3c373ed67224e5c6ad2bfb446"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f2761e3c373ed67224e5c6ad2bfb446">&#9670;&nbsp;</a></span>PioSetWakeupStateBank()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PioSetWakeupStateBank </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>bank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Controls the state for each PIO line that will wake the chip from deep sleep. The PIO lines must already have been configured to wake the chip. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bank</td><td>The bank index of the PIO lines. </td></tr>
    <tr><td class="paramname">mask</td><td>Bitmask to select the PIO lines to update within the given bank. </td></tr>
    <tr><td class="paramname">value</td><td>Each bit corresponds to a PIO line in the selected bank. Setting a bit high will result in the chip waking when that line goes high, setting the bit low will cause the chip to wake when the line goes low. Default is wakeup when line goes high. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3745e8701fe6def6453aa66679b025e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3745e8701fe6def6453aa66679b025e7">&#9670;&nbsp;</a></span>PsDefrag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PsDefrag </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start PS store defragmentation in the background. </p>
<p>Changing a key with <a class="el" href="group__trapset__core.html#ga023228f45d2cede814c9bed9dcef5680" title="Copy the specified memory buffer to persistent store. A Persistent store user key can be deleted by c...">PsStore()</a> trap adds a new instance of the key to PS store. After some time the store becomes filled with multiple instances of the same keys that consume space. To remove the old data and recover space in the store, defragmentation needs to be performed from time to time. Defragmentation is started automatically if after a PsStore request the store is more than 90% full or can be started manually at any time using this trap or the <a class="el" href="group__trapset__core.html#ga7c21cf7e57edf43a3d540ef0f1ce1a0e" title="Defragment the PS store Changing a key with PsStore() trap adds a new instance of the key to PS store...">PsDefragBlocking()</a> trap.</p>
<p>Unlike previous chips, defragmentation runs in the background and normally is completely transparent to the application. However it can cause some disruption to time-sensitive activities (e.g. streaming audio) depending on overall system load. It is recommended for the application to monitor PS store level with <a class="el" href="group__trapset__core.html#ga3131cc8f4279f63f535db41c4bbb9423" title="Return how many keys of this size in words we could write. ">PsFreeCount()</a> and call <a class="el" href="group__trapset__core.html#ga3745e8701fe6def6453aa66679b025e7" title="Start PS store defragmentation in the background. ">PsDefrag()</a> preventively when idle.</p>
<p>For the reference with 64KB store, PsFreeCount(16) returns 142 when store is 90% full and 1055 when store is 90% empty.</p>
<p>Defragmentation can take up to several seconds to complete depending on the store content, system load and flash chip performance. See <a class="el" href="group__trapset__core.html#ga7c21cf7e57edf43a3d540ef0f1ce1a0e" title="Defragment the PS store Changing a key with PsStore() trap adds a new instance of the key to PS store...">PsDefragBlocking()</a> for a version of this trap that returns once the defragmentation operation is complete. </p>

</div>
</div>
<a id="ga7c21cf7e57edf43a3d540ef0f1ce1a0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c21cf7e57edf43a3d540ef0f1ce1a0e">&#9670;&nbsp;</a></span>PsDefragBlocking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PsDefragBlocking </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defragment the PS store Changing a key with <a class="el" href="group__trapset__core.html#ga023228f45d2cede814c9bed9dcef5680" title="Copy the specified memory buffer to persistent store. A Persistent store user key can be deleted by c...">PsStore()</a> trap adds a new instance of the key to PS store. After some time the store becomes filled with multiple instances of the same keys that consume space. To remove the old data and recover space in the store, defragmentation needs to be performed from time to time. Defragmentation is started automatically if after a PsStore request the store is more than 90% full or can be started manually at any time using this trap or the <a class="el" href="group__trapset__core.html#ga3745e8701fe6def6453aa66679b025e7" title="Start PS store defragmentation in the background. ">PsDefrag()</a> trap. For the reference with 64KB store, PsFreeCount(16) returns 142 when store is 90% full and 1055 when store is 90% empty. This trap will run defragmentation in a blocking manner, i.e. upon calling this trap, control will not be returned to the application until defragmentation is complete. Defragmentation is a time and memory intensive operation, it is recommended that this trap only be called if it's acceptable for the application to be blocked for several seconds. See <a class="el" href="group__trapset__core.html#ga3745e8701fe6def6453aa66679b025e7" title="Start PS store defragmentation in the background. ">PsDefrag()</a> for the non-blocking version of this trap. </p>

</div>
</div>
<a id="ga4b29378f646885e1becc6723e02184c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b29378f646885e1becc6723e02184c8">&#9670;&nbsp;</a></span>PsDrop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PsDrop </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the given key from the system cache. Only applicable to the PSKEY_READONLY key set, this call removes the specified key from the system cache, freeing up system memory. This also makes it unreadable until the next power-cycle, so the customer application should take care to not read the key again. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The persistent store key to drop. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns TRUE if the key is successfully removed, FALSE if the key is not (or doesn't exist). </dd></dl>

</div>
</div>
<a id="ga3131cc8f4279f63f535db41c4bbb9423"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3131cc8f4279f63f535db41c4bbb9423">&#9670;&nbsp;</a></span>PsFreeCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16 PsFreeCount </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>words</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return how many keys of this size in words we could write. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">words</td><td>The key size in words to use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga24848f899c37a03f5ad510d66051faae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga24848f899c37a03f5ad510d66051faae">&#9670;&nbsp;</a></span>PsFullRetrieve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16 PsFullRetrieve </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>words</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read any persistent store key from the full range of supported keys. Note this function can be used to obtain values both for Bluecore PS keys and for Apps Subsystem PS keys. Unlike <a class="el" href="group__trapset__core.html#ga023228f45d2cede814c9bed9dcef5680" title="Copy the specified memory buffer to persistent store. A Persistent store user key can be deleted by c...">PsStore()</a> and <a class="el" href="group__trapset__core.html#ga41e5381ab0482e665e9d7d4ff8760e74" title="Copy to specified memory buffer from persistent store. ">PsRetrieve()</a> it does not use a PS key index in the range [0, 289]. It can be used for three different purposes. </p>
<ol type="1">
<li>To obtain legacy Bluecore PS keys now stored as MIB keys in the Apps Subsystem.</li>
<li>To obtain Apps Subsystem keys.</li>
<li>To obtain Bluetooth Subsystem keys, on supported devices see below.</li>
</ol>
<p>For 1) the following keys may be used:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">PS Key Name  </th><th class="markdownTableHeadNone">PS Key ID  </th><th class="markdownTableHeadNone">Associated MIB key   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">PSKEY_THERMAL_SHUTDOWN_PERIOD  </td><td class="markdownTableBodyNone">9704  </td><td class="markdownTableBodyNone">255   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">PSKEY_SHUTDOWN_TEMPERATURE  </td><td class="markdownTableBodyNone">9705  </td><td class="markdownTableBodyNone">256   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">PSKEY_THERMAL_SHUTDOWN_LONG_PERIOD  </td><td class="markdownTableBodyNone">9706  </td><td class="markdownTableBodyNone">257   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">PSKEY_RAMPDOWN_TEMPERATURE  </td><td class="markdownTableBodyNone">32000  </td><td class="markdownTableBodyNone">258   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">PSKEY_REENABLE_TEMPERATURE  </td><td class="markdownTableBodyNone">32001  </td><td class="markdownTableBodyNone">259   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">PSKEY_CHARGER_MAXIMUM_CURRENT_TRICKLE  </td><td class="markdownTableBodyNone">32002  </td><td class="markdownTableBodyNone">260   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">PSKEY_CHARGER_MAXIMUM_CURRENT_PRE  </td><td class="markdownTableBodyNone">32003  </td><td class="markdownTableBodyNone">261   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">PSKEY_CHARGER_MAXIMUM_CURRENT_FAST  </td><td class="markdownTableBodyNone">32004  </td><td class="markdownTableBodyNone">262   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">PSKEY_CHARGER_MAXIMUM_VOLTAGE  </td><td class="markdownTableBodyNone">9691  </td><td class="markdownTableBodyNone">263   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">PSKEY_USB_BCD_DEVICE  </td><td class="markdownTableBodyNone">125  </td><td class="markdownTableBodyNone">14   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">PSKEY_USB_VERSION  </td><td class="markdownTableBodyNone">700  </td><td class="markdownTableBodyNone">11   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">PSKEY_USB_DEVICE_CLASS_CODES  </td><td class="markdownTableBodyNone">701  </td><td class="markdownTableBodyNone">16   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">PSKEY_USB_VENDOR_ID  </td><td class="markdownTableBodyNone">702  </td><td class="markdownTableBodyNone">12   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">PSKEY_USB_PRODUCT_ID  </td><td class="markdownTableBodyNone">703  </td><td class="markdownTableBodyNone">13   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">PSKEY_USB_MANUF_STRING  </td><td class="markdownTableBodyNone">705  </td><td class="markdownTableBodyNone">7   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">PSKEY_USB_PRODUCT_STRING  </td><td class="markdownTableBodyNone">706  </td><td class="markdownTableBodyNone">8   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">PSKEY_USB_SERIAL_NUMBER_STRING  </td><td class="markdownTableBodyNone">707  </td><td class="markdownTableBodyNone">9   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">PSKEY_USB_CONFIG_STRING  </td><td class="markdownTableBodyNone">708  </td><td class="markdownTableBodyNone">10   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">PSKEY_USB_MAX_POWER  </td><td class="markdownTableBodyNone">709  </td><td class="markdownTableBodyNone">17   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">PSKEY_USB_LANGID  </td><td class="markdownTableBodyNone">713  </td><td class="markdownTableBodyNone">15   </td></tr>
</table>
<p>The ten PSKEY_READONLY(n) keys map onto the equivalent CustomerReadOnlyKey(n) MIBKEYs. These can be read but not written by the application.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">PS Key Name  </th><th class="markdownTableHeadNone">PS Key ID  </th><th class="markdownTableHeadNone">Associated MIB key   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">PSKEY_READONLY0  </td><td class="markdownTableBodyNone">10282  </td><td class="markdownTableBodyNone">295   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">PSKEY_READONLY1  </td><td class="markdownTableBodyNone">10283  </td><td class="markdownTableBodyNone">296   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">PSKEY_READONLY2  </td><td class="markdownTableBodyNone">10284  </td><td class="markdownTableBodyNone">297   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">PSKEY_READONLY3  </td><td class="markdownTableBodyNone">10285  </td><td class="markdownTableBodyNone">298   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">PSKEY_READONLY4  </td><td class="markdownTableBodyNone">10286  </td><td class="markdownTableBodyNone">299   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">PSKEY_READONLY5  </td><td class="markdownTableBodyNone">10287  </td><td class="markdownTableBodyNone">300   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">PSKEY_READONLY6  </td><td class="markdownTableBodyNone">10288  </td><td class="markdownTableBodyNone">301   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">PSKEY_READONLY7  </td><td class="markdownTableBodyNone">10289  </td><td class="markdownTableBodyNone">302   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">PSKEY_READONLY8  </td><td class="markdownTableBodyNone">10290  </td><td class="markdownTableBodyNone">303   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">PSKEY_READONLY9  </td><td class="markdownTableBodyNone">10291  </td><td class="markdownTableBodyNone">304   </td></tr>
</table>
<p>For 2) these keys may be used:</p>
<p>PS Key ID Name | PS Key ID Value | 0..519 space as used by PsRetrieve </p><h2>----------------------------------&mdash; | ------------&mdash; | </h2>
<p>[PSKEY_USR0, PSKEY_USR49] | [650, 699] | [0, 49] [PSKEY_DSP0, PSKEY_DSP49] | [8792, 8841] | [50, 99] [PSKEY_CONNLIB0, PSKEY_CONNLIB49] | [9742, 9791] | [100, 149] [PSKEY_USR50, PSKEY_USR99] | [10142, 10191] | [150, 199] [PSKEY_CUSTOMER0, PSKEY_CUSTOMER89 ] | [10192, 10281] | [200, 289] [PSKEY_CUSTOMER90, PSKEY_CUSTOMER300 ]| [10292, 10502] | [300, 509] [PSKEY_UPGRADE0, PSKEY_UPGRADE9 ] | [10792, 10801] | [510, 519]</p>
<p>For 3) any known Bluetooth Subsystem PS key may be used. <br />
 This class of keys can only be accessed on CSRA68100, QCC302x and QCC512x.</p>
<p>Note that you can override any value with a zero-length value, so testing for a zero-length value does not have this problem. Usually this means you can obey this rule by allowing a zero length key to behave the same as an absent key.</p>
<p>The correct way to read a key which may be a zero length pskey is as follows </p><pre class="fragment">uint16 pio = 0xffff;
if (PsFullRetrieve(PSKEY_*., &amp;pio, sizeof(pio)) &amp;&amp; pio &lt;= 15)
</pre><p>PsFullRetrieve leaves the initialisation of pio unchanged if the key isn't present, PsFullRetrieve returns FALSE if the key doesn't exist.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The persistent store key to copy data from. </td></tr>
    <tr><td class="paramname">buff</td><td>The memory buffer to copy data to, must be word aligned. </td></tr>
    <tr><td class="paramname">words</td><td>The number of uint16 words to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If <em>buff</em> is NULL and <em>words</em> is zero, returns the minimum length in words of the buffer necessary to hold the contents of <em>key</em>. Otherwise, returns the number of words actually read, or zero if the key does not exist or is longer than <em>words</em>. </dd></dl>

</div>
</div>
<a id="ga8b1a86c9c80f7e8a46966ff4f3364afa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b1a86c9c80f7e8a46966ff4f3364afa">&#9670;&nbsp;</a></span>PsGetStore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PsStores PsGetStore </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current PS store used for PS operations. </p>
<dl class="section return"><dt>Returns</dt><dd>The PS store currently used.</dd></dl>
<p>WARNING: This trap is UNIMPLEMENTED </p>

</div>
</div>
<a id="ga8859a805b5bebaa5253777fc5ae1d838"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8859a805b5bebaa5253777fc5ae1d838">&#9670;&nbsp;</a></span>PsNextAudioKey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PsNextAudioKey </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32 *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Give the next Audio key stored in the PsStore. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>0 for start the search from the begining of the store 1 to have the next key.</td></tr>
    <tr><td class="paramname">key</td><td>This is the location where to save the next Audiokey found in the store (or 0 if all Audiokeys have been read.) The first Audiokey stored is returned when the reset of the function is called: PsNextAudioKey(0, key)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return True if there are still Audiokeys in PsStore. Return False if the Audiokey previously read was the last one. </dd></dl>

</div>
</div>
<a id="ga980b769d87fe77a4c25aa1e486eb0a85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga980b769d87fe77a4c25aa1e486eb0a85">&#9670;&nbsp;</a></span>PsNextKey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PsNextKey </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16 *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Give the next Apps key stored in PsStore. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>0 for start from the begining of the store, 1 for the next key.</td></tr>
    <tr><td class="paramname">key</td><td>This is the location where to save the next appkey found in the store (or 0 if all Appkeys have been read.) The first appkey stored is returned when the reset of the function is called: PsNextKey(0, key)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return True if there are still Appkeys in PsStore. Return False if the Appkey previously read was the last one. </dd></dl>

</div>
</div>
<a id="ga975489202189811bf857457d694697e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga975489202189811bf857457d694697e3">&#9670;&nbsp;</a></span>PsReadAudioKey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16 PsReadAudioKey </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16 *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>words</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16 *&#160;</td>
          <td class="paramname"><em>key_length_addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy to specified memory buffer from audio persistent store. A Persistent store audio key can be read by the application by invoking this trap. </p>
<p>The trap can be used to read any part of the key data using the <code>offset</code> and <code>words</code> fields.</p>
<p>The trap can also be used to find the key length without copying any data: </p><pre class="fragment">PsReadAudioKey(key, NULL, 0, 0, &amp;key_len);
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The persistent store audio key to copy data from. </td></tr>
    <tr><td class="paramname">buffer</td><td>The memory buffer to copy data to. </td></tr>
    <tr><td class="paramname">words</td><td>The number of words to copy. </td></tr>
    <tr><td class="paramname">offset</td><td>Number of words from the start of the key to read data. </td></tr>
    <tr><td class="paramname">key_length_addr</td><td>Pointer to return the length of the key in uint16 words. Can be "NULL" if the length is not needed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 if input <em>buffer</em> is NULL. Otherwise, returns the number of words actually read, or zero if the key does not exist. </dd></dl>

</div>
</div>
<a id="ga41e5381ab0482e665e9d7d4ff8760e74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41e5381ab0482e665e9d7d4ff8760e74">&#9670;&nbsp;</a></span>PsRetrieve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16 PsRetrieve </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>words</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy to specified memory buffer from persistent store. </p>
<dl class="section note"><dt>Note</dt><dd>The key is an Apps Subsystem key and is interpreted as an index into PSKEY_USR0 ... PSKEY_USR49, PSKEY_DSP0 ... PSKEY_DSP49, PSKEY_CONNLIB0 ... PSKEY_CONNLIB49, PSKEY_USR50 ... PSKEY_USR99, <br />
 PSKEY_CUSTOMER0 ... PSKEY_CUSTOMER89, PSKEY_CUSTOMER90 ... PSKEY_CUSTOMER299, PSKEY_UPGRADE0 ... PSKEY_UPGRADE9 No other keys can be read by an application using this function. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The persistent store key to copy data from. </td></tr>
    <tr><td class="paramname">buff</td><td>The memory buffer to copy data to, must be word aligned. </td></tr>
    <tr><td class="paramname">words</td><td>The number of uint16 words to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If <em>buff</em> is NULL and <em>words</em> is zero, returns the minimum length in words of the buffer necessary to hold the contents of <em>key</em>. Otherwise, returns the number of words actually read, or zero if the key does not exist or is longer than <em>words</em>. </dd></dl>

</div>
</div>
<a id="ga218eeae791e9c3b75eb200f825d3dad1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga218eeae791e9c3b75eb200f825d3dad1">&#9670;&nbsp;</a></span>PsSetStore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PsSetStore </td>
          <td>(</td>
          <td class="paramtype">PsStores&#160;</td>
          <td class="paramname"><em>store</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the PS Store that are used for subsequent PS operations. </p>
<dl class="section note"><dt>Note</dt><dd>Any store in the BlueCore firmware can be set as default using this trap. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">store</td><td>The PS store to be used</td></tr>
  </table>
  </dd>
</dl>
<p>WARNING: This trap is UNIMPLEMENTED </p>

</div>
</div>
<a id="ga023228f45d2cede814c9bed9dcef5680"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga023228f45d2cede814c9bed9dcef5680">&#9670;&nbsp;</a></span>PsStore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16 PsStore </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>words</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy the specified memory buffer to persistent store. A Persistent store user key can be deleted by calling the <a class="el" href="group__trapset__core.html#ga023228f45d2cede814c9bed9dcef5680" title="Copy the specified memory buffer to persistent store. A Persistent store user key can be deleted by c...">PsStore()</a> function with <em>key</em> to be deleted and <em>words</em> argument being zero. </p>
<p><a class="el" href="group__trapset__core.html#ga023228f45d2cede814c9bed9dcef5680" title="Copy the specified memory buffer to persistent store. A Persistent store user key can be deleted by c...">PsStore()</a> trap can trigger defragmentation if PS store is filled to over 90%. Defragmentation runs in the background and can cause some disruption to time-sensitive activities (e.g. streaming audio) depending on overall system load. It is recommended that the application monitors the PS store level with <a class="el" href="group__trapset__core.html#ga3131cc8f4279f63f535db41c4bbb9423" title="Return how many keys of this size in words we could write. ">PsFreeCount()</a> and calls <a class="el" href="group__trapset__core.html#ga3745e8701fe6def6453aa66679b025e7" title="Start PS store defragmentation in the background. ">PsDefrag()</a> when idle to avoid potential disruption.</p>
<dl class="section note"><dt>Note</dt><dd>The <em>key</em> is an Apps Subsystem key and is interpreted as an index into PSKEY_USR0 ... PSKEY_USR49, PSKEY_DSP0 ... PSKEY_DSP49, PSKEY_CONNLIB0 ... PSKEY_CONNLIB49, PSKEY_USR50 ... PSKEY_USR99, <br />
 PSKEY_CUSTOMER0 ... PSKEY_CUSTOMER89, PSKEY_CUSTOMER90 ... PSKEY_CUSTOMER299, PSKEY_UPGRADE0 ... PSKEY_UPGRADE9 No other keys can be written from an application. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The persistent store key to copy data to. </td></tr>
    <tr><td class="paramname">buff</td><td>The memory buffer to copy data from, must be word aligned. </td></tr>
    <tr><td class="paramname">words</td><td>The number of uint16 words to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of words actually written. Zero if either <em>words</em> is zero or the store failed. Store can fail for the following reasons:<ul>
<li><em>key</em> is greater than #PSKEY_MAX_APPKEY_INDEX.</li>
<li><em>buff</em> pointer is not uint16 word aligned.</li>
<li>PS store is locked by <a class="el" href="group__trapset__imageupgrade.html#ga43686ccae4a7d0ba6103ba96f5a61606" title="Reset the chip, load and run using the images (if present) from the other image bank in all QSPI devi...">ImageUpgradeSwapTry()</a> during DFU.</li>
<li>PS store does not have enough space for the key, defragmentation needs to be started with <a class="el" href="group__trapset__core.html#ga3745e8701fe6def6453aa66679b025e7" title="Start PS store defragmentation in the background. ">PsDefrag()</a> trap. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaf047136770ad108db893089f9a88b510"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf047136770ad108db893089f9a88b510">&#9670;&nbsp;</a></span>PsUpdateAudioKey()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16 PsUpdateAudioKey </td>
          <td>(</td>
          <td class="paramtype">uint32&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16 *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>words</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>key_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy the specified memory buffer to audio persistent store. A Persistent store audio key can be changed by the application by invoking this trap. </p>
<p>Since audio keys can be long, this API allows writing the new value in several steps using the <code>offset</code> field.</p>
<p>Note, that keys can't be partialy updated, the whole new value of a key must be written. Also, blocks of data can't be written out of order. The write is finalised and the new key value becomes effective once the last block of data is written.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The persistent store audio key to copy data to. </td></tr>
    <tr><td class="paramname">buffer</td><td>The memory buffer to copy data from. </td></tr>
    <tr><td class="paramname">words</td><td>Number of word of key data to write. </td></tr>
    <tr><td class="paramname">offset</td><td>Number of words from the start of the key to write data. Block of data will be written at this offset. This must always be equal to the number of words written so far, out-of-order data writes are not supported.</td></tr>
    <tr><td class="paramname">key_length</td><td>Length of the key data in uint16 words. This value gives overall key length and must be the same when calling the trap several times to write blocks of key data. The key update completes and the new value becomes effective once exactly this many words have been written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of words actually written. Zero if either <code>words</code> is zero or the update failed. </dd></dl>

</div>
</div>
<a id="gac9f50ffe8d0d22dfede85d6f17c0e6b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac9f50ffe8d0d22dfede85d6f17c0e6b1">&#9670;&nbsp;</a></span>UtilCompareByte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int UtilCompareByte </td>
          <td>(</td>
          <td class="paramtype">const uint8 *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8 *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility routines. </p>
<p>fileThese routines perform a number of frequently required tasks. They will execute at a greater speed than similar routines written in VM application code. Compare two blocks of memory of extent 'size', as uint8's. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First memory block to compare. </td></tr>
    <tr><td class="paramname">b</td><td>Second memory block to compare. </td></tr>
    <tr><td class="paramname">size</td><td>Size of memory blocks to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&gt; 0 if 'a' is lexicographically greater than 'b', &lt; 0 if 'a' is lexicographically less than 'b', 0 if 'a' and 'b' have identical contents. </dd></dl>

</div>
</div>
<a id="ga10ab002ecb0b1660141b892cd61be208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10ab002ecb0b1660141b892cd61be208">&#9670;&nbsp;</a></span>UtilCompareWord()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int UtilCompareWord </td>
          <td>(</td>
          <td class="paramtype">const uint16 *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16 *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two blocks of memory of extent 'size', as uint16's. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First memory block to compare. </td></tr>
    <tr><td class="paramname">b</td><td>Second memory block to compare. </td></tr>
    <tr><td class="paramname">size</td><td>Size of memory blocks to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&gt; 0 if 'a' is lexicographically greater than 'b', &lt; 0 if 'a' is lexicographically less than 'b', 0 if 'a' and 'b' have identical contents. </dd></dl>

</div>
</div>
<a id="gaeab962f598a36bb777bb47f26064541a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeab962f598a36bb777bb47f26064541a">&#9670;&nbsp;</a></span>UtilFindByte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8* UtilFindByte </td>
          <td>(</td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8 *&#160;</td>
          <td class="paramname"><em>data_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two memory blocks. Conceptually we have a table in memory starting at 'data_start', with 'count' entries where each entry is 'size'. UtilFindByte searches for 'value', at 'offset' from the start of each entry, using bitmask 'mask'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>The bitmask to use. </td></tr>
    <tr><td class="paramname">value</td><td>The value to look for. </td></tr>
    <tr><td class="paramname">data_start</td><td>The memory location of the start of the table. </td></tr>
    <tr><td class="paramname">offset</td><td>The offset into each table entry that the search will be performed at. </td></tr>
    <tr><td class="paramname">size</td><td>The size of each table entry. </td></tr>
    <tr><td class="paramname">count</td><td>The number of entries in the table. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>VM address of the table entry containing 'value' if found, else 0. </dd></dl>

</div>
</div>
<a id="ga6013ef492ba46f94fc0bf3388d18a927"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6013ef492ba46f94fc0bf3388d18a927">&#9670;&nbsp;</a></span>UtilFindWord()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16* UtilFindWord </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16 *&#160;</td>
          <td class="paramname"><em>data_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two memory blocks. Conceptually we have a table in memory starting at 'data_start', with 'count' entries where each entry is 'size'. UtilFindWord searches for 'value', at 'offset' from the start of each entry, using bitmask 'mask'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>The bitmask to use. </td></tr>
    <tr><td class="paramname">value</td><td>The value to look for. </td></tr>
    <tr><td class="paramname">data_start</td><td>The memory location of the start of the table. </td></tr>
    <tr><td class="paramname">offset</td><td>The offset into each table entry that the search will be performed at. </td></tr>
    <tr><td class="paramname">size</td><td>The size of each table entry. </td></tr>
    <tr><td class="paramname">count</td><td>The number of entries in the table. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>VM address of the table entry containing 'value' if found, else 0. </dd></dl>

</div>
</div>
<a id="gaec0024ab0aa069db2a69e502556405fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec0024ab0aa069db2a69e502556405fb">&#9670;&nbsp;</a></span>UtilGetNumber()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8* UtilGetNumber </td>
          <td>(</td>
          <td class="paramtype">const uint8 *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8 *&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16 *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a string into a number. Note that the string converted here will not include the character pointed to by 'end'. That is, to convert the string "123" you would need to call 'UtilGetNumber(start, start+3, &amp;result)'. The number is expected to be an unsigned decimal in the range 0 to 2^16-1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>The start of the string to convert. </td></tr>
    <tr><td class="paramname">end</td><td>The 'end' of the string to convert. </td></tr>
    <tr><td class="paramname">result</td><td>Will contain the resulting number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer into the string (the first character after the number) unless no number was found, in which case 0 is returned. </dd></dl>

</div>
</div>
<a id="ga5332498b655fe38db0208fdda040fbce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5332498b655fe38db0208fdda040fbce">&#9670;&nbsp;</a></span>UtilHash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16 UtilHash </td>
          <td>(</td>
          <td class="paramtype">const uint8 *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>seed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a uint16 hash value for the memory at 'data', of extent 'size' uint16's, starting with the given 'seed'. This function is deprecated. Please use UtilHashWord instead <br />
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The start of the memory block to hash. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the memory block to hash. </td></tr>
    <tr><td class="paramname">seed</td><td>The seed value to use for the hash. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa1cb9d9e27d64c37203ca1bc883b5f11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1cb9d9e27d64c37203ca1bc883b5f11">&#9670;&nbsp;</a></span>UtilHashByte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8 UtilHashByte </td>
          <td>(</td>
          <td class="paramtype">const uint8 *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8&#160;</td>
          <td class="paramname"><em>seed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a uint8 hash value for the memory at 'data', of extent 'size' uint16's, starting with the given 'seed'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The start of the memory block to hash. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the memory block to hash. </td></tr>
    <tr><td class="paramname">seed</td><td>The seed value to use for the hash. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae36e8ea73ce8abf563e5155a26fa4e20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae36e8ea73ce8abf563e5155a26fa4e20">&#9670;&nbsp;</a></span>UtilHashWord()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16 UtilHashWord </td>
          <td>(</td>
          <td class="paramtype">const uint16 *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>seed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a uint16 hash value for the memory at 'data', of extent 'size' uint16's, starting with the given 'seed'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The start of the memory block to hash. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the memory block to hash. </td></tr>
    <tr><td class="paramname">seed</td><td>The seed value to use for the hash. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga48ec60b9c243c79070b96d519994b498"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga48ec60b9c243c79070b96d519994b498">&#9670;&nbsp;</a></span>UtilRandom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16 UtilRandom </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a 16-bit random number. Uses a numerical approach, but the state is shared with the BlueCore firmware which also makes calls into this function so predictability will be low. </p>

</div>
</div>
<a id="gaf3716e288edcbffdc024ccc87fa145fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf3716e288edcbffdc024ccc87fa145fc">&#9670;&nbsp;</a></span>UtilSwap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UtilSwap </td>
          <td>(</td>
          <td class="paramtype">uint16 *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exchanges the high and low bytes of 'size' words at 'data'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The memory location to begin swapping from. </td></tr>
    <tr><td class="paramname">size</td><td>The number of swaps to perform. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa3e62f3b97b056e1d10ec590f072f349"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa3e62f3b97b056e1d10ec590f072f349">&#9670;&nbsp;</a></span>VmAdvertisePowerSetMaximum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VmAdvertisePowerSetMaximum </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>override</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16&#160;</td>
          <td class="paramname"><em>power</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows the application to override the power for LE Adverts. If the override parameter is TRUE request that LE adverts are transmitted at the requested power level. Otherwise revert to the default for the Bluetooth controller. In most cases the controller will select the closest dBm value at or below the requested value, to ensure that max power limits are not exceeded. However, if the requested value is lower than the lowest supported transmit power then the Controller will instead use the lowest supported value. </p>
<p>This Traps will return FALSE on CSRA68105, QCC302x and QCC512x.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">override</td><td>Set TRUE to override the system default or FALSE to revert. </td></tr>
    <tr><td class="paramname">power</td><td>The new power to use for LE Adverts in dBm. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success, else FALSE. </dd></dl>

</div>
</div>
<a id="ga9a1785ecca01fc9ebeb000252198ca36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a1785ecca01fc9ebeb000252198ca36">&#9670;&nbsp;</a></span>VmDeepSleepEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VmDeepSleepEnable </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>en</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables or disables deep sleep. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">en</td><td>FALSE will prevent the chip going into deep sleep. TRUE will permit the chip to go into deep sleep. It can still be blocked from doing so by other firmware components. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previous status. </dd></dl>

</div>
</div>
<a id="ga6b3943587bd8218a9ca0878aa4e983db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b3943587bd8218a9ca0878aa4e983db">&#9670;&nbsp;</a></span>VmDeepSleepWakeSourcesEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VmDeepSleepWakeSourcesEnable </td>
          <td>(</td>
          <td class="paramtype">vm_wake_source_type&#160;</td>
          <td class="paramname"><em>wake_source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>en</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables or disables some deep sleep wake sources. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wake_source</td><td>Wake source ID to enable or disable. </td></tr>
    <tr><td class="paramname">en</td><td>TRUE if wake source should be enabled, FALSE otherwise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the operation was successful, FALSE otherwise. </dd></dl>

</div>
</div>
<a id="ga6d9e41289da06caa7c3e2f025c53a12b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d9e41289da06caa7c3e2f025c53a12b">&#9670;&nbsp;</a></span>VmEnableSecurity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VmEnableSecurity </td>
          <td>(</td>
          <td class="paramtype">security_bits&#160;</td>
          <td class="paramname"><em>enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set chip wide security features in OTP memory. This trap takes a bitfield of security features to write to the OTP (One Time Program) memory in the bitfield format. </p>
<p>Defines for the bits are provided in the header vm_if.h</p>
<p>A chip reset is required for the new OTP settings to become effective. <a class="el" href="group__trapset__core.html#gab55a7127c95c583e769574f57bdd943a" title="Allows the application to read the Security features from OTP memory. This trap takes a bitfield of s...">VmReadSecurity()</a> will not return the new value until the chip is reset.</p>
<p>Once the USB Debug disabled is written, USB Debug will be permanently disabled, with no means to re-enable.</p>
<p>To write the Security bits in OTP the chip needs to lower the voltage on the output of the 'Bypass LDO' to 2.65V. This LDO normally outputs 3.3V (when external power source is connected to VCHG or when BypassLdoForce3v3 System Manager MIB key is set) or 2.9V. Reducing this voltage may affect functionality of USB, audio hardware and/or any external circuitry using this supply rail.</p>
<p>This trap will return FALSE if invalid bits are selected or if SECURITY_DEBUG_TRANSPORT is being set without SECURITY_ENABLE bit set. In these cases the contents of the OTP is not altered.</p>
<p>The SECURITY_ENABLE bit can be set using the BlueFlash component in BlueSuite.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>Security feature bits: Bit 0 Reserved Bit 1 SECURITY_DEBUG_TRANSPORT Bit 2 SECURITY_USBDBG_DISABLED Example: Enable value of 6 (0b110) requests SECURITY_DEBUG_TRANSPORT and SECURITY_USBDBG_DISABLED to be set</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if successful, else FALSE. </dd></dl>

</div>
</div>
<a id="ga02aaa28a27ec99b81a57cfda05500a72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga02aaa28a27ec99b81a57cfda05500a72">&#9670;&nbsp;</a></span>VmGetAvailableAllocations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16 VmGetAvailableAllocations </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts the maximum number of additional memory blocks which can be allocated. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of free slots in the VM memory map. Note that this does not correspond to physical memory; it's possible for malloc() and similar functions to fail even when this function returns non-zero; the value returned by this function is only an upper bound on the number of possible allocations. See CS-110364-ANP "VM Memory Mapping and Memory Usage" for more detail. </dd></dl>

</div>
</div>
<a id="ga03af15948e7d1e33957f054880b91878"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga03af15948e7d1e33957f054880b91878">&#9670;&nbsp;</a></span>VmGetClock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 VmGetClock </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the current value of a 32-bit millisecond timer. Don't poll this; using MessageSendLater is much more efficient. </p>

</div>
</div>
<a id="gadb00022347383cdcc12acc1c4e6347c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb00022347383cdcc12acc1c4e6347c9">&#9670;&nbsp;</a></span>VmGetFwVersion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 VmGetFwVersion </td>
          <td>(</td>
          <td class="paramtype">component_id&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the firmware or application version. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Enumeration to select the component whose version is being read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return the version or 0 if the id key is wrong. </dd></dl>

</div>
</div>
<a id="gaee3dd147edcc2ea19d3ce2316ade376c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee3dd147edcc2ea19d3ce2316ade376c">&#9670;&nbsp;</a></span>VmGetPcmClock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vm_pcm_clock_setting VmGetPcmClock </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables the VM to check the current PCM_CLK frequency, when it is being generated from the 4MHz internal clock. </p>
<dl class="section return"><dt>Returns</dt><dd>A vm_pcm_clock_setting type indicating the current PCM clock frequency.</dd></dl>
<p>WARNING: This trap is UNIMPLEMENTED </p>

</div>
</div>
<a id="gac0705e3271d59f90a2fe6f5437f37c6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac0705e3271d59f90a2fe6f5437f37c6a">&#9670;&nbsp;</a></span>VmGetResetSource()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vm_reset_source VmGetResetSource </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an enum value relating to the cause of the last reset. When a system reset occurs on BC7 chips a value is stored which relates to the cause of the reset. This value can be retrieved by a VM app and takes the enumerated values defined in the #vm_reset_source type. Any value not covered by this definition cannot be determined and is deemed an unexpected reset. See the type definition for more information. </p>
<dl class="section return"><dt>Returns</dt><dd>A #vm_reset_source type indicating the source of the last reset. </dd></dl>

</div>
</div>
<a id="gaddc7b1642cb8ff29eaafae10af122ee9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaddc7b1642cb8ff29eaafae10af122ee9">&#9670;&nbsp;</a></span>VmGetTemperature()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16 VmGetTemperature </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the internal temperature of BlueCore. </p>
<dl class="section return"><dt>Returns</dt><dd>Approximate temperature in degrees Celsius, or INVALID_TEMPERATURE if it could not be read. </dd></dl>

</div>
</div>
<a id="gaccca4dbfa25d3d5529c0b8ab36773b92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaccca4dbfa25d3d5529c0b8ab36773b92">&#9670;&nbsp;</a></span>VmGetTemperatureBySensor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16 VmGetTemperatureBySensor </td>
          <td>(</td>
          <td class="paramtype">vm_temp_sensor&#160;</td>
          <td class="paramname"><em>sensor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the temperature sensors on BlueCore BC7+ chips. </p>
<p>Sensor Action TSENSOR_MAIN Reads cached temp from main sensor TSENSOR_PMU Reads temp from PMU sensor xxx All other sensor numbers return INVALID_SENSOR </p><dl class="section return"><dt>Returns</dt><dd>Temperature in degrees Celsius, or INVALID_TEMPERATURE if it could not be read. </dd></dl>

</div>
</div>
<a id="gae2e6477d6302bd1ff9012449b769e457"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2e6477d6302bd1ff9012449b769e457">&#9670;&nbsp;</a></span>VmGetTimerTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32 VmGetTimerTime </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the current value of the 32-bit micro-second timer. The 32-bit value returned will wrap from 0xFFFFFFFF to 0x00000000 every 2**32 / 1e6 / 60 = 71.6 minutes. Don't poll this; using MessageSendLater is much more efficient. </p>
<dl class="section return"><dt>Returns</dt><dd>The current value of the 32-bit microsecond timer. </dd></dl>

</div>
</div>
<a id="gab6174a6f6a49eaaf125ee06068a91d49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab6174a6f6a49eaaf125ee06068a91d49">&#9670;&nbsp;</a></span>VmPutChar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VmPutChar </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Output a character on the given channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channel</td><td>The character to output. </td></tr>
    <tr><td class="paramname">c</td><td>The channel to output to.</td></tr>
  </table>
  </dd>
</dl>
<p>WARNING: This trap is UNIMPLEMENTED </p>

</div>
</div>
<a id="gab55a7127c95c583e769574f57bdd943a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab55a7127c95c583e769574f57bdd943a">&#9670;&nbsp;</a></span>VmReadSecurity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16 VmReadSecurity </td>
          <td>(</td>
          <td class="paramtype">security_bits&#160;</td>
          <td class="paramname"><em>read_mask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows the application to read the Security features from OTP memory. This trap takes a bitfield of security features to read and returns the settings read from the OTP (One Time Program) memory in the same bitfield format. </p>
<p>Defines for the bits are provided in the header vm_if.h</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">read_mask</td><td>Bitmask indicating bit to read: Bit 0 SECURITY_ENABLE Bit 1 SECURITY_DEBUG_TRANSPORT Bit 2 SECURITY_USBDBG_DISABLED Bit 3 SECURITY_DEBUG_ALLOWED Value of 5 (0b0101) means SECURITY_ENABLE and SECURITY_USBDBG_DISABLED will be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return bits read. Bit 0 SECURITY_ENABLE Bit 1 SECURITY_DEBUG_TRANSPORT Bit 2 SECURITY_USBDBG_DISABLED Bit 3 SECURITY_DEBUG_ALLOWED</dd></dl>
<p>Example: Return value of 3 (0b0011) with the mask set to 15 (0b1111) means SECURITY_ENABLE and SECURITY_DEBUG_TRANSPORT bits are set while SECURITY_USBDBG_DISABLED and SECURITY_DEBUG_ALLOWED bits are not set. </p>

</div>
</div>
<a id="gae8d197784f84effbe11f38ceb3692a44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae8d197784f84effbe11f38ceb3692a44">&#9670;&nbsp;</a></span>VmReadVrefConstant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16 VmReadVrefConstant </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the absolute value for Vref on this version of BlueCore This is a constant value for a given version of BlueCore. See <a class="el" href="adc_8h.html">adc.h</a> for the intended use of this function. In ADK6 firmware, <a class="el" href="group__trapset__core.html#gafb642634557cf5ffb084d67405fb436b" title="Access to ADC hardware. ">AdcReadRequest()</a> will return reading for Vref (#adcsel_vref_hq_buff) without scaling it to a nominal voltage. This function provides the information that the battery library needs to adjust its readings appropriately. </p>
<dl class="section return"><dt>Returns</dt><dd>The value of Vref (in mV) for the version of BlueCore the application is running on. </dd></dl>

</div>
</div>
<a id="gaed39856160114a494bda22e8c5ea782c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed39856160114a494bda22e8c5ea782c">&#9670;&nbsp;</a></span>VmSetPcmClock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VmSetPcmClock </td>
          <td>(</td>
          <td class="paramtype">vm_pcm_clock_setting&#160;</td>
          <td class="paramname"><em>frequency</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables the VM to set the PCM_CLK frequency when using the 4 mHz internal clock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frequency</td><td>The frequency PCM_CLK will output at as a vm_pcm_clock_setting type. Valid values are PCM_CLK_OFF, PCM_CLK_128, PCM_CLK_256 and PCM_CLK_512 kHz. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if the change was accepted, else FALSE.</dd></dl>
<p>WARNING: This trap is UNIMPLEMENTED </p>

</div>
</div>
<a id="ga269b447dc709fad74a31b0c794c9cf20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga269b447dc709fad74a31b0c794c9cf20">&#9670;&nbsp;</a></span>VmSoftwareWdKick()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VmSoftwareWdKick </td>
          <td>(</td>
          <td class="paramtype">uint16&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>By default, the VM software watchdog is disabled. Calling this trap with a valid timeout value will initiate/reset the VM software watchdog timer. If the VM software watchdog timer expires, then a VM Panic will be raised with Panic code PANIC_VM_SW_WD_EXPIRED and it will reset the chip. </p>
<dl class="section note"><dt>Note</dt><dd>The purpose of the 3-stage disable sequence is to ensure that rogue applications do not randomly disable the watchdog by kicking it with some single disable codes. The return value of the this trap is designed to indicate to the user that either the watchdog kick has succeeded due to a valid timeout within the specified range or that the entire 3-stage disable sequence has succeeded. Returning TRUE for a call on the first disable sequence alone would actually go against the notion that the operation of disabling the watchdog has succeeded. In-fact at that moment (after having kicked with the first disable code), there is no guarantee of whether the disabling is either being done deliberately (in a valid manner) or the kick has been called by some rouge code. Hence, unless the entire disable operation does not succeed, the VM must not return TRUE. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>The timeout period in seconds, in the range 1 to 300 or the specific disable codes VM_SW_WATCHDOG_DISABLE_CODE1, VM_SW_WATCHDOG_DISABLE_CODE2, VM_SW_WATCHDOG_DISABLE_CODE3. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns TRUE, 1.Whenever the VM software watchdog is kicked i.e., valid range (1-300 seconds). Eg: VmsoftwareWDKick(20); - Returns TRUE 2.Whenever the 3-stage disable sequence is followed as per the requirement. Eg: VmsoftwareWDKick(20); - Returns TRUE VmSoftwareWDKick(VM_SW_WATCHDOG_DISABLE_CODE1); - Returns FALSE VmSoftwareWDKick(VM_SW_WATCHDOG_DISABLE_CODE2); - Returns FALSE VmSoftwareWDKick(VM_SW_WATCHDOG_DISABLE_CODE3); - Returns TRUE returns FALSE, 1.Whenever the VM software watchdog timeout doesn't fall under 1-300 seconds range. 2.Whenever the VM software watchdog doesn't follow the 3-stage sequence or disabling the VM software watchdog fails. Eg: VmsoftwareWDKick(20); - Returns TRUE VmSoftwareWDKick(VM_SW_WATCHDOG_DISABLE_CODE2); - Returns FALSE VmSoftwareWDKick(VM_SW_WATCHDOG_DISABLE_CODE1); - Returns FALSE VmSoftwareWDKick(VM_SW_WATCHDOG_DISABLE_CODE3); - Returns FALSE </dd></dl>

</div>
</div>
<a id="gac7dfd59c130bc32c9ebd19d60f6f4e88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac7dfd59c130bc32c9ebd19d60f6f4e88">&#9670;&nbsp;</a></span>VmTransmitEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VmTransmitEnable </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Request that the radio transmitter be enabled or disabled. </p>
<p>Equivalent to using ENABLE_TX and DISABLE_TX over BCCMD from off-chip. </p><dl class="section return"><dt>Returns</dt><dd>TRUE if the request was satisfied, FALSE if it was not possible. </dd></dl>

</div>
</div>
<a id="gabf4606391ecb5d811f8abf0de8a8c7f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabf4606391ecb5d811f8abf0de8a8c7f6">&#9670;&nbsp;</a></span>VmTransmitPowerGetDefault()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16 VmTransmitPowerGetDefault </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current default power setting. </p>

</div>
</div>
<a id="ga8b7466c263ec7f89013baf6dc81c8291"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b7466c263ec7f89013baf6dc81c8291">&#9670;&nbsp;</a></span>VmTransmitPowerGetMaximum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16 VmTransmitPowerGetMaximum </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current maximum power setting. </p>

</div>
</div>
<a id="gac7ce051e2f5da01808c83502a9a4f5f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac7ce051e2f5da01808c83502a9a4f5f4">&#9670;&nbsp;</a></span>VmTransmitPowerMessagesEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VmTransmitPowerMessagesEnable </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows one #MESSAGE_TX_POWER_CHANGE_EVENT to be sent to the system task. This is a one-shot enable, i.e., it allows exactly one power change message to be sent to the task registered with <a class="el" href="group__trapset__core.html#gabd1023998e25adee54f220a8d71736ae" title="Register a task to handle system-wide messages. ">MessageSystemTask()</a>. Once that message has been sent, <a class="el" href="group__trapset__core.html#gac7ce051e2f5da01808c83502a9a4f5f4" title="Allows one #MESSAGE_TX_POWER_CHANGE_EVENT to be sent to the system task. This is a one-shot enable...">VmTransmitPowerMessagesEnable()</a> must be called again to allow the next power change message to be sent. This gives the application the opportunity to limit the rate at which power change messages arrive, which can be quite frequent if unchecked. Calling VmTransmitPowerMessagesEnable(TRUE) again before a power change message has been received has no effect. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>TRUE to permit power change messages to be sent, FALSE to stop them. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa318c8d5fba4619c0029a91cc04af672"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa318c8d5fba4619c0029a91cc04af672">&#9670;&nbsp;</a></span>VmTransmitPowerSetDefault()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VmTransmitPowerSetDefault </td>
          <td>(</td>
          <td class="paramtype">int16&#160;</td>
          <td class="paramname"><em>power</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows the application to override the default specified by PSKEY_LC_DEFAULT_TX_POWER. The default transmit power is used for paging, inquiry, and their responses, and as the initial power for new acl links. The value passed is rounded down to the next available value when set, so the value returned by a call to VmTransmitPowerGetDefault may be less than that previously passed to VmTransmitPowerSetDefault. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">power</td><td>int16 The new default power to use in dBm. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success, else FALSE. </dd></dl>

</div>
</div>
<a id="gaf609631fa386bd0a2dcd0a182d7e0f37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf609631fa386bd0a2dcd0a182d7e0f37">&#9670;&nbsp;</a></span>VmTransmitPowerSetMaximum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool VmTransmitPowerSetMaximum </td>
          <td>(</td>
          <td class="paramtype">int16&#160;</td>
          <td class="paramname"><em>power</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows the application to override the maximum specified by PSKEY_LC_MAX_TX_POWER. The maximum transmit power is only referenced when increasing the transmit power, so if the transmit power on a link is already above this level the new value will not take effect until an attempt is made to increase the power. The value passed is rounded down to the next available value when set, so the value returned by a call to VmTransmitPowerGetMaximum may be less than that previously passed to VmTransmitPowerSetMaximum. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">power</td><td>The new maximum power to use in dBm. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE on success, else FALSE. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
