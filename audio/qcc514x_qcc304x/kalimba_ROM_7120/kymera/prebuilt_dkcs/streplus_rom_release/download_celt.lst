
/home/svc-audio-dspsw/kymera_builds/builds/2020/kymera_2005191628/kalimba/kymera/tools/KCSMaker/out/7120/streplus_rom_release/download/debugbin/download_celt.elf:     file format elf32-littlekalimba

Disassembly of section .text_maxim:

84200000 <$celt.decoder_init>:
#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.DECODER_INIT.PATCH_ID_0,r1)     // celt_patchers
#endif   

   // -- get data object
   push r5;
84200000:	00 00 70 f3 	push r5;
   r9 = r5;
84200004:	0f 00 b7 00 	r9 = r5 + Null;
   r5 = M[r5 + $codec.DECODER_DATA_OBJECT_FIELD];
84200008:	18 00 77 d1 	r5 = M[r5 + 24];

   // -- disable re-init flag
   M[r5 + $celt.dec.REINIT_DECODER_FIELD] = 0;
8420000c:	24 00 07 d5 	M[r5 + 36] = Null;
      
   // reset byte pos
   r0 = $celt.BYTE_POS_MAX_VALUE;
84200010:	03 00 20 01 	r0 = Null + 3;
   M[r5 + $celt.dec.GET_BYTE_POS_FIELD] = r0;
84200014:	a4 00 27 d5 	M[r5 + 164] = r0;
   
   // -- read mode variables
   r10 = $celt.mode.STRUC_SIZE ;
84200018:	14 00 c0 01 	r10 = Null + 20;
   r8 = M[r5 + $celt.dec.CELT_MODE_OBJECT_FIELD];
8420001c:	00 00 a7 d1 	r8 = M[r5 + 0];
   I3 = r8;
84200020:	af 00 30 50 	I3 = Null + r8;
   I6 = r5 + $celt.dec.MODE_FIELDS_OFFSET_FIELD;
84200024:	3c 00 67 51 	I6 = r5 + 60;
   do read_single_vars_loop;
84200028:	03 00 f0 e5 	do $M.celt.decoder_init.read_single_vars_loop;
      r0 = M[I3, MK1];
8420002c:	00 2d 00 03 	Null = Null + Null, r0 = M[I3,4];
      M[I6, MK1] = r0;
84200030:	a9 00 00 03 	Null = Null + Null, M[I6,4] = r0;

84200034 <$M.celt.decoder_init.read_single_vars_loop>:
   read_single_vars_loop:
      
   r1 = M[r5 + $celt.dec.CELT_CHANNELS_FIELD];
84200034:	08 00 37 d1 	r1 = M[r5 + 8];
   r0 = M[r9 + $codec.DECODER_OUT_RIGHT_BUFFER_FIELD];
84200038:	08 00 2b d1 	r0 = M[r9 + 8];
   r1 = r1 XOR 1;
8420003c:	01 00 33 89 	r1 = r1 XOR 0x1;
   r0 = r0 * r1 (int);
84200040:	00 00 23 9b 	r0 = r0 * r1 (int);
   M[r5 + $celt.dec.SCRATCHVAR_MONO_TO_STEREO] = r0;
84200044:	78 01 27 d5 	M[r5 + 376] = r0;
 
   r0 = &$celt.ec_dec_tell;
84200048:	20 04 00 fd 	r0 = Null + 69214572;
8420004c:	6c 21 20 01 
   M[r5 + $celt.dec.TELL_FUNC_FIELD] = r0;
84200050:	30 00 27 d5 	M[r5 + 48] = r0;
   r0 = &$celt.alg_unquant;
84200054:	20 04 00 fd 	r0 = Null + 69218544;
84200058:	f0 30 20 01 
   M[r5 + $celt.dec.ALG_QUANT_FUNC_FIELD] = r0;
8420005c:	34 00 27 d5 	M[r5 + 52] = r0;
   r0 = &$celt.ec_dec_uint;
84200060:	20 04 00 fd 	r0 = Null + 69214264;
84200064:	38 20 20 01 
   M[r5 + $celt.dec.EC_UINT_FUNC_FIELD] = r0;
84200068:	38 00 27 d5 	M[r5 + 56] = r0;
   
   pop r5;
8420006c:	00 00 74 f3 	pop r5;
   rts;
84200070:	0f 00 0d dc 	rts;

84200074 <$_celt_decode_lib_init>:

#if defined(PATCH_LIBS)
   LIBS_PUSH_R0_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.DECODE_LIB_INIT.PATCH_ID_0,r1)     // celt_patchers
#endif   
   // Save the registers C expects us to preserve that get trashed
   PUSH_ALL_C
84200074:	c0 af 00 f1 	pushm <r4, r5, r6, r7, r8, r9, rLink, rMACB>;
84200078:	77 00 01 f1 	pushm <I0, I1, I2, I4, I5, I6>;
8420007c:	00 f7 01 f1 	pushm <M0, M1, M2, L0, L1, L4, L5>;
   r9 = r0;
84200080:	0f 00 b2 00 	r9 = r0 + Null;
   r5 = r0;
84200084:	0f 00 72 00 	r5 = r0 + Null;
   push r0;
84200088:	00 00 20 f3 	push r0;

   r5 = M[r5 + $codec.DECODER_DATA_OBJECT_FIELD];
8420008c:	18 00 77 d1 	r5 = M[r5 + 24];
   r6 = 0 ;                                  // decoder 
84200090:	00 00 80 01 	r6 = Null + 0;
   r0 = M[r5 + $celt.dec.MODE_FIELD];        // mode 
84200094:	3c 02 27 d1 	r0 = M[r5 + 572];
   call $celt.codec.init_tables;
84200098:	33 05 f0 e1 	call $celt.codec.init_tables;
   
   pop r0;
8420009c:	00 00 24 f3 	pop r0;
   r9 = r0;
842000a0:	0f 00 b2 00 	r9 = r0 + Null;
   r5 = r0;
842000a4:	0f 00 72 00 	r5 = r0 + Null;
   call $celt.decoder_init;
842000a8:	d6 ff f0 e1 	call $celt.decoder_init;
   
   r5 = M[r5 + $codec.DECODER_DATA_OBJECT_FIELD];
842000ac:	18 00 77 d1 	r5 = M[r5 + 24];
   
   r8 = M[r5 + $celt.dec.PTR_celt_dec_state_pool];
842000b0:	38 02 a7 d1 	r8 = M[r5 + 568];
   r7 = 306;                                 //length($celt_enc_state_pool);
842000b4:	32 01 90 01 	r7 = Null + 306;
   call $celt.alloc_state_mem;
842000b8:	0c 00 f0 e1 	call $celt.alloc_state_mem;
#ifdef KYMERA 
   NULL = M[r5 + $celt.dec.FFT_TABLE_INIT_DONE_FIELD];
842000bc:	40 02 07 d1 	Null = M[r5 + 576];
   if NZ jump dont_init_fft_tables;
842000c0:	06 00 10 dd 	if NE jump $M.celt.decoder_init.dont_init_fft_tables;
   r0 = $celt.dec.FFT_TWIDDLE_SIZE;
842000c4:	00 02 20 01 	r0 = Null + 512;
   call $math.fft_twiddle.alloc;
842000c8:	07 00 00 fd 	call 0x74f20;
842000cc:	20 4f f0 e1 
   r0 = 1;
842000d0:	2f 00 20 e4 	r0 = Null + 1;
   M[r5 + $celt.dec.FFT_TABLE_INIT_DONE_FIELD] = r0;
842000d4:	40 02 27 d5 	M[r5 + 576] = r0;

842000d8 <$M.celt.decoder_init.dont_init_fft_tables>:
dont_init_fft_tables:
#endif 

   // restore preserved registers
   POP_ALL_C
842000d8:	00 f7 05 f1 	popm <M0, M1, M2, L0, L1, L4, L5>;
842000dc:	77 00 05 f1 	popm <I0, I1, I2, I4, I5, I6>;
842000e0:	c0 af 04 f1 	popm <r4, r5, r6, r7, r8, r9, rLink, rMACB>;
   rts;
842000e4:	0f 00 0d dc 	rts;

842000e8 <$celt.alloc_state_mem>:
#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.ALLOC_STATE_MEM.PATCH_ID_0,r1)     // celt_patchers
#endif   

   // -- get data object
   r0 = $celt.MAX_BANDS;
842000e8:	19 00 20 01 	r0 = Null + 25;
   r1 = M[r5 + $celt.dec.MODE_OVERLAP_FIELD];   
842000ec:	40 00 37 d1 	r1 = M[r5 + 64];
   r2 = M[r5 + $celt.dec.CELT_CHANNELS_FIELD];
842000f0:	08 00 47 d1 	r2 = M[r5 + 8];
   r2 = r2 + 1;
842000f4:	2f 00 44 e4 	r2 = r2 + 1;
   r3 = r0 + r1;
842000f8:	3f 00 52 00 	r3 = r0 + r1;
   r3 = r3 * r2 (int);
842000fc:	00 00 54 9b 	r3 = r3 * r2 (int);
   Null = r7 - r3;
84200100:	5f 00 09 20 	Null = r7 - r3;
   if NEG call $error;
84200104:	03 00 00 fd 	if NEG call (m) 0x3ac3e;
84200108:	3f ac 40 e1 
   M[r5 + $celt.dec.OLD_EBAND_LEFT_FIELD] = r8;
8420010c:	8c 00 a7 d5 	M[r5 + 140] = r8;
   Words2Addr(r0);
84200110:	02 00 22 91 	r0 = r0 ASHIFT 2;
   r8 = r8 + r0;
84200114:	00 00 a2 03 	r8 = r8 + r0;
   if NZ r8 = r8 + r0;
84200118:	21 00 aa 00 	if NE r8 = r8 + r0;
   M[r5 + $celt.dec.HIST_OLA_LEFT_FIELD] = r8;
8420011c:	94 00 a7 d5 	M[r5 + 148] = r8;
   Words2Addr(r1);
84200120:	02 00 33 91 	r1 = r1 ASHIFT 2;
   r8 = r8 + r1;   
84200124:	00 00 a3 03 	r8 = r8 + r1;
   M[r5 + $celt.dec.HIST_OLA_RIGHT_FIELD] = r8;   
84200128:	98 00 a7 d5 	M[r5 + 152] = r8;

   rts;
8420012c:	0f 00 0d dc 	rts;

84200130 <$celt.alloc_scratch_mem>:
  
#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.ALLOC_SCRATCH_MEM.PATCH_ID_0,r6)     // celt_patchers
#endif
  
   I0 = r5 + $celt.dec.DM1_SCRATCH_FIELDS_OFFSET ;
84200130:	bc 00 07 51 	I0 = r5 + 188;
   r10 = $celt.dec.DM1_SCRATCH_FIELDS_LENGTH;
84200134:	0e 00 c0 01 	r10 = Null + 14;
   I4 = r1;
84200138:	3f 00 40 50 	I4 = Null + r1;
   do copy_dm1_loop;
8420013c:	05 00 f0 e5 	do $M.celt.alloc_scratch_mem.copy_dm1_loop;
      r0 = M[I4, MK1];
84200140:	21 00 00 03 	Null = Null + Null, r0 = M[I4,4];
      Words2Addr(r0);
84200144:	02 00 22 91 	r0 = r0 ASHIFT 2;
      r0 = r0 + r2;
84200148:	00 00 24 03 	r0 = r0 + r2;
      M[I0, MK1] = r0;
8420014c:	00 a1 00 03 	Null = Null + Null, M[I0,4] = r0;

84200150 <$M.celt.alloc_scratch_mem.copy_dm1_loop>:
   copy_dm1_loop:
   
   I0 = r5 + $celt.dec.DM2_SCRATCH_FIELDS_OFFSET ;
84200150:	04 01 07 51 	I0 = r5 + 260;
   r10 = $celt.dec.DM2_SCRATCH_FIELDS_LENGTH;
84200154:	0d 00 c0 01 	r10 = Null + 13;
   I4 = r3;
84200158:	5f 00 40 50 	I4 = Null + r3;
   do copy_dm2_loop;
8420015c:	05 00 f0 e5 	do $M.celt.alloc_scratch_mem.copy_dm2_loop;
      r0 = M[I4, MK1];
84200160:	21 00 00 03 	Null = Null + Null, r0 = M[I4,4];
      Words2Addr(r0);
84200164:	02 00 22 91 	r0 = r0 ASHIFT 2;
      r0 = r0 + r4;
84200168:	00 00 26 03 	r0 = r0 + r4;
      M[I0, MK1] = r0;
8420016c:	00 a1 00 03 	Null = Null + Null, M[I0,4] = r0;

84200170 <$M.celt.alloc_scratch_mem.copy_dm2_loop>:
   copy_dm2_loop:
   rts;
84200170:	0f 00 0d dc 	rts;

84200174 <$celt.decoder_frame_init>:
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.DECODER_FRAME_INIT.PATCH_ID_0,r1)     // celt_patchers
#endif
   
   // push rLink onto stack
   //$push_rLink_macro;
   push rlink;
84200174:	00 00 d0 f3 	push rLink;

   // set byte-pos values
   r0 = M[r5 + $celt.dec.GET_BYTE_POS_FIELD];
84200178:	a4 00 27 d1 	r0 = M[r5 + 164];
   M[r5 + $celt.dec.SCRATCHVAR_GET_BYTEPOS] = r0;
8420017c:	f8 01 27 d5 	M[r5 + 504] = r0;
   r0 = M[r9 + $codec.DECODER_IN_BUFFER_FIELD];
84200180:	00 00 2b d1 	r0 = M[r9 + 0];
#ifdef BASE_REGISTER_MODE
   call $cbuffer.get_read_address_and_size_and_start_address;
84200184:	03 00 00 fd 	call (m) 0x3a27a;
84200188:	7b a2 f0 e1 
   push r2;
8420018c:	00 00 40 f3 	push r2;
   pop  B0;
84200190:	00 00 a6 f3 	pop B0;
#else
   call $cbuffer.get_read_address_and_size;
#endif
   I0 = r0;
84200194:	2f 00 00 50 	I0 = Null + r0;
   L0 = r1;
84200198:	3f 00 c0 50 	L0 = Null + r1;
   
   // get the frame length in bytes
   r8 = M[r9 + $celt.dec.CELT_MODE_OBJECT_FIELD];
8420019c:	00 00 ab d1 	r8 = M[r9 + 0];
   r0 = M[r5 + $celt.dec.CELT_CODEC_FRAME_SIZE_FIELD];
842001a0:	04 00 27 d1 	r0 = M[r5 + 4];
   M[r5 + $celt.dec.SCRATCHVAR_FRAME_BYTES_REMAINED] = r0;
842001a4:	fc 01 27 d5 	M[r5 + 508] = r0;
   M[r5 + $celt.dec.SCRATCHVAR_FRAME_BYTES_REMAINED_REVERSE] = r0;
842001a8:	04 02 27 d5 	M[r5 + 516] = r0;
   r1 = M[r5 + $celt.dec.SCRATCHVAR_GET_BYTEPOS];
842001ac:	f8 01 37 d1 	r1 = M[r5 + 504];
   r1 = r0 + r1;
842001b0:	3f 00 32 00 	r1 = r0 + r1;
   r1 = r1 AND $celt.BYTE_POS_MAX_VALUE;
842001b4:	03 00 33 81 	r1 = r1 AND 0x3;
   M[r5 + $celt.dec.SCRATCHVAR_GET_BYTEPOS_REVERSE] = r1;
842001b8:	00 02 37 d5 	M[r5 + 512] = r1;
   
   //I1/L1 -> must point to end of buffer
   I1 = I0;
842001bc:	0f 00 10 58 	I1 = I0 + Null;
   L1 = L0;
842001c0:	0f 00 dc 58 	L1 = L0 + Null;
#ifdef BASE_REGISTER_MODE
   push B0;
842001c4:	00 00 a2 f3 	push B0;
   pop B1;
842001c8:	00 00 b6 f3 	pop B1;
#endif
   r10 = M[r5 + $celt.dec.SCRATCHVAR_GET_BYTEPOS_REVERSE];
842001cc:	00 02 c7 d1 	r10 = M[r5 + 512];
   r0 = r0 + r10;
842001d0:	00 00 2c 03 	r0 = r0 + r10;
   r10 = M[r5 + $celt.dec.SCRATCHVAR_GET_BYTEPOS];
842001d4:	f8 01 c7 d1 	r10 = M[r5 + 504];
   r0 = r0 - r10;
842001d8:	00 00 2c 23 	r0 = r0 - r10;
   r0 = r0 LSHIFT $celt.FRM_DATA_MID_DIV_CONST;
842001dc:	fe 00 22 8d 	r0 = r0 LSHIFT -2;
   Words2Addr(r0);
842001e0:	02 00 22 91 	r0 = r0 ASHIFT 2;
   M0 = r0;
842001e4:	2f 00 80 50 	M0 = Null + r0;
   r0 = M[I1, M0];
842001e8:	00 24 00 02 	Null = Null + Null, r0 = M[I1,M0];
   
   // initialise entropy decoder
   call $celt.ec_dec_init;
842001ec:	ce 06 f0 e1 	call $celt.ec_dec_init;

   // pop rLink from stack
   jump $pop_rLink_and_rts;
842001f0:	03 00 00 fd 	jump (m) 0x3b020;
842001f4:	21 b0 f0 dd 

842001f8 <$celt.end_reading_frame>:

#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.END_READING_FRAME.PATCH_ID_0,r1)     // celt_patchers
#endif

   push rlink;
842001f8:	00 00 d0 f3 	push rLink;
   
   r0 = M[r5 + $celt.dec.GET_BYTE_POS_FIELD];
842001fc:	a4 00 27 d1 	r0 = M[r5 + 164];
   r4 = M[r5 + $celt.dec.CELT_CODEC_FRAME_SIZE_FIELD];
84200200:	04 00 67 d1 	r4 = M[r5 + 4];
   //Get byte position for next frame
   r1 = r4 AND $celt.BYTE_POS_MAX_VALUE;
84200204:	03 00 36 81 	r1 = r4 AND 0x3;
   r2 = r0 XOR r1;
84200208:	3f 00 42 88 	r2 = r0 XOR r1;
   M[r5 + $celt.dec.GET_BYTE_POS_FIELD] = r2;
8420020c:	a4 00 47 d5 	M[r5 + 164] = r2;
   r4 = r4 + r2;
84200210:	00 00 64 03 	r4 = r4 + r2;
   r4 = r4 LSHIFT $celt.FRM_DATA_MID_DIV_CONST;
84200214:	fe 00 66 8d 	r4 = r4 LSHIFT -2;
   Words2Addr(r4);
84200218:	02 00 66 91 	r4 = r4 ASHIFT 2;
   M0 = r4;   
8420021c:	6f 00 80 50 	M0 = Null + r4;
   r0 = M[r9 + $codec.DECODER_IN_BUFFER_FIELD];
84200220:	00 00 2b d1 	r0 = M[r9 + 0];
#ifdef BASE_REGISTER_MODE
   call $cbuffer.get_read_address_and_size_and_start_address;
84200224:	03 00 00 fd 	call (m) 0x3a27a;
84200228:	7b a2 f0 e1 
   push r2;
8420022c:	00 00 40 f3 	push r2;
   pop  B0;
84200230:	00 00 a6 f3 	pop B0;
#else
   call $cbuffer.get_read_address_and_size;
#endif
   I0 = r0;
84200234:	2f 00 00 50 	I0 = Null + r0;
   L0 = r1;
84200238:	3f 00 c0 50 	L0 = Null + r1;
   r0 = M[I0, M0];
8420023c:	00 20 00 02 	Null = Null + Null, r0 = M[I0,M0];
   L0 = 0;
84200240:	00 00 c0 51 	L0 = Null + 0;
   r0 = M[r9 + $codec.DECODER_IN_BUFFER_FIELD];
84200244:	00 00 2b d1 	r0 = M[r9 + 0];
   r1 = I0;
84200248:	0f 00 30 44 	r1 = Null + I0;
   call $cbuffer.set_read_address;
8420024c:	03 00 00 fd 	call (m) 0x3a2e6;
84200250:	e7 a2 f0 e1 
   L0 = 0;
84200254:	00 00 c0 51 	L0 = Null + 0;
   L1 = 0;
84200258:	00 00 d0 51 	L1 = Null + 0;
#ifdef BASE_REGISTER_MODE
   push Null;
8420025c:	00 00 00 f3 	push Null;
   pop  B0;
84200260:	00 00 a6 f3 	pop B0;
   push Null;
84200264:	00 00 00 f3 	push Null;
   pop  B1; 
84200268:	00 00 b6 f3 	pop B1;
#endif
   
   // pop rLink from stack
   jump $pop_rLink_and_rts;
8420026c:	03 00 00 fd 	jump (m) 0x3b020;
84200270:	21 b0 f0 dd 

84200274 <$celt.encode_flags>:
84200274:	00 00 d0 f3 	push rLink;
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.ENCODE_FLAGS.PATCH_ID_0,r1)     // celt_patchers
#endif

   // push rLink onto stack
    push rlink;
   r0 = M[r5 + $celt.enc.INTRA_ENER_FIELD];
84200278:	54 01 27 d1 	r0 = M[r5 + 340];
   r1 = M[r5 + $celt.enc.HAS_PITCH_FIELD];
8420027c:	5c 01 37 d1 	r1 = M[r5 + 348];
   r0 = r0 OR r1;
84200280:	00 00 23 87 	r0 = r0 OR r1;
   r1 = M[r5 + $celt.enc.SHORT_BLOCKS_FIELD];
84200284:	58 01 37 d1 	r1 = M[r5 + 344];
   r0 = r0 OR r1;
84200288:	00 00 23 87 	r0 = r0 OR r1;
   r1 = M[r5 + $celt.enc.HAS_FOLD_FIELD];
8420028c:	60 01 37 d1 	r1 = M[r5 + 352];
   r0 = r0 OR r1;
84200290:	00 00 23 87 	r0 = r0 OR r1;
   // verify it is a valid flag
   r10 = 8;
84200294:	08 00 c0 01 	r10 = Null + 8;
#ifdef CELT_USE_EXTERNAL_MEMORY
   r1 = M[r5 + $celt.enc.PTR_FLAGLIST_TABLE_FIELD];
84200298:	10 02 37 d1 	r1 = M[r5 + 528];
   I2 = r1;
8420029c:	3f 00 20 50 	I2 = Null + r1;
#else // CELT_USE_EXTERNAL_MEMORY
   I2 = &$celt.flaglist;
#endif // CELT_USE_EXTERNAL_MEMORY
   r1 = M[I2, MK1];
842002a0:	00 39 00 03 	Null = Null + Null, r1 = M[I2,4];
   r2 = r1 AND $celt.FLAG_MASK;
842002a4:	00 3c 43 81 	r2 = r1 AND 0x3c00;
   do ver_on_list_loop;
842002a8:	04 00 f0 e5 	do $M.celt.encode_flags.ver_on_list_loop;
      r2 = r2 - r0, r1 = M[I2, MK1];
842002ac:	00 39 42 23 	r2 = r2 - r0, r1 = M[I2,4];
      if Z jump break_ver_lp;
842002b0:	05 00 00 dd 	if EQ jump $M.celt.encode_flags.break_ver_lp;
      r2 = r1 AND $celt.FLAG_MASK;
842002b4:	00 3c 43 81 	r2 = r1 AND 0x3c00;

842002b8 <$M.celt.encode_flags.ver_on_list_loop>:
   ver_on_list_loop:
      // flag not found in the list
      // return error
      r0 = 1;
842002b8:	2f 00 20 e4 	r0 = Null + 1;
      jump $pop_rLink_and_rts;
842002bc:	03 00 00 fd 	jump (m) 0x3b020;
842002c0:	21 b0 f0 dd 

842002c4 <$M.celt.encode_flags.break_ver_lp>:
   break_ver_lp:
#ifdef CELT_USE_EXTERNAL_MEMORY
   r1 = M[r5 + $celt.enc.PTR_FLAGLIST_TABLE_FIELD];
842002c4:	10 02 37 d1 	r1 = M[r5 + 528];
   r0 = I2-r1;
842002c8:	3f 00 22 68 	r0 = I2 - r1;
#else // CELT_USE_EXTERNAL_MEMORY
   r0 = I2-(&$celt.flaglist);
#endif // CELT_USE_EXTERNAL_MEMORY
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FL + 1*ADDR_PER_WORD] = Null;
842002cc:	d8 01 07 d5 	M[r5 + 472] = Null;
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FT + 1*ADDR_PER_WORD] = Null;
842002d0:	d0 01 07 d5 	M[r5 + 464] = Null;
#ifdef CELT_USE_EXTERNAL_MEMORY
   r1 = r1 - 2*ADDR_PER_WORD;
842002d4:	08 00 33 21 	r1 = r1 - 8;
   r1 = M[r1 + r0];
842002d8:	00 00 32 d3 	r1 = M[r1 + r0];
#else // CELT_USE_EXTERNAL_MEMORY
   r1 = M[(&$celt.flaglist-2 * ADDR_PER_WORD + r0];   
#endif // CELT_USE_EXTERNAL_MEMORY
   r1 = r1 AND 0xF;
842002dc:	0f 00 33 81 	r1 = r1 AND 0xf;
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FL + 0] = r1;
842002e0:	d4 01 37 d5 	M[r5 + 468] = r1;
   r1 = 3;
842002e4:	03 00 30 01 	r1 = Null + 3;
   Addr2Words(r0);
842002e8:	fe 00 22 91 	r0 = r0 ASHIFT -2;
   r0 = r0 LSHIFT -2;
842002ec:	fe 00 22 8d 	r0 = r0 LSHIFT -2;
   if NZ r0 = r0 XOR r1;
842002f0:	31 00 22 88 	if NE r0 = r0 XOR r1;
   r0 = 4 LSHIFT r0;
842002f4:	04 00 22 e9 	r0 = 0x4 LSHIFT r0;
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FT + 0] = r0;
842002f8:	cc 01 27 d5 	M[r5 + 460] = r0;
   call $celt.ec_enc_uint;   
842002fc:	75 08 f0 e1 	call $celt.ec_enc_uint;
   

   Null = M[r5 + $celt.enc.SHORT_BLOCKS_FIELD];
84200300:	58 01 07 d1 	Null = M[r5 + 344];
   if Z jump end;
84200304:	20 00 00 dd 	if EQ jump $M.celt.encode_flags.end;
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FT + 1*ADDR_PER_WORD] = Null;
84200308:	d0 01 07 d5 	M[r5 + 464] = Null;
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FL + 1*ADDR_PER_WORD] = Null;
8420030c:	d8 01 07 d5 	M[r5 + 472] = Null;
   r0 = M[r5 + $celt.enc.TRANSIENT_SHIFT_FIELD];
84200310:	68 01 27 d1 	r0 = M[r5 + 360];
   if Z jump no_transient_shift;
84200314:	0d 00 00 dd 	if EQ jump $M.celt.encode_flags.no_transient_shift;
      M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FL + 0*ADDR_PER_WORD] = r0;
84200318:	d4 01 27 d5 	M[r5 + 468] = r0;
      r0 = 4;
8420031c:	bf 00 20 e4 	r0 = Null + 4;
      M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FT + 0*ADDR_PER_WORD] = r0;
84200320:	cc 01 27 d5 	M[r5 + 460] = r0;
      call $celt.ec_enc_uint;
84200324:	6b 08 f0 e1 	call $celt.ec_enc_uint;
      r0 = M[r5 + $celt.enc.TRANSIENT_TIME_FIELD];
84200328:	64 01 27 d1 	r0 = M[r5 + 356];
      M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FL + 0*ADDR_PER_WORD] = r0;
8420032c:	d4 01 27 d5 	M[r5 + 468] = r0;
      r0 = M[r5 + $celt.enc.MODE_OVERLAP_FIELD];
84200330:	40 00 27 d1 	r0 = M[r5 + 64];
      r1 = M[r5 + $celt.enc.MODE_MDCT_SIZE_FIELD];
84200334:	44 00 37 d1 	r1 = M[r5 + 68];
      r0 = r0 + r1;
84200338:	00 00 23 03 	r0 = r0 + r1;
      M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FT + 0*ADDR_PER_WORD] = r0;
8420033c:	cc 01 27 d5 	M[r5 + 460] = r0;
      call $celt.ec_enc_uint;
84200340:	64 08 f0 e1 	call $celt.ec_enc_uint;
      jump end;      
84200344:	10 00 f0 dd 	jump $M.celt.encode_flags.end;

84200348 <$M.celt.encode_flags.no_transient_shift>:
   no_transient_shift:
      r0 = M[r5 + $celt.enc.MDCT_WEIGHT_SHIFT_FIELD];
84200348:	6c 01 27 d1 	r0 = M[r5 + 364];
      M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FL + 0*ADDR_PER_WORD] = r0;
8420034c:	d4 01 27 d5 	M[r5 + 468] = r0;
      r0 = 4;
84200350:	bf 00 20 e4 	r0 = Null + 4;
      M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FT + 0*ADDR_PER_WORD] = r0;
84200354:	cc 01 27 d5 	M[r5 + 460] = r0;
      call $celt.ec_enc_uint;
84200358:	5e 08 f0 e1 	call $celt.ec_enc_uint;
      r0 = M[r5 + $celt.enc.MDCT_WEIGHT_SHIFT_FIELD];
8420035c:	6c 01 27 d1 	r0 = M[r5 + 364];
      if Z jump end;
84200360:	09 00 00 dd 	if EQ jump $M.celt.encode_flags.end;
      r0 = M[r5 + $celt.enc.MODE_NB_SHORT_MDCTS_FIELD];
84200364:	58 00 27 d1 	r0 = M[r5 + 88];
      Null = r0 - 3;
84200368:	03 00 02 21 	Null = r0 - 3;
      if NEG jump end;
8420036c:	06 00 40 dd 	if NEG jump $M.celt.encode_flags.end;
      r0 = r0 - 1;
84200370:	3f 00 22 e4 	r0 = r0 - 1;
      r1 = M[r5 + $celt.enc.MDCT_WEIGHT_POS_FIELD];
84200374:	70 01 37 d1 	r1 = M[r5 + 368];
      M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FL + 0*ADDR_PER_WORD] = r1;
84200378:	d4 01 37 d5 	M[r5 + 468] = r1;
      M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FT + 0*ADDR_PER_WORD] = r0;
8420037c:	cc 01 27 d5 	M[r5 + 460] = r0;
      call $celt.ec_enc_uint;
84200380:	54 08 f0 e1 	call $celt.ec_enc_uint;

84200384 <$M.celt.encode_flags.end>:
   end:
   // output
   r0 = 0;
84200384:	00 00 20 01 	r0 = Null + 0;
   // pop rLink from stack
   jump $pop_rLink_and_rts;
84200388:	03 00 00 fd 	jump (m) 0x3b020;
8420038c:	21 b0 f0 dd 

84200390 <$celt.encoder_init>:
84200390:	00 00 70 f3 	push r5;
#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.ENCODER_INIT.PATCH_ID_0,r8)     // celt_patchers
#endif
   
   push r5;
   r9 = r5;
84200394:	0f 00 b7 00 	r9 = r5 + Null;
   r5 = M[r5 + $codec.ENCODER_DATA_OBJECT_FIELD];
84200398:	10 00 77 d1 	r5 = M[r5 + 16];

   // -- disable re-init flag
   M[r5 + $celt.enc.REINIT_ENCODER_FIELD] = 0;
8420039c:	14 00 07 d5 	M[r5 + 20] = Null;
      
   // reset byte pos
   r0 = $celt.BYTE_POS_MAX_VALUE;
842003a0:	03 00 20 01 	r0 = Null + 3;
   M[r5 + $celt.enc.PUT_BYTE_POS_FIELD] = r0;
842003a4:	a4 00 27 d5 	M[r5 + 164] = r0;
   
   // -- read mode variables
   r10 = $celt.mode.STRUC_SIZE ;
842003a8:	14 00 c0 01 	r10 = Null + 20;
   r8 = M[r5 + $celt.enc.CELT_MODE_OBJECT_FIELD];
842003ac:	00 00 a7 d1 	r8 = M[r5 + 0];
   I3 = r8;
842003b0:	af 00 30 50 	I3 = Null + r8;
   I6 = r5 + $celt.enc.MODE_FIELDS_OFFSET_FIELD;
842003b4:	3c 00 67 51 	I6 = r5 + 60;
   do read_single_vars_loop;
842003b8:	03 00 f0 e5 	do $M.celt.encoder_init.read_single_vars_loop;
      r0 = M[I3, MK1];
842003bc:	00 2d 00 03 	Null = Null + Null, r0 = M[I3,4];
      M[I6, MK1] = r0;
842003c0:	a9 00 00 03 	Null = Null + Null, M[I6,4] = r0;

842003c4 <$M.celt.encoder_init.read_single_vars_loop>:
   read_single_vars_loop:
      
   r0 = &$celt.ec_enc_tell;
842003c4:	20 04 00 fd 	r0 = Null + 69215192;
842003c8:	d8 23 20 01 
   M[r5 + $celt.enc.TELL_FUNC_FIELD] = r0;
842003cc:	30 00 27 d5 	M[r5 + 48] = r0;
   r0 = &$celt.alg_quant;
842003d0:	20 04 00 fd 	r0 = Null + 69225864;
842003d4:	88 4d 20 01 
   M[r5 + $celt.enc.ALG_QUANT_FUNC_FIELD] = r0;
842003d8:	34 00 27 d5 	M[r5 + 52] = r0;
   r0 = &$celt.ec_enc_uint;
842003dc:	20 04 00 fd 	r0 = Null + 69215440;
842003e0:	d0 24 20 01 
   M[r5 + $celt.dec.EC_UINT_FUNC_FIELD] = r0;
842003e4:	38 00 27 d5 	M[r5 + 56] = r0;

   pop r5;
842003e8:	00 00 74 f3 	pop r5;
   rts;
842003ec:	0f 00 0d dc 	rts;

842003f0 <$_celt_encode_lib_init>:

#if defined(PATCH_LIBS)
   LIBS_PUSH_R0_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.ENCODE_LIB_INIT.PATCH_ID_0,r1)     // celt_patchers
#endif
   // Save the registers C expects us to preserve that get trashed
   PUSH_ALL_C
842003f0:	c0 af 00 f1 	pushm <r4, r5, r6, r7, r8, r9, rLink, rMACB>;
842003f4:	77 00 01 f1 	pushm <I0, I1, I2, I4, I5, I6>;
842003f8:	00 f7 01 f1 	pushm <M0, M1, M2, L0, L1, L4, L5>;
   r9 = r0;
842003fc:	0f 00 b2 00 	r9 = r0 + Null;
   r5 = r0;
84200400:	0f 00 72 00 	r5 = r0 + Null;
   push r0;
84200404:	00 00 20 f3 	push r0;
 
   
   r5 = M[r5 + $codec.ENCODER_DATA_OBJECT_FIELD];
84200408:	10 00 77 d1 	r5 = M[r5 + 16];
   r6 = 1 ;                                  // encoder 
8420040c:	2f 00 80 e4 	r6 = Null + 1;
   r0 = M[r5 + $celt.enc.MODE_FIELD];        // mode 
84200410:	3c 02 27 d1 	r0 = M[r5 + 572];
   call $celt.codec.init_tables;
84200414:	54 04 f0 e1 	call $celt.codec.init_tables;
   
   pop r0;
84200418:	00 00 24 f3 	pop r0;
   r9 = r0;
8420041c:	0f 00 b2 00 	r9 = r0 + Null;
   r5 = r0;
84200420:	0f 00 72 00 	r5 = r0 + Null;
   call $celt.encoder_init;
84200424:	db ff f0 e1 	call $celt.encoder_init;

   r5 = M[r5 + $codec.ENCODER_DATA_OBJECT_FIELD];
84200428:	10 00 77 d1 	r5 = M[r5 + 16];
   r8 = M[r5 + $celt.enc.PTR_celt_enc_state_pool];
8420042c:	38 02 a7 d1 	r8 = M[r5 + 568];
   r7 = 306;                                 //length($celt_enc_state_pool);
84200430:	32 01 90 01 	r7 = Null + 306;
   call $celt.alloc_state_mem;
84200434:	2d ff f0 e1 	call $celt.alloc_state_mem;
#ifdef KYMERA 
   NULL = M[r5 + $celt.enc.FFT_TABLE_INIT_DONE_FIELD];
84200438:	40 02 07 d1 	Null = M[r5 + 576];
   if NZ jump dont_init_fft_tables_enc;
8420043c:	06 00 10 dd 	if NE jump $M.celt.encoder_init.dont_init_fft_tables_enc;
   r0 = $celt.FFT_TWIDDLE_SIZE;
84200440:	00 02 20 01 	r0 = Null + 512;
   call $math.fft_twiddle.alloc;
84200444:	07 00 00 fd 	call 0x74f20;
84200448:	20 4f f0 e1 
   r0 = 1;
8420044c:	2f 00 20 e4 	r0 = Null + 1;
   M[r5 + $celt.enc.FFT_TABLE_INIT_DONE_FIELD] = r0;
84200450:	40 02 27 d5 	M[r5 + 576] = r0;

84200454 <$M.celt.encoder_init.dont_init_fft_tables_enc>:
dont_init_fft_tables_enc:
#endif 

   // restore preserved registers
   POP_ALL_C
84200454:	00 f7 05 f1 	popm <M0, M1, M2, L0, L1, L4, L5>;
84200458:	77 00 05 f1 	popm <I0, I1, I2, I4, I5, I6>;
8420045c:	c0 af 04 f1 	popm <r4, r5, r6, r7, r8, r9, rLink, rMACB>;
   rts;
84200460:	0f 00 0d dc 	rts;

84200464 <$celt.encoder_frame_init>:
   
   $celt.encoder_frame_init:
   
   // push rLink onto stack

   push rlink;
84200464:	00 00 d0 f3 	push rLink;
#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.ENCODER_FRAME_INIT.PATCH_ID_0,r2)     // celt_patchers
#endif

   // set byte-pos values
   r0 = M[r5 + $celt.enc.PUT_BYTE_POS_FIELD];
84200468:	a4 00 27 d1 	r0 = M[r5 + 164];
   M[r5 + $celt.enc.SCRATCHVAR_PUT_BYTEPOS] = r0;
8420046c:	e8 01 27 d5 	M[r5 + 488] = r0;
   r0 = M[r9 + $codec.ENCODER_OUT_BUFFER_FIELD];
84200470:	00 00 2b d1 	r0 = M[r9 + 0];
#ifdef BASE_REGISTER_MODE
   call $cbuffer.get_write_address_and_size_and_start_address;
84200474:	03 00 00 fd 	call (m) 0x3a2b0;
84200478:	b1 a2 f0 e1 
   push r2;
8420047c:	00 00 40 f3 	push r2;
   pop  B0;
84200480:	00 00 a6 f3 	pop B0;
#else
   call $cbuffer.get_write_address_and_size;
#endif 
   I0 = r0;
84200484:	2f 00 00 50 	I0 = Null + r0;
   L0 = r1;
84200488:	3f 00 c0 50 	L0 = Null + r1;
   
   // get the frame length in bytes
   r8 = M[r5 + $celt.enc.CELT_MODE_OBJECT_FIELD];
8420048c:	00 00 a7 d1 	r8 = M[r5 + 0];
   r0 = M[r5 + $celt.enc.CELT_CODEC_FRAME_SIZE_FIELD];
84200490:	04 00 27 d1 	r0 = M[r5 + 4];
   M[r5 + $celt.enc.SCRATCHVAR_FRAME_BYTES_REMAINED] = r0;
84200494:	ec 01 27 d5 	M[r5 + 492] = r0;
   M[r5 + $celt.enc.SCRATCHVAR_FRAME_BYTES_REMAINED_REVERSE] = r0;
84200498:	f4 01 27 d5 	M[r5 + 500] = r0;
   r1 = M[r5 + $celt.enc.SCRATCHVAR_PUT_BYTEPOS];
8420049c:	e8 01 37 d1 	r1 = M[r5 + 488];
   r1 = r0 + r1;
842004a0:	3f 00 32 00 	r1 = r0 + r1;
   r1 = r1 AND $celt.BYTE_POS_MAX_VALUE;
842004a4:	03 00 33 81 	r1 = r1 AND 0x3;
   M[r5 + $celt.enc.SCRATCHVAR_PUT_BYTEPOS_REVERSE] = r1;
842004a8:	f0 01 37 d5 	M[r5 + 496] = r1;
   
   //I1/L1 -> must point to end of buffer
   I1 = I0;
842004ac:	0f 00 10 58 	I1 = I0 + Null;
   L1 = L0;
842004b0:	0f 00 dc 58 	L1 = L0 + Null;
#ifdef BASE_REGISTER_MODE   
   push B0;
842004b4:	00 00 a2 f3 	push B0;
   pop B1;
842004b8:	00 00 b6 f3 	pop B1;
#endif 
   r1 = M[r5 + $celt.enc.SCRATCHVAR_PUT_BYTEPOS_REVERSE];
842004bc:	f0 01 37 d1 	r1 = M[r5 + 496];
#ifdef DATAFORMAT_32
   r1 = $celt.BYTE_POS_MAX_VALUE - r1;
842004c0:	03 00 33 65 	r1 = 3 - r1;
#endif
   r0 = r0 + r1;
842004c4:	00 00 23 03 	r0 = r0 + r1;
   r1 = M[r5 + $celt.enc.SCRATCHVAR_PUT_BYTEPOS];
842004c8:	e8 01 37 d1 	r1 = M[r5 + 488];
   r0 = r0 - r1;
842004cc:	00 00 23 23 	r0 = r0 - r1;
   r0 = r0 LSHIFT $celt.FRM_DATA_MID_DIV_CONST;
842004d0:	fe 00 22 8d 	r0 = r0 LSHIFT -2;
   Words2Addr(r0);
842004d4:	02 00 22 91 	r0 = r0 ASHIFT 2;
   M0 = r0;
842004d8:	2f 00 80 50 	M0 = Null + r0;
   r0 = M[I1, M0];
842004dc:	00 24 00 02 	Null = Null + Null, r0 = M[I1,M0];
   
   // initialise entropy decoder
   call $celt.ec_enc_init;
842004e0:	45 07 f0 e1 	call $celt.ec_enc_init;

   // pop rLink from stack
   jump $pop_rLink_and_rts;
842004e4:	03 00 00 fd 	jump (m) 0x3b020;
842004e8:	21 b0 f0 dd 

842004ec <$_celt_free_decoder_twiddle>:
#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.FREE_DECODER_TWIDDLE.PATCH_ID_0,r1)     // celt_patchers
#endif
   
   // Save the registers C expects us to preserve that get trashed
   pushm <r5, r9, rLink>;
842004ec:	80 28 00 f1 	pushm <r5, r9, rLink>;
   push I0;
842004f0:	00 00 01 f3 	push I0;
   r0 = $celt.FFT_TWIDDLE_SIZE;
842004f4:	00 02 20 01 	r0 = Null + 512;
   call $math.fft_twiddle.release;
842004f8:	07 00 00 fd 	call 0x74ff8;
842004fc:	f8 4f f0 e1 

   // restore preserved registers
   pop I0;
84200500:	00 00 05 f3 	pop I0;
   popm <r5, r9, rLink>;
84200504:	80 28 04 f1 	popm <r5, r9, rLink>;

   rts;
84200508:	0f 00 0d dc 	rts;

8420050c <$celt.frame_decode>:
8420050c:	00 00 d0 f3 	push rLink;

   // push rLink onto stack
      push rlink;

   //-- Is re-init required?
   Null = M[r5 + $celt.dec.REINIT_DECODER_FIELD];
84200510:	24 00 07 d1 	Null = M[r5 + 36];
   if NZ call $celt.decoder_init;
84200514:	bb fe 10 e1 	if NE call $celt.decoder_init;
   
   push r5;
84200518:	00 00 70 f3 	push r5;
   r9 = r5;
8420051c:	0f 00 b7 00 	r9 = r5 + Null;
   r5 = M[r5 + $codec.DECODER_DATA_OBJECT_FIELD];
84200520:	18 00 77 d1 	r5 = M[r5 + 24];
 #ifdef KYMERA 
   r1 = M[r5 + $celt.dec.PTR_MODE_DM1SCRATCH_ALLOC];//&$celt.enc.celt_512_48000_mode.dm1scratch_alloc;
84200524:	28 02 37 d1 	r1 = M[r5 + 552];
   r2 = M[r5 + $celt.dec.PTR_celt_dm1_scratch];//&$celt_dm1_scratch;
84200528:	30 02 47 d1 	r2 = M[r5 + 560];
   r3 = M[r5 + $celt.dec.PTR_MODE_DM2SCRATCH_ALLOC];//&$celt.enc.celt_512_48000_mode.dm2scratch_alloc; 
8420052c:	2c 02 57 d1 	r3 = M[r5 + 556];
   r4 = M[r5 + $celt.dec.PTR_celt_dm2_scratch];//&$celt_dm2_scratch;
84200530:	34 02 67 d1 	r4 = M[r5 + 564];
   call $celt.alloc_scratch_mem;
84200534:	ff fe f0 e1 	call $celt.alloc_scratch_mem;
 #endif

   // -- Save codec struct pointer --
   M[r5 + $celt.dec.SCRATCHVAR_CODEC_STRUC] = r5;
84200538:	74 01 77 d5 	M[r5 + 372] = r5;

   // -- No output samples yet
   M[r9 + $codec.DECODER_NUM_OUTPUT_SAMPLES_FIELD] = 0;
8420053c:	10 00 0b d5 	M[r9 + 16] = Null;
   
   // -- See if there is enough output space
   r4 = M[r5 + $celt.dec.MODE_AUDIO_FRAME_SIZE_FIELD];
84200540:	44 00 67 d1 	r4 = M[r5 + 68];
   r0 = M[r9 + $codec.DECODER_OUT_LEFT_BUFFER_FIELD];
84200544:	04 00 2b d1 	r0 = M[r9 + 4];
#ifdef KYMERA
        call $cbuffer.calc_amount_space_in_words;
84200548:	03 00 00 fd 	call (m) 0x39d88;
8420054c:	89 9d f0 e1 
#else
        call $cbuffer.calc_amount_space;
#endif
   Null = r0 - r4;
84200550:	6f 00 02 20 	Null = r0 - r4;
   if NEG jump exit_not_enough_output_space;
84200554:	75 00 40 dd 	if NEG jump $M.celt.frame_decode.exit_not_enough_output_space;
   r0 = M[r9 + $codec.DECODER_OUT_RIGHT_BUFFER_FIELD];
84200558:	08 00 2b d1 	r0 = M[r9 + 8];
   if Z jump end_space_check;
8420055c:	05 00 00 dd 	if EQ jump $M.celt.frame_decode.end_space_check;
#ifdef KYMERA
        call $cbuffer.calc_amount_space_in_words;
84200560:	03 00 00 fd 	call (m) 0x39d88;
84200564:	89 9d f0 e1 
#else
        call $cbuffer.calc_amount_space;
#endif
      Null = r0 - r4;
84200568:	6f 00 02 20 	Null = r0 - r4;
      if NEG jump exit_not_enough_output_space;
8420056c:	6f 00 40 dd 	if NEG jump $M.celt.frame_decode.exit_not_enough_output_space;

84200570 <$M.celt.frame_decode.end_space_check>:
   end_space_check:
   
   // save output buffer addresses
   r0 = M[r9 + $codec.DECODER_OUT_LEFT_BUFFER_FIELD];
84200570:	04 00 2b d1 	r0 = M[r9 + 4];
#ifdef BASE_REGISTER_MODE
   call $cbuffer.get_write_address_and_size_and_start_address;
84200574:	03 00 00 fd 	call (m) 0x3a2b0;
84200578:	b1 a2 f0 e1 
   M[r5 + $celt.dec.SCRATCHVAR_LEFT_OBUF_START_ADDR] = r2;
8420057c:	84 01 47 d5 	M[r5 + 388] = r2;
#else   
   call $cbuffer.get_write_address_and_size;
#endif
   M[r5 + $celt.dec.SCRATCHVAR_LEFT_OBUF_ADDR] = r0;
84200580:	7c 01 27 d5 	M[r5 + 380] = r0;
   M[r5 + $celt.dec.SCRATCHVAR_LEFT_OBUF_LEN] = r1;
84200584:	80 01 37 d5 	M[r5 + 384] = r1;
   r0 = M[r9 + $codec.DECODER_OUT_RIGHT_BUFFER_FIELD];
84200588:	08 00 2b d1 	r0 = M[r9 + 8];
   if Z jump end_ch_addr_save;
8420058c:	06 00 00 dd 	if EQ jump $M.celt.frame_decode.end_ch_addr_save;
#ifdef BASE_REGISTER_MODE
   call $cbuffer.get_write_address_and_size_and_start_address;
84200590:	03 00 00 fd 	call (m) 0x3a2b0;
84200594:	b1 a2 f0 e1 
   M[r5 + $celt.dec.SCRATCHVAR_RIGHT_OBUF_START_ADDR] = r2;
84200598:	90 01 47 d5 	M[r5 + 400] = r2;
#else  
   call $cbuffer.get_write_address_and_size;
#endif
      M[r5 + $celt.dec.SCRATCHVAR_RIGHT_OBUF_ADDR] = r0;
8420059c:	88 01 27 d5 	M[r5 + 392] = r0;
      M[r5 + $celt.dec.SCRATCHVAR_RIGHT_OBUF_LEN] = r1;
842005a0:	8c 01 37 d5 	M[r5 + 396] = r1;

842005a4 <$M.celt.frame_decode.end_ch_addr_save>:
      no_plc_run:
      M[r5 + $celt.dec.PLC_COUNTER_FIELD] = Null;
   #endif
*/   
   //-- See if there is at least one frame 
   r0 = M[r9 + $codec.DECODER_IN_BUFFER_FIELD];
842005a4:	00 00 2b d1 	r0 = M[r9 + 0];
#ifdef KYMERA
   call $cbuffer.calc_amount_data_in_words;
842005a8:	03 00 00 fd 	call (m) 0x39dd4;
842005ac:	d5 9d f0 e1 
#else
   call $cbuffer.calc_amount_data;
#endif
   r0 = r0 + r0;
842005b0:	00 00 22 03 	r0 = r0 + r0;
   r1 = M[r5 + $celt.dec.GET_BYTE_POS_FIELD];
842005b4:	a4 00 37 d1 	r1 = M[r5 + 164];
   r2 = r0 + r1;
842005b8:	3f 00 42 00 	r2 = r0 + r1;
   r2 = r2 - 1;
842005bc:	3f 00 44 e4 	r2 = r2 - 1;
   r1 = M[r5 + $celt.dec.CELT_CODEC_FRAME_SIZE_FIELD];
842005c0:	04 00 37 d1 	r1 = M[r5 + 4];
   r0 = $codec.NOT_ENOUGH_INPUT_DATA;
842005c4:	2f 00 20 e4 	r0 = Null + 1;
   Null = r2 - r1;
842005c8:	3f 00 04 20 	Null = r2 - r1;
   if NEG jump exit;
842005cc:	58 00 40 dd 	if NEG jump $M.celt.frame_decode.exit;
 
   // -- Initialise frame decoder
   call $celt.decoder_frame_init;
842005d0:	e9 fe f0 e1 	call $celt.decoder_frame_init;
   
   // -- Extract flags
   call $celt.decode_flags;
842005d4:	24 14 f0 e1 	call $celt.decode_flags;
   M[r5 + $celt.dec.SCRATCHVAR_FRAME_CORRUPT] = r0;
842005d8:	94 01 27 d5 	M[r5 + 404] = r0;
   if NZ jump frame_corrupt;
842005dc:	50 00 10 dd 	if NE jump $M.celt.frame_decode.frame_corrupt;
   
   // -- Unquantise Coarse Energies
   call $celt.unquant_coarse_energy;
842005e0:	54 0d f0 e1 	call $celt.unquant_coarse_energy;
   
   // -- Compute bit allocations
   call $celt.compute_allocation;
842005e4:	66 13 f0 e1 	call $celt.compute_allocation;
   
   // -- Decode fine energy bits
   call $celt.unquant_fine_energy;
842005e8:	a7 0d f0 e1 	call $celt.unquant_fine_energy;
   
   // -- Dequantise residual bits 
   r0 = M[r5 + $celt.dec.CELT_CHANNELS_FIELD];
842005ec:	08 00 27 d1 	r0 = M[r5 + 8];
   if Z call $celt.unquant_bands;
842005f0:	cd 0d 00 e1 	if EQ call $celt.quant_bands;
   r0 = M[r5 + $celt.dec.CELT_CHANNELS_FIELD];
842005f4:	08 00 27 d1 	r0 = M[r5 + 8];
   if NZ call $celt.unquant_bands_stereo;
842005f8:	44 0e 10 e1 	if NE call $celt.unquant_bands_stereo;
   
   // -- Decode remaining bits
   call $celt.unquant_energy_finalise;
842005fc:	5e 10 f0 e1 	call $celt.unquant_energy_finalise;
   
   // -- MDCT shape for some short encoded frames
   r8 = $celt.CELT_DECODER;
84200600:	00 00 a0 01 	r8 = Null + 0;
   Null = M[r5 + $celt.dec.MDCT_WEIGHT_SHIFT_FIELD];
84200604:	6c 01 07 d1 	Null = M[r5 + 364];
   if NZ call  $celt.mdct_shape;
84200608:	ea 0c 10 e1 	if NE call $celt.mdct_shape;
 
   // -- Denormalising bands
   call $celt.denormalise_bands;
8420060c:	b6 10 f0 e1 	call $celt.denormalise_bands;
 
   // -- Input frame processed, terminate reading
   call $celt.end_reading_frame;
84200610:	fa fe f0 e1 	call $celt.end_reading_frame;
   
   //-- TODO: Do optional stereo to mono processing here
   push r9;   
84200614:	00 00 b0 f3 	push r9;
   // -- Apply windowing and overlap add
   call $celt.imdct_window_overlap_add;
84200618:	ca 01 f0 e1 	call $celt.imdct_window_overlap_add;
   pop r9;
8420061c:	00 00 b4 f3 	pop r9;

84200620 <$M.celt.frame_decode.post_proc>:
      if NZ call $celt.fill_plc_buffers; 
   #endif
*/   
   
   // -- Apply final de-emphasis filter  
   call $celt.deemphasis;
84200620:	5e 14 f0 e1 	call $celt.deemphasis;
   
   //-- Mono to stereo convert
   Null = M[r5 + $celt.dec.SCRATCHVAR_MONO_TO_STEREO];
84200624:	78 01 07 d1 	Null = M[r5 + 376];
   if Z jump end_mono_to_stereo_convert;
84200628:	19 00 00 dd 	if EQ jump $M.celt.frame_decode.end_mono_to_stereo_convert;
   r10 = M[r5 + $celt.dec.MODE_AUDIO_FRAME_SIZE_FIELD];
8420062c:	44 00 c7 d1 	r10 = M[r5 + 68];
   r0 = M[r5 + $celt.dec.SCRATCHVAR_LEFT_OBUF_ADDR];
84200630:	7c 01 27 d1 	r0 = M[r5 + 380];
   r1 = M[r5 + $celt.dec.SCRATCHVAR_LEFT_OBUF_LEN];
84200634:	80 01 37 d1 	r1 = M[r5 + 384];
   I5 = r0;
84200638:	2f 00 50 50 	I5 = Null + r0;
   L5 = r1;
8420063c:	3f 00 f0 50 	L5 = Null + r1;
   r0 = M[r5 + $celt.dec.SCRATCHVAR_RIGHT_OBUF_ADDR];
84200640:	88 01 27 d1 	r0 = M[r5 + 392];
   r1 = M[r5 + $celt.dec.SCRATCHVAR_RIGHT_OBUF_LEN];
84200644:	8c 01 37 d1 	r1 = M[r5 + 396];
   I4 = r0;
84200648:	2f 00 40 50 	I4 = Null + r0;
   L4 = r1;
8420064c:	3f 00 e0 50 	L4 = Null + r1;
#ifdef BASE_REGISTER_MODE
   r0 = M[r5 + $celt.dec.SCRATCHVAR_LEFT_OBUF_START_ADDR];
84200650:	84 01 27 d1 	r0 = M[r5 + 388];
   push r0;
84200654:	00 00 20 f3 	push r0;
   pop B5;
84200658:	00 00 d6 f3 	pop B5;
   r0 = M[r5 + $celt.dec.SCRATCHVAR_RIGHT_OBUF_START_ADDR];
8420065c:	90 01 27 d1 	r0 = M[r5 + 400];
   push r0;
84200660:	00 00 20 f3 	push r0;
   pop B4;
84200664:	00 00 c6 f3 	pop B4;
#endif 
   do copy_left_to_right_loop;
84200668:	03 00 f0 e5 	do $M.celt.frame_decode.copy_left_to_right_loop;
      r0 = M[I5, MK1];
8420066c:	25 00 00 03 	Null = Null + Null, r0 = M[I5,4];
      M[I4, MK1] = r0;
84200670:	a1 00 00 03 	Null = Null + Null, M[I4,4] = r0;

84200674 <$M.celt.frame_decode.copy_left_to_right_loop>:
   copy_left_to_right_loop:
   L4 = 0;
84200674:	00 00 e0 51 	L4 = Null + 0;
   L5 = 0;   
84200678:	00 00 f0 51 	L5 = Null + 0;
#ifdef BASE_REGISTER_MODE
   push Null;
8420067c:	00 00 00 f3 	push Null;
   pop B4;
84200680:	00 00 c6 f3 	pop B4;
   push Null; 
84200684:	00 00 00 f3 	push Null;
   pop B5; 
84200688:	00 00 d6 f3 	pop B5;

8420068c <$M.celt.frame_decode.end_mono_to_stereo_convert>:
   end_mono_to_stereo_convert:
   
   // -- Stereo to mono convert
   // Celt library doesnt do this at the moment   
   //-- Set write address for left channel
   r0 = M[r9 + $codec.DECODER_OUT_LEFT_BUFFER_FIELD];
8420068c:	04 00 2b d1 	r0 = M[r9 + 4];
#ifdef BASE_REGISTER_MODE
   call $cbuffer.get_write_address_and_size_and_start_address;
84200690:	03 00 00 fd 	call (m) 0x3a2b0;
84200694:	b1 a2 f0 e1 
   push r2;
84200698:	00 00 40 f3 	push r2;
   pop  B5;
8420069c:	00 00 d6 f3 	pop B5;
#else  
   call $cbuffer.get_write_address_and_size;
#endif
   I5 = r0;
842006a0:	2f 00 50 50 	I5 = Null + r0;
   L5 = r1;
842006a4:	3f 00 f0 50 	L5 = Null + r1;
   r0 = M[r5 + $celt.dec.MODE_AUDIO_FRAME_SIZE_FIELD];
842006a8:	44 00 27 d1 	r0 = M[r5 + 68];
   Words2Addr(r0);
842006ac:	02 00 22 91 	r0 = r0 ASHIFT 2;
   M0 = r0;
842006b0:	2f 00 80 50 	M0 = Null + r0;
   r0 = M[I5, M0];
842006b4:	24 00 00 02 	Null = Null + Null, r0 = M[I5,M0];
   r0 = M[r9 + $codec.DECODER_OUT_LEFT_BUFFER_FIELD];
842006b8:	04 00 2b d1 	r0 = M[r9 + 4];
   r1 = I5;
842006bc:	5f 00 30 44 	r1 = Null + I5;
   call $cbuffer.set_write_address;
842006c0:	03 00 00 fd 	call (m) 0x3a320;
842006c4:	21 a3 f0 e1 
   
   //-- Set write address for right channel
   r0 = M[r9 + $codec.DECODER_OUT_RIGHT_BUFFER_FIELD];
842006c8:	08 00 2b d1 	r0 = M[r9 + 8];
   if Z jump end_buffer_set_write_address;
842006cc:	0c 00 00 dd 	if EQ jump $M.celt.frame_decode.end_buffer_set_write_address;
#ifdef BASE_REGISTER_MODE
   call $cbuffer.get_write_address_and_size_and_start_address;
842006d0:	03 00 00 fd 	call (m) 0x3a2b0;
842006d4:	b1 a2 f0 e1 
   push r2;
842006d8:	00 00 40 f3 	push r2;
   pop  B5;
842006dc:	00 00 d6 f3 	pop B5;
#else     
   call $cbuffer.get_write_address_and_size;
#endif
   I5 = r0;
842006e0:	2f 00 50 50 	I5 = Null + r0;
   L5 = r1;
842006e4:	3f 00 f0 50 	L5 = Null + r1;
   r0 = M[I5, M0];
842006e8:	24 00 00 02 	Null = Null + Null, r0 = M[I5,M0];
   r0 = M[r9 + $codec.DECODER_OUT_RIGHT_BUFFER_FIELD];
842006ec:	08 00 2b d1 	r0 = M[r9 + 8];
   r1 = I5;
842006f0:	5f 00 30 44 	r1 = Null + I5;
   call $cbuffer.set_write_address;
842006f4:	03 00 00 fd 	call (m) 0x3a320;
842006f8:	21 a3 f0 e1 

842006fc <$M.celt.frame_decode.end_buffer_set_write_address>:
   end_buffer_set_write_address:
   L5 = 0;
842006fc:	00 00 f0 51 	L5 = Null + 0;
#ifdef BASE_REGISTER_MODE
   push Null;
84200700:	00 00 00 f3 	push Null;
   pop  B5;
84200704:	00 00 d6 f3 	pop B5;
#endif
   
   // -- Decoding Successful
   r0 = M0;
84200708:	8f 00 20 44 	r0 = Null + M0;
   Addr2Words(r0);
8420070c:	fe 00 22 91 	r0 = r0 ASHIFT -2;
   M[r9 + $codec.DECODER_NUM_OUTPUT_SAMPLES_FIELD] = r0;
84200710:	10 00 2b d5 	M[r9 + 16] = r0;
   r0 = $codec.SUCCESS;
84200714:	00 00 20 01 	r0 = Null + 0;
   jump exit;
84200718:	05 00 f0 dd 	jump $M.celt.frame_decode.exit;

8420071c <$M.celt.frame_decode.frame_corrupt>:
   
   // check if any errors occured
   frame_corrupt:
      call $celt.end_reading_frame;
8420071c:	b7 fe f0 e1 	call $celt.end_reading_frame;
      r0 = $codec.FRAME_CORRUPT;
84200720:	05 00 20 01 	r0 = Null + 5;
      jump exit;
84200724:	02 00 f0 dd 	jump $M.celt.frame_decode.exit;

84200728 <$M.celt.frame_decode.exit_not_enough_output_space>:
 
   exit_not_enough_output_space:
   // set NOT_ENOUGH_OUTPUT_SPACE flag and exit
   r0 = $codec.NOT_ENOUGH_OUTPUT_SPACE;
84200728:	af 00 20 e4 	r0 = Null + 2;

8420072c <$M.celt.frame_decode.exit>:
   
   exit:
   M[r9 + $codec.DECODER_MODE_FIELD] = r0;
8420072c:	0c 00 2b d5 	M[r9 + 12] = r0;

   pop r5;
84200730:	00 00 74 f3 	pop r5;

   // pop rLink from stack
   jump $pop_rLink_and_rts;
84200734:	03 00 00 fd 	jump (m) 0x3b020;
84200738:	21 b0 f0 dd 

8420073c <$_celt_frame_encode>:
8420073c:	00 00 d0 f3 	push rLink;

   // push rLink onto stack
   push rlink;
   
   //-- Is re-init required?
   push r5;
84200740:	00 00 70 f3 	push r5;
   r9 = r5;
84200744:	0f 00 b7 00 	r9 = r5 + Null;
   r5 = M[r5 + $codec.ENCODER_DATA_OBJECT_FIELD];
84200748:	10 00 77 d1 	r5 = M[r5 + 16];
   Null = M[r5 + $celt.enc.REINIT_ENCODER_FIELD];
8420074c:	14 00 07 d1 	Null = M[r5 + 20];
   if Z jump no_reinit;
84200750:	04 00 00 dd 	if EQ jump $M.celt.frame_encode.no_reinit;
      r5 = r9;
84200754:	0f 00 7b 00 	r5 = r9 + Null;
      call $celt.encoder_init;
84200758:	0e ff f0 e1 	call $celt.encoder_init;
      r5 = M[r5 + $codec.ENCODER_DATA_OBJECT_FIELD];
8420075c:	10 00 77 d1 	r5 = M[r5 + 16];

84200760 <$M.celt.frame_encode.no_reinit>:
   no_reinit:
   
 #ifdef KYMERA 
   r1 = M[r5 + $celt.enc.PTR_MODE_DM1SCRATCH_ALLOC];//&$celt.enc.celt_512_48000_mode.dm1scratch_alloc;
84200760:	28 02 37 d1 	r1 = M[r5 + 552];
   r2 = M[r5 + $celt.enc.PTR_celt_dm1_scratch];//&$celt_dm1_scratch;
84200764:	30 02 47 d1 	r2 = M[r5 + 560];
   r3 = M[r5 + $celt.enc.PTR_MODE_DM2SCRATCH_ALLOC];//&$celt.enc.celt_512_48000_mode.dm2scratch_alloc; 
84200768:	2c 02 57 d1 	r3 = M[r5 + 556];
   r4 = M[r5 + $celt.enc.PTR_celt_dm2_scratch];//&$celt_dm2_scratch;
8420076c:	34 02 67 d1 	r4 = M[r5 + 564];
   call $celt.alloc_scratch_mem;
84200770:	70 fe f0 e1 	call $celt.alloc_scratch_mem;
 #endif 
 
   // -- Save codec struct pointer --
   M[r5 + $celt.enc.SCRATCHVAR_CODEC_STRUC] = r5;
84200774:	74 01 77 d5 	M[r5 + 372] = r5;
   // -- See if there is enough input data
   r4 = M[r5 + $celt.enc.MODE_AUDIO_FRAME_SIZE_FIELD];
84200778:	44 00 67 d1 	r4 = M[r5 + 68];
   r0 = M[r9 + $codec.ENCODER_IN_LEFT_BUFFER_FIELD];
8420077c:	04 00 2b d1 	r0 = M[r9 + 4];
#ifdef KYMERA
   call $cbuffer.calc_amount_data_in_words;
84200780:	03 00 00 fd 	call (m) 0x39dd4;
84200784:	d5 9d f0 e1 
#else
   call $cbuffer.calc_amount_data;
#endif
   Null = r0 - r4;
84200788:	6f 00 02 20 	Null = r0 - r4;
   if NEG jump exit_not_enough_input_data;
8420078c:	83 00 40 dd 	if NEG jump $M.celt.frame_encode.exit_not_enough_input_data;
   r0 = M[r9 + $codec.ENCODER_IN_RIGHT_BUFFER_FIELD];
84200790:	08 00 2b d1 	r0 = M[r9 + 8];
   if Z jump end_data_check;
84200794:	05 00 00 dd 	if EQ jump $M.celt.frame_encode.end_data_check;
#ifdef KYMERA
   call $cbuffer.calc_amount_data_in_words;
84200798:	03 00 00 fd 	call (m) 0x39dd4;
8420079c:	d5 9d f0 e1 
#else
   call $cbuffer.calc_amount_data;
#endif
      Null = r0 - r4;
842007a0:	6f 00 02 20 	Null = r0 - r4;
      if NEG jump exit_not_enough_input_data;
842007a4:	7d 00 40 dd 	if NEG jump $M.celt.frame_encode.exit_not_enough_input_data;

842007a8 <$M.celt.frame_encode.end_data_check>:
   end_data_check:
   
   // save output buffer addresses
   r0 = M[r9 + $codec.ENCODER_IN_LEFT_BUFFER_FIELD];
842007a8:	04 00 2b d1 	r0 = M[r9 + 4];
#ifdef BASE_REGISTER_MODE
   call $cbuffer.get_read_address_and_size_and_start_address;
842007ac:	03 00 00 fd 	call (m) 0x3a27a;
842007b0:	7b a2 f0 e1 
   M[r5 + $celt.enc.SCRATCHVAR_LEFT_IBUF_START_ADDR] = r2;
842007b4:	84 01 47 d5 	M[r5 + 388] = r2;
#else
   call $cbuffer.get_read_address_and_size;
#endif
   M[r5 + $celt.enc.SCRATCHVAR_LEFT_IBUF_ADDR] = r0;
842007b8:	7c 01 27 d5 	M[r5 + 380] = r0;
   M[r5 + $celt.enc.SCRATCHVAR_LEFT_IBUF_LEN] = r1;
842007bc:	80 01 37 d5 	M[r5 + 384] = r1;
   r0 =  M[r9 + $codec.ENCODER_IN_RIGHT_BUFFER_FIELD];
842007c0:	08 00 2b d1 	r0 = M[r9 + 8];
   if Z jump end_ch_addr_save;
842007c4:	06 00 00 dd 	if EQ jump $M.celt.frame_encode.end_ch_addr_save;
#ifdef BASE_REGISTER_MODE
   call $cbuffer.get_read_address_and_size_and_start_address;
842007c8:	03 00 00 fd 	call (m) 0x3a27a;
842007cc:	7b a2 f0 e1 
   M[r5 + $celt.enc.SCRATCHVAR_RIGHT_IBUF_START_ADDR] = r2;
842007d0:	90 01 47 d5 	M[r5 + 400] = r2;
#else
   call $cbuffer.get_read_address_and_size;
#endif

   M[r5 + $celt.enc.SCRATCHVAR_RIGHT_IBUF_ADDR] = r0;
842007d4:	88 01 27 d5 	M[r5 + 392] = r0;
   M[r5 + $celt.enc.SCRATCHVAR_RIGHT_IBUF_LEN] = r1;
842007d8:	8c 01 37 d5 	M[r5 + 396] = r1;

842007dc <$M.celt.frame_encode.end_ch_addr_save>:
   end_ch_addr_save:

   //-- See if there is at least one frame output space 
   r0 = M[r9 + $codec.ENCODER_OUT_BUFFER_FIELD];
842007dc:	00 00 2b d1 	r0 = M[r9 + 0];
#ifdef KYMERA
        call $cbuffer.calc_amount_space_in_words;
842007e0:	03 00 00 fd 	call (m) 0x39d88;
842007e4:	89 9d f0 e1 
#else
        call $cbuffer.calc_amount_space;
#endif
#ifdef DATAFORMAT_32
   r0 = r0 LSHIFT LOG2_ADDR_PER_WORD;
842007e8:	02 00 22 8d 	r0 = r0 LSHIFT 2;
#else
   r0 = r0 + r0;
#endif
   r1 = M[r5 + $celt.enc.PUT_BYTE_POS_FIELD];
842007ec:	a4 00 37 d1 	r1 = M[r5 + 164];
   r2 = r0 + r1;
842007f0:	3f 00 42 00 	r2 = r0 + r1;
   r2 = r2 - 1;
842007f4:	3f 00 44 e4 	r2 = r2 - 1;
   r1 = M[r5 + $celt.enc.CELT_CODEC_FRAME_SIZE_FIELD];
842007f8:	04 00 37 d1 	r1 = M[r5 + 4];
   r0 = $codec.NOT_ENOUGH_OUTPUT_SPACE;
842007fc:	af 00 20 e4 	r0 = Null + 2;
   Null = r2 - r1;
84200800:	3f 00 04 20 	Null = r2 - r1;
   if NEG jump exit;
84200804:	66 00 40 dd 	if NEG jump $M.celt.frame_encode.exit;

   // -- stereo to mono --
   // Please note right channel signal is mixed into left channel signal. 
   // The mono output signal will be a mixed signal of left and right channels. 
   r0 = 1;
84200808:	2f 00 20 e4 	r0 = Null + 1;
   Null = M[r9 + $codec.ENCODER_IN_RIGHT_BUFFER_FIELD];
8420080c:	08 00 0b d1 	Null = M[r9 + 8];
   if Z r0 = 0;
84200810:	00 00 20 00 	if EQ r0 = Null + Null;
   r1 = M[r5 + $celt.enc.CELT_CHANNELS_FIELD];
84200814:	08 00 37 d1 	r1 = M[r5 + 8];
   r2 = r1 XOR r0; 
84200818:	2f 00 43 88 	r2 = r1 XOR r0;
   r0 = r0 AND r2;
8420081c:	00 00 24 83 	r0 = r0 AND r2;
   M[r5 + $celt.enc.SCRATCHVAR_STEREO_TO_MONO] = r0;
84200820:	78 01 27 d5 	M[r5 + 376] = r0;
   
   if Z jump end_stereo_to_mono_convert;
84200824:	22 00 00 dd 	if EQ jump $M.celt.frame_encode.end_stereo_to_mono_convert;
      r10 = M[r5 + $celt.enc.MODE_AUDIO_FRAME_SIZE_FIELD];
84200828:	44 00 c7 d1 	r10 = M[r5 + 68];
      r0 = M[r5 + $celt.enc.SCRATCHVAR_LEFT_IBUF_ADDR];
8420082c:	7c 01 27 d1 	r0 = M[r5 + 380];
      I4 = r0;
84200830:	2f 00 40 50 	I4 = Null + r0;
      r0 = M[r5 + $celt.enc.SCRATCHVAR_LEFT_IBUF_LEN];
84200834:	80 01 27 d1 	r0 = M[r5 + 384];
      L4 = r0;
84200838:	2f 00 e0 50 	L4 = Null + r0;
      r0 = M[r5 + $celt.enc.SCRATCHVAR_RIGHT_IBUF_ADDR];
8420083c:	88 01 27 d1 	r0 = M[r5 + 392];
      I5 = r0;
84200840:	2f 00 50 50 	I5 = Null + r0;
      r0 = M[r5 + $celt.enc.SCRATCHVAR_RIGHT_IBUF_LEN];
84200844:	8c 01 27 d1 	r0 = M[r5 + 396];
      L5 = r0;
84200848:	2f 00 f0 50 	L5 = Null + r0;
#ifdef BASE_REGISTER_MODE  
      r0 = M[r5 + $celt.enc.SCRATCHVAR_LEFT_IBUF_START_ADDR];
8420084c:	84 01 27 d1 	r0 = M[r5 + 388];
      push r0; 
84200850:	00 00 20 f3 	push r0;
      pop B4;
84200854:	00 00 c6 f3 	pop B4;
      r0 = M[r5 + $celt.enc.SCRATCHVAR_RIGHT_IBUF_START_ADDR];
84200858:	90 01 27 d1 	r0 = M[r5 + 400];
      push r0;
8420085c:	00 00 20 f3 	push r0;
      pop B5; 
84200860:	00 00 d6 f3 	pop B5;
#endif       
      r2 = 0.5;
84200864:	00 40 00 fd 	r2 = Null + 1073741824;
84200868:	00 00 40 01 
      r10 = r10 - 1;
8420086c:	3f 00 cc e4 	r10 = r10 - 1;
      r0 = M[I5, MK1];
84200870:	25 00 00 03 	Null = Null + Null, r0 = M[I5,4];
      rMAC = r0 * r2;
84200874:	4f 00 12 cc 	rMAC = r0 * r2 (SS);
      do stereo_to_mono_loop;
84200878:	04 00 f0 e5 	do $M.celt.frame_encode.stereo_to_mono_loop;
         r0 = M[I4, 0];
8420087c:	20 00 00 03 	Null = Null + Null, r0 = M[I4,0];
         rMAC = rMAC + r0 * r2, r0 = M[I5, MK1];
84200880:	25 00 24 af 	rMAC = rMAC + r0 * r2 (SS), r0 = M[I5,4];
         rMAC = r0 * r2, M[I4, MK1] = rMAC;
84200884:	91 00 24 cf 	rMAC = r0 * r2 (SS), M[I4,4] = rMAC;

84200888 <$M.celt.frame_encode.stereo_to_mono_loop>:
      stereo_to_mono_loop:
      r0 = M[I4, 0];
84200888:	20 00 00 03 	Null = Null + Null, r0 = M[I4,0];
      rMAC = rMAC + r0 * r2;
8420088c:	4f 00 12 ac 	rMAC = rMAC + r0 * r2 (SS);
      M[I4, MK1] = rMAC;    
84200890:	91 00 00 03 	Null = Null + Null, M[I4,4] = rMAC;
      L5 = 0;
84200894:	00 00 f0 51 	L5 = Null + 0;
      L4 = 0;
84200898:	00 00 e0 51 	L4 = Null + 0;
      
#ifdef BASE_REGISTER_MODE 
      push Null; 
8420089c:	00 00 00 f3 	push Null;
      pop B4;
842008a0:	00 00 c6 f3 	pop B4;
      push Null; 
842008a4:	00 00 00 f3 	push Null;
      pop B5; 
842008a8:	00 00 d6 f3 	pop B5;

842008ac <$M.celt.frame_encode.end_stereo_to_mono_convert>:
#endif
      
   end_stereo_to_mono_convert:
   
   push r9;
842008ac:	00 00 b0 f3 	push r9;

   // -- Preemphasis
   call $celt.preemphasis;
842008b0:	e4 03 f0 e1 	call $celt.preemphasis;
   
  // --
  call  $celt.transient_analysis;
842008b4:	8c 0b f0 e1 	call $celt.transient_analysis;


   // -- Windowing and MDCT
   call $celt.mdct_analysis;
842008b8:	0d 02 f0 e1 	call $celt.mdct_analysis;
    
   // -- Bands processing
   call $celt.bands_process;
842008bc:	88 12 f0 e1 	call $celt.bands_process;

   pop r9;
842008c0:	00 00 b4 f3 	pop r9;
   
   // -- Initialise frame encoder
   call $celt.encoder_frame_init;
842008c4:	e8 fe f0 e1 	call $celt.encoder_frame_init;


   // -- update output buffer addresses
   r0 =  M[r9 + $codec.ENCODER_IN_LEFT_BUFFER_FIELD];
842008c8:	04 00 2b d1 	r0 = M[r9 + 4];
#ifdef BASE_REGISTER_MODE
   call $cbuffer.get_read_address_and_size_and_start_address;
842008cc:	03 00 00 fd 	call (m) 0x3a27a;
842008d0:	7b a2 f0 e1 
   push r2;
842008d4:	00 00 40 f3 	push r2;
   pop  B4;
842008d8:	00 00 c6 f3 	pop B4;
#else
   call $cbuffer.get_read_address_and_size;
#endif
   r4 = M[r5 + $celt.enc.MODE_AUDIO_FRAME_SIZE_FIELD];
842008dc:	44 00 67 d1 	r4 = M[r5 + 68];
   I4 = r0;
842008e0:	2f 00 40 50 	I4 = Null + r0;
   L4 = r1;
842008e4:	3f 00 e0 50 	L4 = Null + r1;
   Words2Addr(r4);
842008e8:	02 00 66 91 	r4 = r4 ASHIFT 2;
   M0 = r4;
842008ec:	6f 00 80 50 	M0 = Null + r4;
   r0 = M[I4, M0];
842008f0:	20 00 00 02 	Null = Null + Null, r0 = M[I4,M0];
   r1 = I4;
842008f4:	4f 00 30 44 	r1 = Null + I4;
   r0 = M[r9 + $codec.ENCODER_IN_LEFT_BUFFER_FIELD];
842008f8:	04 00 2b d1 	r0 = M[r9 + 4];
   call $cbuffer.set_read_address;
842008fc:	03 00 00 fd 	call (m) 0x3a2e6;
84200900:	e7 a2 f0 e1 
   
   // -- see if right buffer is enabled
   r0 =  M[r9 + $codec.ENCODER_IN_RIGHT_BUFFER_FIELD];
84200904:	08 00 2b d1 	r0 = M[r9 + 8];
   if Z jump end_ch_addr_update;
84200908:	0c 00 00 dd 	if EQ jump $M.celt.frame_encode.end_ch_addr_update;
#ifdef BASE_REGISTER_MODE
    call $cbuffer.get_read_address_and_size_and_start_address;
8420090c:	03 00 00 fd 	call (m) 0x3a27a;
84200910:	7b a2 f0 e1 
    push r2;
84200914:	00 00 40 f3 	push r2;
    pop  B4;
84200918:	00 00 c6 f3 	pop B4;
#else  
    call $cbuffer.get_read_address_and_size;
#endif
    I4 = r0;
8420091c:	2f 00 40 50 	I4 = Null + r0;
    L4 = r1;
84200920:	3f 00 e0 50 	L4 = Null + r1;
    r0 = M[I4, M0];
84200924:	20 00 00 02 	Null = Null + Null, r0 = M[I4,M0];
    r1 = I4;
84200928:	4f 00 30 44 	r1 = Null + I4;
    r0 = M[r9 + $codec.ENCODER_IN_RIGHT_BUFFER_FIELD];
8420092c:	08 00 2b d1 	r0 = M[r9 + 8];
    call $cbuffer.set_read_address;
84200930:	03 00 00 fd 	call (m) 0x3a2e6;
84200934:	e7 a2 f0 e1 

84200938 <$M.celt.frame_encode.end_ch_addr_update>:
 end_ch_addr_update:
    L4 = 0;
84200938:	00 00 e0 51 	L4 = Null + 0;
 #ifdef BASE_REGISTER_MODE
    push Null;
8420093c:	00 00 00 f3 	push Null;
    pop  B4;
84200940:	00 00 c6 f3 	pop B4;
#endif

   push r9;
84200944:	00 00 b0 f3 	push r9;
  
   // -- encode flags
   r0 = $celt.FLAG_INTRA;
84200948:	00 20 20 01 	r0 = Null + 8192;
   M[r5 + $celt.enc.INTRA_ENER_FIELD] = r0;
8420094c:	54 01 27 d5 	M[r5 + 340] = r0;
   M[r5 + $celt.enc.HAS_PITCH_FIELD] = Null;
84200950:	5c 01 07 d5 	M[r5 + 348] = Null;
   //M[r5 + $celt.enc.SHORT_BLOCKS_FIELD] = Null;
   r0 = $celt.FLAG_FOLD;
84200954:	00 04 20 01 	r0 = Null + 1024;
   M[r5 + $celt.enc.HAS_FOLD_FIELD] = r0;
84200958:	60 01 27 d5 	M[r5 + 352] = r0;
   
   // -- more transient processing for short blocks
   Null = M[r5 + $celt.enc.SHORT_BLOCKS_FIELD];
8420095c:	58 01 07 d1 	Null = M[r5 + 344];
   if NZ call $celt.transient_block_process;
84200960:	40 0c 10 e1 	if NE call $celt.transient_block_process;
   
   
   call $celt.encode_flags;
84200964:	44 fe f0 e1 	call $celt.encode_flags;
   
   // -- quant coarse energy
   call $celt.quant_coarse_energy;
84200968:	f1 03 f0 e1 	call $celt.quant_coarse_energy;
  
   // -- Compute bit allocations
   call $celt.compute_allocation;
8420096c:	84 12 f0 e1 	call $celt.compute_allocation;
   
   // -- Encode fine energy bits
   call $celt.quant_fine_energy;
84200970:	57 04 f0 e1 	call $celt.quant_fine_energy;

   // -- Quantise residual bits 
   r0 = M[r5 + $celt.enc.CELT_CHANNELS_FIELD];
84200974:	08 00 27 d1 	r0 = M[r5 + 8];
   if Z call $celt.quant_bands;
84200978:	eb 0c 00 e1 	if EQ call $celt.quant_bands;
   r0 = M[r5 + $celt.enc.CELT_CHANNELS_FIELD];
8420097c:	08 00 27 d1 	r0 = M[r5 + 8];
   if NZ call $celt.quant_bands_stereo;
84200980:	64 0d 10 e1 	if NE call $celt.quant_bands_stereo;
   
   // -- Finalize energy quantization
   call $celt.quant_energy_finalise;
84200984:	86 04 f0 e1 	call $celt.quant_energy_finalise;
   
   pop r9;
84200988:	00 00 b4 f3 	pop r9;
   // -- Complete final steps in encoding frame
   //    this also updates output buffer pointers
   call $celt.end_writing_frame;
8420098c:	f3 06 f0 e1 	call $celt.end_writing_frame;
   
   // -- Encoding Successful!
   r0 = $codec.SUCCESS;
84200990:	00 00 20 01 	r0 = Null + 0;
   jump exit;
84200994:	02 00 f0 dd 	jump $M.celt.frame_encode.exit;

84200998 <$M.celt.frame_encode.exit_not_enough_input_data>:
   
   exit_not_enough_input_data:
   // set NOT_ENOUGH_OUTPUT_SPACE flag and exit
   r0 = $codec.NOT_ENOUGH_INPUT_DATA;
84200998:	2f 00 20 e4 	r0 = Null + 1;

8420099c <$M.celt.frame_encode.exit>:
   
   exit:
   M[r9 + $codec.ENCODER_MODE_FIELD] = r0;
8420099c:	0c 00 2b d5 	M[r9 + 12] = r0;

   pop r5;
842009a0:	00 00 74 f3 	pop r5;
   // pop rLink from stack
   jump $pop_rLink_and_rts;
842009a4:	03 00 00 fd 	jump (m) 0x3b020;
842009a8:	21 b0 f0 dd 

842009ac <$_celt_imdct_radix2>:
842009ac:	01 20 00 f1 	pushm <FP(=SP), rLink>;
   // push rLink onto stack
   .CONST TEMP                 (0 + 2)*ADDR_PER_WORD;
   .CONST TMP_VAR              (7 + 2)*ADDR_PER_WORD;
   .CONST STACK_FRAME_SIZE     8*ADDR_PER_WORD;
   pushm <FP(=SP), rLink>;
   SP = SP + STACK_FRAME_SIZE;
842009b0:	20 00 03 f1 	SP = SP + 32;
   
   M[FP + TEMP + 0*MK1] = r5; 
842009b4:	08 00 7c f1 	M[FP + 0x8] = r5;
   M[FP + TEMP + 1*MK1] = r8; 
842009b8:	0c 00 ac f1 	M[FP + 0xc] = r8;
   M[FP + TEMP + 2*MK1] = r6; 
842009bc:	10 00 8c f1 	M[FP + 0x10] = r6;
   r0 = I0;
842009c0:	0f 00 20 44 	r0 = Null + I0;
#ifdef BASE_REGISTER_MODE
   push r0;
842009c4:	00 00 20 f3 	push r0;
   pop B0;
842009c8:	00 00 a6 f3 	pop B0;
   push Null;
842009cc:	00 00 00 f3 	push Null;
   pop B5;
842009d0:	00 00 d6 f3 	pop B5;
   L4 = 0;
842009d4:	00 00 e0 51 	L4 = Null + 0;
   L5 = 0;
842009d8:	00 00 f0 51 	L5 = Null + 0;
#endif 
   M[FP + TEMP + 3*MK1] = r0;
842009dc:	14 00 2c f1 	M[FP + 0x14] = r0;
   r0 = I5;
842009e0:	5f 00 20 44 	r0 = Null + I5;
   M[FP + TEMP + 4*MK1] = r0;
842009e4:	18 00 2c f1 	M[FP + 0x18] = r0;
   M[FP + TEMP + 5*MK1] = r4;
842009e8:	1c 00 6c f1 	M[FP + 0x1c] = r4;
   
   // get the trig from mode object
   I7 = r5 + $celt.dec.SCRATCHVAR_FFT_STRUCT;
842009ec:	98 01 77 51 	I7 = r5 + 408;
   r2 = r8 LSHIFT -1;
842009f0:	ff 00 4a 8d 	r2 = r8 LSHIFT -1;
   M[r5 + $celt.dec.SCRATCHVAR_FFT_STRUCT + $fft.NUM_POINTS_FIELD] = r2;
842009f4:	98 01 47 d5 	M[r5 + 408] = r2;
   r0 = I0;
842009f8:	0f 00 20 44 	r0 = Null + I0;
   M[r5 + $celt.dec.SCRATCHVAR_FFT_STRUCT + $fft.REAL_ADDR_FIELD] = r0;
842009fc:	9c 01 27 d5 	M[r5 + 412] = r0;
   r0 = I5;
84200a00:	5f 00 20 44 	r0 = Null + I5;
   M[r5 + $celt.dec.SCRATCHVAR_FFT_STRUCT + $fft.IMAG_ADDR_FIELD] = r0;
84200a04:	a0 01 27 d5 	M[r5 + 416] = r0;


   // get scale factor from mode object
   r0 = M[r5 + $celt.dec.MODE_TRIG_OFFSET_FIELD];
84200a08:	78 00 27 d1 	r0 = M[r5 + 120];
   r1 = &$celt.mode.TRIG_VECTOR_SIZE;
84200a0c:	0c 00 30 01 	r1 = Null + 12;
   NULL = M[r5 + $celt.dec.SHORT_BLOCKS_FIELD];
84200a10:	58 01 07 d1 	Null = M[r5 + 344];
   if Z r1 = 0;
84200a14:	00 00 30 00 	if EQ r1 = Null + Null;
   Words2Addr(r1);
84200a18:	02 00 33 91 	r1 = r1 ASHIFT 2;
   I2 = r0 + r1;
84200a1c:	3f 00 22 50 	I2 = r0 + r1;
   r0 = M[I2, MK1];
84200a20:	00 29 00 03 	Null = Null + Null, r0 = M[I2,4];
   M[FP + TEMP + 6*MK1] = r0;
84200a24:	20 00 2c f1 	M[FP + 0x20] = r0;
   r0 = M[I2, MK1];
84200a28:	00 29 00 03 	Null = Null + Null, r0 = M[I2,4];

   // set up the modify registers
   M0 = MK1;
84200a2c:	04 00 80 51 	M0 = Null + 4;
   M1 = MK2;
84200a30:	08 00 90 51 	M1 = Null + 8;
   M2 = -MK2;
84200a34:	f8 ff a0 51 	M2 = Null + -8;

   // need to copy the odd values into the output buffer
   r10 = r8 LSHIFT -1;
84200a38:	ff 00 ca 8d 	r10 = r8 LSHIFT -1;
   r10 = r10 - 1;
84200a3c:	3f 00 cc e4 	r10 = r10 - 1;

   // set a pointer to the start of the copy, and the target
   // and two buffers as output pointers for below
   I4 = I0;                         // input
84200a40:	0f 00 40 58 	I4 = I0 + Null;
   Words2Addr(r8);
84200a44:	02 00 aa 91 	r8 = r8 ASHIFT 2;
#ifdef BASE_REGISTER_MODE
   push B0;
84200a48:	00 00 a2 f3 	push B0;
   pop B4;
84200a4c:	00 00 c6 f3 	pop B4;
#endif 
   I0 = I0 + r8, r2 = M[I2,M0];                  // cfreq
84200a50:	00 48 0a 5a 	I0 = I0 + r8, r2 = M[I2,M0];
   I0 = I0 - M0, r3 = M[I2,M0];                  // sfreq
84200a54:	00 58 08 7e 	I0 = I0 - M0, r3 = M[I2,M0];
   r0 = M[r5 + $celt.dec.IMDCT_OUTPUT_FIELD];
84200a58:	d4 00 27 d1 	r0 = M[r5 + 212];
   I6 = r0;
84200a5c:	2f 00 60 50 	I6 = Null + r0;
   r4 = M[r5 + $celt.dec.TEMP_FFT_FIELD];
84200a60:	dc 00 67 d1 	r4 = M[r5 + 220];
   I5 = r4, r0 = M[I0,M2];
84200a64:	6f 22 50 50 	I5 = Null + r4, r0 = M[I0,M2];
   do pre_copy_loop;
84200a68:	02 00 f0 e5 	do $M.celt.imdct_radix2.pre_copy_loop;
      r0 = M[I0,M2],
       M[I5,M0] = r0;
84200a6c:	a4 22 00 02 	Null = Null + Null, r0 = M[I0,M2], M[I5,M0] = r0;

84200a70 <$M.celt.imdct_radix2.pre_copy_loop>:
   pre_copy_loop:
   M[I5,M0] = r0;
84200a70:	a4 00 00 02 	Null = Null + Null, M[I5,M0] = r0;

   // set up two registers to work through the input in opposite directions
   I0 = I4;                         // input
84200a74:	0f 00 04 58 	I0 = I4 + Null;
   I5 = r4, r4 = M[I2,M0];                  // c
84200a78:	6f 68 50 50 	I5 = Null + r4, r4 = M[I2,M0];

   // to make the additions easier below set c= -c & s= -s
   r4 = -r4, r1 = M[I2,M0];   // r4 = -c
84200a7c:	6f 38 60 20 	r4 = Null - r4, r1 = M[I2,M0];
   r7 = -r1, r0 = M[I0, M1];  // r7 = -s
84200a80:	3f 21 90 20 	r7 = Null - r1, r0 = M[I0,M1];
 
   // use M3 as a loop counter
   M3 = 3*MK1;
84200a84:	0c 00 b0 51 	M3 = Null + 12;
   M2 = 0;
84200a88:	00 00 a0 51 	M2 = Null + 0;

   // tmp used to store c
   r1 = FP + TMP_VAR;
84200a8c:	24 00 37 f1 	r1 = FP + 36;
   I1 = r1;
84200a90:	3f 00 10 50 	I1 = Null + r1;
   Addr2Words(r8);
84200a94:	fe 00 aa 91 	r8 = r8 ASHIFT -2;

84200a98 <$M.celt.imdct_radix2.outer_pre_process_loop>:
   outer_pre_process_loop:
      r10 = r8 LSHIFT -3;              // r10 = N/8
84200a98:	fd 00 ca 8d 	r10 = r8 LSHIFT -3;
      //I2 = I2 + 2;
      do pre_process_loop;
84200a9c:	0a 00 f0 e5 	do $M.celt.imdct_radix2.pre_process_loop;
      
         // process the data
         rMAC = r0 * r4, r1 = M[I5, M0];        // rMAC = (-tempr) * (-c)
84200aa0:	34 00 26 ce 	rMAC = r0 * r4 (SS), r1 = M[I5,M0];
         rMAC = rMAC + r1 * r7;                 // rMAC = temp*c + tempi*(-s)
84200aa4:	9f 00 13 ac 	rMAC = rMAC + r1 * r7 (SS);
         rMAC = r0 * r7, M[I4, M0] = rMAC;      // rMAC = (-tempr)*(-s)
84200aa8:	90 00 29 ce 	rMAC = r0 * r7 (SS), M[I4,M0] = rMAC;
         rMAC = rMAC - r1 * r4;                 // rMAC = tempr*s - tempi*(-c)
84200aac:	6f 00 13 bc 	rMAC = rMAC - r1 * r4 (SS);
         
         // update the multipliers: "c" and "s"
         rMAC = r4 * r2, M[I6, M0] = rMAC;      // (-c) * cfreq
84200ab0:	98 00 64 ce 	rMAC = r4 * r2 (SS), M[I6,M0] = rMAC;
         rMAC = rMAC - r7 * r3, r0 = M[I0, M1]; // (-c)'= (-c) * cfreq - (-s) * sfreq
84200ab4:	5f 21 19 bc 	rMAC = rMAC - r7 * r3 (SS), r0 = M[I0,M1];
         rMAC = r4 * r3, M[I1,M2] = rMAC;       // (-c_old) * sfreq
84200ab8:	5f 96 16 cc 	rMAC = r4 * r3 (SS), M[I1,M2] = rMAC;
         rMAC = rMAC + r7 * r2;                 // (-s)' = (-c_old)*sfreq + (-s)*cfreq
84200abc:	4f 00 19 ac 	rMAC = rMAC + r7 * r2 (SS);
         r7 = rMAC, r4 = M[I1,M2];              // r7 = (-s)'
84200ac0:	0f 66 91 00 	r7 = rMAC + Null, r4 = M[I1,M2];

84200ac4 <$M.celt.imdct_radix2.pre_process_loop>:
      pre_process_loop:

      // load the constant points mid way to improve accuracy
      r4 = M[I2,M0];
84200ac4:	00 68 00 02 	Null = Null + Null, r4 = M[I2,M0];
      r4 = -r4, r1 = M[I2,M0];
84200ac8:	6f 38 60 20 	r4 = Null - r4, r1 = M[I2,M0];
      r7 = -r1;
84200acc:	3f 00 90 20 	r7 = Null - r1;
      M3 = M3 - M0;
84200ad0:	00 00 b8 7f 	M3 = M3 - M0;
   if POS jump outer_pre_process_loop;
84200ad4:	f1 ff 50 dd 	if POS jump $M.celt.imdct_radix2.outer_pre_process_loop;
   
#ifdef BASE_REGISTER_MODE
   push NULL;
84200ad8:	00 00 00 f3 	push Null;
   pop B5;
84200adc:	00 00 d6 f3 	pop B5;
   push NULL;
84200ae0:	00 00 00 f3 	push Null;
   pop B4;
84200ae4:	00 00 c6 f3 	pop B4;
#endif 
   // set up data in fft_structure
   I7 = r5 + $celt.dec.SCRATCHVAR_FFT_STRUCT;
84200ae8:	98 01 77 51 	I7 = r5 + 408;

   // -- call the ifft --
   r8 = M[FP + TEMP + 6*MK1];
84200aec:	20 00 a8 f1 	r8 = M[FP + 0x20];
   call $math.scaleable_ifft;
84200af0:	07 00 00 fd 	call 0x74bf0;
84200af4:	f0 4b f0 e1 
   
   r5 = M[FP + TEMP + 0*MK1]; //pointer to objcet
84200af8:	08 00 78 f1 	r5 = M[FP + 0x8];
   r8 = M[FP + TEMP + 1*MK1]; //N
84200afc:	0c 00 a8 f1 	r8 = M[FP + 0xc];
   r6 = M[FP + TEMP + 2*MK1]; //c
84200b00:	10 00 88 f1 	r6 = M[FP + 0x10];
   
   // get the trig from mode object
   r0 = M[r5 + $celt.dec.MODE_TRIG_OFFSET_FIELD];
84200b04:	78 00 27 d1 	r0 = M[r5 + 120];
   r1 = $celt.mode.TRIG_VECTOR_SIZE;
84200b08:	0c 00 30 01 	r1 = Null + 12;
   NULL = M[r5 + $celt.dec.SHORT_BLOCKS_FIELD];
84200b0c:	58 01 07 d1 	Null = M[r5 + 344];
   if Z r1 = 0;
84200b10:	00 00 30 00 	if EQ r1 = Null + Null;
   Words2Addr(r1);
84200b14:	02 00 33 91 	r1 = r1 ASHIFT 2;
   I2 = r0 + r1;
84200b18:	3f 00 22 50 	I2 = r0 + r1;
   I2 = I2 + 2*ADDR_PER_WORD;
84200b1c:	08 00 22 59 	I2 = I2 + 8;

   // re-set up the number of points
   r1 = I7;
84200b20:	7f 00 30 44 	r1 = Null + I7;
   r10 = r8 LSHIFT -1;
84200b24:	ff 00 ca 8d 	r10 = r8 LSHIFT -1;
 
   // set up the shift registers
   M0 = MK1;
84200b28:	04 00 80 51 	M0 = Null + 4;
   M1 = MK2;
84200b2c:	08 00 90 51 	M1 = Null + 8;
   M2 = -MK2;
84200b30:	f8 ff a0 51 	M2 = Null + -8;

   // copy the data out of the temporary store after the IFFT
   r2 = M[FP + TEMP + 3*MK1];
84200b34:	14 00 48 f1 	r2 = M[FP + 0x14];
   I0 = r2;
84200b38:	4f 00 00 50 	I0 = Null + r2;
   Words2Addr(r10);
84200b3c:	02 00 cc 91 	r10 = r10 ASHIFT 2;
   I0 = I0 + r10;                      // I0 points to the second half
84200b40:	00 00 0c 5b 	I0 = I0 + r10;
   Addr2Words(r10);
84200b44:	fe 00 cc 91 	r10 = r10 ASHIFT -2;

   r2 = M[FP + TEMP + 4*MK1];
84200b48:	18 00 48 f1 	r2 = M[FP + 0x18];
   I4 = r2;
84200b4c:	4f 00 40 50 	I4 = Null + r2;
   I7 = r2;
84200b50:	4f 00 70 50 	I7 = Null + r2;

   r10 = r10 - 1;                    // r10 = N/2 - 1
84200b54:	3f 00 cc e4 	r10 = r10 - 1;
   r0 = M[I4, M0];                   // do one read and write outside the loop
84200b58:	20 00 00 02 	Null = Null + Null, r0 = M[I4,M0];
                  
   do copy_loop;
84200b5c:	02 00 f0 e5 	do $M.celt.imdct_radix2.copy_loop;
      r0 = M[I4, M0], M[I0, M0] = r0;
84200b60:	20 a0 00 02 	Null = Null + Null, M[I0,M0] = r0, r0 = M[I4,M0];

84200b64 <$M.celt.imdct_radix2.copy_loop>:




   // calculate some bit reverse constants
   r6 = SIGNDET r8, M[I0, M0] = r0; // perform the last memory write
84200b64:	0f a0 8a d8 	r6 = SIGNDET r8, M[I0,M0] = r0;
   r6 = r6 + 2 - LOG2_ADDR_PER_WORD;                     
84200b68:	00 00 88 01 	r6 = r6 + 0;
   r7 = 1;                          // r7 used as loop counter, set for below
84200b6c:	2f 00 90 e4 	r7 = Null + 1;
   r6 = r7 LSHIFT r6;
84200b70:	8f 00 89 8c 	r6 = r7 LSHIFT r6;
   M3 = r6;                         // bit reverse shift register
84200b74:	8f 00 b0 50 	M3 = Null + r6;
   r6 = r6 LSHIFT -1;               // shift operator for I1 initialisation
84200b78:	ff 00 88 8d 	r6 = r6 LSHIFT -1;

   r0 = M[FP + TEMP + 3*MK1];
84200b7c:	14 00 28 f1 	r0 = M[FP + 0x14];

#ifdef BASE_REGISTER_MODE
   push r0;
84200b80:	00 00 20 f3 	push r0;
   pop B0;
84200b84:	00 00 a6 f3 	pop B0;
#endif 

   call $math.address_bitreverse;
84200b88:	07 00 00 fd 	call 0x748ec;
84200b8c:	ec 48 f0 e1 
   I0 = r1;
84200b90:	3f 00 00 50 	I0 = Null + r1;
  
#ifdef BASE_REGISTER_MODE   
    r0 = M[FP + TEMP + 3*MK1]; 
84200b94:	14 00 28 f1 	r0 = M[FP + 0x14];
    r2 = r8 LSHIFT -1;
84200b98:	ff 00 4a 8d 	r2 = r8 LSHIFT -1;
    Words2Addr(r2);
84200b9c:	02 00 44 91 	r2 = r2 ASHIFT 2;
    r0 = r0 + r2;
84200ba0:	00 00 24 03 	r0 = r0 + r2;
    push r0 ;
84200ba4:	00 00 20 f3 	push r0;
    pop B1;
84200ba8:	00 00 b6 f3 	pop B1;
    call $math.address_bitreverse;
84200bac:	07 00 00 fd 	call 0x748ec;
84200bb0:	ec 48 f0 e1 
    I1 = r1;
84200bb4:	3f 00 10 50 	I1 = Null + r1;
#else 
    I1 = I0 + r6;
#endif 
   r2 = M[I2, M0];                     // imaginary ifft component
84200bb8:	00 48 00 02 	Null = Null + Null, r2 = M[I2,M0];
   I2 = r1, r2 = M[I2, M0];*/
  
                                                   // cfreq
   //r10 = r8 LSHIFT -1;                               // r10 = N/2
   // set up pointers to output buffers
   r3 = M[I2, M0];                                   // sfreq
84200bbc:	00 58 00 02 	Null = Null + Null, r3 = M[I2,M0];
   I6 = I7 - M0, r4 = M[I2, M0];                     // c
84200bc0:	8f 68 67 7c 	I6 = I7 - M0, r4 = M[I2,M0];
   Words2Addr(r8);
84200bc4:	02 00 aa 91 	r8 = r8 ASHIFT 2;
   I6 = I6 + r8, r5 = M[I2, M0];  
84200bc8:	00 78 6a 5a 	I6 = I6 + r8, r5 = M[I2,M0];
   Addr2Words(r8);                   // s
84200bcc:	fe 00 aa 91 	r8 = r8 ASHIFT -2;

   // store the constant locations in r6
   r6 = I2;
84200bd0:	2f 00 80 44 	r6 = Null + I2;

   // data is returned bit reversed, so enable bit reverse addressing on AG1
   rFlags = rFlags OR $BR_FLAG;
84200bd4:	40 00 ee 85 	rFlags = rFlags OR 0x40;

   // load bit reversed tmp c location
   r0 = FP + TMP_VAR;
84200bd8:	24 00 27 f1 	r0 = FP + 36;
   call $math.address_bitreverse;
84200bdc:	07 00 00 fd 	call 0x748ec;
84200be0:	ec 48 f0 e1 
   I2 = r1;
84200be4:	3f 00 20 50 	I2 = Null + r1;
   //call save_I0;
   M0 = 0, r0 = M[I0, M3];                 // tempr
84200be8:	0f 23 80 50 	M0 = Null + Null, r0 = M[I0,M3];

84200bec <$M.celt.imdct_radix2.post_process_loop1>:

   // use r7 as outer loop counter, set above
   post_process_loop1:

      r10 = r8 LSHIFT -3;             // r10 = N/8
84200bec:	fd 00 ca 8d 	r10 = r8 LSHIFT -3;
      do inner_post_process_loop1;
84200bf0:	0a 00 f0 e5 	do $M.celt.imdct_radix2.inner_post_process_loop1;
         //call save_I1;
         rMAC = r0 * r4, r1 = M[I1, M3];                 // rMAC = tempr * c
84200bf4:	6f 37 12 cc 	rMAC = r0 * r4 (SS), r1 = M[I1,M3];
                                                         // tempi
         rMAC = rMAC - r1 * r5;                          // rMAC = tempr*c - tempi*s
84200bf8:	7f 00 13 bc 	rMAC = rMAC - r1 * r5 (SS);
         rMAC = r1 * r4, M[I6, M2] = rMAC;               // rMAC = tempi * c
84200bfc:	9a 00 36 ce 	rMAC = r1 * r4 (SS), M[I6,M2] = rMAC;
                                                         // I6 = tr
         rMAC = rMAC + r0 * r5;                          // rMAC = tempi*c + tempr*s
84200c00:	7f 00 12 ac 	rMAC = rMAC + r0 * r5 (SS);
         
         // update the multipliers: "c" and "s"
         rMAC = r4 * r2, M[I7, M1] = rMAC;               // c * cfreq
84200c04:	9d 00 64 ce 	rMAC = r4 * r2 (SS), M[I7,M1] = rMAC;
        // call save_I0;
         rMAC = rMAC - r5 * r3, r0 = M[I0, M3];          // c' = c * cfreq - s * sfreq
84200c08:	5f 23 17 bc 	rMAC = rMAC - r5 * r3 (SS), r0 = M[I0,M3];
         rMAC = r4 * r3, M[I2,M0] = rMAC;                // c_old * sfreq
84200c0c:	5f 98 16 cc 	rMAC = r4 * r3 (SS), M[I2,M0] = rMAC;
         rMAC = rMAC + r5 * r2;                          // s' = c_old*sfreq + s*cfreq
84200c10:	4f 00 17 ac 	rMAC = rMAC + r5 * r2 (SS);
         r5 = rMAC, r4 = M[I2,M0];                       // r5 = s'
84200c14:	0f 68 71 00 	r5 = rMAC + Null, r4 = M[I2,M0];

84200c18 <$M.celt.imdct_radix2.inner_post_process_loop1>:
      inner_post_process_loop1:

      // load more accurate data for c and s
      r4 = M[r6];
84200c18:	0f 00 68 d0 	r4 = M[r6 + Null];
      r5 = M[r6 + MK1];
84200c1c:	04 00 78 d1 	r5 = M[r6 + 4];
      r6 = r6 + 2*ADDR_PER_WORD;
84200c20:	08 00 88 01 	r6 = r6 + 8;
      r7 = r7 - 1;
84200c24:	3f 00 99 e4 	r7 = r7 - 1;
   if POS jump post_process_loop1;
84200c28:	f1 ff 50 dd 	if POS jump $M.celt.imdct_radix2.post_process_loop1;
   // second loop i.e. inner_post_process_loop2_2 address bitreversal 
   // causes a memory access problem in the last iteration. This is a read
   // operation that is not going to be used therefore the loop counter on 
   // the second loop has been reduced by one to avoid this issue and last 
   // iteration is run separattely without the read operation.
   r10 = r8 LSHIFT -3;              // r10 = N/8
84200c2c:	fd 00 ca 8d 	r10 = r8 LSHIFT -3;
   do inner_post_process_loop2_1;
84200c30:	0a 00 f0 e5 	do $M.celt.imdct_radix2.inner_post_process_loop2_1;
     // call save_I1;
      rMAC = r0 * r5, r1 = M[I1, M3];                  // rMAC = tempr*s
84200c34:	7f 37 12 cc 	rMAC = r0 * r5 (SS), r1 = M[I1,M3];
                                                       // tempi
      rMAC = rMAC + r1 * r4;                           // rMAC = tempr*s + tempi * c
84200c38:	6f 00 13 ac 	rMAC = rMAC + r1 * r4 (SS);
      rMAC = r0 * r4,M[I7, M1] = rMAC;                 // rMAC = tempr * c
84200c3c:	9d 00 26 ce 	rMAC = r0 * r4 (SS), M[I7,M1] = rMAC;
      rMAC = rMAC - r1 * r5;                           // rMAC = tempr*c - tempi*s
84200c40:	7f 00 13 bc 	rMAC = rMAC - r1 * r5 (SS);
      
      // Update the multipliers: "c" and "s"
      rMAC = r4 * r2, M[I6, M2] = rMAC;                // c * cfreq
84200c44:	9a 00 64 ce 	rMAC = r4 * r2 (SS), M[I6,M2] = rMAC;
      //call save_I0;
      rMAC = rMAC - r5 * r3, r0 = M[I0, M3];           // c' = c * cfreq - s * sfreq
84200c48:	5f 23 17 bc 	rMAC = rMAC - r5 * r3 (SS), r0 = M[I0,M3];
            
      rMAC = r4 * r3, M[I2,M0] = rMAC;                 // c_old * sfreq
84200c4c:	5f 98 16 cc 	rMAC = r4 * r3 (SS), M[I2,M0] = rMAC;
      rMAC = rMAC + r5 * r2;                           // s' = c_old*sfreq + s*cfreq
84200c50:	4f 00 17 ac 	rMAC = rMAC + r5 * r2 (SS);
      r5 = rMAC, r4 = M[I2,M0];                        // r5 = s'          
84200c54:	0f 68 71 00 	r5 = rMAC + Null, r4 = M[I2,M0];

84200c58 <$M.celt.imdct_radix2.inner_post_process_loop2_1>:
   inner_post_process_loop2_1:
   // load more accurate data for c and s
   r4 = M[r6];
84200c58:	0f 00 68 d0 	r4 = M[r6 + Null];
   r5 = M[r6 + MK1];
84200c5c:	04 00 78 d1 	r5 = M[r6 + 4];
   r6 = r6 + 2*ADDR_PER_WORD;    //4;
84200c60:	08 00 88 01 	r6 = r6 + 8;
   
   // Initialise the second loop
   r10 = r8 LSHIFT -3;           // r10 = N/8 
84200c64:	fd 00 ca 8d 	r10 = r8 LSHIFT -3;
   r10 = r10 -1;  // Explanation on top of inner_post_process_loop2_1 loop above
84200c68:	3f 00 cc e4 	r10 = r10 - 1;
   do inner_post_process_loop2_2;
84200c6c:	0a 00 f0 e5 	do $M.celt.imdct_radix2.inner_post_process_loop2_2;
     // call save_I1;
      rMAC = r0 * r5, r1 = M[I1, M3];                  // rMAC = tempr*s
84200c70:	7f 37 12 cc 	rMAC = r0 * r5 (SS), r1 = M[I1,M3];
                                                       // tempi
      rMAC = rMAC + r1 * r4;                           // rMAC = tempr*s + tempi * c
84200c74:	6f 00 13 ac 	rMAC = rMAC + r1 * r4 (SS);
      rMAC = r0 * r4,M[I7, M1] = rMAC;                 // rMAC = tempr * c
84200c78:	9d 00 26 ce 	rMAC = r0 * r4 (SS), M[I7,M1] = rMAC;
      rMAC = rMAC - r1 * r5;                           // rMAC = tempr*c - tempi*s
84200c7c:	7f 00 13 bc 	rMAC = rMAC - r1 * r5 (SS);
      
      // Update the multipliers: "c" and "s"
      rMAC = r4 * r2, M[I6, M2] = rMAC;                // c * cfreq
84200c80:	9a 00 64 ce 	rMAC = r4 * r2 (SS), M[I6,M2] = rMAC;
      //call save_I0;
      rMAC = rMAC - r5 * r3, r0 = M[I0, M3];           // c' = c * cfreq - s * sfreq
84200c84:	5f 23 17 bc 	rMAC = rMAC - r5 * r3 (SS), r0 = M[I0,M3];
            
      rMAC = r4 * r3, M[I2,M0] = rMAC;                 // c_old * sfreq
84200c88:	5f 98 16 cc 	rMAC = r4 * r3 (SS), M[I2,M0] = rMAC;
      rMAC = rMAC + r5 * r2;                           // s' = c_old*sfreq + s*cfreq
84200c8c:	4f 00 17 ac 	rMAC = rMAC + r5 * r2 (SS);
      r5 = rMAC, r4 = M[I2,M0];                        // r5 = s'          
84200c90:	0f 68 71 00 	r5 = rMAC + Null, r4 = M[I2,M0];

84200c94 <$M.celt.imdct_radix2.inner_post_process_loop2_2>:
   inner_post_process_loop2_2:

   // Run the additional itteration without bit reverse access.
   // Also the last two statements of loop are redundant so are omitted.
      rMAC = r0 * r5, r1 = M[I1, M3];                  // rMAC = tempr*s
84200c94:	7f 37 12 cc 	rMAC = r0 * r5 (SS), r1 = M[I1,M3];
                                                       // tempi
      rMAC = rMAC + r1 * r4;                           // rMAC = tempr*s + tempi * c
84200c98:	6f 00 13 ac 	rMAC = rMAC + r1 * r4 (SS);
      rMAC = r0 * r4,M[I7, M1] = rMAC;                 // rMAC = tempr * c
84200c9c:	9d 00 26 ce 	rMAC = r0 * r4 (SS), M[I7,M1] = rMAC;
      rMAC = rMAC - r1 * r5;                           // rMAC = tempr*c - tempi*s
84200ca0:	7f 00 13 bc 	rMAC = rMAC - r1 * r5 (SS);
      
      // Update the multipliers: "c" and "s"
      rMAC = r4 * r2, M[I6, M2] = rMAC;                // c * cfreq
84200ca4:	9a 00 64 ce 	rMAC = r4 * r2 (SS), M[I6,M2] = rMAC;
      //call save_I0;
      rMAC = rMAC - r5 * r3;                           // c' = c * cfreq - s * sfreq
84200ca8:	5f 00 17 bc 	rMAC = rMAC - r5 * r3 (SS);
            
      rMAC = r4 * r3, M[I2,M0] = rMAC;                 // c_old * sfreq
84200cac:	5f 98 16 cc 	rMAC = r4 * r3 (SS), M[I2,M0] = rMAC;



   // disable bit reversed addressing on AG1
   rFlags = rFlags AND $NOT_BR_FLAG;
84200cb0:	bf ff ee 81 	rFlags = rFlags AND 0xffbf;

   L4 = 0;
84200cb4:	00 00 e0 51 	L4 = Null + 0;
   L5 = 0;
84200cb8:	00 00 f0 51 	L5 = Null + 0;
#ifdef BASE_REGISTER_MODE
   push Null;
84200cbc:	00 00 00 f3 	push Null;
   pop B0;
84200cc0:	00 00 a6 f3 	pop B0;
   push Null;
84200cc4:	00 00 00 f3 	push Null;
   pop B1;
84200cc8:	00 00 b6 f3 	pop B1;
   push Null;
84200ccc:	00 00 00 f3 	push Null;
   pop B4;
84200cd0:	00 00 c6 f3 	pop B4;
   push Null;
84200cd4:	00 00 00 f3 	push Null;
   pop B5;
84200cd8:	00 00 d6 f3 	pop B5;
#endif
   // -- see if shift is required
   r4 = M[FP + TEMP + 5*MK1];
84200cdc:	1c 00 68 f1 	r4 = M[FP + 0x1c];
   if Z jump end;
84200ce0:	14 00 00 dd 	if EQ jump $M.celt.imdct_radix2.end;

   r7 = 0.5;
84200ce4:	00 40 00 fd 	r7 = Null + 1073741824;
84200ce8:	00 00 90 01 

   r8 = (2-DAWTH) - r4;
84200cec:	e2 ff a6 65 	r8 = -30 - r4;
   r8 = r7 LSHIFT r8;
84200cf0:	af 00 a9 8c 	r8 = r7 LSHIFT r8;
   
   // -- get output address
   r0 = M[FP + TEMP + 4*MK1];
84200cf4:	18 00 28 f1 	r0 = M[FP + 0x18];
   I2 = r0;
84200cf8:	2f 00 20 50 	I2 = Null + r0;
   
   // -- get output length
   r10 = M[FP + TEMP + MK1];   
84200cfc:	0c 00 c8 f1 	r10 = M[FP + 0xc];
   M0 = -MK1;   
84200d00:	fc ff 80 51 	M0 = Null + -4;
   M1 = MK2;
84200d04:	08 00 90 51 	M1 = Null + 8;
   r10 = r10 - 1;
84200d08:	3f 00 cc e4 	r10 = r10 - 1;
   r0 = 1.0;
84200d0c:	ff 7f 00 fd 	r0 = Null + 2147483647;
84200d10:	ff ff 20 01 
   
   // -- shift and round
   rMAC = M[I2, MK1];          
84200d14:	00 19 00 03 	Null = Null + Null, rMAC = M[I2,4];
   rMAC = rMAC + r8 * r7;
84200d18:	9f 00 1a ac 	rMAC = rMAC + r8 * r7 (SS);
   do shift_round_loop;
84200d1c:	03 00 f0 e5 	do $M.celt.imdct_radix2.shift_round_loop;
      r1 = rMAC ASHIFT r4, rMAC = M[I2, M0];   
84200d20:	6f 18 31 90 	r1 = rMAC ASHIFT r4, rMAC = M[I2,M0];
      rMAC = rMAC + r8 * r7, M[I2, M1] = r1;    
84200d24:	9f b9 1a ac 	rMAC = rMAC + r8 * r7 (SS), M[I2,M1] = r1;

84200d28 <$M.celt.imdct_radix2.shift_round_loop>:
   shift_round_loop:
   r1 = rMAC ASHIFT r4, rMAC = M[I2, M0];
84200d28:	6f 18 31 90 	r1 = rMAC ASHIFT r4, rMAC = M[I2,M0];
   M[I2, M1] = r1;
84200d2c:	00 b9 00 02 	Null = Null + Null, M[I2,M1] = r1;

84200d30 <$M.celt.imdct_radix2.end>:
   end:
   
   r5 = M[FP + TEMP + 0*MK1]; //pointer to objcet
84200d30:	08 00 78 f1 	r5 = M[FP + 0x8];
  
   // pop rLink from stack
   SP = SP - STACK_FRAME_SIZE;
84200d34:	e0 ff 03 f1 	SP = SP + -32;
   popm <FP,rLink>;
84200d38:	01 20 04 f1 	popm <FP, rLink>;
   rts;
84200d3c:	0f 00 0d dc 	rts;

84200d40 <$celt.imdct_window_overlap_add>:
84200d40:	01 20 00 f1 	pushm <FP(=SP), rLink>;
   .CONST OBUF_LEN             (3 + 2)*ADDR_PER_WORD;
   .CONST OBUF_START           (4 + 2)*ADDR_PER_WORD;
   .CONST OLA_ADDR             (5 + 2)*ADDR_PER_WORD;
   .CONST STACK_FRAME_SIZE     6*ADDR_PER_WORD;
   pushm <FP(=SP), rLink>;
   SP = SP + STACK_FRAME_SIZE;
84200d44:	18 00 03 f1 	SP = SP + 24;


   // different processing for short blocks
   Null = M[r5 + $celt.dec.SHORT_BLOCKS_FIELD];
84200d48:	58 01 07 d1 	Null = M[r5 + 344];
   if NZ jump short_block_proc;
84200d4c:	31 00 10 dd 	if NE jump $M.celt.imdct_window_overlap_add.short_block_proc;

84200d50 <$M.celt.imdct_window_overlap_add.long_block_proc>:
   long_block_proc:
   
      // IMDCT transform
      r0 = M[r5 + $celt.dec.FREQ_FIELD];
84200d50:	14 01 27 d1 	r0 = M[r5 + 276];
      I0 = r0;                                       // frequency spectrum
84200d54:	2f 00 00 50 	I0 = Null + r0;
      r0 = M[r5 + $celt.dec.IMDCT_OUTPUT_FIELD];
84200d58:	d4 00 27 d1 	r0 = M[r5 + 212];
      I5 = r0;                                       // imdct output
84200d5c:	2f 00 50 50 	I5 = Null + r0;
      r8 = M[r5 + $celt.dec.MODE_MDCT_SIZE_FIELD];       
84200d60:	44 00 a7 d1 	r8 = M[r5 + 68];
      r6 = 0;                                        // left channel
84200d64:	00 00 80 01 	r6 = Null + 0;
      r0 = M[r5 + $celt.dec.IMDCT_FUNCTION_FIELD];   // obtain imdct function
84200d68:	0c 00 27 d1 	r0 = M[r5 + 12];
      r4 = M[r5 + $celt.dec.SCRATCHVAR_MAX_SBAND + 0];
84200d6c:	f0 01 67 d1 	r4 = M[r5 + 496];
      call r0;
84200d70:	0f 00 02 e0 	call r0;
  
      // -- Apply window+overlap-add
      r0 = M[r5 + $celt.dec.IMDCT_OUTPUT_FIELD];
84200d74:	d4 00 27 d1 	r0 = M[r5 + 212];
      I0 = r0;                                // input
84200d78:	2f 00 00 50 	I0 = Null + r0;
      r0 = M[r5 + $celt.dec.HIST_OLA_LEFT_FIELD];
84200d7c:	94 00 27 d1 	r0 = M[r5 + 148];
      M3 = r0;              // history
84200d80:	2f 00 b0 50 	M3 = Null + r0;
#ifdef BASE_REGISTER_MODE
      r0 = M[r5 + $celt.dec.SCRATCHVAR_LEFT_OBUF_START_ADDR];
84200d84:	84 01 27 d1 	r0 = M[r5 + 388];
      push r0; 
84200d88:	00 00 20 f3 	push r0;
      pop B5; 
84200d8c:	00 00 d6 f3 	pop B5;
#endif
      r0 = M[r5 + $celt.dec.SCRATCHVAR_LEFT_OBUF_ADDR];
84200d90:	7c 01 27 d1 	r0 = M[r5 + 380];
      r1 = M[r5 + $celt.dec.SCRATCHVAR_LEFT_OBUF_LEN];
84200d94:	80 01 37 d1 	r1 = M[r5 + 384];
      I5 = r0;                                                    // output buffer
84200d98:	2f 00 50 50 	I5 = Null + r0;
      L5 = r1;
84200d9c:	3f 00 f0 50 	L5 = Null + r1;

      r8 = M[r5 + $celt.dec.CELT_MODE_OBJECT_FIELD];
84200da0:	00 00 a7 d1 	r8 = M[r5 + 0];
      r3 = M[r5 + $celt.dec.MODE_MDCT_SIZE_FIELD];                // audio frame size
84200da4:	44 00 57 d1 	r3 = M[r5 + 68];
      call $celt.windowing_overlapadd;
84200da8:	88 00 f0 e1 	call $celt.windowing_overlapadd;

      // right channel is available?
      Null = M[r5 + $celt.dec.CELT_CHANNELS_FIELD];
84200dac:	08 00 07 d1 	Null = M[r5 + 8];
      if Z jump end_long_proc;
84200db0:	17 00 00 dd 	if EQ jump $M.celt.imdct_window_overlap_add.end_long_proc;
         // IMDCT transform
         r0 = M[r5 + $celt.dec.FREQ2_FIELD];
84200db4:	18 01 27 d1 	r0 = M[r5 + 280];
         I0 = r0;
84200db8:	2f 00 00 50 	I0 = Null + r0;
         // frequency spectrum
         r0 = M[r5 + $celt.dec.IMDCT_OUTPUT_FIELD];
84200dbc:	d4 00 27 d1 	r0 = M[r5 + 212];
         I5 = r0;                          // imdct output
84200dc0:	2f 00 50 50 	I5 = Null + r0;
         r8 = M[r5 + $celt.dec.MODE_MDCT_SIZE_FIELD];          // audio frame size
84200dc4:	44 00 a7 d1 	r8 = M[r5 + 68];
         r6 = 1;                                               // right channel
84200dc8:	2f 00 80 e4 	r6 = Null + 1;
         r0 = M[r5 + $celt.dec.IMDCT_FUNCTION_FIELD];          // obtain imdct function
84200dcc:	0c 00 27 d1 	r0 = M[r5 + 12];
         r4 = M[r5 + $celt.dec.SCRATCHVAR_MAX_SBAND + 1*MK1];
84200dd0:	f4 01 67 d1 	r4 = M[r5 + 500];
         call r0;
84200dd4:	0f 00 02 e0 	call r0;
         
         // -- Apply window+overlap-add
         r0 = M[r5 + $celt.dec.IMDCT_OUTPUT_FIELD];
84200dd8:	d4 00 27 d1 	r0 = M[r5 + 212];
         I0 = r0;                               // input
84200ddc:	2f 00 00 50 	I0 = Null + r0;
         r0 = M[r5 + $celt.dec.HIST_OLA_RIGHT_FIELD];
84200de0:	98 00 27 d1 	r0 = M[r5 + 152];
         M3 = r0;                // history
84200de4:	2f 00 b0 50 	M3 = Null + r0;
#ifdef BASE_REGISTER_MODE
         r0 = M[r5 + $celt.dec.SCRATCHVAR_RIGHT_OBUF_START_ADDR];
84200de8:	90 01 27 d1 	r0 = M[r5 + 400];
         push r0; 
84200dec:	00 00 20 f3 	push r0;
         pop B5; 
84200df0:	00 00 d6 f3 	pop B5;
#endif
         r0 = M[r5 + $celt.dec.SCRATCHVAR_RIGHT_OBUF_ADDR];
84200df4:	88 01 27 d1 	r0 = M[r5 + 392];
         r1 = M[r5 + $celt.dec.SCRATCHVAR_RIGHT_OBUF_LEN];
84200df8:	8c 01 37 d1 	r1 = M[r5 + 396];
         I5 = r0;                                                  // output buffer
84200dfc:	2f 00 50 50 	I5 = Null + r0;
         L5 = r1;
84200e00:	3f 00 f0 50 	L5 = Null + r1;
         r3 = M[r5 + $celt.dec.MODE_MDCT_SIZE_FIELD];              // audio frame size
84200e04:	44 00 57 d1 	r3 = M[r5 + 68];
         call $celt.windowing_overlapadd;
84200e08:	70 00 f0 e1 	call $celt.windowing_overlapadd;

84200e0c <$M.celt.imdct_window_overlap_add.end_long_proc>:
      end_long_proc:
      jump end;
84200e0c:	6c 00 f0 dd 	jump $M.celt.imdct_window_overlap_add.end;

84200e10 <$M.celt.imdct_window_overlap_add.short_block_proc>:
   short_block_proc:
      // -- Short Blocks processing
      M[FP + CH_NO] = Null;
84200e10:	0c 00 0c f1 	M[FP + 0xc] = Null;
      
#ifdef BASE_REGISTER_MODE
      r0 = M[r5 + $celt.dec.SCRATCHVAR_LEFT_OBUF_START_ADDR];
84200e14:	84 01 27 d1 	r0 = M[r5 + 388];
      M[FP + OBUF_START] = r0; 
84200e18:	18 00 2c f1 	M[FP + 0x18] = r0;
#endif
      r0 = M[r5 + $celt.dec.SCRATCHVAR_LEFT_OBUF_ADDR];
84200e1c:	7c 01 27 d1 	r0 = M[r5 + 380];
      r1 = M[r5 + $celt.dec.SCRATCHVAR_LEFT_OBUF_LEN];
84200e20:	80 01 37 d1 	r1 = M[r5 + 384];
      M[FP + OBUF_ADDR] = r0;
84200e24:	10 00 2c f1 	M[FP + 0x10] = r0;
      M[FP + OBUF_LEN] = r1;
84200e28:	14 00 3c f1 	M[FP + 0x14] = r1;
      r0 = M[r5 + $celt.dec.HIST_OLA_LEFT_FIELD];
84200e2c:	94 00 27 d1 	r0 = M[r5 + 148];
      M[FP + OLA_ADDR] = r0;
84200e30:	1c 00 2c f1 	M[FP + 0x1c] = r0;

84200e34 <$M.celt.imdct_window_overlap_add.chan_loop>:
      chan_loop:
         // silence hist, first block overlap add is performed after windowing
         r0 =  0;
84200e34:	00 00 20 01 	r0 = Null + 0;
         r1 = M[r5 + $celt.dec.SHORT_HIST_FIELD];
84200e38:	d8 00 37 d1 	r1 = M[r5 + 216];
         I0 = r1;//&$celt.dec.short_hist;
84200e3c:	3f 00 00 50 	I0 = Null + r1;
         r8 = M[r5 + $celt.dec.CELT_MODE_OBJECT_FIELD];
84200e40:	00 00 a7 d1 	r8 = M[r5 + 0];
         r10 = M[r5 +$celt.dec.MODE_OVERLAP_FIELD];
84200e44:	40 00 c7 d1 	r10 = M[r5 + 64];
         do silent_hist_loop;
84200e48:	02 00 f0 e5 	do $M.celt.imdct_window_overlap_add.silent_hist_loop;
            M[I0, MK1] = r0;
84200e4c:	00 a1 00 03 	Null = Null + Null, M[I0,4] = r0;

84200e50 <$M.celt.imdct_window_overlap_add.silent_hist_loop>:
         silent_hist_loop:
         M[FP + TEMP_LP] = r0; //block counter
84200e50:	08 00 2c f1 	M[FP + 0x8] = r0;

84200e54 <$M.celt.imdct_window_overlap_add.short_mdct_loop>:
         short_mdct_loop:
            //get short freq inputs
            r1 = M[r5 + $celt.dec.SHORT_FREQ_FIELD];
84200e54:	1c 01 37 d1 	r1 = M[r5 + 284];
            I0 = r1;
84200e58:	3f 00 00 50 	I0 = Null + r1;
            r4 = M[r5 +$celt.dec.MODE_NB_SHORT_MDCTS_FIELD];
84200e5c:	58 00 67 d1 	r4 = M[r5 + 88];
            Words2Addr(r4);
84200e60:	02 00 66 91 	r4 = r4 ASHIFT 2;
            M0 = r4;
84200e64:	6f 00 80 50 	M0 = Null + r4;
            M1 = MK1;
84200e68:	04 00 90 51 	M1 = Null + 4;
            r1 = M[r5 + $celt.dec.FREQ_FIELD];
84200e6c:	14 01 37 d1 	r1 = M[r5 + 276];
            r8 = M[r5 + $celt.dec.FREQ2_FIELD];
84200e70:	18 01 a7 d1 	r8 = M[r5 + 280];
            Null = M[FP + CH_NO];
84200e74:	0c 00 08 f1 	Null = M[FP + 0xc];
            if NZ r1 = r8;
84200e78:	01 00 3a 00 	if NE r1 = r8 + Null;
            Words2Addr(r0);
84200e7c:	02 00 22 91 	r0 = r0 ASHIFT 2;
            I4 = r1 + r0;
84200e80:	2f 00 43 50 	I4 = r1 + r0;
            r4 = M[r5 + $celt.dec.MODE_SHORT_MDCT_SIZE_FIELD];
84200e84:	5c 00 67 d1 	r4 = M[r5 + 92];
            r10 = r4 - 1;
84200e88:	3f 00 c6 e4 	r10 = r4 - 1;
            r1 = M[I4, M0];
84200e8c:	30 00 00 02 	Null = Null + Null, r1 = M[I4,M0];
            do copy_short_freq;
84200e90:	02 00 f0 e5 	do $M.celt.imdct_window_overlap_add.copy_short_freq;
               M[I0, M1] = r1, r1 = M[I4, M0];
84200e94:	30 b1 00 02 	Null = Null + Null, M[I0,M1] = r1, r1 = M[I4,M0];

84200e98 <$M.celt.imdct_window_overlap_add.copy_short_freq>:
            copy_short_freq:
            M[I0, MK1] = r1;
84200e98:	00 b1 00 03 	Null = Null + Null, M[I0,4] = r1;
            
            // -- IMDCT transform
            r1 = M[r5 + $celt.dec.SHORT_FREQ_FIELD];
84200e9c:	1c 01 37 d1 	r1 = M[r5 + 284];
            I0 = r1;                                           //input
84200ea0:	3f 00 00 50 	I0 = Null + r1;
            r1 = M[r5 + $celt.dec.IMDCT_OUTPUT_FIELD];
84200ea4:	d4 00 37 d1 	r1 = M[r5 + 212];
            I5 = r1;                                           //output
84200ea8:	3f 00 50 50 	I5 = Null + r1;
            r8 = r4;                                           //short block size
84200eac:	0f 00 a6 00 	r8 = r4 + Null;
            r6 = 0;                                            //left channel
84200eb0:	00 00 80 01 	r6 = Null + 0;
            r1 = M[FP + CH_NO];
84200eb4:	0c 00 38 f1 	r1 = M[FP + 0xc];
            r0 = M[r5 + $celt.dec.IMDCT_SHORT_FUNCTION_FIELD]; //IMDCT function
84200eb8:	10 00 27 d1 	r0 = M[r5 + 16];
            Words2Addr(r1);
84200ebc:	02 00 33 91 	r1 = r1 ASHIFT 2;
            r4 = r5 + r1;
84200ec0:	3f 00 67 00 	r4 = r5 + r1;
            r4 = M[r4 + $celt.dec.SCRATCHVAR_MAX_SBAND];
84200ec4:	f0 01 66 d1 	r4 = M[r4 + 496];
            call r0;
84200ec8:	0f 00 02 e0 	call r0;
           
            // window + overlap-add
#ifdef BASE_REGISTER_MODE
            r0 = M[FP + OBUF_START]; 
84200ecc:	18 00 28 f1 	r0 = M[FP + 0x18];
            push r0;
84200ed0:	00 00 20 f3 	push r0;
            pop B5;
84200ed4:	00 00 d6 f3 	pop B5;
#endif
            r0 = M[FP + OBUF_ADDR];
84200ed8:	10 00 28 f1 	r0 = M[FP + 0x10];
            r1 = M[FP + OBUF_LEN];
84200edc:	14 00 38 f1 	r1 = M[FP + 0x14];
            I5 = r0;
84200ee0:	2f 00 50 50 	I5 = Null + r0;
            L5 = r1;
84200ee4:	3f 00 f0 50 	L5 = Null + r1;

            r3 = M[r5 + $celt.dec.MODE_SHORT_MDCT_SIZE_FIELD];
84200ee8:	5c 00 57 d1 	r3 = M[r5 + 92];
            r0 =  M[FP + TEMP_LP];
84200eec:	08 00 28 f1 	r0 = M[FP + 0x8];
            r0 = r0 * r3(int);
84200ef0:	00 00 25 9b 	r0 = r0 * r3 (int);
            Words2Addr(r0);
84200ef4:	02 00 22 91 	r0 = r0 ASHIFT 2;
            M0 = r0;
84200ef8:	2f 00 80 50 	M0 = Null + r0;
            r0 = M[I5, M0];
84200efc:	24 00 00 02 	Null = Null + Null, r0 = M[I5,M0];
            r0 = M[r5 + $celt.dec.IMDCT_OUTPUT_FIELD];
84200f00:	d4 00 27 d1 	r0 = M[r5 + 212];
            I0 = r0;
84200f04:	2f 00 00 50 	I0 = Null + r0;
            r0 = M[r5 + $celt.dec.SHORT_HIST_FIELD];
84200f08:	d8 00 27 d1 	r0 = M[r5 + 216];
            M3 = r0;
84200f0c:	2f 00 b0 50 	M3 = Null + r0;
            call $celt.windowing_overlapadd;
84200f10:	2e 00 f0 e1 	call $celt.windowing_overlapadd;

            // prepare for next block
            r0 = M[FP + TEMP_LP];
84200f14:	08 00 28 f1 	r0 = M[FP + 0x8];
            r0 = r0 + 1;
84200f18:	2f 00 22 e4 	r0 = r0 + 1;
            M[FP + TEMP_LP] = r0;
84200f1c:	08 00 2c f1 	M[FP + 0x8] = r0;
            r1 = M[r5 + $celt.dec.MODE_NB_SHORT_MDCTS_FIELD];
84200f20:	58 00 37 d1 	r1 = M[r5 + 88];
            Null = r1 - r0;
84200f24:	2f 00 03 20 	Null = r1 - r0;
         if NZ jump short_mdct_loop;
84200f28:	cb ff 10 dd 	if NE jump $M.celt.imdct_window_overlap_add.short_mdct_loop;

         // transient processing if enabled
         r0 = M[FP + OBUF_ADDR];
84200f2c:	10 00 28 f1 	r0 = M[FP + 0x10];
         I5 = r0;
84200f30:	2f 00 50 50 	I5 = Null + r0;
         r0 = M[r5 + $celt.dec.SHORT_HIST_FIELD];
84200f34:	d8 00 27 d1 	r0 = M[r5 + 216];
         I0 = r0;
84200f38:	2f 00 00 50 	I0 = Null + r0;
         r0 = M[r5 + $celt.dec.TRANSIENT_SHIFT_FIELD];
84200f3c:	68 01 27 d1 	r0 = M[r5 + 360];
         if NZ call $celt.transient_synthesis;
84200f40:	65 0a 10 e1 	if NE call $celt.transient_synthesis;

         // overlap add for first block
         r10 = M[r5 +$celt.dec.MODE_OVERLAP_FIELD];
84200f44:	40 00 c7 d1 	r10 = M[r5 + 64];
         r0 = M[FP + OBUF_ADDR];
84200f48:	10 00 28 f1 	r0 = M[FP + 0x10];
         I5 = r0;
84200f4c:	2f 00 50 50 	I5 = Null + r0;
         r0 = M[r5 + $celt.dec.SHORT_HIST_FIELD];
84200f50:	d8 00 27 d1 	r0 = M[r5 + 216];
         I0 = r0;
84200f54:	2f 00 00 50 	I0 = Null + r0;
         r0 = M[FP + OLA_ADDR];
84200f58:	1c 00 28 f1 	r0 = M[FP + 0x1c];
         I1 = r0;
84200f5c:	2f 00 10 50 	I1 = Null + r0;
         r7 = 1.0;
84200f60:	ff 7f 00 fd 	r7 = Null + 2147483647;
84200f64:	ff ff 90 01 
         do short_wola_loop;
84200f68:	04 00 f0 e5 	do $M.celt.imdct_window_overlap_add.short_wola_loop;
            rMAC = M[I1, 0], r0 = M[I5, 0]; 
84200f6c:	24 14 00 03 	Null = Null + Null, rMAC = M[I1,0], r0 = M[I5,0];
            rMAC = rMAC + r0*r7, r1 = M[I0, MK1];
84200f70:	00 31 29 af 	rMAC = rMAC + r0 * r7 (SS), r1 = M[I0,4];
            M[I5, MK1] = rMAC, M[I1, MK1] = r1;
84200f74:	95 b5 00 03 	Null = Null + Null, M[I1,4] = r1, M[I5,4] = rMAC;

84200f78 <$M.celt.imdct_window_overlap_add.short_wola_loop>:
         short_wola_loop:
         L5 = 0;
84200f78:	00 00 f0 51 	L5 = Null + 0;

#ifdef BASE_REGISTER_MODE
         push Null; 
84200f7c:	00 00 00 f3 	push Null;
         pop B5; 
84200f80:	00 00 d6 f3 	pop B5;

         r0 = M[r5 + $celt.dec.SCRATCHVAR_RIGHT_OBUF_START_ADDR];
84200f84:	90 01 27 d1 	r0 = M[r5 + 400];
         M[FP + OBUF_START] = r0; 
84200f88:	18 00 2c f1 	M[FP + 0x18] = r0;
#endif       
         r0 = M[r5 + $celt.dec.SCRATCHVAR_RIGHT_OBUF_ADDR];
84200f8c:	88 01 27 d1 	r0 = M[r5 + 392];
         r1 = M[r5 + $celt.dec.SCRATCHVAR_RIGHT_OBUF_LEN];
84200f90:	8c 01 37 d1 	r1 = M[r5 + 396];
         M[FP + OBUF_ADDR] = r0;
84200f94:	10 00 2c f1 	M[FP + 0x10] = r0;
         M[FP + OBUF_LEN] = r1;
84200f98:	14 00 3c f1 	M[FP + 0x14] = r1;
         r0 = M[r5 + $celt.dec.HIST_OLA_RIGHT_FIELD];
84200f9c:	98 00 27 d1 	r0 = M[r5 + 152];
         M[FP + OLA_ADDR] = r0;      
84200fa0:	1c 00 2c f1 	M[FP + 0x1c] = r0;
         r0 = M[FP + CH_NO];
84200fa4:	0c 00 28 f1 	r0 = M[FP + 0xc];
         r0 = r0 + 1;
84200fa8:	2f 00 22 e4 	r0 = r0 + 1;
         M[FP + CH_NO] = r0;
84200fac:	0c 00 2c f1 	M[FP + 0xc] = r0;
         r1 = M[r5 + $celt.dec.CELT_CHANNELS_FIELD];
84200fb0:	08 00 37 d1 	r1 = M[r5 + 8];
         Null = r1 - r0;
84200fb4:	2f 00 03 20 	Null = r1 - r0;
         if POS jump chan_loop;
84200fb8:	9f ff 50 dd 	if POS jump $M.celt.imdct_window_overlap_add.chan_loop;

84200fbc <$M.celt.imdct_window_overlap_add.end>:
   end:
   SP = SP - STACK_FRAME_SIZE;
84200fbc:	e8 ff 03 f1 	SP = SP + -24;
   popm <FP,rLink>;
84200fc0:	01 20 04 f1 	popm <FP, rLink>;
   rts;
84200fc4:	0f 00 0d dc 	rts;

84200fc8 <$celt.windowing_overlapadd>:
#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.WINDOWING_OVERLAPADD.PATCH_ID_0,r8)     // celt_patchers
#endif

   // obtain window data
   r0 = M[r5 + $celt.dec.MODE_WINDOW_ADDR_FIELD];
84200fc8:	68 00 27 d1 	r0 = M[r5 + 104];
   I3 = r0;
84200fcc:	2f 00 30 50 	I3 = Null + r0;
   
   // r8 = overlap_size
   // r6 = overlap size)
   // r4 = frame_size/2
   r8 = M[r5 + $celt.dec.MODE_OVERLAP_FIELD];
84200fd0:	40 00 a7 d1 	r8 = M[r5 + 64];
   r6 = r8 LSHIFT -1;
84200fd4:	ff 00 8a 8d 	r6 = r8 LSHIFT -1;
   r4 = r3 LSHIFT -1;
84200fd8:	ff 00 65 8d 	r4 = r3 LSHIFT -1;
    
   // set a few Modify registers
   M0 = MK1;
84200fdc:	04 00 80 51 	M0 = Null + 4;
   M1 = -MK1;
84200fe0:	fc ff 90 51 	M1 = Null + -4;
    
   // copy from middle of the window (reverse)
   r10 = r4 - r6;
84200fe4:	8f 00 c6 20 	r10 = r4 - r6;
   Words2Addr(r4);
84200fe8:	02 00 66 91 	r4 = r4 ASHIFT 2;
   Words2Addr(r6);
84200fec:	02 00 88 91 	r6 = r6 ASHIFT 2;
   I1 = I0 + r4;
84200ff0:	6f 00 10 58 	I1 = I0 + r4;
   I1 = I1 - M0;
84200ff4:	00 00 18 7f 	I1 = I1 - M0;
   L4 = L5;
84200ff8:	0f 00 ef 58 	L4 = L5 + Null;
   I4 = I5;
84200ffc:	0f 00 45 58 	I4 = I5 + Null;
#ifdef BASE_REGISTER_MODE
   push B5;
84201000:	00 00 d2 f3 	push B5;
   pop B4;
84201004:	00 00 c6 f3 	pop B4;
#endif 
   M2 = r6 + r4;
84201008:	6f 00 a8 50 	M2 = r6 + r4;
   Addr2Words(r6);
8420100c:	fe 00 88 91 	r6 = r6 ASHIFT -2;
   M2 = M2 - M0;
84201010:	00 00 a8 7f 	M2 = M2 - M0;
   r0 = M[I4, M2];
84201014:	22 00 00 02 	Null = Null + Null, r0 = M[I4,M2];
   r10 = r10 - 1;
84201018:	3f 00 cc e4 	r10 = r10 - 1;
   if LE jump end_copy_q1_loop;
8420101c:	05 00 d0 dd 	if LE jump $M.celt.windowing_overlapadd.end_copy_q1_loop;
   r0 = M[I1, M1];
84201020:	00 25 00 02 	Null = Null + Null, r0 = M[I1,M1];
   do copy_q1_loop;        
84201024:	02 00 f0 e5 	do $M.celt.windowing_overlapadd.copy_q1_loop;
      M[I4, M1] = r0, r0 = M[I1, M1]; 
84201028:	a1 25 00 02 	Null = Null + Null, r0 = M[I1,M1], M[I4,M1] = r0;

8420102c <$M.celt.windowing_overlapadd.copy_q1_loop>:
   copy_q1_loop:
   M[I4, M1] = r0;
8420102c:	a1 00 00 02 	Null = Null + Null, M[I4,M1] = r0;

84201030 <$M.celt.windowing_overlapadd.end_copy_q1_loop>:
   // window and add hist one overlap size
   //I2 = hist(0)
   //I0 = hist(ov - 1)
   //I3 = w1(0)
   //I7 = w2(ov-1)
   Words2Addr(r8);
84201030:	02 00 aa 91 	r8 = r8 ASHIFT 2;
   I2 = M3;
84201034:	0f 00 2b 58 	I2 = M3 + Null;
   I0 = M3 + r8;
84201038:	af 00 0b 58 	I0 = M3 + r8;
   I0 = I0 - M0;
8420103c:	00 00 08 7f 	I0 = I0 - M0;
   r7 = 1.0;
84201040:	ff 7f 00 fd 	r7 = Null + 2147483647;
84201044:	ff ff 90 01 
   r10 = r6 - 1, r0 = M[I1, M1];                // r0 = x1
84201048:	3f 25 c8 e4 	r10 = r6 - 1, r0 = M[I1,M1];
   I7 = I3 + r8, rMAC = M[I2, M0];               // rMAC = h1
8420104c:	af 18 73 58 	I7 = I3 + r8, rMAC = M[I2,M0];
   I7 = I7 - M0, r2 = M[I3, M0];                 // r2 = w1
84201050:	00 4c 78 7e 	I7 = I7 - M0, r2 = M[I3,M0];
   do left_wola_loop;
84201054:	05 00 f0 e5 	do $M.celt.windowing_overlapadd.left_wola_loop;
      rMAC = rMAC - r0*r2, r2 = M[I7, M1], r1 = M[I0, M1];      //rMAC = h1 -x1*w1, r2 = w2, r1 = h2
84201058:	4d 31 24 be 	rMAC = rMAC - r0 * r2 (SS), r1 = M[I0,M1], r2 = M[I7,M1];
      rMAC = r0*r2, M[I5, M0] = rMAC, r0 = M[I1, M1];           //yp1 = h1 -x1*w1, rMAC = w2*x1, r0 = x1
8420105c:	94 25 24 ce 	rMAC = r0 * r2 (SS), r0 = M[I1,M1], M[I5,M0] = rMAC;
      rMAC = rMAC + r7*r1, r2 = M[I3, M0];                      //rMAC = h2 + w2*x1, r2 = w1
84201060:	3f 4c 19 ac 	rMAC = rMAC + r7 * r1 (SS), r2 = M[I3,M0];
      M[I4, M1] = rMAC, rMAC = M[I2, M0];                       //out1 = h2 + w2*x2, rMAC = h2                  
84201064:	91 18 00 02 	Null = Null + Null, rMAC = M[I2,M0], M[I4,M1] = rMAC;

84201068 <$M.celt.windowing_overlapadd.left_wola_loop>:
   left_wola_loop:
   rMAC = rMAC - r0*r2, r2 = M[I7, M1], r1 = M[I0, M1];           //rMAC = h1 -x1*w1, r2 = w2, r1 = h2
84201068:	4d 31 24 be 	rMAC = rMAC - r0 * r2 (SS), r1 = M[I0,M1], r2 = M[I7,M1];
   rMAC = r0*r2, M[I5, M0] = rMAC;                                //yp1 = h1 -x1*w1, rMAC = w2*x1
8420106c:	94 00 24 ce 	rMAC = r0 * r2 (SS), M[I5,M0] = rMAC;
   rMAC = rMAC + r7*r1;                                           //rMAC = h2 + w2*x1
84201070:	3f 00 19 ac 	rMAC = rMAC + r7 * r1 (SS);
   M[I4, M1] = rMAC;                                              //out2 = h2 + w2*x2
84201074:	91 00 00 02 	Null = Null + Null, M[I4,M1] = rMAC;
   L4 = 0;
84201078:	00 00 e0 51 	L4 = Null + 0;
#ifdef BASE_REGISTER_MODE
   push Null; 
8420107c:	00 00 00 f3 	push Null;
   pop B4;
84201080:	00 00 c6 f3 	pop B4;
#endif   

   // copy from middle of window (forward)
   // I1 = wp(0)
   // I7 = wp(ov - 1)
   I1 = I1 + r4;
84201084:	00 00 16 5b 	I1 = I1 + r4;
   M2 = r4, r0 = M[I1, M0];
84201088:	6f 24 a0 50 	M2 = Null + r4, r0 = M[I1,M0];
   Addr2Words(r4);
8420108c:	fe 00 66 91 	r4 = r4 ASHIFT -2;
   r0 = M[I5, M2];
84201090:	26 00 00 02 	Null = Null + Null, r0 = M[I5,M2];
   r10 = r4 - r6;
84201094:	8f 00 c6 20 	r10 = r4 - r6;
   r10 = r10 - 1;
84201098:	3f 00 cc e4 	r10 = r10 - 1;
   if LE jump end_copy_bloop; 
8420109c:	05 00 d0 dd 	if LE jump $M.celt.windowing_overlapadd.end_copy_bloop;
   r0 = M[I1, M0];
842010a0:	00 24 00 02 	Null = Null + Null, r0 = M[I1,M0];
   do copy_bloop;
842010a4:	02 00 f0 e5 	do $M.celt.windowing_overlapadd.copy_bloop;
      M[I5, M0] = r0, r0 = M[I1, M0];      
842010a8:	a4 24 00 02 	Null = Null + Null, r0 = M[I1,M0], M[I5,M0] = r0;

842010ac <$M.celt.windowing_overlapadd.copy_bloop>:
   copy_bloop:
   M[I5, M0] = r0;
842010ac:	a4 00 00 02 	Null = Null + Null, M[I5,M0] = r0;

842010b0 <$M.celt.windowing_overlapadd.end_copy_bloop>:
   // window the last ov size and store to hist only
   // I1 = wp(0)
   // I7 = wp(ov-1)
   // I2 = hist(0)
   // I3 = hist(ov-1)
   r10 = r6 - 1;
842010b0:	3f 00 c8 e4 	r10 = r6 - 1;
   Words2Addr(r6);
842010b4:	02 00 88 91 	r6 = r6 ASHIFT 2;
   I4 = I3 - r6;
842010b8:	8f 00 43 78 	I4 = I3 - r6;
   I7 = I7 + r6;
842010bc:	00 00 78 5b 	I7 = I7 + r6;
   I2 = M3;
842010c0:	0f 00 2b 58 	I2 = M3 + Null;
   I3 = M3 + r8, r0 = M[I1, M0];
842010c4:	af 24 3b 58 	I3 = M3 + r8, r0 = M[I1,M0];
   I3 = I3 - M0, r2 = M[I4, M0];                         
842010c8:	40 00 38 7e 	I3 = I3 - M0, r2 = M[I4,M0];
   rMAC = r2*r0, r2 = M[I7, M1];
842010cc:	4d 00 42 ce 	rMAC = r2 * r0 (SS), r2 = M[I7,M1];
   do left_whist_loop;
842010d0:	04 00 f0 e5 	do $M.celt.windowing_overlapadd.left_whist_loop;
      rMAC = r0*r2, M[I3, M1] = rMAC, r2 = M[I4, M0];
842010d4:	40 9d 24 ce 	rMAC = r0 * r2 (SS), M[I3,M1] = rMAC, r2 = M[I4,M0];
      r0 = M[I1, M0];  
842010d8:	00 24 00 02 	Null = Null + Null, r0 = M[I1,M0];
      rMAC = r0*r2, r2 = M[I7, M1], M[I2, M0] = rMAC;
842010dc:	4d 98 24 ce 	rMAC = r0 * r2 (SS), M[I2,M0] = rMAC, r2 = M[I7,M1];

842010e0 <$M.celt.windowing_overlapadd.left_whist_loop>:
   left_whist_loop:
   rMAC = r0*r2, M[I3, M1] = rMAC;
842010e0:	4f 9d 12 cc 	rMAC = r0 * r2 (SS), M[I3,M1] = rMAC;
   M[I2, M0] = rMAC;
842010e4:	00 98 00 02 	Null = Null + Null, M[I2,M0] = rMAC;
   rts;
842010e8:	0f 00 0d dc 	rts;

842010ec <$celt.mdct_analysis>:
842010ec:	01 20 00 f1 	pushm <FP(=SP), rLink>;
   .CONST CH_OUT_BUF           (1 + 2)*ADDR_PER_WORD;
   .CONST CH_COUNTER           (2 + 2)*ADDR_PER_WORD;;
   .CONST BLOCK_COUNTER        (3 + 2)*ADDR_PER_WORD;
   .CONST STACK_FRAME_SIZE     4*ADDR_PER_WORD;
   pushm <FP(=SP), rLink>;
   SP = SP + STACK_FRAME_SIZE;
842010f0:	10 00 03 f1 	SP = SP + 16;

   
   M[FP + CH_COUNTER] = Null;
842010f4:	10 00 0c f1 	M[FP + 0x10] = Null;
   r0 = M[r5 + $celt.enc.PREEMPH_LEFT_AUDIO_FIELD];
842010f8:	d8 00 27 d1 	r0 = M[r5 + 216];
   M[FP + CH_INP_BUF] = r0;
842010fc:	08 00 2c f1 	M[FP + 0x8] = r0;
   r0 = M[r5 + $celt.enc.FREQ_FIELD];
84201100:	14 01 27 d1 	r0 = M[r5 + 276];
   M[FP + CH_OUT_BUF] = r0;
84201104:	0c 00 2c f1 	M[FP + 0xc] = r0;

84201108 <$M.celt.mdct_analysis.chan_process>:
   chan_process:
   
      // -- scale the input if needed
      call scale_in;
84201108:	58 00 f0 e1 	call $M.celt.mdct_analysis.scale_in;

      // -- different procedure for short blocks
      Null = M[r5 + $celt.enc.SHORT_BLOCKS_FIELD];
8420110c:	58 01 07 d1 	Null = M[r5 + 344];
      if NZ jump short_proc;   
84201110:	17 00 10 dd 	if NE jump $M.celt.mdct_analysis.short_proc;
   
      // -- Window and reshuffle for MDCT 
      r0 = M[r5 + $celt.enc.MDCT_INPUT_REAL_FIELD];
84201114:	20 01 27 d1 	r0 = M[r5 + 288];
      I6 = r0;
84201118:	2f 00 60 50 	I6 = Null + r0;
      r0 = M[r5 + $celt.enc.MDCT_INPUT_IMAG_FIELD];
8420111c:	d4 00 27 d1 	r0 = M[r5 + 212];
      I7 = r0;
84201120:	2f 00 70 50 	I7 = Null + r0;
      r8 = M[r5 + $celt.enc.MODE_MDCT_SIZE_FIELD];
84201124:	44 00 a7 d1 	r8 = M[r5 + 68];
      r0 = M[FP + CH_INP_BUF];
84201128:	08 00 28 f1 	r0 = M[FP + 0x8];
      I0 = r0;
8420112c:	2f 00 00 50 	I0 = Null + r0;
      call $celt.window_reshuffle;
84201130:	d0 0f f0 e1 	call $celt.window_reshuffle;
  
      // -- MDCT spectrum analysis
      r0 = M[r5 + $celt.enc.MDCT_INPUT_REAL_FIELD];
84201134:	20 01 27 d1 	r0 = M[r5 + 288];
      I6 = r0;
84201138:	2f 00 60 50 	I6 = Null + r0;
      r0 = M[r5 + $celt.enc.MDCT_INPUT_IMAG_FIELD];
8420113c:	d4 00 27 d1 	r0 = M[r5 + 212];
      I7 = r0;
84201140:	2f 00 70 50 	I7 = Null + r0;
      r8 = M[r5 + $celt.enc.MODE_MDCT_SIZE_FIELD]; //N2
84201144:	44 00 a7 d1 	r8 = M[r5 + 68];
      r0 = M[FP + CH_OUT_BUF];
84201148:	0c 00 28 f1 	r0 = M[FP + 0xc];
      I0 = r0;    
8420114c:	2f 00 00 50 	I0 = Null + r0;
      r0 = M[FP + CH_COUNTER];
84201150:	10 00 28 f1 	r0 = M[FP + 0x10];
      Words2Addr(r0);
84201154:	02 00 22 91 	r0 = r0 ASHIFT 2;
      r0 = r0 + r5;
84201158:	00 00 27 03 	r0 = r0 + r5;
      r4 = M[r0 + $celt.enc.MAX_SBAND];
8420115c:	f8 01 62 d1 	r4 = M[r0 + 504];
      r0 = M[r5 + $celt.enc.MDCT_FUNCTION_FIELD];
84201160:	0c 00 27 d1 	r0 = M[r5 + 12];
      call r0;
84201164:	0f 00 02 e0 	call r0;
      jump ch_end;
84201168:	35 00 f0 dd 	jump $M.celt.mdct_analysis.ch_end;

8420116c <$M.celt.mdct_analysis.short_proc>:
   
      short_proc:
      // -- short block mdct analysis
      r0 = M[r5 + $celt.enc.MODE_NB_SHORT_MDCTS_FIELD];
8420116c:	58 00 27 d1 	r0 = M[r5 + 88];
      r0 = r0 - 1;
84201170:	3f 00 22 e4 	r0 = r0 - 1;
      M[FP + BLOCK_COUNTER] = r0;
84201174:	14 00 2c f1 	M[FP + 0x14] = r0;

84201178 <$M.celt.mdct_analysis.block_loop>:
      block_loop:
         // -- Window and reshuffle for MDCT 
         r1 = M[r5 + $celt.enc.MDCT_INPUT_REAL_FIELD];
84201178:	20 01 37 d1 	r1 = M[r5 + 288];
         I6 = r1;
8420117c:	3f 00 60 50 	I6 = Null + r1;
         r1 = M[r5 + $celt.enc.MDCT_INPUT_IMAG_FIELD];
84201180:	d4 00 37 d1 	r1 = M[r5 + 212];
         I7 = r1;
84201184:	3f 00 70 50 	I7 = Null + r1;
         r8 = M[r5 + $celt.enc.MODE_SHORT_MDCT_SIZE_FIELD];
84201188:	5c 00 a7 d1 	r8 = M[r5 + 92];
         r1 = M[FP + CH_INP_BUF];
8420118c:	08 00 38 f1 	r1 = M[FP + 0x8];
         r0 = r0 * r8 (int);
84201190:	00 00 2a 9b 	r0 = r0 * r8 (int);
         Words2Addr(r0);
84201194:	02 00 22 91 	r0 = r0 ASHIFT 2;
         I0 = r1 + r0; 
84201198:	2f 00 03 50 	I0 = r1 + r0;
         call $celt.window_reshuffle;      
8420119c:	b5 0f f0 e1 	call $celt.window_reshuffle;
      
         // -- MDCT spectrum analysis
         r0 = M[r5 + $celt.enc.MDCT_INPUT_REAL_FIELD];
842011a0:	20 01 27 d1 	r0 = M[r5 + 288];
         I6 = r0;
842011a4:	2f 00 60 50 	I6 = Null + r0;
         r0 = M[r5 + $celt.enc.MDCT_INPUT_IMAG_FIELD];
842011a8:	d4 00 27 d1 	r0 = M[r5 + 212];
         I7 = r0;
842011ac:	2f 00 70 50 	I7 = Null + r0;
         r8 = M[r5 + $celt.enc.MODE_SHORT_MDCT_SIZE_FIELD];
842011b0:	5c 00 a7 d1 	r8 = M[r5 + 92];
         r0 = M[r5 + $celt.enc.SHORT_FREQ_FIELD];
842011b4:	1c 01 27 d1 	r0 = M[r5 + 284];
         r1 = M[FP + BLOCK_COUNTER];
842011b8:	14 00 38 f1 	r1 = M[FP + 0x14];
         r1 = r1 * r8 (int);
842011bc:	00 00 3a 9b 	r1 = r1 * r8 (int);
         Words2Addr(r1);
842011c0:	02 00 33 91 	r1 = r1 ASHIFT 2;
         I0 = r0 + r1;     
842011c4:	3f 00 02 50 	I0 = r0 + r1;
         r0 = M[FP + CH_COUNTER];
842011c8:	10 00 28 f1 	r0 = M[FP + 0x10];
         Words2Addr(r0);
842011cc:	02 00 22 91 	r0 = r0 ASHIFT 2;
         r0 = r0 + r5;
842011d0:	00 00 27 03 	r0 = r0 + r5;
         r4 = M[r0 + $celt.enc.MAX_SBAND];
842011d4:	f8 01 62 d1 	r4 = M[r0 + 504];
         r0 = M[r5 + $celt.enc.MDCT_SHORT_FUNCTION_FIELD];
842011d8:	10 00 27 d1 	r0 = M[r5 + 16];
         call r0;
842011dc:	0f 00 02 e0 	call r0;
         r0 = M[FP + BLOCK_COUNTER];
842011e0:	14 00 28 f1 	r0 = M[FP + 0x14];
         r0 = r0 - 1;
842011e4:	3f 00 22 e4 	r0 = r0 - 1;
         M[FP + BLOCK_COUNTER] = r0;
842011e8:	14 00 2c f1 	M[FP + 0x14] = r0;
      if POS jump block_loop;
842011ec:	e3 ff 50 dd 	if POS jump $M.celt.mdct_analysis.block_loop;
   
      // -- interleaving
      // r4 = freq
      r4 = M[FP + CH_OUT_BUF];
842011f0:	0c 00 68 f1 	r4 = M[FP + 0xc];
      I0 = r4;   
842011f4:	6f 00 00 50 	I0 = Null + r4;
      r0 = M[r5 + $celt.enc.SHORT_FREQ_FIELD];
842011f8:	1c 01 27 d1 	r0 = M[r5 + 284];
      I4 = r0;
842011fc:	2f 00 40 50 	I4 = Null + r0;
      r6 = M[r5 + $celt.enc.MODE_NB_SHORT_MDCTS_FIELD];
84201200:	58 00 87 d1 	r6 = M[r5 + 88];
      Words2Addr(r6);
84201204:	02 00 88 91 	r6 = r6 ASHIFT 2;
      M1 = r6;
84201208:	8f 00 90 50 	M1 = Null + r6;
      Addr2Words(r6);
8420120c:	fe 00 88 91 	r6 = r6 ASHIFT -2;
      M2 = 1 * ADDR_PER_WORD;
84201210:	04 00 a0 51 	M2 = Null + 4;
      M3 = 1;
84201214:	01 00 b0 51 	M3 = Null + 1;

84201218 <$M.celt.mdct_analysis.shortf_outer_loop>:
      shortf_outer_loop:
         r10 = M[r5 + $celt.enc.MODE_SHORT_MDCT_SIZE_FIELD];
84201218:	5c 00 c7 d1 	r10 = M[r5 + 92];
         r10 = r10 - M3, r0 = M[I4, M2];
8420121c:	22 00 cb 66 	r10 = r10 - M3, r0 = M[I4,M2];
         r4 = r4 + ADDR_PER_WORD;
84201220:	bf 00 66 e4 	r4 = r4 + 4;
         do shortf_inner_loop;
84201224:	02 00 f0 e5 	do $M.celt.mdct_analysis.shortf_inner_loop;
            r0 = M[I4, M2], M[I0, M1] = r0; 
84201228:	22 a1 00 02 	Null = Null + Null, M[I0,M1] = r0, r0 = M[I4,M2];

8420122c <$M.celt.mdct_analysis.shortf_inner_loop>:
         shortf_inner_loop:
         M[I0, M1] = r0;
8420122c:	00 a1 00 02 	Null = Null + Null, M[I0,M1] = r0;
         I0 = r4;
84201230:	6f 00 00 50 	I0 = Null + r4;
         r6 = r6 - 1;
84201234:	3f 00 88 e4 	r6 = r6 - 1;
      if NZ jump shortf_outer_loop;
84201238:	f8 ff 10 dd 	if NE jump $M.celt.mdct_analysis.shortf_outer_loop;

8420123c <$M.celt.mdct_analysis.ch_end>:
      ch_end:
      r0 = M[r5 + $celt.enc.CELT_CHANNELS_FIELD];
8420123c:	08 00 27 d1 	r0 = M[r5 + 8];
      r1 = M[FP + CH_COUNTER];
84201240:	10 00 38 f1 	r1 = M[FP + 0x10];
      r1 = r1 + 1;
84201244:	2f 00 33 e4 	r1 = r1 + 1;
      M[FP + CH_COUNTER] = r1;
84201248:	10 00 3c f1 	M[FP + 0x10] = r1;
      Null = r0 - r1;
8420124c:	3f 00 02 20 	Null = r0 - r1;
      if NEG jump cleanup_and_exit;
84201250:	19 00 40 dd 	if NEG jump $M.celt.mdct_analysis.cleanup_and_exit;
      r0 = M[r5 + $celt.enc.PREEMPH_RIGHT_AUDIO_FIELD];
84201254:	24 01 27 d1 	r0 = M[r5 + 292];
      M[FP + CH_INP_BUF] = r0;
84201258:	08 00 2c f1 	M[FP + 0x8] = r0;
      r0 = M[r5 + $celt.enc.FREQ2_FIELD];
8420125c:	18 01 27 d1 	r0 = M[r5 + 280];
      M[FP + CH_OUT_BUF] = r0;
84201260:	0c 00 2c f1 	M[FP + 0xc] = r0;
   jump chan_process;
84201264:	a9 ff f0 dd 	jump $M.celt.mdct_analysis.chan_process;

84201268 <$M.celt.mdct_analysis.scale_in>:

   scale_in:
   // -- scale in the input in order to get the best result from fft module
   // Negative scale factors will be compensated in mdct analysis
   r0 = M[FP + CH_COUNTER];
84201268:	10 00 28 f1 	r0 = M[FP + 0x10];
   Words2Addr(r0);
8420126c:	02 00 22 91 	r0 = r0 ASHIFT 2;
   r0 = r0 + r5;
84201270:	00 00 27 03 	r0 = r0 + r5;
   r2 = M[r0 + $celt.enc.MAX_SBAND];
84201274:	f8 01 42 d1 	r2 = M[r0 + 504];
   if LE rts;
84201278:	0d 00 0d dc 	if LE rts;
   
   r3 = M[FP + CH_INP_BUF];
8420127c:	08 00 58 f1 	r3 = M[FP + 0x8];
   I0 = r3;
84201280:	5f 00 00 50 	I0 = Null + r3;
   r4 = M[r5 + $celt.enc.MODE_OVERLAP_FIELD];
84201284:	40 00 67 d1 	r4 = M[r5 + 64];
   r0 =  M[r5 + $celt.enc.MODE_AUDIO_FRAME_SIZE_FIELD];
84201288:	44 00 27 d1 	r0 = M[r5 + 68];
   r10 = r4 + r0;
8420128c:	2f 00 c6 00 	r10 = r4 + r0;
   M0 = 1 * ADDR_PER_WORD;
84201290:	04 00 80 51 	M0 = Null + 4;
   r10 = r10 - 1;
84201294:	3f 00 cc e4 	r10 = r10 - 1;
   I1 = r3 , r0 = M[I0, M0];
84201298:	5f 20 10 50 	I1 = Null + r3, r0 = M[I0,M0];
   do scale_in_loop;
8420129c:	03 00 f0 e5 	do $M.celt.mdct_analysis.scale_in_loop;
      r1 = r0 ASHIFT r2, r0 = M[I0, M0];
842012a0:	4f 20 32 90 	r1 = r0 ASHIFT r2, r0 = M[I0,M0];
      M[I1, M0] = r1;
842012a4:	00 b4 00 02 	Null = Null + Null, M[I1,M0] = r1;

842012a8 <$M.celt.mdct_analysis.scale_in_loop>:
   scale_in_loop:
   r1 = r0 ASHIFT r2;
842012a8:	4f 00 32 90 	r1 = r0 ASHIFT r2;
   M[I1, M0] = r1;
842012ac:	00 b4 00 02 	Null = Null + Null, M[I1,M0] = r1;
   rts;
842012b0:	0f 00 0d dc 	rts;

842012b4 <$M.celt.mdct_analysis.cleanup_and_exit>:
cleanup_and_exit:   
   SP = SP - STACK_FRAME_SIZE;
842012b4:	f0 ff 03 f1 	SP = SP + -16;
   popm <FP,rLink>;
842012b8:	01 20 04 f1 	popm <FP, rLink>;
   rts;
842012bc:	0f 00 0d dc 	rts;

842012c0 <$_celt_mdct_radix2>:
842012c0:	01 20 00 f1 	pushm <FP(=SP), rLink>;
   .CONST SCALE_FACTOR         (0 + 2)*ADDR_PER_WORD;
   .CONST TEMP                 (1 + 2)*ADDR_PER_WORD;
   .CONST TMP_VAR              (7 + 2)*ADDR_PER_WORD;
   .CONST STACK_FRAME_SIZE     8*ADDR_PER_WORD;
   pushm <FP(=SP), rLink>;
   SP = SP + STACK_FRAME_SIZE;
842012c4:	20 00 03 f1 	SP = SP + 32;


   M[FP + TEMP + 0* ADDR_PER_WORD] = r8;
842012c8:	0c 00 ac f1 	M[FP + 0xc] = r8;
   r0 = I6;
842012cc:	6f 00 20 44 	r0 = Null + I6;
   M[FP + TEMP + 1* ADDR_PER_WORD] = r0;
842012d0:	10 00 2c f1 	M[FP + 0x10] = r0;
   r0 = I7;
842012d4:	7f 00 20 44 	r0 = Null + I7;
   M[FP + TEMP + 2* ADDR_PER_WORD] = r0;
842012d8:	14 00 2c f1 	M[FP + 0x14] = r0;
   r0 = I0;
842012dc:	0f 00 20 44 	r0 = Null + I0;
 #ifdef BASE_REGISTER_MODE
   push r0;
842012e0:	00 00 20 f3 	push r0;
   pop B0;
842012e4:	00 00 a6 f3 	pop B0;
#endif
   M[FP + TEMP + 3* ADDR_PER_WORD] = r0; 
842012e8:	18 00 2c f1 	M[FP + 0x18] = r0;
   M[FP + TEMP + 5* ADDR_PER_WORD] = r5;
842012ec:	20 00 7c f1 	M[FP + 0x20] = r5;
   
   
  
   // get scale factor from mode object
   r0 = M[r5 + $celt.enc.MODE_TRIG_OFFSET_FIELD];
842012f0:	78 00 27 d1 	r0 = M[r5 + 120];
   r1 = &$celt.mode.TRIG_VECTOR_SIZE;
842012f4:	0c 00 30 01 	r1 = Null + 12;
   NULL = M[r5 + $celt.enc.SHORT_BLOCKS_FIELD];
842012f8:	58 01 07 d1 	Null = M[r5 + 344];
   if Z r1 = 0;
842012fc:	00 00 30 00 	if EQ r1 = Null + Null;
   Words2Addr(r1);
84201300:	02 00 33 91 	r1 = r1 ASHIFT 2;
   I2 = r0 + r1;
84201304:	3f 00 22 50 	I2 = r0 + r1;
   r0 = r0 + r1;
84201308:	00 00 23 03 	r0 = r0 + r1;
   M[FP + TEMP + 4* ADDR_PER_WORD] = r0; 
8420130c:	1c 00 2c f1 	M[FP + 0x1c] = r0;
   r0 = M[I2, MK1];
84201310:	00 29 00 03 	Null = Null + Null, r0 = M[I2,4];
   r0 = M[I2, MK1];
84201314:	00 29 00 03 	Null = Null + Null, r0 = M[I2,4];
   M[FP + SCALE_FACTOR] = r0;
84201318:	08 00 2c f1 	M[FP + 0x8] = r0;

   r2 = r8 LSHIFT -1;
8420131c:	ff 00 4a 8d 	r2 = r8 LSHIFT -1;
   M[r5 + $celt.enc.SCRATCHVAR_FFT_STRUCT + $fft.NUM_POINTS_FIELD] = r2;
84201320:	94 01 47 d5 	M[r5 + 404] = r2;
   r1 = I6;
84201324:	6f 00 30 44 	r1 = Null + I6;
   M[r5 + $celt.enc.SCRATCHVAR_FFT_STRUCT + $fft.REAL_ADDR_FIELD] = r1;
84201328:	98 01 37 d5 	M[r5 + 408] = r1;
   r1 = I7;
8420132c:	7f 00 30 44 	r1 = Null + I7;
   M[r5 + $celt.enc.SCRATCHVAR_FFT_STRUCT + $fft.IMAG_ADDR_FIELD] = r1;
84201330:	9c 01 37 d5 	M[r5 + 412] = r1;



   // compensation for negative global scale factors
   rMAC = r4;
84201334:	0f 00 16 00 	rMAC = r4 + Null;
   if POS jump no_further_scale;
84201338:	0b 00 50 dd 	if POS jump $M.celt.mdct_radix2.no_further_scale;
      // get the size of fft (N)
      r2 = signdet r2;
8420133c:	0f 00 44 d8 	r2 = SIGNDET r2;
      r2 = (DAWTH-2) - r2;
84201340:	1e 00 44 65 	r2 = 30 - r2;
      
      // calc g = 2.0**(s / N)
      rMAC = rMAC ASHIFT -8 (56bit);
84201344:	f8 00 11 91 	rMAC = rMAC ASHIFT -8 (56bit);
      Div = rMAC / r2;
84201348:	00 00 14 d9 	Div = rMAC / r2;
      r0 = DivResult;      
8420134c:	01 00 20 d9 	r0 = DivResult;
      call $math.pow2_taylor;
84201350:	07 00 00 fd 	call 0x744b8;
84201354:	b8 44 f0 e1 
      
      // sf = sf * g
      r1 = M[FP + SCALE_FACTOR];
84201358:	08 00 38 f1 	r1 = M[FP + 0x8];
      r1 = r1 * r0 (frac);
8420135c:	00 00 32 97 	r1 = r1 * r0 (frac);
      M[FP + SCALE_FACTOR] = r1;
84201360:	08 00 3c f1 	M[FP + 0x8] = r1;

84201364 <$M.celt.mdct_radix2.no_further_scale>:
   no_further_scale:
   
   push r5;
84201364:	00 00 70 f3 	push r5;
   M3 = 4;
84201368:	04 00 b0 51 	M3 = Null + 4;
   M0 = 1 * ADDR_PER_WORD;
8420136c:	04 00 80 51 	M0 = Null + 4;
   M1 = 0;
84201370:	00 00 90 51 	M1 = Null + 0;
   r2 = M[I2,M0];
84201374:	00 48 00 02 	Null = Null + Null, r2 = M[I2,M0];
   r3 = M[I2, M0];
84201378:	00 58 00 02 	Null = Null + Null, r3 = M[I2,M0];
   r4 = M[I2, M0], r0 = M[I6, M1];
8420137c:	29 68 00 02 	Null = Null + Null, r4 = M[I2,M0], r0 = M[I6,M1];
   r4 = - r4, r5 = M[I2, M0];
84201380:	6f 78 60 20 	r4 = Null - r4, r5 = M[I2,M0];
   r5 = - r5;
84201384:	7f 00 70 20 	r5 = Null - r5;
   r1 = FP + TMP_VAR;
84201388:	24 00 37 f1 	r1 = FP + 36;
   I1 = r1;
8420138c:	3f 00 10 50 	I1 = Null + r1;

84201390 <$M.celt.mdct_radix2.prerot_outer_loop>:
   prerot_outer_loop:
      r10 = r8 LSHIFT -3;
84201390:	fd 00 ca 8d 	r10 = r8 LSHIFT -3;
      do prerot_inner_loop;
84201394:	0a 00 f0 e5 	do $M.celt.mdct_radix2.prerot_inner_loop;
         rMAC = r0*r4,  r1 = M[I7, M1];
84201398:	3d 00 26 ce 	rMAC = r0 * r4 (SS), r1 = M[I7,M1];
         rMAC = rMAC + r5*r1;
8420139c:	3f 00 17 ac 	rMAC = rMAC + r5 * r1 (SS);
         rMAC = r1*r4, M[I6, M0] = rMAC;
842013a0:	98 00 36 ce 	rMAC = r1 * r4 (SS), M[I6,M0] = rMAC;
         rMAC = rMAC - r0*r5;
842013a4:	7f 00 12 bc 	rMAC = rMAC - r0 * r5 (SS);
         
         // update the multipliers: "c" and "s"
         rMAC = r4 * r2, M[I7, M0] = rMAC;      // (-c) * cfreq
842013a8:	9c 00 64 ce 	rMAC = r4 * r2 (SS), M[I7,M0] = rMAC;
         rMAC = rMAC - r5 * r3, r0 = M[I6, M1]; // (-c)'= (-c) * cfreq - (-s) * sfreq
842013ac:	29 00 75 be 	rMAC = rMAC - r5 * r3 (SS), r0 = M[I6,M1];
         rMAC = r4 * r3, M[I1,M1] = rMAC;       // (-c_old) * sfreq
842013b0:	5f 95 16 cc 	rMAC = r4 * r3 (SS), M[I1,M1] = rMAC;
         rMAC = rMAC + r5 * r2;                 // (-s)' = (-c_old)*sfreq + (-s)*cfreq
842013b4:	4f 00 17 ac 	rMAC = rMAC + r5 * r2 (SS);
         r5 = rMAC, r4 = M[I1,M1];              // r5 = (-s)'
842013b8:	0f 65 71 00 	r5 = rMAC + Null, r4 = M[I1,M1];

842013bc <$M.celt.mdct_radix2.prerot_inner_loop>:
      prerot_inner_loop:
      // load the constant points mid way to improve accuracy
      r4 = M[I2,M0];
842013bc:	00 68 00 02 	Null = Null + Null, r4 = M[I2,M0];
      r4 = -r4, r5 = M[I2,M0];
842013c0:	6f 78 60 20 	r4 = Null - r4, r5 = M[I2,M0];
      r5 = -r5;      
842013c4:	7f 00 70 20 	r5 = Null - r5;
      M3 = M3 - 1;
842013c8:	01 00 bb 79 	M3 = M3 - 1;
   if NZ jump prerot_outer_loop;
842013cc:	f1 ff 10 dd 	if NE jump $M.celt.mdct_radix2.prerot_outer_loop;
   
   pop r5;
842013d0:	00 00 74 f3 	pop r5;
#ifdef BASE_REGISTER_MODE
   push Null;
842013d4:	00 00 00 f3 	push Null;
   pop B0;
842013d8:	00 00 a6 f3 	pop B0;
#endif 
   // set up data in fft_structure
   I7 = r5 + $celt.enc.SCRATCHVAR_FFT_STRUCT;
842013dc:	94 01 77 51 	I7 = r5 + 404;
   // -- call the ifft --
   r8 = M[FP + SCALE_FACTOR];
842013e0:	08 00 a8 f1 	r8 = M[FP + 0x8];
   //r8 = r8 * r8 (frac);
   call $math.scaleable_fft;
842013e4:	07 00 00 fd 	call 0x74be8;
842013e8:	e8 4b f0 e1 


   r8 = M[FP + TEMP + 0 * ADDR_PER_WORD];
842013ec:	0c 00 a8 f1 	r8 = M[FP + 0xc];
   r0 = M[FP + TEMP + 3 * ADDR_PER_WORD];  
842013f0:	18 00 28 f1 	r0 = M[FP + 0x18];
   I4 = r0;
842013f4:	2f 00 40 50 	I4 = Null + r0;
#ifdef BASE_REGISTER_MODE
    push B0;
842013f8:	00 00 a2 f3 	push B0;
	pop B4;
842013fc:	00 00 c6 f3 	pop B4;
    push B0;
84201400:	00 00 a2 f3 	push B0;
	pop B5;
84201404:	00 00 d6 f3 	pop B5;
#endif 
   Words2Addr(r8);
84201408:	02 00 aa 91 	r8 = r8 ASHIFT 2;
   I5 = I4 + r8;
8420140c:	af 00 54 58 	I5 = I4 + r8;
   Addr2Words(r8);
84201410:	fe 00 aa 91 	r8 = r8 ASHIFT -2;
   I5 = I5 - 1 * ADDR_PER_WORD;
84201414:	04 00 55 79 	I5 = I5 - 4;
      
   r0 = M[FP + TEMP + 4 * ADDR_PER_WORD];
84201418:	1c 00 28 f1 	r0 = M[FP + 0x1c];
   I7 = r0 + 2 * ADDR_PER_WORD;
8420141c:	08 00 72 51 	I7 = r0 + 8;

   // calculate some bit reverse constants
   r6 = SIGNDET r8; // perform the last memory write
84201420:	0f 00 8a d8 	r6 = SIGNDET r8;
   r6 = r6 + 2 - LOG2_ADDR_PER_WORD;                     
84201424:	00 00 88 01 	r6 = r6 + 0;
   r6 = 1 LSHIFT r6;
84201428:	01 00 88 e9 	r6 = 0x1 LSHIFT r6;
   M2 = r6;                         // bit reverse shift register
8420142c:	8f 00 a0 50 	M2 = Null + r6;
   r0 = M[FP + TEMP + 1 * ADDR_PER_WORD];
84201430:	10 00 28 f1 	r0 = M[FP + 0x10];
#ifdef BASE_REGISTER_MODE
    push r0;
84201434:	00 00 20 f3 	push r0;
	pop B0;
84201438:	00 00 a6 f3 	pop B0;
#endif 
   call $math.address_bitreverse;
8420143c:	07 00 00 fd 	call 0x748ec;
84201440:	ec 48 f0 e1 
   I0 = r1;
84201444:	3f 00 00 50 	I0 = Null + r1;
   r0 = M[FP + TEMP + 2 * ADDR_PER_WORD];
84201448:	14 00 28 f1 	r0 = M[FP + 0x14];
#ifdef BASE_REGISTER_MODE
    push r0;
8420144c:	00 00 20 f3 	push r0;
	pop B1;
84201450:	00 00 b6 f3 	pop B1;
#endif 
   call $math.address_bitreverse;
84201454:	07 00 00 fd 	call 0x748ec;
84201458:	ec 48 f0 e1 
   I1 = r1;
8420145c:	3f 00 10 50 	I1 = Null + r1;

 
   // data is returned bit reversed, so enable bit reverse addressing on AG1
   rFlags = rFlags OR $BR_FLAG;
84201460:	40 00 ee 85 	rFlags = rFlags OR 0x40;

   // load bit reversed tmp c location
   r0 = FP + TMP_VAR;
84201464:	24 00 27 f1 	r0 = FP + 36;
   call $math.address_bitreverse;
84201468:	07 00 00 fd 	call 0x748ec;
8420146c:	ec 48 f0 e1 
   I2 = r1;
84201470:	3f 00 20 50 	I2 = Null + r1;
   
   // postrot_outer_loop below needs to run 4 times but the last iteration 
   // causes misaligned memory access due to bit reverse addressing. To 
   // avoid this the loop is unrolled to execute the last iterration setparately
   // with this memory access removed.
   r6 = 4 - 1;
84201474:	03 00 80 01 	r6 = Null + 3;
   M3 = -2 * ADDR_PER_WORD;
84201478:	f8 ff b0 51 	M3 = Null + -8;
   M0 = 1 * ADDR_PER_WORD;
8420147c:	04 00 80 51 	M0 = Null + 4;
   M1 = 0;
84201480:	00 00 90 51 	M1 = Null + 0;
   r2 = M[I7,M0];
84201484:	4c 00 00 02 	Null = Null + Null, r2 = M[I7,M0];
   r3 = M[I7, M0];
84201488:	5c 00 00 02 	Null = Null + Null, r3 = M[I7,M0];
   r4 = M[I7, M0], r0 = M[I1, M2];
8420148c:	6c 26 00 02 	Null = Null + Null, r0 = M[I1,M2], r4 = M[I7,M0];
   r5 = M[I7, M0];
84201490:	7c 00 00 02 	Null = Null + Null, r5 = M[I7,M0];

84201494 <$M.celt.mdct_radix2.postrot_outer_loop>:
   postrot_outer_loop:
      M0 = 2 * ADDR_PER_WORD;
84201494:	08 00 80 51 	M0 = Null + 8;
      r10 = r8 LSHIFT -3;
84201498:	fd 00 ca 8d 	r10 = r8 LSHIFT -3;
      do postrot_inner_loop;
8420149c:	0a 00 f0 e5 	do $M.celt.mdct_radix2.postrot_inner_loop;
         rMAC = r0*r5,  r1 = M[I0, M2];
842014a0:	7f 32 12 cc 	rMAC = r0 * r5 (SS), r1 = M[I0,M2];
         rMAC = rMAC + r4*r1;
842014a4:	3f 00 16 ac 	rMAC = rMAC + r4 * r1 (SS);
         rMAC = r1*r5, M[I4, M0] = rMAC;
842014a8:	90 00 37 ce 	rMAC = r1 * r5 (SS), M[I4,M0] = rMAC;
         rMAC = rMAC - r0*r4;
842014ac:	6f 00 12 bc 	rMAC = rMAC - r0 * r4 (SS);
         
         // update the multipliers: "c" and "s"
         rMAC = r4 * r2, M[I5, M3] = rMAC;      // (-c) * cfreq
842014b0:	97 00 64 ce 	rMAC = r4 * r2 (SS), M[I5,M3] = rMAC;
         rMAC = rMAC - r5 * r3, r0 = M[I1, M2]; // (-c)'= (-c) * cfreq - (-s) * sfreq
842014b4:	5f 26 17 bc 	rMAC = rMAC - r5 * r3 (SS), r0 = M[I1,M2];
         rMAC = r4 * r3, M[I2,M1] = rMAC;       // (-c_old) * sfreq
842014b8:	5f 99 16 cc 	rMAC = r4 * r3 (SS), M[I2,M1] = rMAC;
         rMAC = rMAC + r5 * r2;                 // (-s)' = (-c_old)*sfreq + (-s)*cfreq
842014bc:	4f 00 17 ac 	rMAC = rMAC + r5 * r2 (SS);
         r5 = rMAC, r4 = M[I2,M1];              // r5 = (-s)'
842014c0:	0f 69 71 00 	r5 = rMAC + Null, r4 = M[I2,M1];

842014c4 <$M.celt.mdct_radix2.postrot_inner_loop>:
      postrot_inner_loop:
      // load the constant points mid way to improve accuracy
      M0 = 1 * ADDR_PER_WORD;
842014c4:	04 00 80 51 	M0 = Null + 4;
      r4 = M[I7, M0];
842014c8:	6c 00 00 02 	Null = Null + Null, r4 = M[I7,M0];
      r5 = M[I7,M0];
842014cc:	7c 00 00 02 	Null = Null + Null, r5 = M[I7,M0];
      r6 = r6 - 1;
842014d0:	3f 00 88 e4 	r6 = r6 - 1;
   if NZ jump postrot_outer_loop;
842014d4:	f0 ff 10 dd 	if NE jump $M.celt.mdct_radix2.postrot_outer_loop;

   // Run the last iteration of the outer loop with last iteration 
   // of its inner loop unrolled
    M0 = 2 * ADDR_PER_WORD;
842014d8:	08 00 80 51 	M0 = Null + 8;
    r10 = r8 LSHIFT -3;
842014dc:	fd 00 ca 8d 	r10 = r8 LSHIFT -3;
    r10 = r10 - 1;  // Avoid the last iteration
842014e0:	3f 00 cc e4 	r10 = r10 - 1;
    do postrot_inner_loop_2;
842014e4:	0a 00 f0 e5 	do $M.celt.mdct_radix2.postrot_inner_loop_2;
       rMAC = r0*r5,  r1 = M[I0, M2];
842014e8:	7f 32 12 cc 	rMAC = r0 * r5 (SS), r1 = M[I0,M2];
       rMAC = rMAC + r4*r1;
842014ec:	3f 00 16 ac 	rMAC = rMAC + r4 * r1 (SS);
       rMAC = r1*r5, M[I4, M0] = rMAC;
842014f0:	90 00 37 ce 	rMAC = r1 * r5 (SS), M[I4,M0] = rMAC;
       rMAC = rMAC - r0*r4;
842014f4:	6f 00 12 bc 	rMAC = rMAC - r0 * r4 (SS);
         
       // update the multipliers: "c" and "s"
       rMAC = r4 * r2, M[I5, M3] = rMAC;      // (-c) * cfreq
842014f8:	97 00 64 ce 	rMAC = r4 * r2 (SS), M[I5,M3] = rMAC;
       rMAC = rMAC - r5 * r3, r0 = M[I1, M2]; // (-c)'= (-c) * cfreq - (-s) * sfreq
842014fc:	5f 26 17 bc 	rMAC = rMAC - r5 * r3 (SS), r0 = M[I1,M2];
       rMAC = r4 * r3, M[I2,M1] = rMAC;       // (-c_old) * sfreq
84201500:	5f 99 16 cc 	rMAC = r4 * r3 (SS), M[I2,M1] = rMAC;
       rMAC = rMAC + r5 * r2;                 // (-s)' = (-c_old)*sfreq + (-s)*cfreq
84201504:	4f 00 17 ac 	rMAC = rMAC + r5 * r2 (SS);
       r5 = rMAC, r4 = M[I2,M1];              // r5 = (-s)'
84201508:	0f 69 71 00 	r5 = rMAC + Null, r4 = M[I2,M1];

8420150c <$M.celt.mdct_radix2.postrot_inner_loop_2>:
    postrot_inner_loop_2:

    // Run the last iteration with bit reverse addressing removed
    rMAC = r0*r5,  r1 = M[I0, M2];
8420150c:	7f 32 12 cc 	rMAC = r0 * r5 (SS), r1 = M[I0,M2];
    rMAC = rMAC + r4*r1;
84201510:	3f 00 16 ac 	rMAC = rMAC + r4 * r1 (SS);
    rMAC = r1*r5, M[I4, M0] = rMAC;
84201514:	90 00 37 ce 	rMAC = r1 * r5 (SS), M[I4,M0] = rMAC;
    rMAC = rMAC - r0*r4;
84201518:	6f 00 12 bc 	rMAC = rMAC - r0 * r4 (SS);
     
    // update the multipliers: "c" and "s"
    rMAC = r4 * r2, M[I5, M3] = rMAC;      // (-c) * cfreq
8420151c:	97 00 64 ce 	rMAC = r4 * r2 (SS), M[I5,M3] = rMAC;
    rMAC = rMAC - r5 * r3;                 // (-c)'= (-c) * cfreq - (-s) * sfreq - avoid bit reverse addressing
84201520:	5f 00 17 bc 	rMAC = rMAC - r5 * r3 (SS);
    rMAC = r4 * r3, M[I2,M1] = rMAC;       // (-c_old) * sfreq
84201524:	5f 99 16 cc 	rMAC = r4 * r3 (SS), M[I2,M1] = rMAC;
    rMAC = rMAC + r5 * r2;                 // (-s)' = (-c_old)*sfreq + (-s)*cfreq
84201528:	4f 00 17 ac 	rMAC = rMAC + r5 * r2 (SS);
    r5 = rMAC, r4 = M[I2,M1];              // r5 = (-s)'
8420152c:	0f 69 71 00 	r5 = rMAC + Null, r4 = M[I2,M1];
   
#ifdef BASE_REGISTER_MODE
   push Null;
84201530:	00 00 00 f3 	push Null;
   pop  B4;
84201534:	00 00 c6 f3 	pop B4;
   push Null;
84201538:	00 00 00 f3 	push Null;
   pop  B0;
8420153c:	00 00 a6 f3 	pop B0;
   push Null;
84201540:	00 00 00 f3 	push Null;
   pop  B1;
84201544:	00 00 b6 f3 	pop B1;
   push Null;
84201548:	00 00 00 f3 	push Null;
   pop  B5;
8420154c:	00 00 d6 f3 	pop B5;
#endif
   rFlags = rFlags AND $NOT_BR_FLAG;
84201550:	bf ff ee 81 	rFlags = rFlags AND 0xffbf;
   
    r5 = M[FP + TEMP + 5 * ADDR_PER_WORD];
84201554:	20 00 78 f1 	r5 = M[FP + 0x20];
   // pop rLink from stack
   SP = SP - STACK_FRAME_SIZE;
84201558:	e0 ff 03 f1 	SP = SP + -32;
   popm <FP,rLink>;
8420155c:	01 20 04 f1 	popm <FP, rLink>;
   rts;
84201560:	0f 00 0d dc 	rts;

84201564 <$celt.codec.init_tables>:
84201564:	00 00 d0 f3 	push rLink;

   $celt.codec.init_tables:

   // push rLink onto stack
   push rLink;
   push r4;
84201568:	00 00 60 f3 	push r4;
   r1 = r0;                 // mode
8420156c:	0f 00 32 00 	r1 = r0 + Null;
   r3 = $all_modes;
84201570:	70 00 00 fd 	r3 = Null + 7347316;
84201574:	74 1c 50 01 
   Words2Addr(r0);
84201578:	02 00 22 91 	r0 = r0 ASHIFT 2;
   r3 = M[r3 + r0];         // index into the appropriate mode
8420157c:	00 00 52 d3 	r3 = M[r3 + r0];
   r4 = $all_modes_size;
84201580:	70 00 00 fd 	r4 = Null + 7347328;
84201584:	80 1c 60 01 
   r4 = M[r4 + r0];         // index into the appropriate mode size
84201588:	00 00 62 d3 	r4 = M[r4 + r0];

   r8 = M[r5 + $celt.enc.CELT_MODE_OBJECT_FIELD];
8420158c:	00 00 a7 d1 	r8 = M[r5 + 0];
   r7 = r8;
84201590:	0f 00 9a 00 	r7 = r8 + Null;
   r0 = r8;
84201594:	0f 00 2a 00 	r0 = r8 + Null;
   r10 = M[r4 + 0*MK1];
84201598:	00 00 c6 d1 	r10 = M[r4 + 0];
   Words2Addr(r10);
8420159c:	02 00 cc 91 	r10 = r10 ASHIFT 2;
   r8 = r8 + r10;
842015a0:	00 00 ac 03 	r8 = r8 + r10;
   Addr2Words(r10);
842015a4:	fe 00 cc 91 	r10 = r10 ASHIFT -2;
   r2 =  M[r3 + 0*MK1];
842015a8:	00 00 45 d1 	r2 = M[r3 + 0];
   call copytoramTables;
842015ac:	62 00 f0 e1 	call $M.celt.codec.init_tables.copytoramTables;

   r10 = M[r4 + 1*MK1];
842015b0:	04 00 c6 d1 	r10 = M[r4 + 4];
   r2 =  M[r3 + 1*MK1];
842015b4:	04 00 45 d1 	r2 = M[r3 + 4];
   r0 = r8;
842015b8:	0f 00 2a 00 	r0 = r8 + Null;
   M[r7 + $celt.EBAND_OFFSET] = r0;
842015bc:	24 00 29 d5 	M[r7 + 36] = r0;
   Words2Addr(r10);
842015c0:	02 00 cc 91 	r10 = r10 ASHIFT 2;
   r8 = r8 + r10;
842015c4:	00 00 ac 03 	r8 = r8 + r10;
   Addr2Words(r10);
842015c8:	fe 00 cc 91 	r10 = r10 ASHIFT -2;
#ifdef PACKED_TABLES_ARCH4
   call copytoramTables_upack3;
842015cc:	79 00 f0 e1 	call $M.celt.codec.init_tables.copytoramTables_upack3;
#else
   call copytoramTables;
#endif

   r10 = M[r4 + 2*MK1];
842015d0:	08 00 c6 d1 	r10 = M[r4 + 8];
   r2 =  M[r3 + 2*MK1];
842015d4:	08 00 45 d1 	r2 = M[r3 + 8];
   r0 = r8;
842015d8:	0f 00 2a 00 	r0 = r8 + Null;
   M[r7 + $celt.ALLOCVECTORS_OFFSET] = r0;
842015dc:	28 00 29 d5 	M[r7 + 40] = r0;
   Words2Addr(r10);
842015e0:	02 00 cc 91 	r10 = r10 ASHIFT 2;
   r8 = r8 + r10;
842015e4:	00 00 ac 03 	r8 = r8 + r10;
   Addr2Words(r10);
842015e8:	fe 00 cc 91 	r10 = r10 ASHIFT -2;
#ifdef PACKED_TABLES_ARCH4
   call copytoramTables_upack4;
842015ec:	84 00 f0 e1 	call $M.celt.codec.init_tables.copytoramTables_upack4;
#else
   call copytoramTables;
#endif

   r2 =  M[r3 + 3*MK1];
842015f0:	0c 00 45 d1 	r2 = M[r3 + 12];
#ifdef CELT_TABLE_NO_FLASH_COPY
   M[r7 + $celt.WINDOW_OFFSET] = r2;
842015f4:	2c 00 49 d5 	M[r7 + 44] = r2;
   r8 = r8 + r10;
   Addr2Words(r10);
   call copytoramTables;
#endif

   r10 = M[r4 + 4*MK1];
842015f8:	10 00 c6 d1 	r10 = M[r4 + 16];
   r2 =  M[r3 + 4*MK1];
842015fc:	10 00 45 d1 	r2 = M[r3 + 16];
   r0 = r8;
84201600:	0f 00 2a 00 	r0 = r8 + Null;
   M[r7 + $celt.PROB_OFFSET] = r0;
84201604:	30 00 29 d5 	M[r7 + 48] = r0;
   Words2Addr(r10);
84201608:	02 00 cc 91 	r10 = r10 ASHIFT 2;
   r8 = r8 + r10;
8420160c:	00 00 ac 03 	r8 = r8 + r10;
   Addr2Words(r10);
84201610:	fe 00 cc 91 	r10 = r10 ASHIFT -2;
#ifdef PACKED_TABLES_ARCH4
   call copytoramTables_upack2;
84201614:	4e 00 f0 e1 	call $M.celt.codec.init_tables.copytoramTables_upack2;
#else
   call copytoramTables;
#endif
   r10 = M[r4 + 5*MK1];
84201618:	14 00 c6 d1 	r10 = M[r4 + 20];
   r2 =  M[r3 + 5*MK1];
8420161c:	14 00 45 d1 	r2 = M[r3 + 20];
   r0 = r8;
84201620:	0f 00 2a 00 	r0 = r8 + Null;
   M[r7 + $celt.BITS_OFFSET] = r0;
84201624:	34 00 29 d5 	M[r7 + 52] = r0;
   Words2Addr(r10);
84201628:	02 00 cc 91 	r10 = r10 ASHIFT 2;
   r8 = r8 + r10;
8420162c:	00 00 ac 03 	r8 = r8 + r10;
   Addr2Words(r10);
84201630:	fe 00 cc 91 	r10 = r10 ASHIFT -2;
#ifdef PACKED_TABLES_ARCH4
   call copytoramTables_upack2;
84201634:	46 00 f0 e1 	call $M.celt.codec.init_tables.copytoramTables_upack2;
#else
   call copytoramTables;
#endif

   r2 =  M[r3 + 6*MK1];
84201638:	18 00 45 d1 	r2 = M[r3 + 24];
#ifdef CELT_TABLE_NO_FLASH_COPY
   M[r7 + $celt.EBANDS_DIF_SQRT_OFFSET] = r2;
8420163c:	38 00 49 d5 	M[r7 + 56] = r2;
   r8 = r8 + r10;
   Addr2Words(r10);
   call copytoramTables;
#endif

   r2 =  M[r3 + 7*MK1];
84201640:	1c 00 45 d1 	r2 = M[r3 + 28];
#ifdef CELT_TABLE_NO_FLASH_COPY
   M[r7 + $celt.TRIG_OFFSET] = r2;
84201644:	3c 00 49 d5 	M[r7 + 60] = r2;
   call copytoramTables;
#endif

#ifdef CELT_TABLE_NO_FLASH_COPY

   r0 = &$celt.flaglist;
84201648:	70 00 00 fd 	r0 = Null + 7347468;
8420164c:	0c 1d 20 01 
   M[r5 + $celt.dec.PTR_FLAGLIST_TABLE_FIELD] = r0;
84201650:	10 02 27 d5 	M[r5 + 528] = r0;

   r0 = &$celt.eMeans;
84201654:	70 00 00 fd 	r0 = Null + 7347500;
84201658:	2c 1d 20 01 
   M[r5 + $celt.dec.PTR_EMEANS_TABLE_FIELD] = r0;
8420165c:	14 02 27 d5 	M[r5 + 532] = r0;

   r0 = &$celt.maxN;
84201660:	70 00 00 fd 	r0 = Null + 7347600;
84201664:	90 1d 20 01 
   M[r5 + $celt.dec.PTR_MAX_N_TABLE_FIELD]= r0;
84201668:	18 02 27 d5 	M[r5 + 536] = r0;

   r0 = &$celt.maxK;
8420166c:	70 00 00 fd 	r0 = Null + 7347660;
84201670:	cc 1d 20 01 
   M[r5 + $celt.dec.PTR_MAX_K_TABLE_FIELD] = r0;
84201674:	1c 02 27 d5 	M[r5 + 540] = r0;

   r0 = &$celt.inv2;
84201678:	70 00 00 fd 	r0 = Null + 7347720;
8420167c:	08 1e 20 01 
   M[r5 + $celt.dec.PTR_INV2_TABLE_FIELD]= r0;
84201680:	20 02 27 d5 	M[r5 + 544] = r0;

   NULL = r6 ;
84201684:	0f 00 08 00 	Null = r6 + Null;
   if NZ jump encoder_table;
84201688:	15 00 10 dd 	if NE jump $M.celt.codec.init_tables.encoder_table;
   r0 = &$celt.transientWindow;
8420168c:	70 00 00 fd 	r0 = Null + 7347340;
84201690:	8c 1c 20 01 
   M[r5 + $celt.dec.PTR_TRANSIENT_WINDOW_TABLE_FIELD] = r0;
84201694:	0c 02 27 d5 	M[r5 + 524] = r0;

   r0 = &$celt.decode_jump_table;
84201698:	70 00 00 fd 	r0 = Null + 7347752;
8420169c:	28 1e 20 01 
   M[r5 + $celt.dec.DEC_JUMP_TABLE_FIELD] = r0;
842016a0:	24 02 27 d5 	M[r5 + 548] = r0;
   r0 = M[r5 + $celt.dec.DEC_JUMP_TABLE_FIELD];
   r2 = &$celt.decode_jump_table;
   r10 = 5;
   call copytoramTables;
#endif
   r0 = M[r5 + $celt.dec.PTR_MODE_DM1SCRATCH_ALLOC];
842016a4:	28 02 27 d1 	r0 = M[r5 + 552];
   r2 = $dec_mode_dm1scratch_alloc;
842016a8:	70 00 00 fd 	r2 = Null + 7347076;
842016ac:	84 1b 40 01 
   Words2Addr(r1);
842016b0:	02 00 33 91 	r1 = r1 ASHIFT 2;
   r2 = M[r2 + r1];
842016b4:	00 00 43 d3 	r2 = M[r2 + r1];
   r10 = 14;
842016b8:	0e 00 c0 01 	r10 = Null + 14;
#ifdef PACKED_TABLES_ARCH4
   //r10 = $celt.dec.DM1_SCRATCH_FIELDS_LENGTH_ARCH4_PACKED;
   call copytoramTables_upack2;
842016bc:	24 00 f0 e1 	call $M.celt.codec.init_tables.copytoramTables_upack2;
#else
  // r10 = $celt.dec.DM1_SCRATCH_FIELDS_LENGTH;
   call copytoramTables;
#endif

   r0 = M[r5 + $celt.dec.PTR_MODE_DM2SCRATCH_ALLOC];
842016c0:	2c 02 27 d1 	r0 = M[r5 + 556];
   r2 = $dec_mode_dm2scratch_alloc;
842016c4:	70 00 00 fd 	r2 = Null + 7347088;
842016c8:	90 1b 40 01 
   r2 = M[r2 + r1];
842016cc:	00 00 43 d3 	r2 = M[r2 + r1];
   r10 = 13;
842016d0:	0d 00 c0 01 	r10 = Null + 13;
#ifdef PACKED_TABLES_ARCH4
   //r10 = $celt.dec.DM2_SCRATCH_FIELDS_LENGTH_ARCH4_PACKED;
   call copytoramTables_upack2_odd;
842016d4:	29 00 f0 e1 	call $M.celt.codec.init_tables.copytoramTables_upack2_odd;
#else
   //r10 = $celt.dec.DM2_SCRATCH_FIELDS_LENGTH;
   call copytoramTables;
#endif

   jump tables_set;
842016d8:	14 00 f0 dd 	jump $M.celt.codec.init_tables.tables_set;

842016dc <$M.celt.codec.init_tables.encoder_table>:

encoder_table:
#ifdef CELT_TABLE_NO_FLASH_COPY
   r0 = &$celt.inv_transientWindow;
842016dc:	70 00 00 fd 	r0 = Null + 7347404;
842016e0:	cc 1c 20 01 
   M[r5 + $celt.enc.PTR_INV_TRANSIENT_WINDOW_TABLE_FIELD] = r0;
842016e4:	0c 02 27 d5 	M[r5 + 524] = r0;

   r0 = &$celt.encode_jump_table;
842016e8:	70 00 00 fd 	r0 = Null + 7347772;
842016ec:	3c 1e 20 01 
   M[r5 + $celt.enc.ENC_JUMP_TABLE_FIELD] = r0;
842016f0:	24 02 27 d5 	M[r5 + 548] = r0;
   r0 = M[r5 + $celt.enc.ENC_JUMP_TABLE_FIELD];
   r2 = &$celt.encode_jump_table;
   r10 = 5;
   call copytoramTables;
#endif
   r0 = M[r5 + $celt.enc.PTR_MODE_DM1SCRATCH_ALLOC];
842016f4:	28 02 27 d1 	r0 = M[r5 + 552];
   r2 = $enc_mode_dm1scratch_alloc;
842016f8:	70 00 00 fd 	r2 = Null + 7347100;
842016fc:	9c 1b 40 01 
   Words2Addr(r1);
84201700:	02 00 33 91 	r1 = r1 ASHIFT 2;
   r2 = M[r2 + r1];
84201704:	00 00 43 d3 	r2 = M[r2 + r1];
   r10 = 14;
84201708:	0e 00 c0 01 	r10 = Null + 14;
#ifdef PACKED_TABLES_ARCH4
  // r10 = $celt.dec.DM1_SCRATCH_FIELDS_LENGTH_ARCH4_PACKED;
   call copytoramTables_upack2;
8420170c:	10 00 f0 e1 	call $M.celt.codec.init_tables.copytoramTables_upack2;
#else
   r10 = $celt.dec.DM1_SCRATCH_FIELDS_LENGTH;
   call copytoramTables;
#endif

   r0 = M[r5 + $celt.enc.PTR_MODE_DM2SCRATCH_ALLOC];
84201710:	2c 02 27 d1 	r0 = M[r5 + 556];
   r2 = $enc_mode_dm2scratch_alloc;
84201714:	70 00 00 fd 	r2 = Null + 7347112;
84201718:	a8 1b 40 01 
   r2 = M[r2 + r1];
8420171c:	00 00 43 d3 	r2 = M[r2 + r1];
   r10 = 13;
84201720:	0d 00 c0 01 	r10 = Null + 13;
#ifdef PACKED_TABLES_ARCH4
  // r10 = $celt.dec.DM2_SCRATCH_FIELDS_LENGTH_ARCH4_PACKED;
   call copytoramTables_upack2_odd;
84201724:	15 00 f0 e1 	call $M.celt.codec.init_tables.copytoramTables_upack2_odd;

84201728 <$M.celt.codec.init_tables.tables_set>:
   r10 = $celt.dec.DM2_SCRATCH_FIELDS_LENGTH;
   call copytoramTables;
#endif

tables_set:
   pop r4;
84201728:	00 00 64 f3 	pop r4;
   jump $pop_rLink_and_rts;
8420172c:	03 00 00 fd 	jump (m) 0x3b020;
84201730:	21 b0 f0 dd 

84201734 <$M.celt.codec.init_tables.copytoramTables>:
  // r0  = RAM ADDRESS
  // r2  = DMCONST ADDRESS
  // r10 = number of coefficients to copy
  // *************************************************************************
copytoramTables:
   I4 = r0;
84201734:	2f 00 40 50 	I4 = Null + r0;
   I1 = r2;
84201738:	4f 00 10 50 	I1 = Null + r2;
   r0 = M[I1,MK1];
8420173c:	00 25 00 03 	Null = Null + Null, r0 = M[I1,4];
   do copy_celt_table_to_ram;
84201740:	02 00 f0 e5 	do $M.celt.codec.init_tables.copy_celt_table_to_ram;
      r0 = M[I1,MK1] , M[I4,MK1] = r0;
84201744:	a1 25 00 03 	Null = Null + Null, r0 = M[I1,4], M[I4,4] = r0;

84201748 <$M.celt.codec.init_tables.copy_celt_table_to_ram>:
   copy_celt_table_to_ram:

   rts;
84201748:	0f 00 0d dc 	rts;

8420174c <$M.celt.codec.init_tables.copytoramTables_upack2>:
  // r0  = RAM ADDRESS
  // r2  = DMCONST ADDRESS
  // r10 = number of coefficients to copy
  // *************************************************************************
copytoramTables_upack2:
   I4 = r0;
8420174c:	2f 00 40 50 	I4 = Null + r0;
   I1 = r2;
84201750:	4f 00 10 50 	I1 = Null + r2;
   r0 = M[I1,MK1];
84201754:	00 25 00 03 	Null = Null + Null, r0 = M[I1,4];
   r10 = r10 LSHIFT -1;
84201758:	ff 00 cc 8d 	r10 = r10 LSHIFT -1;
   do copy_celt_table_to_ram_upack2;
8420175c:	06 00 f0 e5 	do $M.celt.codec.init_tables.copy_celt_table_to_ram_upack2;
      r2 = r0 AND 0x0000FFFF;
84201760:	ff ff 42 81 	r2 = r0 AND 0xffff;
      M[I4,MK1] = r2;
84201764:	c1 00 00 03 	Null = Null + Null, M[I4,4] = r2;
      r2 = r0 ASHIFT -16 ;
84201768:	f0 00 42 91 	r2 = r0 ASHIFT -16;
      r2 = r2 AND 0x0000FFFF;
8420176c:	ff ff 44 81 	r2 = r2 AND 0xffff;
      r0 = M[I1,MK1] , M[I4,MK1] = r2;
84201770:	c1 25 00 03 	Null = Null + Null, r0 = M[I1,4], M[I4,4] = r2;

84201774 <$M.celt.codec.init_tables.copy_celt_table_to_ram_upack2>:
   copy_celt_table_to_ram_upack2:


   rts;
84201774:	0f 00 0d dc 	rts;

84201778 <$M.celt.codec.init_tables.copytoramTables_upack2_odd>:
  // r0  = RAM ADDRESS
  // r2  = DMCONST ADDRESS
  // r10 = number of coefficients to copy
  // *************************************************************************
copytoramTables_upack2_odd:
   I4 = r0;
84201778:	2f 00 40 50 	I4 = Null + r0;
   I1 = r2;
8420177c:	4f 00 10 50 	I1 = Null + r2;
   r10 = r10 - 1;
84201780:	3f 00 cc e4 	r10 = r10 - 1;
   r10 = r10 LSHIFT -1;
84201784:	ff 00 cc 8d 	r10 = r10 LSHIFT -1;
   r0 = M[I1,MK1];
84201788:	00 25 00 03 	Null = Null + Null, r0 = M[I1,4];
   do copy_celt_table_to_ram_upack2_odd;
8420178c:	06 00 f0 e5 	do $M.celt.codec.init_tables.copy_celt_table_to_ram_upack2_odd;
      r2 = r0 AND 0x0000FFFF;
84201790:	ff ff 42 81 	r2 = r0 AND 0xffff;
      M[I4,MK1] = r2;
84201794:	c1 00 00 03 	Null = Null + Null, M[I4,4] = r2;
      r2 = r0 ASHIFT -16 ;
84201798:	f0 00 42 91 	r2 = r0 ASHIFT -16;
      r2 = r2 AND 0x0000FFFF;
8420179c:	ff ff 44 81 	r2 = r2 AND 0xffff;
      r0 = M[I1,MK1] , M[I4,MK1] = r2;
842017a0:	c1 25 00 03 	Null = Null + Null, r0 = M[I1,4], M[I4,4] = r2;

842017a4 <$M.celt.codec.init_tables.copy_celt_table_to_ram_upack2_odd>:
   copy_celt_table_to_ram_upack2_odd:
    r2 = r0 AND 0x0000FFFF;
842017a4:	ff ff 42 81 	r2 = r0 AND 0xffff;
    M[I4,MK1] = r2;
842017a8:	c1 00 00 03 	Null = Null + Null, M[I4,4] = r2;

   rts;
842017ac:	0f 00 0d dc 	rts;

842017b0 <$M.celt.codec.init_tables.copytoramTables_upack3>:
  // r0  = RAM ADDRESS
  // r2  = DMCONST ADDRESS
  // r10 = number of coefficients to copy
  // *************************************************************************
copytoramTables_upack3:
   I4 = r0;
842017b0:	2f 00 40 50 	I4 = Null + r0;
   I1 = r2;
842017b4:	4f 00 10 50 	I1 = Null + r2;
   r10 = 8 ;
842017b8:	08 00 c0 01 	r10 = Null + 8;
   //r10 = r10 - 1 ;
   r0 = M[I1,MK1];
842017bc:	00 25 00 03 	Null = Null + Null, r0 = M[I1,4];
   do copy_celt_table_to_ram_upack3;
842017c0:	09 00 f0 e5 	do $M.celt.codec.init_tables.copy_celt_table_to_ram_upack3;
      r2 = r0 AND 0x000003FF;
842017c4:	ff 03 42 81 	r2 = r0 AND 0x3ff;
      M[I4,MK1] = r2;
842017c8:	c1 00 00 03 	Null = Null + Null, M[I4,4] = r2;
      r2 = r0 LSHIFT -10 ;
842017cc:	f6 00 42 8d 	r2 = r0 LSHIFT -10;
      r2 = r2 AND 0x000003FF;
842017d0:	ff 03 44 81 	r2 = r2 AND 0x3ff;
      M[I4,MK1] = r2;
842017d4:	c1 00 00 03 	Null = Null + Null, M[I4,4] = r2;
      r2 = r0 LSHIFT -20 ;
842017d8:	ec 00 42 8d 	r2 = r0 LSHIFT -20;
      r2 = r2 AND 0x000003FF;
842017dc:	ff 03 44 81 	r2 = r2 AND 0x3ff;
      r0 = M[I1,MK1] , M[I4,MK1] = r2;
842017e0:	c1 25 00 03 	Null = Null + Null, r0 = M[I1,4], M[I4,4] = r2;

842017e4 <$M.celt.codec.init_tables.copy_celt_table_to_ram_upack3>:
   copy_celt_table_to_ram_upack3:
      r2 = r0 AND 0x000003FF;
842017e4:	ff 03 42 81 	r2 = r0 AND 0x3ff;
      M[I4,MK1] = r2;
842017e8:	c1 00 00 03 	Null = Null + Null, M[I4,4] = r2;
      r2 = r0 LSHIFT -10 ;
842017ec:	f6 00 42 8d 	r2 = r0 LSHIFT -10;
      r2 = r2 AND 0x000003FF;
842017f0:	ff 03 44 81 	r2 = r2 AND 0x3ff;
      M[I4,MK1] = r2;
842017f4:	c1 00 00 03 	Null = Null + Null, M[I4,4] = r2;
   rts;
842017f8:	0f 00 0d dc 	rts;

842017fc <$M.celt.codec.init_tables.copytoramTables_upack4>:
  // r0  = RAM ADDRESS
  // r2  = DMCONST ADDRESS
  // r10 = number of coefficients to copy
  // *************************************************************************
copytoramTables_upack4:
   I4 = r0;
842017fc:	2f 00 40 50 	I4 = Null + r0;
   I1 = r2;
84201800:	4f 00 10 50 	I1 = Null + r2;
   r10 = r10 LSHIFT -2;
84201804:	fe 00 cc 8d 	r10 = r10 LSHIFT -2;
   r0 = M[I1,MK1];
84201808:	00 25 00 03 	Null = Null + Null, r0 = M[I1,4];
   do copy_celt_table_to_ram_upack4;
8420180c:	0c 00 f0 e5 	do $M.celt.codec.init_tables.copy_celt_table_to_ram_upack4;
      r2 = r0 AND 0x000000FF;
84201810:	ff 00 42 81 	r2 = r0 AND 0xff;
      M[I4,MK1] = r2;
84201814:	c1 00 00 03 	Null = Null + Null, M[I4,4] = r2;
      r2 = r0 LSHIFT -8 ;
84201818:	f8 00 42 8d 	r2 = r0 LSHIFT -8;
      r2 = r2 AND 0x000000FF;
8420181c:	ff 00 44 81 	r2 = r2 AND 0xff;
      M[I4,MK1] = r2;
84201820:	c1 00 00 03 	Null = Null + Null, M[I4,4] = r2;
      r2 = r0 LSHIFT -16 ;
84201824:	f0 00 42 8d 	r2 = r0 LSHIFT -16;
      r2 = r2 AND 0x000000FF;
84201828:	ff 00 44 81 	r2 = r2 AND 0xff;
      M[I4,MK1] = r2;
8420182c:	c1 00 00 03 	Null = Null + Null, M[I4,4] = r2;
      r2 = r0 LSHIFT -24 ;
84201830:	e8 00 42 8d 	r2 = r0 LSHIFT -24;
      r2 = r2 AND 0x000000FF;
84201834:	ff 00 44 81 	r2 = r2 AND 0xff;
      r0 = M[I1,MK1] , M[I4,MK1] = r2;
84201838:	c1 25 00 03 	Null = Null + Null, r0 = M[I1,4], M[I4,4] = r2;

8420183c <$M.celt.codec.init_tables.copy_celt_table_to_ram_upack4>:
   copy_celt_table_to_ram_upack4:

   rts;
8420183c:	0f 00 0d dc 	rts;

84201840 <$celt.preemphasis>:
84201840:	7c 01 27 d1 	r0 = M[r5 + 380];
#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.PREEMPHASIS.PATCH_ID_0,r1)     // celt_patchers
#endif   

   r0 = M[r5 + $celt.enc.SCRATCHVAR_LEFT_IBUF_ADDR];
   r1 = M[r5 + $celt.enc.SCRATCHVAR_LEFT_IBUF_LEN];
84201844:	80 01 37 d1 	r1 = M[r5 + 384];
   I5 = r0;
84201848:	2f 00 50 50 	I5 = Null + r0;
   L5 = r1;
8420184c:	3f 00 f0 50 	L5 = Null + r1;
#ifdef BASE_REGISTER_MODE  
   r0 = M[r5 + $celt.enc.SCRATCHVAR_LEFT_IBUF_START_ADDR];
84201850:	84 01 27 d1 	r0 = M[r5 + 388];
   push r0; 
84201854:	00 00 20 f3 	push r0;
   pop B5;
84201858:	00 00 d6 f3 	pop B5;
#endif 
   r0 = M[r5 + $celt.enc.PREEMPH_LEFT_AUDIO_FIELD];
8420185c:	d8 00 27 d1 	r0 = M[r5 + 216];
   I0 = r0;
84201860:	2f 00 00 50 	I0 = Null + r0;
   r3 = 0.5;//0.5; //scale factor
84201864:	00 40 00 fd 	r3 = Null + 1073741824;
84201868:	00 00 50 01 
   r0 = M[r5 + $celt.enc.CELT_CHANNELS_FIELD];
8420186c:	08 00 27 d1 	r0 = M[r5 + 8];
   M0 = r0 + 1;
84201870:	01 00 82 51 	M0 = r0 + 1;
   r4 = M[r5 + $celt.enc.MODE_E_PRED_COEF_FIELD];   //r0 = alpha
84201874:	50 00 67 d1 	r4 = M[r5 + 80];
   r4 = -r4;
84201878:	6f 00 60 20 	r4 = Null - r4;
   r4 = r4 * r3(frac);
8420187c:	00 00 65 97 	r4 = r4 * r3 (frac);
   r6 = r5;
84201880:	0f 00 87 00 	r6 = r5 + Null;
   r0 = M[r5 + $celt.enc.HIST_OLA_LEFT_FIELD];
84201884:	94 00 27 d1 	r0 = M[r5 + 148];
   I6 = r0;
84201888:	2f 00 60 50 	I6 = Null + r0;

8420188c <$M.celt.preemphasis.chan_loop>:
   chan_loop:
      I1 = I0;
8420188c:	0f 00 10 58 	I1 = I0 + Null;
      r0 = M[r5 + $celt.enc.MODE_OVERLAP_FIELD];
84201890:	40 00 27 d1 	r0 = M[r5 + 64];
      Words2Addr(r0);
84201894:	02 00 22 91 	r0 = r0 ASHIFT 2;
      I0 = I0 + r0;
84201898:	00 00 02 5b 	I0 = I0 + r0;
      r10 = M[r5 + $celt.enc.MODE_AUDIO_FRAME_SIZE_FIELD];
8420189c:	44 00 c7 d1 	r10 = M[r5 + 68];
      r10 = r10 - 1;
842018a0:	3f 00 cc e4 	r10 = r10 - 1;
      r2 = M[r6 + $celt.enc.PREEMPH_HIST_SAMPLE_FIELD];  
842018a4:	9c 00 48 d1 	r2 = M[r6 + 156];
      r1 = M[I5, 0];
842018a8:	34 00 00 03 	Null = Null + Null, r1 = M[I5,0];
      rMAC = r2 * r4, r2 = M[I5, MK1];
842018ac:	45 00 46 cf 	rMAC = r2 * r4 (SS), r2 = M[I5,4];
      do preemphasis_loop;
842018b0:	03 00 f0 e5 	do $M.celt.preemphasis.preemphasis_loop;
         rMAC = rMAC + r1 * r3, r1 = M[I5, 0];
842018b4:	34 00 35 af 	rMAC = rMAC + r1 * r3 (SS), r1 = M[I5,0];
         rMAC = r4 * r2, M[I0, MK1] = rMAC, r2 = M[I5, MK1];
842018b8:	45 91 64 cf 	rMAC = r4 * r2 (SS), M[I0,4] = rMAC, r2 = M[I5,4];

842018bc <$M.celt.preemphasis.preemphasis_loop>:
      preemphasis_loop:
      rMAC = rMAC + r1 * r3;
842018bc:	5f 00 13 ac 	rMAC = rMAC + r1 * r3 (SS);
      M[I0, MK1] = rMAC;
842018c0:	00 91 00 03 	Null = Null + Null, M[I0,4] = rMAC;
      M[r6 + $celt.enc.PREEMPH_HIST_SAMPLE_FIELD] = r2;      
842018c4:	9c 00 48 d5 	M[r6 + 156] = r2;
      
      // copy overlap
      r10 = M[r5 + $celt.enc.MODE_OVERLAP_FIELD];
842018c8:	40 00 c7 d1 	r10 = M[r5 + 64];
      Words2Addr(r10);
842018cc:	02 00 cc 91 	r10 = r10 ASHIFT 2;
      I0 = I0 - r10;
842018d0:	00 00 0c 7b 	I0 = I0 - r10;
      Addr2Words(r10);
842018d4:	fe 00 cc 91 	r10 = r10 ASHIFT -2;
      do copy_hist_ola_loop;
842018d8:	03 00 f0 e5 	do $M.celt.preemphasis.copy_hist_ola_loop;
         r0 = M[I0, MK1], r1 = M[I6, 0];
842018dc:	38 21 00 03 	Null = Null + Null, r0 = M[I0,4], r1 = M[I6,0];
         M[I1, MK1] = r1, M[I6, MK1] = r0;
842018e0:	a9 b5 00 03 	Null = Null + Null, M[I1,4] = r1, M[I6,4] = r0;

842018e4 <$M.celt.preemphasis.copy_hist_ola_loop>:
      copy_hist_ola_loop:
      
      // set up registers for second channel
      r0 = M[r5 + $celt.enc.SCRATCHVAR_RIGHT_IBUF_ADDR];
842018e4:	88 01 27 d1 	r0 = M[r5 + 392];
      r1 = M[r5 + $celt.enc.SCRATCHVAR_RIGHT_IBUF_LEN];
842018e8:	8c 01 37 d1 	r1 = M[r5 + 396];
      I5 = r0;
842018ec:	2f 00 50 50 	I5 = Null + r0;
      L5 = r1;
842018f0:	3f 00 f0 50 	L5 = Null + r1;

#ifdef BASE_REGISTER_MODE        
      r0 = M[r5 + $celt.enc.SCRATCHVAR_RIGHT_IBUF_START_ADDR];
842018f4:	90 01 27 d1 	r0 = M[r5 + 400];
      push r0;
842018f8:	00 00 20 f3 	push r0;
      pop B5;
842018fc:	00 00 d6 f3 	pop B5;
#endif      
      r6 = r6 + ADDR_PER_WORD;
84201900:	bf 00 88 e4 	r6 = r6 + 4;
      r0 = M[r5 + $celt.enc.PREEMPH_RIGHT_AUDIO_FIELD];
84201904:	24 01 27 d1 	r0 = M[r5 + 292];
      I0 = r0; 
84201908:	2f 00 00 50 	I0 = Null + r0;
      r0 = M[r5 + $celt.enc.HIST_OLA_RIGHT_FIELD];
8420190c:	98 00 27 d1 	r0 = M[r5 + 152];
      I6 = r0;
84201910:	2f 00 60 50 	I6 = Null + r0;
      // run for right channel if exisiting
      M0 = M0 - 1;
84201914:	01 00 88 79 	M0 = M0 - 1;
   if NZ jump chan_loop;   
84201918:	dd ff 10 dd 	if NE jump $M.celt.preemphasis.chan_loop;
   L5 = 0;
8420191c:	00 00 f0 51 	L5 = Null + 0;
#ifdef BASE_REGISTER_MODE  
   push Null;
84201920:	00 00 00 f3 	push Null;
   pop B5;
84201924:	00 00 d6 f3 	pop B5;
#endif
   
   rts;   
84201928:	0f 00 0d dc 	rts;

8420192c <$celt.quant_coarse_energy>:
8420192c:	01 20 00 f1 	pushm <FP(=SP), rLink>;
   .CONST TEMP                 (4 + 2)*ADDR_PER_WORD;
   .CONST BUDGET               (7 + 2)*ADDR_PER_WORD;
   .CONST COUNTER              (8 + 2)*ADDR_PER_WORD;
   .CONST STACK_FRAME_SIZE     9*ADDR_PER_WORD;
   pushm <FP(=SP), rLink>;
   SP = SP + STACK_FRAME_SIZE;
84201930:	24 00 03 f1 	SP = SP + 36;

   // reset prev for both channels
   M[FP + PREV] = Null;
84201934:	10 00 0c f1 	M[FP + 0x10] = Null;
   M[FP + PREV + 1*MK1] = Null;
84201938:	14 00 0c f1 	M[FP + 0x14] = Null;
   r1 = M[r5 + $celt.enc.MODE_PROB_ADDR_FIELD];
8420193c:	6c 00 37 d1 	r1 = M[r5 + 108];
   I7 = r1;
84201940:	3f 00 70 50 	I7 = Null + r1;
   r2 = M[r5 + $celt.enc.MODE_NB_EBANDS_FIELD];
84201944:	48 00 47 d1 	r2 = M[r5 + 72];
   M[FP + COUNTER] = r2;
84201948:	28 00 4c f1 	M[FP + 0x28] = r2;
   r0 = M[r5 + $celt.enc.MODE_E_PRED_COEF_FIELD];
8420194c:	50 00 27 d1 	r0 = M[r5 + 80];
   // calc coef
   Null = M[r5 + $celt.enc.INTRA_ENER_FIELD];
84201950:	54 01 07 d1 	Null = M[r5 + 340];
   if Z jump intra_end;
84201954:	05 00 00 dd 	if EQ jump $M.celt.quant_coarse_energy.intra_end;
      r0 = r2 + r2;
84201958:	4f 00 24 00 	r0 = r2 + r2;
      Words2Addr(r0);
8420195c:	02 00 22 91 	r0 = r0 ASHIFT 2;
      I7 = I7 + r0;
84201960:	00 00 72 5b 	I7 = I7 + r0;
      r0 = 0;       
84201964:	00 00 20 01 	r0 = Null + 0;

84201968 <$M.celt.quant_coarse_energy.intra_end>:
   intra_end:
   M[FP + COEF] = r0;
84201968:	08 00 2c f1 	M[FP + 0x8] = r0;
   r0 = r0 * 0.8 (frac);
8420196c:	66 66 00 fd 	r0 = r0 * 0.799999999813735485076904296875 (frac);
84201970:	66 66 22 95 
   M[FP + BETA] = r0;
84201974:	0c 00 2c f1 	M[FP + 0xc] = r0;
   
   // calc budget
   r1 = M[r5 + $celt.enc.CELT_CODEC_FRAME_SIZE_FIELD];
84201978:	04 00 37 d1 	r1 = M[r5 + 4];
   r1 = r1 LSHIFT 2;
8420197c:	02 00 33 8d 	r1 = r1 LSHIFT 2;
   r1 = r1 - 8; // budget
84201980:	08 00 33 21 	r1 = r1 - 8;
   M[FP + BUDGET] = r1;
84201984:	24 00 3c f1 	M[FP + 0x24] = r1;
#ifdef CELT_USE_EXTERNAL_MEMORY
   r0 = M[r5 + $celt.enc.PTR_EMEANS_TABLE_FIELD];
84201988:	14 02 27 d1 	r0 = M[r5 + 532];
   I2 = r0;
8420198c:	2f 00 20 50 	I2 = Null + r0;
#else // CELT_USE_EXTERNAL_MEMORY
   I2 = &$celt.eMeans;
#endif // CELT_USE_EXTERNAL_MEMORY
   r0 = M[r5 + $celt.enc.OLD_EBAND_LEFT_FIELD];
84201990:	8c 00 27 d1 	r0 = M[r5 + 140];
   I3 = r0; 
84201994:	2f 00 30 50 	I3 = Null + r0;
   r0 = FP + PREV;
84201998:	10 00 27 f1 	r0 = FP + 16;
   I4 = r0;
8420199c:	2f 00 40 50 	I4 = Null + r0;
   M2 = 0;
842019a0:	00 00 a0 51 	M2 = Null + 0;
   r0 = M[r5 + $celt.enc.LOG_BANDE_FIELD];
842019a4:	dc 00 27 d1 	r0 = M[r5 + 220];
   I5 = r0;
842019a8:	2f 00 50 50 	I5 = Null + r0;
   r0 = M[r5 + $celt.enc.BAND_ERROR_FIELD];
842019ac:	e0 00 27 d1 	r0 = M[r5 + 224];
   I6 = r0;
842019b0:	2f 00 60 50 	I6 = Null + r0;
   //I3=oldEband
   //I4=prev
   //I5=logband
   //I6=error
   //I7=prob
   r4 = 0;
842019b4:	00 00 60 01 	r4 = Null + 0;

842019b8 <$M.celt.quant_coarse_energy.loop_encode_coarse>:
   loop_encode_coarse:
      call run_ch;
842019b8:	15 00 f0 e1 	call $M.celt.quant_coarse_energy.run_ch;
      
      r0 = M[r5 + $celt.enc.CELT_CHANNELS_FIELD];
842019bc:	08 00 27 d1 	r0 = M[r5 + 8];
      if Z jump end_ch;
842019c0:	0c 00 00 dd 	if EQ jump $M.celt.quant_coarse_energy.end_ch;
      I2 = I2 - 1 * MK1;
842019c4:	04 00 22 79 	I2 = I2 - 4;
      I3 = I3 + ($celt.MAX_BANDS-1)*MK1;
842019c8:	60 00 33 59 	I3 = I3 + 96;
      I4 = I4 + 1*MK1;
842019cc:	04 00 44 59 	I4 = I4 + 4;
      I5 = I5 + ($celt.MAX_BANDS-1)*MK1;
842019d0:	60 00 55 59 	I5 = I5 + 96;
      I6 = I6 + ($celt.MAX_BANDS-1)*MK1;
842019d4:	60 00 66 59 	I6 = I6 + 96;
      I7 = I7 - 2*MK1;
842019d8:	08 00 77 79 	I7 = I7 - 8;
      call run_ch;
842019dc:	0c 00 f0 e1 	call $M.celt.quant_coarse_energy.run_ch;
      I3 = I3 - ($celt.MAX_BANDS*MK1);
842019e0:	64 00 33 79 	I3 = I3 - 100;
      I4 = I4 - 1*MK1;
842019e4:	04 00 44 79 	I4 = I4 - 4;
      I5 = I5 - ($celt.MAX_BANDS*MK1);
842019e8:	64 00 55 79 	I5 = I5 - 100;
      I6 = I6 - ($celt.MAX_BANDS*MK1);
842019ec:	64 00 66 79 	I6 = I6 - 100;

842019f0 <$M.celt.quant_coarse_energy.end_ch>:
      end_ch:
      r0 = M[FP + COUNTER];
842019f0:	28 00 28 f1 	r0 = M[FP + 0x28];
      r0 = r0 - 1;
842019f4:	3f 00 22 e4 	r0 = r0 - 1;
      M[FP + COUNTER] = r0;
842019f8:	28 00 2c f1 	M[FP + 0x28] = r0;
   if NZ jump loop_encode_coarse;
842019fc:	ef ff 10 dd 	if NE jump $M.celt.quant_coarse_energy.loop_encode_coarse;
 
   // pop rLink from stack
   SP = SP - STACK_FRAME_SIZE;
84201a00:	dc ff 03 f1 	SP = SP + -36;
   popm <FP,rLink>;
84201a04:	01 20 04 f1 	popm <FP, rLink>;
   rts;
84201a08:	0f 00 0d dc 	rts;

84201a0c <$M.celt.quant_coarse_energy.run_ch>:
   run_ch:
      push rlink;
84201a0c:	00 00 d0 f3 	push rLink;
      M[FP + TEMP + 1*MK1] = Null;
84201a10:	1c 00 0c f1 	M[FP + 0x1c] = Null;
      call $celt.ec_enc_tell;    
84201a14:	71 02 f0 e1 	call $celt.ec_enc_tell;
      r1 = M[FP + BUDGET];
84201a18:	24 00 38 f1 	r1 = M[FP + 0x24];
      Null = r0 - r1;      
84201a1c:	3f 00 02 20 	Null = r0 - r1;
      if LE jump calc_q;
84201a20:	05 00 d0 dd 	if LE jump $M.celt.quant_coarse_energy.calc_q;
         r1 = -1;
84201a24:	3f 00 30 e4 	r1 = Null - 1;
         r2 = 1.0;
84201a28:	ff 7f 00 fd 	r2 = Null + 2147483647;
84201a2c:	ff ff 40 01 
         jump set_error;
84201a30:	16 00 f0 dd 	jump $M.celt.quant_coarse_energy.set_error;

84201a34 <$M.celt.quant_coarse_energy.calc_q>:
      calc_q:
      r0 = M[I2, MK1];
84201a34:	00 29 00 03 	Null = Null + Null, r0 = M[I2,4];
#ifdef CELT_USE_EXTERNAL_MEMORY
      r7 = M[r5 + $celt.enc.PTR_EMEANS_TABLE_FIELD];
84201a38:	14 02 97 d1 	r7 = M[r5 + 532];
      r7 = r7 + $celt.E_MEANS_SIZE*MK1;
84201a3c:	14 00 99 01 	r7 = r7 + 20;
      Null = I2 - r7;
84201a40:	9f 00 02 68 	Null = I2 - r7;
#else // CELT_USE_EXTERNAL_MEMORY
      Null = I2 - (&$celt.eMeans + $celt.E_MEANS_SIZE*MK1);
#endif // CELT_USE_EXTERNAL_MEMORY
      if GT r0 = r0 - r0;  //r1=eBand=x     
84201a44:	2c 00 22 20 	if GT r0 = r0 - r0;
      M[FP + TEMP + 1*MK1] = r0;
84201a48:	1c 00 2c f1 	M[FP + 0x1c] = r0;
      r7 = M[FP + COEF];      
84201a4c:	08 00 98 f1 	r7 = M[FP + 0x8];
      r2 = r7*r0(frac);
84201a50:	2f 00 49 94 	r2 = r7 * r0 (frac);
      r2 = r2 - r0, r1 = M[I5, MK1];        //r0 =oldBand, r2 = -mean
84201a54:	35 00 42 23 	r2 = r2 - r0, r1 = M[I5,4];
      r1 = r1 + r2, r0 = M[I3, 0];
84201a58:	00 2c 34 03 	r1 = r1 + r2, r0 = M[I3,0];
      r0 = r0*r7(frac), r3 = M[I4, 0];
84201a5c:	50 00 29 97 	r0 = r0 * r7 (frac), r3 = M[I4,0];
      r1 = r1 - r0, r2 = M[I7, MK1];
84201a60:	4d 00 32 23 	r1 = r1 - r0, r2 = M[I7,4];
      r1 = r1 - r3, r3 = M[I7, MK1];
84201a64:	5d 00 35 23 	r1 = r1 - r3, r3 = M[I7,4];
      M[FP + TEMP + 0] = r1;
84201a68:	18 00 3c f1 	M[FP + 0x18] = r1;
      r1 = r1*128(frac);
84201a6c:	00 00 00 fd 	r1 = r1 * 5.9604644775390625e-08 (frac);
84201a70:	80 00 33 95 
      call $celt.ec_laplace_encode_start;
84201a74:	c6 0f f0 e1 	call $celt.ec_laplace_encode_start;
      r2 = r1*(-1.0/128.0)(int);
84201a78:	00 ff 00 fd 	r2 = r1 * -16777216 (int);
84201a7c:	00 00 43 99 
      r0 = M[FP + TEMP + 0];
84201a80:	18 00 28 f1 	r0 = M[FP + 0x18];
      r2 = r2 + r0;      
84201a84:	00 00 42 03 	r2 = r2 + r0;

84201a88 <$M.celt.quant_coarse_energy.set_error>:
      set_error:
      M[I6, MK1] = r2;
84201a88:	c9 00 00 03 	Null = Null + Null, M[I6,4] = r2;
      r1 = r1 ASHIFT (DAWTH-8);
84201a8c:	18 00 33 91 	r1 = r1 ASHIFT 24;
      r0 = M[FP + TEMP + 1*MK1];
84201a90:	1c 00 28 f1 	r0 = M[FP + 0x1c];
      r4 = M[I4, 0];                            //r4 = p
84201a94:	60 00 00 03 	Null = Null + Null, r4 = M[I4,0];
      r4 = r4 + r0, r2 = M[I3, 0];              //r4 = m+ p, r2 =b
84201a98:	00 4c 62 03 	r4 = r4 + r0, r2 = M[I3,0];
      r4 = r4 + r1;                             //r4 = m+p+q
84201a9c:	00 00 63 03 	r4 = r4 + r1;
      r7 = M[FP + COEF];                             //r7 = c
84201aa0:	08 00 98 f1 	r7 = M[FP + 0x8];
      r3 = r2 - r0;                             //r3 = b -m
84201aa4:	2f 00 54 20 	r3 = r2 - r0;
      r3 = r3 * r7 (frac);                      //r3 = (b-m)*c
84201aa8:	00 00 59 97 	r3 = r3 * r7 (frac);
      r3 = r3 + r4;                             //r3 -->b
84201aac:	00 00 56 03 	r3 = r3 + r4;
      rMAC = r0*r7;
84201ab0:	9f 00 12 cc 	rMAC = r0 * r7 (SS);
      r0 = M[FP + BETA];
84201ab4:	0c 00 28 f1 	r0 = M[FP + 0xc];
      rMAC = rMAC + r1*r0, M[I3, MK1] = r3;       //save C-Energy
84201ab8:	00 dd 32 af 	rMAC = rMAC + r1 * r0 (SS), M[I3,4] = r3;
      r4 = r4 - rMAC;
84201abc:	00 00 61 23 	r4 = r4 - rMAC;
      r4 = 0, M[I4, 0] = r4;                    //save prev
84201ac0:	e0 00 66 23 	r4 = r4 - r4, M[I4,0] = r4;
      jump $pop_rLink_and_rts;
84201ac4:	03 00 00 fd 	jump (m) 0x3b020;
84201ac8:	21 b0 f0 dd 

84201acc <$celt.quant_fine_energy>:
#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.QUANT_FINE_ENERGY.PATCH_ID_0,r2)     // celt_patchers
#endif  

   // push rLink onto stack
   push rlink;
84201acc:	00 00 d0 f3 	push rLink;
   r0 = M[r5 + $celt.enc.MODE_NB_EBANDS_FIELD];
84201ad0:	48 00 27 d1 	r0 = M[r5 + 72];
   M3 = r0;
84201ad4:	2f 00 b0 50 	M3 = Null + r0;
   r0 = M[r5 + $celt.enc.FINE_QUANT_FIELD];
84201ad8:	08 01 27 d1 	r0 = M[r5 + 264];
   I2 = r0;
84201adc:	2f 00 20 50 	I2 = Null + r0;
   r0 = M[r5 + $celt.enc.OLD_EBAND_LEFT_FIELD];
84201ae0:	8c 00 27 d1 	r0 = M[r5 + 140];
   I3 = r0;
84201ae4:	2f 00 30 50 	I3 = Null + r0;
   M0 = 1;
84201ae8:	01 00 80 51 	M0 = Null + 1;
   r0 = M[r5 + $celt.enc.CELT_CHANNELS_FIELD];
84201aec:	08 00 27 d1 	r0 = M[r5 + 8];
   I6 = r0;
84201af0:	2f 00 60 50 	I6 = Null + r0;
   r0 = M[r5 + $celt.enc.BAND_ERROR_FIELD];
84201af4:	e0 00 27 d1 	r0 = M[r5 + 224];
   I5 = r0 - 1*MK1;
84201af8:	04 00 52 71 	I5 = r0 - 4;

84201afc <$M.celt.quant_fine_energy.fine_quant_loop>:
   fine_quant_loop:
      r2 = M[I2, MK1], r0 = M[I5, MK1];
84201afc:	25 49 00 03 	Null = Null + Null, r2 = M[I2,4], r0 = M[I5,4];
      M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FTB] = r2;
84201b00:	e4 01 47 d5 	M[r5 + 484] = r2;
      if LE jump b_loop;
84201b04:	0b 00 d0 dd 	if LE jump $M.celt.quant_fine_energy.b_loop;
      push r2;
84201b08:	00 00 40 f3 	push r2;
      call run_ch;
84201b0c:	0d 00 f0 e1 	call $M.celt.quant_fine_energy.run_ch;
      pop r2;
84201b10:	00 00 44 f3 	pop r2;
      r0 = M[r5 + $celt.enc.CELT_CHANNELS_FIELD];
84201b14:	08 00 27 d1 	r0 = M[r5 + 8];
      if Z jump end_ch;
84201b18:	06 00 00 dd 	if EQ jump $M.celt.quant_fine_energy.b_loop;
      I3 = I3 + ($celt.MAX_BANDS*MK1);
84201b1c:	64 00 33 59 	I3 = I3 + 100;
      I5 = I5 + ($celt.MAX_BANDS*MK1);
84201b20:	64 00 55 59 	I5 = I5 + 100;
      call run_ch;
84201b24:	07 00 f0 e1 	call $M.celt.quant_fine_energy.run_ch;
      I3 = I3 - ($celt.MAX_BANDS*MK1);
84201b28:	64 00 33 79 	I3 = I3 - 100;
      I5 = I5 - ($celt.MAX_BANDS*MK1);
84201b2c:	64 00 55 79 	I5 = I5 - 100;

84201b30 <$M.celt.quant_fine_energy.b_loop>:
      end_ch:         
      b_loop:
      M3 = M3 - M0, r0 = M[I3, MK1];
84201b30:	00 2d b8 7f 	M3 = M3 - M0, r0 = M[I3,4];
   if NZ jump fine_quant_loop;
84201b34:	f2 ff 10 dd 	if NE jump $M.celt.quant_fine_energy.fine_quant_loop;
   
   // pop rLink from stack
   jump $pop_rLink_and_rts;
84201b38:	03 00 00 fd 	jump (m) 0x3b020;
84201b3c:	21 b0 f0 dd 

84201b40 <$M.celt.quant_fine_energy.run_ch>:
   run_ch:
   push rlink;
84201b40:	00 00 d0 f3 	push rLink;
   r0 = M[I5, 0];
84201b44:	24 00 00 03 	Null = Null + Null, r0 = M[I5,0];
#ifndef K32   
   r0 = r0 + 0x8000;   //TODO:make sure sat avoided
#else
   r0 = r0 + 0x800000; //TODO:make sure sat avoided
84201b48:	80 00 00 fd 	r0 = r0 + 8388608;
84201b4c:	00 00 22 01 
#endif   
   r1 = r2 - (DAWTH-8);
84201b50:	18 00 34 21 	r1 = r2 - 24;
   r0 = r0 ASHIFT r1;
84201b54:	00 00 23 93 	r0 = r0 ASHIFT r1;
   r1 = 1 LSHIFT r2;
84201b58:	01 00 34 e9 	r1 = 0x1 LSHIFT r2;
   r1 = r1 - 1;
84201b5c:	3f 00 33 e4 	r1 = r1 - 1;
   Null = r0 - r1;
84201b60:	3f 00 02 20 	Null = r0 - r1;
   if POS r0 = r1;
84201b64:	05 00 23 00 	if POS r0 = r1 + Null;
#ifndef K32   
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FL + 0] = r0;
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FL + 1] = Null;
#else
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FL] = r0;
84201b68:	d4 01 27 d5 	M[r5 + 468] = r0;
#endif   
   r1 = r0 + r0;
84201b6c:	2f 00 32 00 	r1 = r0 + r0;
   r1 = r1 + 1;
84201b70:	2f 00 33 e4 	r1 = r1 + 1;
   r2 = (DAWTH-9) - r2;
84201b74:	17 00 44 65 	r2 = 23 - r2;
   r1 = r1 ASHIFT r2, r0 = M[I3, 0];
84201b78:	00 2c 34 93 	r1 = r1 ASHIFT r2, r0 = M[I3,0];
#ifndef K32
   r1 = r1 - 0x8000;   
#else
   r1 = r1 - 0x800000;   
84201b7c:	80 00 00 fd 	r1 = r1 - 8388608;
84201b80:	00 00 33 21 
#endif   
   r0 = r0 + r1, r2 = M[I5, 0];
84201b84:	44 00 23 03 	r0 = r0 + r1, r2 = M[I5,0];
   r2 = r2 - r1, M[I3, 0] = r0;
84201b88:	00 ac 43 23 	r2 = r2 - r1, M[I3,0] = r0;
   M[I5, 0] = r2;
84201b8c:	c4 00 00 03 	Null = Null + Null, M[I5,0] = r2;
   call $celt.ec_enc_bits;
84201b90:	34 02 f0 e1 	call $celt.ec_enc_bits;
   // pop rLink from stack
   jump $pop_rLink_and_rts;  
84201b94:	03 00 00 fd 	jump (m) 0x3b020;
84201b98:	21 b0 f0 dd 

84201b9c <$celt.quant_energy_finalise>:
#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.QUANT_ENERGY_FINALISE.PATCH_ID_0,r1)     // celt_patchers
#endif 
   
   // push rLink onto stack
   push rlink;
84201b9c:	00 00 d0 f3 	push rLink;
   
   // work out bits left
   r4 = 0;
84201ba0:	00 00 60 01 	r4 = Null + 0;
   call $celt.ec_enc_tell;
84201ba4:	0d 02 f0 e1 	call $celt.ec_enc_tell;
   r1 = M[r5 + $celt.enc.CELT_CODEC_FRAME_SIZE_FIELD];
84201ba8:	04 00 37 d1 	r1 = M[r5 + 4];
   r1 = r1 * 8(int);
84201bac:	08 00 33 99 	r1 = r1 * 8 (int);
   M2 = r1 - r0;
84201bb0:	2f 00 a3 70 	M2 = r1 - r0;
   
   // mono/stereo 
   r0 = M[r5 + $celt.enc.CELT_CHANNELS_FIELD];
84201bb4:	08 00 27 d1 	r0 = M[r5 + 8];
   I6 = r0;
84201bb8:	2f 00 60 50 	I6 = Null + r0;
   M3 = 1;
84201bbc:	01 00 b0 51 	M3 = Null + 1;

84201bc0 <$M.celt.quant_energy_finalise.prio_loop>:
   prio_loop:
      r10 = M[r5 + $celt.enc.MODE_NB_EBANDS_FIELD];
84201bc0:	48 00 c7 d1 	r10 = M[r5 + 72];
      r0 = M[r5 + $celt.enc.FINE_QUANT_FIELD];
84201bc4:	08 01 27 d1 	r0 = M[r5 + 264];
      I2 = r0;
84201bc8:	2f 00 20 50 	I2 = Null + r0;
      r0 = M[r5 + $celt.enc.OLD_EBAND_LEFT_FIELD];
84201bcc:	8c 00 27 d1 	r0 = M[r5 + 140];
      I3 = r0;
84201bd0:	2f 00 30 50 	I3 = Null + r0;
      I4 = r0 + ($celt.MAX_BANDS*MK1);
84201bd4:	64 00 42 51 	I4 = r0 + 100;
      r0 = M[r5 + $celt.enc.FINE_PRIORITY_FIELD];
84201bd8:	0c 01 27 d1 	r0 = M[r5 + 268];
      I5 = r0;
84201bdc:	2f 00 50 50 	I5 = Null + r0;
      r0 = M[r5 + $celt.enc.BAND_ERROR_FIELD];
84201be0:	e0 00 27 d1 	r0 = M[r5 + 224];
      I7 = r0;
84201be4:	2f 00 70 50 	I7 = Null + r0;
      do finalise_loop;
84201be8:	29 00 f0 e5 	do $M.celt.quant_energy_finalise.end_finalise_loop;
         r0 = M[r5 + $celt.enc.CELT_CHANNELS_FIELD];
84201bec:	08 00 27 d1 	r0 = M[r5 + 8];
         Null = M2 - r0;
84201bf0:	2f 00 0a 68 	Null = M2 - r0;
         if LE jump end_finalise_loop;
84201bf4:	26 00 d0 dd 	if LE jump $M.celt.quant_energy_finalise.end_finalise_loop;
         r0 = M[I2, 0], r1 = M[I5, 0];
84201bf8:	34 28 00 03 	Null = Null + Null, r0 = M[I2,0], r1 = M[I5,0];
         Null = r0 - 7;
84201bfc:	07 00 02 21 	Null = r0 - 7;
         if POS jump next_fin;
84201c00:	20 00 50 dd 	if POS jump $M.celt.quant_energy_finalise.next_fin;
         Null = r1 - M3;
84201c04:	bf 00 03 64 	Null = r1 - M3;
         if Z jump next_fin;
84201c08:	1e 00 00 dd 	if EQ jump $M.celt.quant_energy_finalise.next_fin;
            r2 = 1;
84201c0c:	2f 00 40 e4 	r2 = Null + 1;
            M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FTB] = r2;
84201c10:	e4 01 47 d5 	M[r5 + 484] = r2;
            r1 = M[I7, 0];
84201c14:	3c 00 00 03 	Null = Null + Null, r1 = M[I7,0];
            Null = r1;
84201c18:	0f 00 03 00 	Null = r1 + Null;
            if NEG r2 = 0;
84201c1c:	04 00 40 00 	if NEG r2 = Null + Null;
#ifndef K32            
            M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FL + 0] = r2;
            M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FL + 1] = Null;
#else 
            M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FL] = r2;                 
84201c20:	d4 01 47 d5 	M[r5 + 468] = r2;
#endif            
            call $celt.ec_enc_bits;
84201c24:	0f 02 f0 e1 	call $celt.ec_enc_bits;
            //calc offset
            r0 = M[I7, 0];
84201c28:	2c 00 00 03 	Null = Null + Null, r0 = M[I7,0];
            r0 = r0 + r0, r2 = M[I2, 0];
84201c2c:	00 48 22 03 	r0 = r0 + r0, r2 = M[I2,0];
            r0 = r0 - 1;
84201c30:	3f 00 22 e4 	r0 = r0 - 1;
            r2 = 14 - r2;
84201c34:	0e 00 44 65 	r2 = 14 - r2;
            r0 = r0 ASHIFT r2, r1 = M[I3, 0];
84201c38:	00 3c 24 93 	r0 = r0 ASHIFT r2, r1 = M[I3,0];
            r0 = r0 + r1;
84201c3c:	00 00 23 03 	r0 = r0 + r1;
            M2 = M2 -1;
84201c40:	01 00 aa 79 	M2 = M2 - 1;
            Null = I6, M[I3, 0] = r0;
84201c44:	00 ac 06 47 	Null = Null + I6, M[I3,0] = r0;
            if Z jump next_fin;
84201c48:	0e 00 00 dd 	if EQ jump $M.celt.quant_energy_finalise.next_fin;
            I7 = I7 + ($celt.MAX_BANDS*MK1);
84201c4c:	64 00 77 59 	I7 = I7 + 100;
            r1 = M[I7, 0];
84201c50:	3c 00 00 03 	Null = Null + Null, r1 = M[I7,0];
#ifndef K32            
            M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FL + 0] = r1;
            M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FL + 1] = Null;
#else
            M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FL] = r1;
84201c54:	d4 01 37 d5 	M[r5 + 468] = r1;
#endif            
            call $celt.ec_enc_bits;
84201c58:	02 02 f0 e1 	call $celt.ec_enc_bits;
            r0 = M[I7, 0];
84201c5c:	2c 00 00 03 	Null = Null + Null, r0 = M[I7,0];
            r0 = r0 + r0, r2 = M[I2, 0];
84201c60:	00 48 22 03 	r0 = r0 + r0, r2 = M[I2,0];
            r0 = r0 - 1;
84201c64:	3f 00 22 e4 	r0 = r0 - 1;
            r2 = 14 - r2;
84201c68:	0e 00 44 65 	r2 = 14 - r2;
            r0 = r0 ASHIFT r2, r1 = M[I4, 0];
84201c6c:	30 00 24 93 	r0 = r0 ASHIFT r2, r1 = M[I4,0];
            r0 = r0 + r1;
84201c70:	00 00 23 03 	r0 = r0 + r1;
            M[I4, 0] = r0;
84201c74:	a0 00 00 03 	Null = Null + Null, M[I4,0] = r0;
            M2 = M2 -1;
84201c78:	01 00 aa 79 	M2 = M2 - 1;
            I7 = I7 - ($celt.MAX_BANDS*MK1);
84201c7c:	64 00 77 79 	I7 = I7 - 100;

84201c80 <$M.celt.quant_energy_finalise.next_fin>:
            next_fin:
            r0 = M[I2, MK1], r1 = M[I5, MK1];
84201c80:	35 29 00 03 	Null = Null + Null, r0 = M[I2,4], r1 = M[I5,4];
            r0 = M[I3, MK1], r1 = M[I7, MK1];
84201c84:	3d 2d 00 03 	Null = Null + Null, r0 = M[I3,4], r1 = M[I7,4];
            r1 = M[I4, MK1]; 
84201c88:	31 00 00 03 	Null = Null + Null, r1 = M[I4,4];

84201c8c <$M.celt.quant_energy_finalise.end_finalise_loop>:
        finalise_loop:
        end_finalise_loop:
   M3 = M3 - 1;
84201c8c:	01 00 bb 79 	M3 = M3 - 1;
   if Z jump prio_loop;
84201c90:	cc ff 00 dd 	if EQ jump $M.celt.quant_energy_finalise.prio_loop;

   // calculate non-logarithmic bands Energies
   r0 = M[r5 + $celt.enc.OLD_EBAND_LEFT_FIELD];
84201c94:	8c 00 27 d1 	r0 = M[r5 + 140];
   I3 = r0;
84201c98:	2f 00 30 50 	I3 = Null + r0;
   r0 = M[r5 + $celt.enc.BANDE_FIELD];
84201c9c:	d0 00 27 d1 	r0 = M[r5 + 208];
   I2 = r0;
84201ca0:	2f 00 20 50 	I2 = Null + r0;
   I4 = I2 + ($celt.MAX_BANDS*MK1);
84201ca4:	64 00 42 59 	I4 = I2 + 100;
   r0 = M[r5 + $celt.enc.CELT_CHANNELS_FIELD];
84201ca8:	08 00 27 d1 	r0 = M[r5 + 8];
   M3 = r0 + 1;
84201cac:	01 00 b2 51 	M3 = r0 + 1;
   r8 = M[r5 + $celt.enc.CELT_MODE_OBJECT_FIELD];
84201cb0:	00 00 a7 d1 	r8 = M[r5 + 0];

84201cb4 <$M.celt.quant_energy_finalise.calc_ebands>:
   calc_ebands:
   r10 = M[r5 + $celt.enc.MODE_NB_EBANDS_FIELD];
84201cb4:	48 00 c7 d1 	r10 = M[r5 + 72];
   do comp_ebands_loop_ch;
84201cb8:	12 00 f0 e5 	do $M.celt.quant_energy_finalise.comp_ebands_loop_ch;
      r0 = M[I3, 0];
84201cbc:	00 2c 00 03 	Null = Null + Null, r0 = M[I3,0];
      r4 = 0;
84201cc0:	00 00 60 01 	r4 = Null + 0;
      r1 = r0 ASHIFT -(DAWTH-8);
84201cc4:	e8 00 32 91 	r1 = r0 ASHIFT -24;
      if NEG jump calc_log;
84201cc8:	04 00 40 dd 	if NEG jump $M.celt.quant_energy_finalise.calc_log;
         r4 = r1 + 1;
84201ccc:	2f 00 63 e4 	r4 = r1 + 1;
         r1 = r4 ASHIFT (DAWTH-8);
84201cd0:	18 00 36 91 	r1 = r4 ASHIFT 24;
         r0 = r0 - r1;
84201cd4:	00 00 23 23 	r0 = r0 - r1;

84201cd8 <$M.celt.quant_energy_finalise.calc_log>:
      calc_log:
      call $math.pow2_table;
84201cd8:	07 00 00 fd 	call 0x74514;
84201cdc:	14 45 f0 e1 
      r4 = r4 - 12;
84201ce0:	0c 00 66 21 	r4 = r4 - 12;
      // store E in the form of a gain and a shift value
      M[I4, MK1] = r4; 
84201ce4:	e1 00 00 03 	Null = Null + Null, M[I4,4] = r4;
      M[I2, MK1] = r0;
84201ce8:	00 a9 00 03 	Null = Null + Null, M[I2,4] = r0;

      // minimum energy clipping
      r0 = M[I3, 0];
84201cec:	00 2c 00 03 	Null = Null + Null, r0 = M[I3,0];
      r1 = r0 + 0.0546875;
84201cf0:	00 07 00 fd 	r1 = r0 + 117440512;
84201cf4:	00 00 32 01 
      if NEG r0 = r0 - r1;
84201cf8:	34 00 22 20 	if NEG r0 = r0 - r1;
      M[I3, MK1] = r0;
84201cfc:	00 ad 00 03 	Null = Null + Null, M[I3,4] = r0;

84201d00 <$M.celt.quant_energy_finalise.comp_ebands_loop_ch>:
   comp_ebands_loop_ch:
   r0 = M[r5 + $celt.enc.OLD_EBAND_LEFT_FIELD];
84201d00:	8c 00 27 d1 	r0 = M[r5 + 140];
   I3 = r0 + ($celt.MAX_BANDS*MK1);
84201d04:	64 00 32 51 	I3 = r0 + 100;
   r0 = M[r5 + $celt.enc.BANDE_FIELD];
84201d08:	d0 00 27 d1 	r0 = M[r5 + 208];
   I2 = r0 + (2*$celt.MAX_BANDS*MK1);
84201d0c:	c8 00 22 51 	I2 = r0 + 200;
   I4 = I2 + ($celt.MAX_BANDS*MK1);
84201d10:	64 00 42 59 	I4 = I2 + 100;
   M3 = M3 - 1;
84201d14:	01 00 bb 79 	M3 = M3 - 1;
   if NZ jump calc_ebands;
84201d18:	e7 ff 10 dd 	if NE jump $M.celt.quant_energy_finalise.calc_ebands;
 
   // pop rLink from stack
   jump $pop_rLink_and_rts;
84201d1c:	03 00 00 fd 	jump (m) 0x3b020;
84201d20:	21 b0 f0 dd 

84201d24 <$celt.ec_dec_init>:
84201d24:	00 00 d0 f3 	push rLink;

   // push rLink onto stack
   push rlink;

   // get rem
   call $celt.get1byte;
84201d28:	c5 0e f0 e1 	call $celt.get1byte;
   M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_REM] = r1;
84201d2c:	a4 01 37 d5 	M[r5 + 420] = r1;
   
   // init rng
   r2 = 1<<$celt.EC_CODE_EXTRA;
84201d30:	80 00 40 01 	r2 = Null + 128;
   M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_RNG + 0] = r2;
84201d34:	a8 01 47 d5 	M[r5 + 424] = r2;
   M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_RNG + MK1] = 0;
84201d38:	ac 01 07 d5 	M[r5 + 428] = Null;

   // init diff
   r1 = r1 LSHIFT (-$celt.EC_SYM_BITS+$celt.EC_CODE_EXTRA);
84201d3c:	ff 00 33 8d 	r1 = r1 LSHIFT -1;
   r1 = r2 - r1; // 0x80 - (r1>>1), (borrow impossible)
84201d40:	3f 00 34 20 	r1 = r2 - r1;
   r2 = Null - Null -borrow;
84201d44:	0f 00 40 24 	r2 = Null - Null - Borrow;
#ifdef K32
   $celt.NATIVE_WORD32_CONVERT(r2,r1)
84201d48:	18 00 44 8d 	r2 = r2 LSHIFT 24;
84201d4c:	00 00 34 87 	r1 = r1 OR r2;
84201d50:	00 00 40 01 	r2 = Null + 0;
#endif
   M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_DIF + 0] = r1;
84201d54:	b0 01 37 d5 	M[r5 + 432] = r1;
   M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_DIF + MK1] = r2;
84201d58:	b4 01 47 d5 	M[r5 + 436] = r2;

   // Normalise the interval
   call $celt.ec_dec_normalise;
84201d5c:	05 00 f0 e1 	call $celt.ec_dec_normalise;

   // reset bits reading from end of buffer
   M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_END_BITS_LEFT] = Null;
84201d60:	c4 01 07 d5 	M[r5 + 452] = Null;
   M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_NB_END_BITS] = Null;
84201d64:	c8 01 07 d5 	M[r5 + 456] = Null;



   // pop rLink from stack
   jump $pop_rLink_and_rts;
84201d68:	03 00 00 fd 	jump (m) 0x3b020;
84201d6c:	21 b0 f0 dd 

84201d70 <$celt.ec_dec_normalise>:
#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.EC_DEC_NORMALISE.PATCH_ID_0,r4)     // celt_patchers
#endif
   
   // push rLink onto stack
    push rlink;
84201d70:	00 00 d0 f3 	push rLink;
   M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_DIF + MK1] = r8;

#else // K32

   // rng=r4
   r4 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_RNG];
84201d74:	a8 01 67 d1 	r4 = M[r5 + 424];
   // rem = rMAC
   rMAC = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_REM];
84201d78:	a4 01 17 d1 	rMAC = M[r5 + 420];
   // dif = r7
   r7 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_DIF];
84201d7c:	b0 01 97 d1 	r7 = M[r5 + 432];

84201d80 <$M.celt.ec_dec_normalise.retry>:
   retry:
      // see if range is still small
      r0 = r4 - ($celt.EC_CODE_BOT+1);
84201d80:	80 00 00 fd 	r0 = r4 - 8388609;
84201d84:	01 00 26 21 
      if C jump end;
84201d88:	0d 00 20 dd 	if C jump $M.celt.ec_dec_normalise.end;
         // update range
         r4 = r4 LSHIFT 8;
84201d8c:	08 00 66 8d 	r4 = r4 LSHIFT 8;
         // read next byte from input buffer
         call $celt.get1byte;
84201d90:	ab 0e f0 e1 	call $celt.get1byte;
         // use the ramining bits
         rMAC = rMAC LSHIFT $celt.EC_CODE_EXTRA;
84201d94:	07 00 e1 8d 	rMAC = rMAC LSHIFT 7 (MI);
         rMAC = rMAC AND $celt.EC_SYM_MAX;
84201d98:	ff 00 11 81 	rMAC = rMAC AND 0xff;
         r0 = r1 LSHIFT ($celt.EC_CODE_EXTRA-$celt.EC_SYM_BITS);
84201d9c:	ff 00 23 8d 	r0 = r1 LSHIFT -1;
         rMAC = rMAC OR r0;
84201da0:	00 00 12 87 	rMAC = rMAC OR r0;
         r7 = r7 LSHIFT 8;
84201da4:	08 00 99 8d 	r7 = r7 LSHIFT 8;
         r7 = r7 - rMAC;
84201da8:	00 00 91 23 	r7 = r7 - rMAC;
         r7 = r7 AND 0x7FFFFFFF;
84201dac:	ff 7f 00 fd 	r7 = r7 AND 0x7fffffff;
84201db0:	ff ff 99 81 
         rMAC = r1;
84201db4:	0f 00 13 00 	rMAC = r1 + Null;
   jump retry;
84201db8:	f2 ff f0 dd 	jump $M.celt.ec_dec_normalise.retry;

84201dbc <$M.celt.ec_dec_normalise.end>:
   end:
   // rng = r4
   M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_RNG] = r4;
84201dbc:	a8 01 67 d5 	M[r5 + 424] = r4;
   // rem = rMAC
   M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_REM] = rMAC;
84201dc0:	a4 01 17 d5 	M[r5 + 420] = rMAC;
   // dif = r7
   M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_DIF] = r7;
84201dc4:	b0 01 97 d5 	M[r5 + 432] = r7;

#endif // K32

    // pop rLink from stack
   jump $pop_rLink_and_rts;
84201dc8:	03 00 00 fd 	jump (m) 0x3b020;
84201dcc:	21 b0 f0 dd 

84201dd0 <$celt.ec_decode>:
#if defined(PATCH_LIBS)
   LIBS_PUSH_REGS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.EC_DECODE.PATCH_ID_0)     // celt_patchers
#endif
   
   // push rLink onto stack
   push rlink;
84201dd0:	00 00 d0 f3 	push rLink;
   //ft = r0:r0
   M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FT + 0] = r0;
84201dd4:	cc 01 27 d5 	M[r5 + 460] = r0;
   M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FT + MK1] = r1;
84201dd8:	d0 01 37 d5 	M[r5 + 464] = r1;
   r2 = r0;
84201ddc:	0f 00 42 00 	r2 = r0 + Null;
   r3 = r1;
84201de0:	0f 00 53 00 	r3 = r1 + Null;
   r0 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_RNG + 0];
84201de4:	a8 01 27 d1 	r0 = M[r5 + 424];
   r1 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_RNG + MK1];
84201de8:	ac 01 37 d1 	r1 = M[r5 + 428];
#ifdef DEBUG_ON
#ifdef K32
if NZ call $error; // K32: highword should be zero
#endif
#endif
   call $celt.idiv32;
84201dec:	11 0f f0 e1 	call $celt.idiv32;

84201df0 <$celt.ec_decode.bin_jump>:
   // label for jumping from $celt.ec_decode_bin
   $celt.ec_decode.bin_jump:
   // save norm = rng/inp
   M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_NRM + 0] = r6;
84201df0:	b8 01 87 d5 	M[r5 + 440] = r6;
   M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_NRM + MK1] = r7;
84201df4:	bc 01 97 d5 	M[r5 + 444] = r7;
   r2 = r6;
84201df8:	0f 00 48 00 	r2 = r6 + Null;
   r3 = r7;
84201dfc:	0f 00 59 00 	r3 = r7 + Null;
   r0 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_DIF + 0];
84201e00:	b0 01 27 d1 	r0 = M[r5 + 432];
   r1 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_DIF + MK1];
84201e04:	b4 01 37 d1 	r1 = M[r5 + 436];
   r0 = r0 - 1;
84201e08:	3f 00 22 e4 	r0 = r0 - 1;
   r1 = r1 - borrow;
84201e0c:	00 00 30 27 	r1 = r1 - Null - Borrow;
#ifdef DEBUG_ON
#ifdef K32
if NZ call $error; // K32: highword should be zero
#endif
#endif
   call $celt.idiv32;
84201e10:	08 0f f0 e1 	call $celt.idiv32;
   r2 = r6 + 1;
84201e14:	2f 00 48 e4 	r2 = r6 + 1;
   r3 = r7 + carry;
84201e18:	0f 00 59 04 	r3 = r7 + Null + Carry;
   r0 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FT + 0];
84201e1c:	cc 01 27 d1 	r0 = M[r5 + 460];
   r1 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FT + MK1];
84201e20:	d0 01 37 d1 	r1 = M[r5 + 464];
   r0 = r0 - r2;
84201e24:	00 00 24 23 	r0 = r0 - r2;
   r1 = r1 - r3 - borrow;
84201e28:	00 00 35 27 	r1 = r1 - r3 - Borrow;
   if POS jump end;
84201e2c:	03 00 50 dd 	if POS jump $M.celt.ec_decode.end;
     r0 = 0;
84201e30:	00 00 20 01 	r0 = Null + 0;
     r1 = 0;
84201e34:	00 00 30 01 	r1 = Null + 0;

84201e38 <$M.celt.ec_decode.end>:
   end:
   // pop rLink from stack
   jump $pop_rLink_and_rts;
84201e38:	03 00 00 fd 	jump (m) 0x3b020;
84201e3c:	21 b0 f0 dd 

84201e40 <$celt.ec_decode_bin>:

#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.EC_DECODE_BIN.PATCH_ID_0,r1)     // celt_patchers
#endif
   
   push rlink;
84201e40:	00 00 d0 f3 	push rLink;
   r0 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_RNG + 0];
84201e44:	a8 01 27 d1 	r0 = M[r5 + 424];
   r1 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_RNG + MK1];
84201e48:	ac 01 37 d1 	r1 = M[r5 + 428];
#ifdef DEBUG_ON
#ifdef K32
if NZ call $error; // K32: high word should be zero
#endif
#endif  
   r0 = r0 LSHIFT -15;
84201e4c:	f1 00 22 8d 	r0 = r0 LSHIFT -15;
   r1 = r1 LSHIFT (24-15);
84201e50:	09 00 33 8d 	r1 = r1 LSHIFT 9;
   r6 = r0 + r1;
84201e54:	3f 00 82 00 	r6 = r0 + r1;
   r0 = 32768;
84201e58:	00 00 00 fd 	r0 = Null + 32768;
84201e5c:	00 80 20 01 
   M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FT + 0] = r0;
84201e60:	cc 01 27 d5 	M[r5 + 460] = r0;
   M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FT + MK1] = Null;
84201e64:	d0 01 07 d5 	M[r5 + 464] = Null;
   r7 = 0;
84201e68:	00 00 90 01 	r7 = Null + 0;
   jump $celt.ec_decode.bin_jump;
84201e6c:	e1 ff f0 dd 	jump $celt.ec_decode.bin_jump;

84201e70 <$celt.ec_dec_update>:
#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.EC_DEC_UPDATE.PATCH_ID_0,r1)     // celt_patchers
#endif

   // push rLink onto stack
   push rlink;
84201e70:	00 00 d0 f3 	push rLink;

   r0 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FT + 0];
84201e74:	cc 01 27 d1 	r0 = M[r5 + 460];
   r1 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FT + MK1];
84201e78:	d0 01 37 d1 	r1 = M[r5 + 464];
   rMAC = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FH + 0];
84201e7c:	dc 01 17 d1 	rMAC = M[r5 + 476];
   rMACB = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FH + MK1];
84201e80:	e0 01 f7 d1 	rMACB = M[r5 + 480];
   r0 = r0 - rMAC;
84201e84:	00 00 21 23 	r0 = r0 - rMAC;
   r1 = r1 - rMACB - borrow;
84201e88:	00 00 3f 27 	r1 = r1 - rMACB - Borrow;
#ifdef DEBUG_ON
#ifdef K32
if NZ call $error; // K32: high word should be zero
#endif
#endif  
   r2 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_NRM + 0];
84201e8c:	b8 01 47 d1 	r2 = M[r5 + 440];
   r3 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_NRM + MK1];
84201e90:	bc 01 57 d1 	r3 = M[r5 + 444];

   //IMUL32 , TODO:BC7OPT
   rMAC = r0*r2(UU);
84201e94:	4f 00 12 c0 	rMAC = r0 * r2 (UU);
   r6 = rMAC LSHIFT (DAWTH-1);
84201e98:	1f 00 81 8d 	r6 = rMAC LSHIFT 31;
#ifdef K32
   r7 = 0;
84201e9c:	00 00 90 01 	r7 = Null + 0;
   rMAC = rMAC + r3*r0(SU);
   r7 = rMAC LSHIFT 23;
#endif

   //update dif
   r0 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_DIF + 0];
84201ea0:	b0 01 27 d1 	r0 = M[r5 + 432];
   r1 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_DIF + MK1];
84201ea4:	b4 01 37 d1 	r1 = M[r5 + 436];
   r0 = r0 - r6;
84201ea8:	00 00 28 23 	r0 = r0 - r6;
   r1 = r1 - r7 -borrow;
84201eac:	00 00 39 27 	r1 = r1 - r7 - Borrow;
#ifdef DEBUG_ON
#ifdef K32
if NZ call $error; // K32: high word should be zero
#endif
#endif   
   M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_DIF + 0] = r0;
84201eb0:	b0 01 27 d5 	M[r5 + 432] = r0;
   M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_DIF + MK1] = r1;
84201eb4:	b4 01 37 d5 	M[r5 + 436] = r1;

   // update rng
   r0 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FL + 0];
84201eb8:	d4 01 27 d1 	r0 = M[r5 + 468];
   r1 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FL + MK1];
84201ebc:	d8 01 37 d1 	r1 = M[r5 + 472];
   NULL = r1 OR r0;
84201ec0:	2f 00 03 84 	Null = r1 OR r0;
   if NZ jump calc_rng_norm;
84201ec4:	08 00 10 dd 	if NE jump $M.celt.ec_dec_update.calc_rng_norm;
      r0 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_RNG + 0];
84201ec8:	a8 01 27 d1 	r0 = M[r5 + 424];
      r1 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_RNG + MK1];
84201ecc:	ac 01 37 d1 	r1 = M[r5 + 428];
      r4 = r0 - r6;
84201ed0:	8f 00 62 20 	r4 = r0 - r6;
      r6 = r1 - r7 - borrow;
84201ed4:	9f 00 83 24 	r6 = r1 - r7 - Borrow;
#ifdef DEBUG_ON
#ifdef K32
if NZ call $error; // K32: high word should be zero
#endif
#endif        
      M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_RNG + 0] = r4;
84201ed8:	a8 01 67 d5 	M[r5 + 424] = r4;
      M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_RNG + MK1] = r6;
84201edc:	ac 01 87 d5 	M[r5 + 428] = r6;


      jump norm_dec;
84201ee0:	0c 00 f0 dd 	jump $M.celt.ec_dec_update.norm_dec;

84201ee4 <$M.celt.ec_dec_update.calc_rng_norm>:
   calc_rng_norm:
   r0 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FH + 0];
84201ee4:	dc 01 27 d1 	r0 = M[r5 + 476];
   r1 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FH + MK1];
84201ee8:	e0 01 37 d1 	r1 = M[r5 + 480];
   rMAC = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FL + 0];
84201eec:	d4 01 17 d1 	rMAC = M[r5 + 468];
   rMACB = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FL + MK1];
84201ef0:	d8 01 f7 d1 	rMACB = M[r5 + 472];
   r0 = r0 - rMAC;
84201ef4:	00 00 21 23 	r0 = r0 - rMAC;
   r1 = r1 - rMACB - borrow;
84201ef8:	00 00 3f 27 	r1 = r1 - rMACB - Borrow;
#ifdef K32
if NZ call $error; // K32: high word should be zero
#endif
#endif     
   //IMUL32 , TODO:BC7OPT
   rMAC = r0*r2(UU);
84201efc:	4f 00 12 c0 	rMAC = r0 * r2 (UU);
   r6 = rMAC LSHIFT (DAWTH-1);
84201f00:	1f 00 81 8d 	r6 = rMAC LSHIFT 31;
#ifdef K32
   r7 = 0;
84201f04:	00 00 90 01 	r7 = Null + 0;
   rMAC = rMAC + r3*r0(SU);
   r7 = rMAC LSHIFT 23;
#endif

   //IMUL32
   M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_RNG + 0] = r6;
84201f08:	a8 01 87 d5 	M[r5 + 424] = r6;
   M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_RNG + MK1] = r7;
84201f0c:	ac 01 97 d5 	M[r5 + 428] = r7;

84201f10 <$M.celt.ec_dec_update.norm_dec>:
   norm_dec:
   // normalise
   call $celt.ec_dec_normalise;
84201f10:	98 ff f0 e1 	call $celt.ec_dec_normalise;

   // pop rLink from stack
   jump $pop_rLink_and_rts;
84201f14:	03 00 00 fd 	jump (m) 0x3b020;
84201f18:	21 b0 f0 dd 

84201f1c <$celt.ec_dec_bits>:
   
   // push rLink onto stack
   // r2=ftb
   .CONST TEMP_T               (0 + 2)*ADDR_PER_WORD;
   .CONST STACK_FRAME_SIZE     2*ADDR_PER_WORD;
   pushm <FP(=SP), rLink>;
84201f1c:	01 20 00 f1 	pushm <FP(=SP), rLink>;
   SP = SP + STACK_FRAME_SIZE;
84201f20:	08 00 03 f1 	SP = SP + 8;
   M[FP + TEMP_T + 0] = Null;
84201f24:	08 00 0c f1 	M[FP + 0x8] = Null;
   M[FP + TEMP_T + MK1] =  Null;
84201f28:	0c 00 0c f1 	M[FP + 0xc] = Null;
   r2 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FTB];
84201f2c:	e4 01 47 d1 	r2 = M[r5 + 484];

84201f30 <$M.celt.ec_dec_bits.loop_check_ftp>:
   loop_check_ftp:
      Null = r2 - $celt.EC_UNIT_BITS;
84201f30:	08 00 04 21 	Null = r2 - 8;
      if NEG jump end_check_ftp;
84201f34:	11 00 40 dd 	if NEG jump $M.celt.ec_dec_bits.end_check_ftp;
      r8 = $celt.EC_UNIT_BITS;
84201f38:	08 00 a0 01 	r8 = Null + 8;
      call $celt.ec_decode_raw;
84201f3c:	1e 00 f0 e1 	call $celt.ec_decode_raw;
      r2 = M[FP + TEMP_T + 0];
84201f40:	08 00 48 f1 	r2 = M[FP + 0x8];
      r3 = M[FP + TEMP_T + MK1];
84201f44:	0c 00 58 f1 	r3 = M[FP + 0xc];
      r3 = r3 LSHIFT  $celt.EC_UNIT_BITS;
84201f48:	08 00 55 8d 	r3 = r3 LSHIFT 8;
      r4 = r2  LSHIFT ($celt.EC_UNIT_BITS-24);
84201f4c:	f0 00 64 8d 	r4 = r2 LSHIFT -16;
      r3 = r3 + r4;
84201f50:	00 00 56 03 	r3 = r3 + r4;
      r2 = r2 LSHIFT  $celt.EC_UNIT_BITS;
84201f54:	08 00 44 8d 	r2 = r2 LSHIFT 8;
      r2 = r2 OR r0;
84201f58:	00 00 42 87 	r2 = r2 OR r0;
      r3 = r3 OR r1;
84201f5c:	00 00 53 87 	r3 = r3 OR r1;
      M[FP + TEMP_T + 0] = r2;
84201f60:	08 00 4c f1 	M[FP + 0x8] = r2;
      M[FP + TEMP_T + MK1] = r3;
84201f64:	0c 00 5c f1 	M[FP + 0xc] = r3;
      r2 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FTB];
84201f68:	e4 01 47 d1 	r2 = M[r5 + 484];
      r2 = r2 - $celt.EC_UNIT_BITS;
84201f6c:	08 00 44 21 	r2 = r2 - 8;
      M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FTB] = r2;
84201f70:	e4 01 47 d5 	M[r5 + 484] = r2;
  jump  loop_check_ftp;
84201f74:	ef ff f0 dd 	jump $M.celt.ec_dec_bits.loop_check_ftp;

84201f78 <$M.celt.ec_dec_bits.end_check_ftp>:
  end_check_ftp:
  r8 = r2;
84201f78:	0f 00 a4 00 	r8 = r2 + Null;
  call $celt.ec_decode_raw;
84201f7c:	0e 00 f0 e1 	call $celt.ec_decode_raw;
  r2 = M[FP + TEMP_T + 0];
84201f80:	08 00 48 f1 	r2 = M[FP + 0x8];
  r3 = M[FP + TEMP_T + MK1];
84201f84:	0c 00 58 f1 	r3 = M[FP + 0xc];
  r4 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FTB];
84201f88:	e4 01 67 d1 	r4 = M[r5 + 484];
  r3 = r3 LSHIFT  r4;
84201f8c:	00 00 56 8f 	r3 = r3 LSHIFT r4;
  r6 = r4 - 24;
84201f90:	18 00 86 21 	r6 = r4 - 24;
  r6 = r2  LSHIFT r6;
84201f94:	8f 00 84 8c 	r6 = r2 LSHIFT r6;
  r3 = r3 + r6;
84201f98:	00 00 58 03 	r3 = r3 + r6;
  r2 = r2 LSHIFT  r4;
84201f9c:	00 00 46 8f 	r2 = r2 LSHIFT r4;
  r0 = r2 OR r0;
84201fa0:	2f 00 24 84 	r0 = r2 OR r0;
  r1 = r3 OR r1;
84201fa4:	3f 00 35 84 	r1 = r3 OR r1;
  // pop rLink from stack
   SP = SP - STACK_FRAME_SIZE;
84201fa8:	f8 ff 03 f1 	SP = SP + -8;
   popm <FP,rLink>;
84201fac:	01 20 04 f1 	popm <FP, rLink>;
   rts;
84201fb0:	0f 00 0d dc 	rts;

84201fb4 <$celt.ec_decode_raw>:
#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.EC_DECODE_RAW.PATCH_ID_0,r4)     // celt_patchers
#endif
   
   // push rLink onto stack
   push rlink;
84201fb4:	00 00 d0 f3 	push rLink;
   //rMAC: value
   //r7: count
   //r2: bits(input)
   //r4:end_bits_left
   //r6:end_byte
   rMAC = 0;
84201fb8:	00 00 10 01 	rMAC = Null + 0;
   r7 = 0;
84201fbc:	00 00 90 01 	r7 = Null + 0;
   r4 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_END_BITS_LEFT];
84201fc0:	c4 01 67 d1 	r4 = M[r5 + 452];
   r6 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_END_BYTE];
84201fc4:	c0 01 87 d1 	r6 = M[r5 + 448];
   r0 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_NB_END_BITS];
84201fc8:	c8 01 27 d1 	r0 = M[r5 + 456];
   r0 = r8 + r0;
84201fcc:	2f 00 2a 00 	r0 = r8 + r0;
   M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_NB_END_BITS] = r0;
84201fd0:	c8 01 27 d5 	M[r5 + 456] = r0;

84201fd4 <$M.celt.ec_decode_raw.loop_until_bits_left>:
   loop_until_bits_left:
      Null = r8 - r4;
84201fd4:	6f 00 0a 20 	Null = r8 - r4;
      if NEG jump end_bits_loop;
84201fd8:	0b 00 40 dd 	if NEG jump $M.celt.ec_decode_raw.end_bits_loop;
         r0 = r4 - 8;
84201fdc:	08 00 26 21 	r0 = r4 - 8;
         r0 = r6 LSHIFT r0;
84201fe0:	2f 00 28 8c 	r0 = r6 LSHIFT r0;
         r0 = r0 LSHIFT r7;
84201fe4:	00 00 29 8f 	r0 = r0 LSHIFT r7;
         rMAC = rMAC OR r0;
84201fe8:	00 00 12 87 	rMAC = rMAC OR r0;
         r7 = r7 + r4;
84201fec:	00 00 96 03 	r7 = r7 + r4;
         r8 = r8 - r4;
84201ff0:	00 00 a6 23 	r8 = r8 - r4;
         call $celt.get1byte_from_end;
84201ff4:	22 0e f0 e1 	call $celt.get1byte_from_end;
         r6 = r1;
84201ff8:	0f 00 83 00 	r6 = r1 + Null;
         r4 = 8;
84201ffc:	08 00 60 01 	r4 = Null + 8;
   jump loop_until_bits_left;
84202000:	f5 ff f0 dd 	jump $M.celt.ec_decode_raw.loop_until_bits_left;

84202004 <$M.celt.ec_decode_raw.end_bits_loop>:
   end_bits_loop:
   r2 = 1 LSHIFT r8;
84202004:	01 00 4a e9 	r2 = 0x1 LSHIFT r8;
   r2 = r2 - 1;
84202008:	3f 00 44 e4 	r2 = r2 - 1;
   r0 = r4 - 8;
8420200c:	08 00 26 21 	r0 = r4 - 8;
   r0 = r6 LSHIFT r0;
84202010:	2f 00 28 8c 	r0 = r6 LSHIFT r0;
   r0 = r0 AND r2;
84202014:	00 00 24 83 	r0 = r0 AND r2;
   r0 = r0 LSHIFT r7;
84202018:	00 00 29 8f 	r0 = r0 LSHIFT r7;
   r0 = rMAC OR r0;
8420201c:	2f 00 21 84 	r0 = rMAC OR r0;
   r4 = r4 - r8;
84202020:	00 00 6a 23 	r4 = r4 - r8;
   M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_END_BITS_LEFT] = r4;
84202024:	c4 01 67 d5 	M[r5 + 452] = r4;
   M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_END_BYTE] = r6;
84202028:	c0 01 87 d5 	M[r5 + 448] = r6;
   r1 = 0;
8420202c:	00 00 30 01 	r1 = Null + 0;
   // pop rLink from stack
   jump $pop_rLink_and_rts;
84202030:	03 00 00 fd 	jump (m) 0x3b020;
84202034:	21 b0 f0 dd 

84202038 <$celt.ec_dec_uint>:
#endif

   .CONST TEMP_FTB             (0 + 2)*ADDR_PER_WORD;
   .CONST TEMP_FT              (1 + 2)*ADDR_PER_WORD;
   .CONST STACK_FRAME_SIZE     3*ADDR_PER_WORD;
   pushm <FP(=SP), rLink>;
84202038:	01 20 00 f1 	pushm <FP(=SP), rLink>;
   SP = SP + STACK_FRAME_SIZE;
8420203c:	0c 00 03 f1 	SP = SP + 12;

   r2 = r0 - 2;
84202040:	cf 00 42 e4 	r2 = r0 - 2;
   r2 = r1 - borrow;
84202044:	0f 00 43 24 	r2 = r1 - Null - Borrow;
   if NEG call $error;
84202048:	03 00 00 fd 	if NEG call (m) 0x3ac3e;
8420204c:	3f ac 40 e1 
   r0 = r0 - 1;
84202050:	3f 00 22 e4 	r0 = r0 - 1;
   r1 = r1 - borrow;
84202054:	00 00 30 27 	r1 = r1 - Null - Borrow;
#ifdef DEBUG_ON
#ifdef K32
if NZ call $error; // K32: highword should be zero
#endif
#endif      
   M[FP + TEMP_FT + 0] = r0;
84202058:	0c 00 2c f1 	M[FP + 0xc] = r0;
   M[FP + TEMP_FT + MK1] = r1;
8420205c:	10 00 3c f1 	M[FP + 0x10] = r1;
   // this is a macro
   $celt.EC_ILOG32(r0, r1, r2)
84202060:	0f 00 13 00 	rMAC = r1 + Null;
84202064:	00 05 e2 8d 	rMAC0 = r0 LSHIFT 0;
84202068:	0f 00 41 d8 	r2 = SIGNDET rMAC;
8420206c:	3f 00 44 65 	r2 = 63 - r2;
   M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FTB] = r2;
84202070:	e4 01 47 d5 	M[r5 + 484] = r2;
   Null = r2 - $celt.EC_UNIT_BITS;
84202074:	08 00 04 21 	Null = r2 - 8;
   if LE jump inc_ft;
84202078:	2b 00 d0 dd 	if LE jump $M.celt.ec_dec_uint.inc_ft;
      r2 = $celt.EC_UNIT_BITS - r2;
8420207c:	08 00 44 65 	r2 = 8 - r2;
      r3 = -r2;
84202080:	4f 00 50 20 	r3 = Null - r2;
      M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FTB] = r3;
84202084:	e4 01 57 d5 	M[r5 + 484] = r3;
      M[FP + TEMP_FTB] = r3;
84202088:	08 00 5c f1 	M[FP + 0x8] = r3;
      M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FT + 0] = r0;
8420208c:	cc 01 27 d5 	M[r5 + 460] = r0;
      M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FT + MK1] = r1;
84202090:	d0 01 37 d5 	M[r5 + 464] = r1;
      // TODO:BC7OPT
      r3 = r2 + 24;
84202094:	18 00 54 01 	r3 = r2 + 24;
      r3 = r1 LSHIFT r3;
84202098:	5f 00 53 8c 	r3 = r1 LSHIFT r3;
      r0 = r0 LSHIFT r2;
8420209c:	00 00 24 8f 	r0 = r0 LSHIFT r2;
      r0 = r0 OR r3;
842020a0:	00 00 25 87 	r0 = r0 OR r3;
      r1 = r1 LSHIFT r2;
842020a4:	00 00 34 8f 	r1 = r1 LSHIFT r2;
      r0 = r0 + 1;
842020a8:	2f 00 22 e4 	r0 = r0 + 1;
      r1 = r1 + carry;
842020ac:	00 00 30 07 	r1 = r1 + Null + Carry;
#ifdef DEBUG_ON
#ifdef K32
if NZ call $error; // K32: highword should be zero
#endif
#endif  
      call $celt.ec_decode;
842020b0:	48 ff f0 e1 	call $celt.ec_decode;
      M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FL + 0] = r0;
842020b4:	d4 01 27 d5 	M[r5 + 468] = r0;
      M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FL + MK1] = r1;
842020b8:	d8 01 37 d5 	M[r5 + 472] = r1;
      r0 = r0 + 1;
842020bc:	2f 00 22 e4 	r0 = r0 + 1;
      r1 = r1 + carry;
842020c0:	00 00 30 07 	r1 = r1 + Null + Carry;
      M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FH + MK1] = r1;
842020c4:	e0 01 37 d5 	M[r5 + 480] = r1;
      M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FH + 0] = r0;
842020c8:	dc 01 27 d5 	M[r5 + 476] = r0;

      call $celt.ec_dec_update;
842020cc:	69 ff f0 e1 	call $celt.ec_dec_update;

      call $celt.ec_dec_bits;
842020d0:	93 ff f0 e1 	call $celt.ec_dec_bits;
      r2 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FL + 0];
842020d4:	d4 01 47 d1 	r2 = M[r5 + 468];
      r3 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FL + MK1];
842020d8:	d8 01 57 d1 	r3 = M[r5 + 472];
      r4 = M[FP + TEMP_FTB];
842020dc:	08 00 68 f1 	r4 = M[FP + 0x8];

      // TODO:BC7OPT
      r3 = r3 LSHIFT r4;
842020e0:	00 00 56 8f 	r3 = r3 LSHIFT r4;
      r7 = r4 - 24;
842020e4:	18 00 96 21 	r7 = r4 - 24;
      r7 = r2 LSHIFT r7;
842020e8:	9f 00 94 8c 	r7 = r2 LSHIFT r7;
      r3 = r3 OR r7;
842020ec:	00 00 59 87 	r3 = r3 OR r7;
      r2 = r2 LSHIFT r4;
842020f0:	00 00 46 8f 	r2 = r2 LSHIFT r4;
      r0 = r0 OR r2;
842020f4:	00 00 24 87 	r0 = r0 OR r2;
#ifdef K32
      r1 = 0;  // 32-bit r1:r0 register pair with MSWord=0
842020f8:	00 00 30 01 	r1 = Null + 0;
#else
      r1 = r1 OR r3;
#endif
      r2 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FT + 0];
842020fc:	cc 01 47 d1 	r2 = M[r5 + 460];
      r3 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FT + MK1];
84202100:	d0 01 57 d1 	r3 = M[r5 + 464];
      r4 = M[FP + TEMP_FT + 0];
84202104:	0c 00 68 f1 	r4 = M[FP + 0xc];
      r10 = M[FP + TEMP_FT + MK1];
84202108:	10 00 c8 f1 	r10 = M[FP + 0x10];
      NULL = r0 - r4;
8420210c:	6f 00 02 20 	Null = r0 - r4;
      NULL = r1 - r10 - borrow;
84202110:	cf 00 03 24 	Null = r1 - r10 - Borrow;
      if LE jump end;
84202114:	13 00 d0 dd 	if LE jump $M.celt.ec_dec_uint.end;
         r0 = r2;
84202118:	0f 00 24 00 	r0 = r2 + Null;
#ifdef K32
         r1 = 0;  // 32-bit r1:r0 register pair with MSWord=0
8420211c:	00 00 30 01 	r1 = Null + 0;
#else
         r1 = r3;
#endif
      jump end;
84202120:	10 00 f0 dd 	jump $M.celt.ec_dec_uint.end;

84202124 <$M.celt.ec_dec_uint.inc_ft>:
   inc_ft:
   r0 = r0 + 1;
84202124:	2f 00 22 e4 	r0 = r0 + 1;
   r1 = r1 + carry;
84202128:	00 00 30 07 	r1 = r1 + Null + Carry;
#ifdef K32
if NZ call $error; // K32: highword should be zero
#endif
#endif     
#ifdef K32
   $celt.NATIVE_WORD32_CONVERT(r1,r0)
8420212c:	18 00 33 8d 	r1 = r1 LSHIFT 24;
84202130:	00 00 23 87 	r0 = r0 OR r1;
84202134:	00 00 30 01 	r1 = Null + 0;
#endif
   call $celt.ec_decode;
84202138:	26 ff f0 e1 	call $celt.ec_decode;
   M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FL + 0] = r0;
8420213c:	d4 01 27 d5 	M[r5 + 468] = r0;
   M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FL + MK1] = r1;
84202140:	d8 01 37 d5 	M[r5 + 472] = r1;
   r0 = r0 + 1;
84202144:	2f 00 22 e4 	r0 = r0 + 1;
   r1 = r1 + carry;
84202148:	00 00 30 07 	r1 = r1 + Null + Carry;
   M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FH + MK1] = r1;
8420214c:	e0 01 37 d5 	M[r5 + 480] = r1;
   M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FH + 0] = r0;
84202150:	dc 01 27 d5 	M[r5 + 476] = r0;
   call $celt.ec_dec_update;
84202154:	47 ff f0 e1 	call $celt.ec_dec_update;
   r0 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FL + 0];
84202158:	d4 01 27 d1 	r0 = M[r5 + 468];
   r1 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FL + MK1];
8420215c:	d8 01 37 d1 	r1 = M[r5 + 472];

84202160 <$M.celt.ec_dec_uint.end>:

   end:
   // pop rLink from stack
   SP = SP - STACK_FRAME_SIZE;
84202160:	f4 ff 03 f1 	SP = SP + -12;
   popm <FP,rLink>;
84202164:	01 20 04 f1 	popm <FP, rLink>;
   rts;
84202168:	0f 00 0d dc 	rts;

8420216c <$celt.ec_dec_tell>:
#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.EC_DEC_TELL.PATCH_ID_0,r3)     // celt_patchers
#endif

   // push rLink onto stack
   push rlink;
8420216c:	00 00 d0 f3 	push rLink;

   // work out number of bits
   r3 = M[r5 + $celt.dec.CELT_CODEC_FRAME_SIZE_FIELD];
84202170:	04 00 57 d1 	r3 = M[r5 + 4];
   r0 = M[r5 + $celt.dec.SCRATCHVAR_FRAME_BYTES_REMAINED];
84202174:	fc 01 27 d1 	r0 = M[r5 + 508];
   r3 = r3 - r0;
84202178:	00 00 52 23 	r3 = r3 - r0;
   r3 = r3 - (($celt.EC_CODE_BITS+$celt.EC_SYM_BITS-1)/$celt.EC_SYM_BITS);
8420217c:	df 00 55 e4 	r3 = r3 - 4;
   r3 = r3 * $celt.EC_SYM_BITS (int);
84202180:	08 00 55 99 	r3 = r3 * 8 (int);
   r0 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_NB_END_BITS];
84202184:	c8 01 27 d1 	r0 = M[r5 + 456];
   r3 = r3 + r0;
84202188:	00 00 52 03 	r3 = r3 + r0;
   r3 = r3 +($celt.EC_CODE_BITS+1);
8420218c:	21 00 55 01 	r3 = r3 + 33;
   r3 = r3 LSHIFT r4;
84202190:	00 00 56 8f 	r3 = r3 LSHIFT r4;
   r0 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_RNG + 0];
84202194:	a8 01 27 d1 	r0 = M[r5 + 424];
   r1 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_RNG + MK1];
84202198:	ac 01 37 d1 	r1 = M[r5 + 428];
   $celt.EC_ILOG32(r0, r1, r2)
8420219c:	0f 00 13 00 	rMAC = r1 + Null;
842021a0:	00 05 e2 8d 	rMAC0 = r0 LSHIFT 0;
842021a4:	0f 00 41 d8 	r2 = SIGNDET rMAC;
842021a8:	3f 00 44 65 	r2 = 63 - r2;
   r6 = 16 - r2;
842021ac:	10 00 84 65 	r6 = 16 - r2;
   r0 = r0 LSHIFT r6;
842021b0:	00 00 28 8f 	r0 = r0 LSHIFT r6;
   r6 = r6 + 24;
842021b4:	18 00 88 01 	r6 = r6 + 24;
   r1 = r1 LSHIFT r6;
842021b8:	00 00 38 8f 	r1 = r1 LSHIFT r6;
   r6 = r0 OR r1;
842021bc:	3f 00 82 84 	r6 = r0 OR r1;
   r1 = -1;
842021c0:	3f 00 30 e4 	r1 = Null - 1;

842021c4 <$M.celt.ec_dec_tell.tel_loop>:
   tel_loop:
      r4 = r4 - 1;
842021c4:	3f 00 66 e4 	r4 = r4 - 1;
      if NEG jump end_tel_loop;
842021c8:	08 00 40 dd 	if NEG jump $M.celt.ec_dec_tell.end_tel_loop;
         rMAC = r6 * r6;
842021cc:	8f 00 18 cc 	rMAC = r6 * r6 (SS);
         r6 = rMAC LSHIFT (DAWTH-15-1);
842021d0:	10 00 81 8d 	r6 = rMAC LSHIFT 16;
         r0 = r6 LSHIFT -16;
842021d4:	f0 00 28 8d 	r0 = r6 LSHIFT -16;
         if NZ r6 = r6 LSHIFT r1;
842021d8:	31 00 88 8c 	if NE r6 = r6 LSHIFT r1;
         r2 = r2 + r2;
842021dc:	00 00 44 03 	r2 = r2 + r2;
         r2 = r2 OR r0;
842021e0:	00 00 42 87 	r2 = r2 OR r0;
      jump tel_loop;
842021e4:	f8 ff f0 dd 	jump $M.celt.ec_dec_tell.tel_loop;

842021e8 <$M.celt.ec_dec_tell.end_tel_loop>:
   end_tel_loop:
   r0 = r3 - r2;
842021e8:	4f 00 25 20 	r0 = r3 - r2;

   // pop rLink from stack
   jump $pop_rLink_and_rts;
842021ec:	03 00 00 fd 	jump (m) 0x3b020;
842021f0:	21 b0 f0 dd 

842021f4 <$celt.ec_enc_init>:
842021f4:	00 00 d0 f3 	push rLink;
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_LOW + 0] = Null;
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_LOW + 1] = Null;
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_EXT] = Null;
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_END_BYTE] = Null;
#else
   r0 = -1;
842021f8:	3f 00 20 e4 	r0 = Null - 1;
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_REM] = r0;
842021fc:	a0 01 27 d5 	M[r5 + 416] = r0;
   // rng = EC_CODE_TOP
   r0 = 0x80000000;
84202200:	00 80 00 fd 	r0 = Null + -2147483648;
84202204:	00 00 20 01 
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_RNG + 0] = r0;
84202208:	a4 01 27 d5 	M[r5 + 420] = r0;
   r0 = 8;
8420220c:	08 00 20 01 	r0 = Null + 8;
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_END_BITS_LEFT] = r0;
84202210:	bc 01 27 d5 	M[r5 + 444] = r0;
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_NB_END_BITS] = Null;
84202214:	c0 01 07 d5 	M[r5 + 448] = Null;
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_LOW] = Null;
84202218:	ac 01 07 d5 	M[r5 + 428] = Null;
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_EXT] = Null;
8420221c:	b4 01 07 d5 	M[r5 + 436] = Null;
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_END_BYTE] = Null;
84202220:	b8 01 07 d5 	M[r5 + 440] = Null;
#endif   

   // pop rLink from stack
   jump $pop_rLink_and_rts;
84202224:	03 00 00 fd 	jump (m) 0x3b020;
84202228:	21 b0 f0 dd 

8420222c <$celt.ec_enc_carry_out>:
#if defined(PATCH_LIBS)
   LIBS_PUSH_REGS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.EC_ENC_CARRY_OUT.PATCH_ID_0)     // celt_patchers
#endif
   
   // push rLink onto stack
   push rlink;
8420222c:	00 00 d0 f3 	push rLink;
   // r3 = carry
   Null = r3 - $celt.EC_SYM_MAX;
84202230:	ff 00 05 21 	Null = r3 - 255;
   if NZ jump write_sym;
84202234:	04 00 10 dd 	if NE jump $M.celt.ec_enc_carry_out.write_sym;
      r2 = M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_EXT];
84202238:	b4 01 47 d1 	r2 = M[r5 + 436];
      r2 = r2 + 1;
8420223c:	2f 00 44 e4 	r2 = r2 + 1;
      jump end;
84202240:	0f 00 f0 dd 	jump $M.celt.ec_enc_carry_out.end;

84202244 <$M.celt.ec_enc_carry_out.write_sym>:
   write_sym:
   r2 = r3 LSHIFT (-$celt.EC_SYM_BITS);
84202244:	f8 00 45 8d 	r2 = r3 LSHIFT -8;

   r1 = M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_REM];
84202248:	a0 01 37 d1 	r1 = M[r5 + 416];
   if NEG jump end_writing_carry;
8420224c:	03 00 40 dd 	if NEG jump $M.celt.ec_enc_carry_out.end_writing_carry;
      r1 = r1 + r2; 
84202250:	00 00 34 03 	r1 = r1 + r2;
      call $celt.put1byte;
84202254:	7a 0e f0 e1 	call $celt.put1byte;

84202258 <$M.celt.ec_enc_carry_out.end_writing_carry>:
   end_writing_carry:
   r2 = r2 + $celt.EC_SYM_MAX;
84202258:	ff 00 44 01 	r2 = r2 + 255;
   r1 = r2 AND $celt.EC_SYM_MAX;
8420225c:	ff 00 34 81 	r1 = r2 AND 0xff;
   r2 = M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_EXT];
84202260:	b4 01 47 d1 	r2 = M[r5 + 436];

84202264 <$M.celt.ec_enc_carry_out.loop_write_sym>:
   loop_write_sym:
      if LE jump end_write_loop;
84202264:	04 00 d0 dd 	if LE jump $M.celt.ec_enc_carry_out.end_write_loop;
      call $celt.put1byte;
84202268:	75 0e f0 e1 	call $celt.put1byte;
      r2 = r2 - 1;
8420226c:	3f 00 44 e4 	r2 = r2 - 1;
   jump loop_write_sym;
84202270:	fd ff f0 dd 	jump $M.celt.ec_enc_carry_out.loop_write_sym;

84202274 <$M.celt.ec_enc_carry_out.end_write_loop>:
   end_write_loop:
   r3 = r3 AND $celt.EC_SYM_MAX; 
84202274:	ff 00 55 81 	r3 = r3 AND 0xff;
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_REM] = r3;
84202278:	a0 01 57 d5 	M[r5 + 416] = r3;

8420227c <$M.celt.ec_enc_carry_out.end>:
   end:
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_EXT] = r2;
8420227c:	b4 01 47 d5 	M[r5 + 436] = r2;
    // pop rLink from stack
   jump $pop_rLink_and_rts;
84202280:	03 00 00 fd 	jump (m) 0x3b020;
84202284:	21 b0 f0 dd 

84202288 <$celt.ec_enc_normalise>:
#if defined(PATCH_LIBS)
   LIBS_PUSH_REGS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.EC_ENC_NORMALISE.PATCH_ID_0)     // celt_patchers
#endif
   
   // push rLink onto stack
   push rlink;
84202288:	00 00 d0 f3 	push rLink;
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_LOW + 1] = r8;
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_RNG + 0] = r4;
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_RNG + 1] = r6;
#else
    // K32 implementation
    r7 = M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_LOW];
8420228c:	ac 01 97 d1 	r7 = M[r5 + 428];
    r4 = M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_RNG];
84202290:	a4 01 67 d1 	r4 = M[r5 + 420];

84202294 <$M.celt.ec_enc_normalise.retry>:
    retry:
       Null = $celt.EC_CODE_BOT - r4;
84202294:	80 00 00 fd 	Null = 8388608 - r4;
84202298:	00 00 06 65 
       if NC jump end;
8420229c:	08 00 30 dd 	if NC jump $M.celt.ec_enc_normalise.end;
          r3 = r7 LSHIFT (-$celt.EC_CODE_SHIFT);
842022a0:	e9 00 59 8d 	r3 = r7 LSHIFT -23;
          call $celt.ec_enc_carry_out;
842022a4:	e2 ff f0 e1 	call $celt.ec_enc_carry_out;
          r7 = r7 LSHIFT 8;
842022a8:	08 00 99 8d 	r7 = r7 LSHIFT 8;
          r7 = r7 AND 0x7FFFFFFF;
842022ac:	ff 7f 00 fd 	r7 = r7 AND 0x7fffffff;
842022b0:	ff ff 99 81 
          r4 = r4 LSHIFT 8;
842022b4:	08 00 66 8d 	r4 = r4 LSHIFT 8;
    jump retry;
842022b8:	f7 ff f0 dd 	jump $M.celt.ec_enc_normalise.retry;

842022bc <$M.celt.ec_enc_normalise.end>:
    end:
    M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_LOW] = r7;
842022bc:	ac 01 97 d5 	M[r5 + 428] = r7;
    M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_RNG] = r4;
842022c0:	a4 01 67 d5 	M[r5 + 420] = r4;
#endif

   
    // pop rLink from stack
   jump $pop_rLink_and_rts;
842022c4:	03 00 00 fd 	jump (m) 0x3b020;
842022c8:	21 b0 f0 dd 

842022cc <$celt.ec_encode>:
#if defined(PATCH_LIBS)
   LIBS_PUSH_REGS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.EC_ENCODE.PATCH_ID_0)     // celt_patchers
#endif
   
   // push rLink onto stack
   push rlink;
842022cc:	00 00 d0 f3 	push rLink;
       M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_RNG + 1] = r1;
    end:
    call $celt.ec_enc_normalise;
#else // K32
   // K32 variant
   r0 = M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_RNG];
842022d0:	a4 01 27 d1 	r0 = M[r5 + 420];
   r2 = M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FT];
842022d4:	cc 01 47 d1 	r2 = M[r5 + 460];
   rMAC = 0;
842022d8:	00 00 10 01 	rMAC = Null + 0;
   rMAC0 = r0;
842022dc:	00 05 e2 8d 	rMAC0 = r0 LSHIFT 0;
   Div = rMAC / r2; // r = rng / ft
842022e0:	00 00 14 d9 	Div = rMAC / r2;
   r6 = DivResult;
842022e4:	01 00 80 d9 	r6 = DivResult;

842022e8 <$celt.ec_encode_bin_jump_point>:
   $celt.ec_encode_bin_jump_point:
   r4 = M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FL]; 
842022e8:	d4 01 67 d1 	r4 = M[r5 + 468];
   r4 = -r4;                                      // r4 = -fl
842022ec:	6f 00 60 20 	r4 = Null - r4;
   if POS jump update_range_only;
842022f0:	0c 00 50 dd 	if POS jump $M.celt.ec_encode.update_range_only;
      r2 = r4 + r2; // (ft + -fl)
842022f4:	4f 00 46 00 	r2 = r4 + r2;
      r3 = r2*r6(int); // r*(ft-fl)
842022f8:	8f 00 54 98 	r3 = r2 * r6 (int);
      r0 = r0 - r3; // rng - r*(ft - fl)
842022fc:	00 00 25 23 	r0 = r0 - r3;
      r2 = M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_LOW];
84202300:	ac 01 47 d1 	r2 = M[r5 + 428];
      r0 = r2 + r0; // low + rng - r*(ft - fl)
84202304:	2f 00 24 00 	r0 = r2 + r0;
      M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_LOW] = r0;
84202308:	ac 01 27 d5 	M[r5 + 428] = r0;
      r2 = M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FH];
8420230c:	dc 01 47 d1 	r2 = M[r5 + 476];
      r2 = r2 + r4;                             // (fh - fl)
84202310:	00 00 46 03 	r2 = r2 + r4;
      r0 = r2*r6(int); // (r*(fh-fl)
84202314:	8f 00 24 98 	r0 = r2 * r6 (int);
      M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_RNG] = r0;
84202318:	a4 01 27 d5 	M[r5 + 420] = r0;
      jump end;
8420231c:	07 00 f0 dd 	jump $M.celt.ec_encode.end;

84202320 <$M.celt.ec_encode.update_range_only>:
   update_range_only:
      r0 = M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FH];
84202320:	dc 01 27 d1 	r0 = M[r5 + 476];
      r2 = r2 - r0;    // (ft - fh)
84202324:	00 00 42 23 	r2 = r2 - r0;
      r0 = r2*r6(int); // r*(ft - fh)
84202328:	8f 00 24 98 	r0 = r2 * r6 (int);
      r1 = M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_RNG];
8420232c:	a4 01 37 d1 	r1 = M[r5 + 420];
      r1 = r1 - r0;
84202330:	00 00 32 23 	r1 = r1 - r0;
      M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_RNG] = r1;   // rng = rng - r*(ft - fh)
84202334:	a4 01 37 d5 	M[r5 + 420] = r1;

84202338 <$M.celt.ec_encode.end>:
   end:
   call $celt.ec_enc_normalise;
84202338:	d4 ff f0 e1 	call $celt.ec_enc_normalise;
#endif

        
    // pop rLink from stack
   jump $pop_rLink_and_rts;
8420233c:	03 00 00 fd 	jump (m) 0x3b020;
84202340:	21 b0 f0 dd 

84202344 <$celt.ec_encode_bin>:
#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.EC_ENCODE_BIN.PATCH_ID_0,r1)     // celt_patchers
#endif
   
   // push rLink onto stack
   push rlink;
84202344:	00 00 d0 f3 	push rLink;
   r2 = 32768;
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FT + 0] = r2;
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FT + 1] = Null;
   r7 = 0;
#else
   r0 = M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_RNG];
84202348:	a4 01 27 d1 	r0 = M[r5 + 420];
   r6 = r0 LSHIFT -15;
8420234c:	f1 00 82 8d 	r6 = r0 LSHIFT -15;
   r2 = 32768;
84202350:	00 00 00 fd 	r2 = Null + 32768;
84202354:	00 80 40 01 
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FT] = r2;
84202358:	cc 01 47 d5 	M[r5 + 460] = r2;
   r7 = 0;
8420235c:	00 00 90 01 	r7 = Null + 0;
#endif   
      
   jump $celt.ec_encode_bin_jump_point;
84202360:	e2 ff f0 dd 	jump $celt.ec_encode_bin_jump_point;

84202364 <$celt.ec_encode_raw>:
#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.EC_ENCODE_RAW.PATCH_ID_0,r4)     // celt_patchers
#endif
   
   // push rLink onto stack
    push rlink;
84202364:	00 00 d0 f3 	push rLink;
   //r8 = bits
   r0 = M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_NB_END_BITS];
84202368:	c0 01 27 d1 	r0 = M[r5 + 448];
   r0 = r0 + r8;
8420236c:	00 00 2a 03 	r0 = r0 + r8;
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_NB_END_BITS] = r0;
84202370:	c0 01 27 d5 	M[r5 + 448] = r0;

   r7 = M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_END_BYTE];
84202374:	b8 01 97 d1 	r7 = M[r5 + 440];
   r4 = M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_END_BITS_LEFT];
84202378:	bc 01 67 d1 	r4 = M[r5 + 444];
   r6 = M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FL + 0];
8420237c:	d4 01 87 d1 	r6 = M[r5 + 468];

84202380 <$M.celt.ec_encode_raw.loop_until_bits_left>:
   loop_until_bits_left:
      Null = r8 - r4;
84202380:	6f 00 0a 20 	Null = r8 - r4;
      if NEG jump end_bits_loop;
84202384:	0c 00 40 dd 	if NEG jump $M.celt.ec_encode_raw.end_bits_loop;
         r1 = 8 - r4;
84202388:	08 00 36 65 	r1 = 8 - r4;
         r1 = r6 LSHIFT r1;
8420238c:	3f 00 38 8c 	r1 = r6 LSHIFT r1;
         r1 = r1 AND 0xFF;
84202390:	ff 00 33 81 	r1 = r1 AND 0xff;
         r1 = r1 OR r7;
84202394:	00 00 39 87 	r1 = r1 OR r7;
         call $celt.put1byte_to_end;
84202398:	48 0e f0 e1 	call $celt.put1byte_to_end;
         r4 = -r4;
8420239c:	6f 00 60 20 	r4 = Null - r4;
         r6 = r6 LSHIFT r4;
842023a0:	00 00 86 8f 	r6 = r6 LSHIFT r4;
         r8 = r8 + r4;
842023a4:	00 00 a6 03 	r8 = r8 + r4;
         r4 = 8;
842023a8:	08 00 60 01 	r4 = Null + 8;
         r7 = 0;
842023ac:	00 00 90 01 	r7 = Null + 0;
   jump loop_until_bits_left;
842023b0:	f4 ff f0 dd 	jump $M.celt.ec_encode_raw.loop_until_bits_left;

842023b4 <$M.celt.ec_encode_raw.end_bits_loop>:
   end_bits_loop: 
   r1 = 8 - r4;
842023b4:	08 00 36 65 	r1 = 8 - r4;
   r1 = r6 LSHIFT r1;
842023b8:	3f 00 38 8c 	r1 = r6 LSHIFT r1;
   r1 = r1 AND 0xFF;
842023bc:	ff 00 33 81 	r1 = r1 AND 0xff;
   r1 = r1 OR r7;
842023c0:	00 00 39 87 	r1 = r1 OR r7;
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_END_BYTE] = r1;
842023c4:	b8 01 37 d5 	M[r5 + 440] = r1;

   r4 = r4 - r8;
842023c8:	00 00 6a 23 	r4 = r4 - r8;
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_END_BITS_LEFT] = r4;
842023cc:	bc 01 67 d5 	M[r5 + 444] = r4;


   // pop rLink from stack
   jump $pop_rLink_and_rts;
842023d0:	03 00 00 fd 	jump (m) 0x3b020;
842023d4:	21 b0 f0 dd 

842023d8 <$celt.ec_enc_tell>:
#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.EC_ENC_TELL.PATCH_ID_0,r3)     // celt_patchers
#endif
   
   // push rLink onto stack
   push rlink;
842023d8:	00 00 d0 f3 	push rLink;
   // work out number of bits
   r3 = M[r5 + $celt.enc.CELT_CODEC_FRAME_SIZE_FIELD];
842023dc:	04 00 57 d1 	r3 = M[r5 + 4];
   r6 = M[r5 + $celt.enc.SCRATCHVAR_FRAME_BYTES_REMAINED];
842023e0:	ec 01 87 d1 	r6 = M[r5 + 492];
   r3 = r3 - r6;
842023e4:	00 00 58 23 	r3 = r3 - r6;
   r0 = M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_EXT];
842023e8:	b4 01 27 d1 	r0 = M[r5 + 436];
   r3 = r3 + r0;
842023ec:	00 00 52 03 	r3 = r3 + r0;
   Null = M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_REM];
842023f0:	a0 01 07 d1 	Null = M[r5 + 416];
   if POS r3 = r3 + 1;
842023f4:	25 00 55 e4 	if POS r3 = r3 + 1;
   r3 = r3 * $celt.EC_SYM_BITS (int);
842023f8:	08 00 55 99 	r3 = r3 * 8 (int);
   r0 = M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_NB_END_BITS];
842023fc:	c0 01 27 d1 	r0 = M[r5 + 448];
   r3 = r3 + r0;
84202400:	00 00 52 03 	r3 = r3 + r0;
   r3 = r3 + ($celt.EC_CODE_BITS+1);
84202404:	21 00 55 01 	r3 = r3 + 33;
   r3 = r3 LSHIFT r4;
84202408:	00 00 56 8f 	r3 = r3 LSHIFT r4;
         r2 = r2 OR r0;
      jump tel_loop;
   end_tel_loop:
   r0 = r3 - r2;
#else
   r0 = M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_RNG];
8420240c:	a4 01 27 d1 	r0 = M[r5 + 420];
#ifdef K32_BITEXACT
   r1 = 0;
84202410:	00 00 30 01 	r1 = Null + 0;
   $celt.EC_ILOG32(r0, r1, r2)
84202414:	0f 00 13 00 	rMAC = r1 + Null;
84202418:	00 05 e2 8d 	rMAC0 = r0 LSHIFT 0;
8420241c:	0f 00 41 d8 	r2 = SIGNDET rMAC;
84202420:	3f 00 44 65 	r2 = 63 - r2;
#else   
   r2 = signdet r0;
   r2 = 31 - r2;
#endif   
   r6 = 16 - r2;
84202424:	10 00 84 65 	r6 = 16 - r2;
   r6 = r0 LSHIFT r6;
84202428:	8f 00 82 8c 	r6 = r0 LSHIFT r6;
   r1 = -1;
8420242c:	3f 00 30 e4 	r1 = Null - 1;

84202430 <$M.celt.ec_enc_tell.tel_loop>:
   tel_loop:
      r4 = r4 - 1;
84202430:	3f 00 66 e4 	r4 = r4 - 1;
      if NEG jump end_tel_loop;
84202434:	08 00 40 dd 	if NEG jump $M.celt.ec_enc_tell.end_tel_loop;
         rMAC = r6 * r6;
84202438:	8f 00 18 cc 	rMAC = r6 * r6 (SS);
         r6 = rMAC LSHIFT (32-15-1);
8420243c:	10 00 81 8d 	r6 = rMAC LSHIFT 16;
         r0 = r6 LSHIFT -16;
84202440:	f0 00 28 8d 	r0 = r6 LSHIFT -16;
         if NZ r6 = r6 LSHIFT r1;
84202444:	31 00 88 8c 	if NE r6 = r6 LSHIFT r1;
         r2 = r2 + r2;
84202448:	00 00 44 03 	r2 = r2 + r2;
         r2 = r2 OR r0;
8420244c:	00 00 42 87 	r2 = r2 OR r0;
      jump tel_loop;
84202450:	f8 ff f0 dd 	jump $M.celt.ec_enc_tell.tel_loop;

84202454 <$M.celt.ec_enc_tell.end_tel_loop>:
   end_tel_loop:
   r0 = r3 - r2;
84202454:	4f 00 25 20 	r0 = r3 - r2;
#endif      
   // pop rLink from stack
   jump $pop_rLink_and_rts;   
84202458:	03 00 00 fd 	jump (m) 0x3b020;
8420245c:	21 b0 f0 dd 

84202460 <$celt.ec_enc_bits>:
#endif
   
   // push rLink onto stack
   .CONST TEMP_T               (0 + 2)*ADDR_PER_WORD;
   .CONST STACK_FRAME_SIZE     2*ADDR_PER_WORD;;
   pushm <FP(=SP), rLink>;
84202460:	01 20 00 f1 	pushm <FP(=SP), rLink>;
   SP = SP + STACK_FRAME_SIZE;
84202464:	08 00 03 f1 	SP = SP + 8;
   r0 = r0 + 1;
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FH + 0] = r0;
   call $celt.ec_encode_raw;
#else
   // K32 variant
   r0 = M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FL];
84202468:	d4 01 27 d1 	r0 = M[r5 + 468];
   M[FP + TEMP_T] = r0;
8420246c:	08 00 2c f1 	M[FP + 0x8] = r0;
   r2 = M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FTB];
84202470:	e4 01 47 d1 	r2 = M[r5 + 484];

84202474 <$M.celt.ec_enc_bits.loop_check_ftb>:
   loop_check_ftb:
      r3 = $celt.EC_UNIT_BITS - r2;    
84202474:	08 00 54 65 	r3 = 8 - r2;
      if POS jump end_check_ftb;
84202478:	0b 00 50 dd 	if POS jump $M.celt.ec_enc_bits.end_check_ftb;
      r1 = -r3;
8420247c:	5f 00 30 20 	r1 = Null - r3;
      M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FTB] = r1;
84202480:	e4 01 37 d5 	M[r5 + 484] = r1;
      r0 = r0 LSHIFT r3;
84202484:	00 00 25 8f 	r0 = r0 LSHIFT r3;
      r0 = r0 AND $celt.EC_UNIT_MASK;
84202488:	ff 00 22 81 	r0 = r0 AND 0xff;
      M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FL] = r0;
8420248c:	d4 01 27 d5 	M[r5 + 468] = r0;
      r8 = $celt.EC_UNIT_BITS;
84202490:	08 00 a0 01 	r8 = Null + 8;
      call $celt.ec_encode_raw;
84202494:	b4 ff f0 e1 	call $celt.ec_encode_raw;
      r0 = M[FP + TEMP_T];
84202498:	08 00 28 f1 	r0 = M[FP + 0x8];
      r2 = M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FTB];
8420249c:	e4 01 47 d1 	r2 = M[r5 + 484];
   jump loop_check_ftb;
842024a0:	f5 ff f0 dd 	jump $M.celt.ec_enc_bits.loop_check_ftb;

842024a4 <$M.celt.ec_enc_bits.end_check_ftb>:
   end_check_ftb:
   r8 = r2;
842024a4:	0f 00 a4 00 	r8 = r2 + Null;
   r2 = 1 LSHIFT r2;
842024a8:	01 00 44 e9 	r2 = 0x1 LSHIFT r2;
   r2 = r2 - 1;
842024ac:	3f 00 44 e4 	r2 = r2 - 1;
   r0 = r0 AND r2;
842024b0:	00 00 24 83 	r0 = r0 AND r2;
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FL] = r0;
842024b4:	d4 01 27 d5 	M[r5 + 468] = r0;
   r0 = r0 + 1;
842024b8:	2f 00 22 e4 	r0 = r0 + 1;
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FH] = r0;
842024bc:	dc 01 27 d5 	M[r5 + 476] = r0;
   call $celt.ec_encode_raw;
842024c0:	a9 ff f0 e1 	call $celt.ec_encode_raw;
#endif
  
   SP = SP - STACK_FRAME_SIZE;
842024c4:	f8 ff 03 f1 	SP = SP + -8;
   popm <FP,rLink>;
842024c8:	01 20 04 f1 	popm <FP, rLink>;
   rts;
842024cc:	0f 00 0d dc 	rts;

842024d0 <$celt.ec_enc_uint>:
#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.EC_ENC_UINT.PATCH_ID_0,r1)     // celt_patchers
#endif
   
   // push rLink onto stack
   push rlink;
842024d0:	00 00 d0 f3 	push rLink;
   r1 = r1 + Carry;
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FH + 1] = r1;
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FH + 0] = r0;
   call $celt.ec_encode;
#else // K32 variant
   r0 = M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FT];
842024d4:	cc 01 27 d1 	r0 = M[r5 + 460];
   r0 = r0 - 1;
842024d8:	3f 00 22 e4 	r0 = r0 - 1;
#ifdef K32_BITEXACT
   r1 = 0;
842024dc:	00 00 30 01 	r1 = Null + 0;
   $celt.EC_ILOG32(r0, r1, r2)
842024e0:	0f 00 13 00 	rMAC = r1 + Null;
842024e4:	00 05 e2 8d 	rMAC0 = r0 LSHIFT 0;
842024e8:	0f 00 41 d8 	r2 = SIGNDET rMAC;
842024ec:	3f 00 44 65 	r2 = 63 - r2;
#else   
   r2 = signdet r0;
   r2 = 31 - r2;
#endif   
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FTB] = r2;
842024f0:	e4 01 47 d5 	M[r5 + 484] = r2;
   //r0 = _ft, r2 = ftb
   r3 = $celt.EC_UNIT_BITS -r2;
842024f4:	08 00 54 65 	r3 = 8 - r2;
   if GT jump inc_ft;
842024f8:	12 00 c0 dd 	if GT jump $M.celt.ec_enc_uint.inc_ft;
     r1 = -r3;
842024fc:	5f 00 30 20 	r1 = Null - r3;
     M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FTB] = r1;
84202500:	e4 01 37 d5 	M[r5 + 484] = r1;
     r0 = r0 LSHIFT r3;
84202504:	00 00 25 8f 	r0 = r0 LSHIFT r3;
     r0 = r0 + 1;
84202508:	2f 00 22 e4 	r0 = r0 + 1;
     M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FT] = r0;
8420250c:	cc 01 27 d5 	M[r5 + 460] = r0;
     r0 = M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FL];
84202510:	d4 01 27 d1 	r0 = M[r5 + 468];
     push r0;
84202514:	00 00 20 f3 	push r0;
     r0 = r0 LSHIFT r3;
84202518:	00 00 25 8f 	r0 = r0 LSHIFT r3;
     M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FL] = r0;
8420251c:	d4 01 27 d5 	M[r5 + 468] = r0;
     r0 = r0 + 1;
84202520:	2f 00 22 e4 	r0 = r0 + 1;
     M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FH] = r0;
84202524:	dc 01 27 d5 	M[r5 + 476] = r0;
     call $celt.ec_encode;
84202528:	69 ff f0 e1 	call $celt.ec_encode;
     pop r0;
8420252c:	00 00 24 f3 	pop r0;
     M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FL] = r0;
84202530:	d4 01 27 d5 	M[r5 + 468] = r0;
     call $celt.ec_enc_bits;
84202534:	cb ff f0 e1 	call $celt.ec_enc_bits;
     jump $pop_rLink_and_rts;
84202538:	03 00 00 fd 	jump (m) 0x3b020;
8420253c:	21 b0 f0 dd 

84202540 <$M.celt.ec_enc_uint.inc_ft>:
   inc_ft:
   r0 = M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FL];
84202540:	d4 01 27 d1 	r0 = M[r5 + 468];
   r0 = r0 + 1;
84202544:	2f 00 22 e4 	r0 = r0 + 1;
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FH] = r0;
84202548:	dc 01 27 d5 	M[r5 + 476] = r0;
   call $celt.ec_encode;
8420254c:	60 ff f0 e1 	call $celt.ec_encode;
#endif
   
   jump $pop_rLink_and_rts;
84202550:	03 00 00 fd 	jump (m) 0x3b020;
84202554:	21 b0 f0 dd 

84202558 <$celt.end_writing_frame>:
#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.END_WRITING_FRAME.PATCH_ID_0,r1)     // celt_patchers
#endif

   // push rLink onto stack
   push rlink;
84202558:	00 00 d0 f3 	push rLink;
      r8 = r8 AND 0x7F;         
      r6 = r6 + $celt.EC_SYM_BITS;
      jump retry;
   end_carry_out:
#else // K32
   r0 = M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_RNG];
8420255c:	a4 01 27 d1 	r0 = M[r5 + 420];
#ifdef K32_BITEXACT
   r1 = 0;
84202560:	00 00 30 01 	r1 = Null + 0;
   $celt.EC_ILOG32(r0, r1, r6)
84202564:	0f 00 13 00 	rMAC = r1 + Null;
84202568:	00 05 e2 8d 	rMAC0 = r0 LSHIFT 0;
8420256c:	0f 00 81 d8 	r6 = SIGNDET rMAC;
84202570:	3f 00 88 65 	r6 = 63 - r6;
#else   
   r6 = signdet r0;
   r6 = 31 - r6;
#endif   
   r6 = r6 - $celt.EC_CODE_BITS;
84202574:	20 00 88 21 	r6 = r6 - 32;
   r2 = 0x7FFFFFFF;
84202578:	ff 7f 00 fd 	r2 = Null + 2147483647;
8420257c:	ff ff 40 01 
   r2 = r2 LSHIFT r6;
84202580:	00 00 48 8f 	r2 = r2 LSHIFT r6;
   //r2 = msk
   r7 = M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_LOW];
84202584:	ac 01 97 d1 	r7 = M[r5 + 428];
   r0 = r0 + r7;
84202588:	00 00 29 03 	r0 = r0 + r7;
   r7 = r7 + r2;
8420258c:	00 00 94 03 	r7 = r7 + r2;
   //a = r7
   //b = r2
   //r4= a&~b=(a xo rb) & a   
   r4 = r7 XOR r2;
84202590:	4f 00 69 88 	r4 = r7 XOR r2;
   r7 = r4 AND r7;
84202594:	9f 00 96 80 	r7 = r4 AND r7;
   r4 = r7 OR r2;
84202598:	4f 00 69 84 	r4 = r7 OR r2;
   Null = r4 - r0;
8420259c:	2f 00 06 20 	Null = r4 - r0;
   if NC jump no_msk_up;
842025a0:	07 00 30 dd 	if NC jump $M.celt.end_writing_frame.no_msk_up;
      r6 = r6 - 1;
842025a4:	3f 00 88 e4 	r6 = r6 - 1;
      r2 = r2 LSHIFT -1;
842025a8:	ff 00 44 8d 	r2 = r2 LSHIFT -1;
      r4 = M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_LOW];
842025ac:	ac 01 67 d1 	r4 = M[r5 + 428];
      r7 = r2 + r4;
842025b0:	6f 00 94 00 	r7 = r2 + r4;
      r4 = r7 XOR r2;
842025b4:	4f 00 69 88 	r4 = r7 XOR r2;
      r7 = r4 AND r7;  
842025b8:	9f 00 96 80 	r7 = r4 AND r7;

842025bc <$M.celt.end_writing_frame.no_msk_up>:
   no_msk_up:
   Null = r6;
842025bc:	0f 00 08 00 	Null = r6 + Null;

842025c0 <$M.celt.end_writing_frame.retry>:
   retry:
   if POS jump end_carry_out;
842025c0:	08 00 50 dd 	if POS jump $M.celt.end_writing_frame.end_carry_out;
      r3 = r7 LSHIFT (-$celt.EC_CODE_SHIFT);
842025c4:	e9 00 59 8d 	r3 = r7 LSHIFT -23;
      call $celt.ec_enc_carry_out;
842025c8:	19 ff f0 e1 	call $celt.ec_enc_carry_out;
      r7 = r7 LSHIFT 8;   // shift 1 byte
842025cc:	08 00 99 8d 	r7 = r7 LSHIFT 8;
      r7 = r7 AND 0x7FFFFFFF;
842025d0:	ff 7f 00 fd 	r7 = r7 AND 0x7fffffff;
842025d4:	ff ff 99 81 
      r6 = r6 + $celt.EC_SYM_BITS;
842025d8:	08 00 88 01 	r6 = r6 + 8;
      jump retry;
842025dc:	f9 ff f0 dd 	jump $M.celt.end_writing_frame.retry;

842025e0 <$M.celt.end_writing_frame.end_carry_out>:
   end_carry_out:
#endif //K32

   r0 = M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_REM];
842025e0:	a0 01 27 d1 	r0 = M[r5 + 416];
   if NEG r0 = 0;
842025e4:	04 00 20 00 	if NEG r0 = Null + Null;
   r1 = M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_EXT];
842025e8:	b4 01 37 d1 	r1 = M[r5 + 436];
   r1 = r1 OR r0;
842025ec:	00 00 32 87 	r1 = r1 OR r0;
   if Z jump end_last_sym;
842025f0:	05 00 00 dd 	if EQ jump $M.celt.end_writing_frame.end_last_sym;
      r3 = 0;
842025f4:	00 00 50 01 	r3 = Null + 0;
      call $celt.ec_enc_carry_out;
842025f8:	0d ff f0 e1 	call $celt.ec_enc_carry_out;
      r0 = -1;
842025fc:	3f 00 20 e4 	r0 = Null - 1;
      M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_REM] = r0;
84202600:	a0 01 27 d5 	M[r5 + 416] = r0;

84202604 <$M.celt.end_writing_frame.end_last_sym>:
   end_last_sym:
   
   r10 = M[r5 + $celt.enc.SCRATCHVAR_FRAME_BYTES_REMAINED];
84202604:	ec 01 c7 d1 	r10 = M[r5 + 492];
   r0 = M[r5 + $celt.enc.SCRATCHVAR_FRAME_BYTES_REMAINED_REVERSE];
84202608:	f4 01 27 d1 	r0 = M[r5 + 500];
   r10 = r10 + r0;
8420260c:	00 00 c2 03 	r10 = r10 + r0;
   r0 = M[r5 + $celt.enc.CELT_CODEC_FRAME_SIZE_FIELD];
84202610:	04 00 27 d1 	r0 = M[r5 + 4];
   r10 = r10 - r0;
84202614:	00 00 c2 23 	r10 = r10 - r0;
   if NEG r10 = 0;
84202618:	04 00 c0 00 	if NEG r10 = Null + Null;

   do lp_pad;
8420261c:	03 00 f0 e5 	do $M.celt.end_writing_frame.lp_pad;
      r1 = 0;
84202620:	00 00 30 01 	r1 = Null + 0;
      call $celt.put1byte;
84202624:	86 0d f0 e1 	call $celt.put1byte;

84202628 <$M.celt.end_writing_frame.lp_pad>:
   lp_pad:
   r0 = M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_END_BITS_LEFT];
84202628:	bc 01 27 d1 	r0 = M[r5 + 444];

   Null = r0 - 8;
8420262c:	08 00 02 21 	Null = r0 - 8;
#ifdef DATAFORMAT_32
   if Z jump update_buffer_addr;
84202630:	09 00 00 dd 	if EQ jump $M.celt.end_writing_frame.update_buffer_addr;
      r0 = M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_END_BYTE];
84202634:	b8 01 27 d1 	r0 = M[r5 + 440];
      r2 = M[r5 + $celt.enc.SCRATCHVAR_PUT_BYTEPOS_REVERSE];
84202638:	f0 01 47 d1 	r2 = M[r5 + 496];
      r2 = $celt.BYTE_POS_MAX_VALUE - r2;
8420263c:	03 00 44 65 	r2 = 3 - r2;
      r2 = r2 LSHIFT 3;
84202640:	03 00 44 8d 	r2 = r2 LSHIFT 3;
      r0 = r0 LSHIFT r2;
84202644:	00 00 24 8f 	r0 = r0 LSHIFT r2;
      r1 = M[I1, 0];
84202648:	00 34 00 03 	Null = Null + Null, r1 = M[I1,0];
      r0 = r0 OR r1;
8420264c:	00 00 23 87 	r0 = r0 OR r1;
      M[I1, 0] = r0;
84202650:	00 a4 00 03 	Null = Null + Null, M[I1,0] = r0;

84202654 <$M.celt.end_writing_frame.update_buffer_addr>:
   update_buffer_addr:
      r0 = M[r5 + $celt.enc.PUT_BYTE_POS_FIELD];
84202654:	a4 00 27 d1 	r0 = M[r5 + 164];
      r4 = M[r5 + $celt.enc.CELT_CODEC_FRAME_SIZE_FIELD];
84202658:	04 00 67 d1 	r4 = M[r5 + 4];
      r0 = $celt.BYTE_POS_MAX_VALUE - r0;
8420265c:	03 00 22 65 	r0 = 3 - r0;
      r1 = r0 + r4;
84202660:	6f 00 32 00 	r1 = r0 + r4;
      r2 = r1 AND 3; //adjust byte pos based on frame size
84202664:	03 00 43 81 	r2 = r1 AND 0x3;
      r2 = $celt.BYTE_POS_MAX_VALUE - r2;
84202668:	03 00 44 65 	r2 = 3 - r2;
      M[r5 + $celt.enc.PUT_BYTE_POS_FIELD] = r2;
8420266c:	a4 00 47 d5 	M[r5 + 164] = r2;
      r2 = r1 - 1;
84202670:	3f 00 43 e4 	r2 = r1 - 1;
      r2 = r1 AND ~3;
84202674:	ff ff 00 fd 	r2 = r1 AND 0xfffffffc;
84202678:	fc ff 43 81 
   M[r5 + $celt.enc.PUT_BYTE_POS_FIELD] = r0;
   r2 = r2 + 1;
   r2 = r2 LSHIFT $celt.FRM_DATA_MID_DIV_CONST;
   Words2Addr(r2);
#endif
   M0 = r2;
8420267c:	4f 00 80 50 	M0 = Null + r2;
   r0 = M[r9 + $codec.ENCODER_OUT_BUFFER_FIELD];
84202680:	00 00 2b d1 	r0 = M[r9 + 0];
#ifdef BASE_REGISTER_MODE
   call $cbuffer.get_write_address_and_size_and_start_address;
84202684:	03 00 00 fd 	call (m) 0x3a2b0;
84202688:	b1 a2 f0 e1 
   push r2;
8420268c:	00 00 40 f3 	push r2;
   pop  B0;
84202690:	00 00 a6 f3 	pop B0;
#else
   call $cbuffer.get_write_address_and_size;
#endif
   I0 = r0;
84202694:	2f 00 00 50 	I0 = Null + r0;
   L0 = r1;
84202698:	3f 00 c0 50 	L0 = Null + r1;
   r0 = M[I0, M0];
8420269c:	00 20 00 02 	Null = Null + Null, r0 = M[I0,M0];
   L0 = 0;
842026a0:	00 00 c0 51 	L0 = Null + 0;
   r0 = M[r9 + $codec.ENCODER_OUT_BUFFER_FIELD];
842026a4:	00 00 2b d1 	r0 = M[r9 + 0];
   r1 = I0;
842026a8:	0f 00 30 44 	r1 = Null + I0;
   call $cbuffer.set_write_address;
842026ac:	03 00 00 fd 	call (m) 0x3a320;
842026b0:	21 a3 f0 e1 
   L0 = 0;
842026b4:	00 00 c0 51 	L0 = Null + 0;
   L1 = 0;   
842026b8:	00 00 d0 51 	L1 = Null + 0;
#ifdef BASE_REGISTER_MODE
   push Null;
842026bc:	00 00 00 f3 	push Null;
   pop  B0;
842026c0:	00 00 a6 f3 	pop B0;
   push Null;
842026c4:	00 00 00 f3 	push Null;
   pop B1;
842026c8:	00 00 b6 f3 	pop B1;
#endif


   // pop rLink from stack
   jump $pop_rLink_and_rts;
842026cc:	03 00 00 fd 	jump (m) 0x3b020;
842026d0:	21 b0 f0 dd 

842026d4 <$celt.decode_pulses32>:
842026d4:	01 20 00 f1 	pushm <FP(=SP), rLink>;
#endif
   
   .CONST TEMP                 (0 + 2)*ADDR_PER_WORD;
   .CONST STACK_FRAME_SIZE     4*ADDR_PER_WORD;
   pushm <FP(=SP), rLink>;
   SP = SP + STACK_FRAME_SIZE;
842026d8:	10 00 03 f1 	SP = SP + 16;
#ifndef CELT_USE_EXTERNAL_MEMORY
   .VAR jump_table[5]  = &n_1, &n_2, &n_3, &n_4, n_5;
#endif     
   // save nr of pulses and bins
   M[FP + TEMP + 0] = r4;
842026dc:	08 00 6c f1 	M[FP + 0x8] = r4;
   M[FP + TEMP + MK1] = r3;
842026e0:	0c 00 5c f1 	M[FP + 0xc] = r3;

#if defined (KAL_ARCH4) || defined (KAL_ARCH5)
   r3 = r3 ASHIFT 2;
842026e4:	02 00 55 91 	r3 = r3 ASHIFT 2;
   Null = r3 - 6*4; // ARCH4/5: 4 AU per program word
842026e8:	18 00 05 21 	Null = r3 - 24;
#else
   Null = r3 - 6; // else: 1 AU per program word
#endif
   if POS jump default;
842026ec:	5c 00 50 dd 	if POS jump $M.celt.decode_pulses32.default;
   Null = r3 - 1;
842026f0:	3f 00 05 e4 	Null = r3 - 1;
   if NEG call $error;
842026f4:	03 00 00 fd 	if NEG call (m) 0x3ac3e;
842026f8:	3f ac 40 e1 
   // jump to proper function based on number of outputs
   // all can be processed using default (takes more cycles)
#ifdef CELT_USE_EXTERNAL_MEMORY
   r0 = M[r5 + $celt.dec.DEC_JUMP_TABLE_FIELD];
842026fc:	24 02 27 d1 	r0 = M[r5 + 548];
   r0 = r0 - MK1;
84202700:	df 00 22 e4 	r0 = r0 - 4;
   r0 = M[r3 + r0];
84202704:	2f 00 25 d0 	r0 = M[r3 + r0];
#else
   r0 = M[r3 + (jump_table-MK1)];
#endif   
   jump r0;
84202708:	0f 00 02 dc 	jump r0;

8420270c <$M.celt.decode_pulses32.n_1>:

   // -- process n = 1
   n_1:
      r0 = 1;
8420270c:	2f 00 20 e4 	r0 = Null + 1;
      M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FTB] = r0;
84202710:	e4 01 27 d5 	M[r5 + 484] = r0;
      call $celt.ec_dec_bits;
84202714:	02 fe f0 e1 	call $celt.ec_dec_bits;
      r4 = M[FP + TEMP + 0];
84202718:	08 00 68 f1 	r4 = M[FP + 0x8];
      $celt.cwrsi1(r2, r0, r1)
8420271c:	2f 00 30 20 	r1 = Null - r0;
84202720:	3f 00 14 00 	rMAC = r2 + r1;
84202724:	00 00 31 8b 	r1 = r1 XOR rMAC;
      M[I7, 0] = r1;
84202728:	bc 00 00 03 	Null = Null + Null, M[I7,0] = r1;
   jump end;
8420272c:	62 00 f0 dd 	jump $M.celt.decode_pulses32.end;

84202730 <$M.celt.decode_pulses32.n_2>:

   // -- process n = 2
   n_2:
      $celt.ncwrs2(r4, r0)
84202730:	2f 00 20 e4 	r0 = Null + 1;
84202734:	0f 00 06 00 	Null = r4 + Null;
84202738:	61 00 26 00 	if NE r0 = r4 + r4;
8420273c:	21 00 22 00 	if NE r0 = r0 + r0;
      r1 = 0;
84202740:	00 00 30 01 	r1 = Null + 0;
      call $celt.ec_dec_uint;
84202744:	3d fe f0 e1 	call $celt.ec_dec_uint;
      r4 = M[FP + TEMP + 0];
84202748:	08 00 68 f1 	r4 = M[FP + 0x8];
      r6 = r0;
8420274c:	0f 00 82 00 	r6 = r0 + Null;
      r7 = r1;
84202750:	0f 00 93 00 	r7 = r1 + Null;
      call $celt.cwrsi2;
84202754:	d3 00 f0 e1 	call $celt.cwrsi2;
   jump end;
84202758:	57 00 f0 dd 	jump $M.celt.decode_pulses32.end;

8420275c <$M.celt.decode_pulses32.n_3>:

   // -- process n = 3
   n_3:
      $celt.ncwrs3(r4, r0, r1, decode_pulses32_n_3_lb1)
8420275c:	2f 00 20 e4 	r0 = Null + 1;
84202760:	00 00 30 01 	r1 = Null + 0;
84202764:	0f 00 16 00 	rMAC = r4 + Null;
84202768:	07 00 00 dd 	if EQ jump $M.celt.decode_pulses32.decode_pulses32_n_3_lb1;
8420276c:	00 00 11 03 	rMAC = rMAC + rMAC;
84202770:	1f 00 16 cc 	rMAC = r4 * rMAC (SS);
84202774:	20 00 21 8d 	r0 = rMAC LSHIFT 32;
84202778:	00 00 31 8d 	r1 = rMAC LSHIFT 0;
8420277c:	af 00 22 e4 	r0 = r0 + 2;
84202780:	00 00 30 07 	r1 = r1 + Null + Carry;

84202784 <$M.celt.decode_pulses32.decode_pulses32_n_3_lb1>:
      call $celt.ec_dec_uint;
84202784:	2d fe f0 e1 	call $celt.ec_dec_uint;
      r4 = M[FP + TEMP + 0];
84202788:	08 00 68 f1 	r4 = M[FP + 0x8];
      r6 = r0;
8420278c:	0f 00 82 00 	r6 = r0 + Null;
      r7 = r1;
84202790:	0f 00 93 00 	r7 = r1 + Null;
      call $celt.cwrsi3;
84202794:	d9 00 f0 e1 	call $celt.cwrsi3;
   jump end;
84202798:	47 00 f0 dd 	jump $M.celt.decode_pulses32.end;

8420279c <$M.celt.decode_pulses32.n_4>:

   // -- process n = 4
   n_4:
      $celt.ncwrs4(r4, r0, r1, r2, decode_pulses32_n_4_lb1)
8420279c:	2f 00 20 e4 	r0 = Null + 1;
842027a0:	00 00 30 01 	r1 = Null + 0;
842027a4:	aa 2a 00 fd 	r2 = Null + 715827883;
842027a8:	ab aa 40 01 
842027ac:	04 00 16 99 	rMAC = r4 * 4 (int);
842027b0:	0c 00 00 dd 	if EQ jump $M.celt.decode_pulses32.decode_pulses32_n_4_lb1;
842027b4:	6f 00 26 98 	r0 = r4 * r4 (int);
842027b8:	af 00 22 e4 	r0 = r0 + 2;
842027bc:	4f 00 31 94 	r1 = rMAC * r2 (frac);
842027c0:	03 00 33 99 	r1 = r1 * 3 (int);
842027c4:	1f 00 03 20 	Null = r1 - rMAC;
842027c8:	41 00 22 94 	if NE r0 = r0 * r2 (frac);
842027cc:	1f 00 03 20 	Null = r1 - rMAC;
842027d0:	40 00 11 94 	if EQ rMAC = rMAC * r2 (frac);
842027d4:	2f 00 11 cc 	rMAC = rMAC * r0 (SS);
842027d8:	20 00 21 8d 	r0 = rMAC LSHIFT 32;
842027dc:	00 00 31 8d 	r1 = rMAC LSHIFT 0;

842027e0 <$M.celt.decode_pulses32.decode_pulses32_n_4_lb1>:
      call $celt.ec_dec_uint;
842027e0:	16 fe f0 e1 	call $celt.ec_dec_uint;
      r4 = M[FP + TEMP + 0];
842027e4:	08 00 68 f1 	r4 = M[FP + 0x8];
      r6 = r0;
842027e8:	0f 00 82 00 	r6 = r0 + Null;
      r7 = r1;
842027ec:	0f 00 93 00 	r7 = r1 + Null;
      call $celt.cwrsi4;
842027f0:	10 01 f0 e1 	call $celt.cwrsi4;
   jump end;
842027f4:	30 00 f0 dd 	jump $M.celt.decode_pulses32.end;

842027f8 <$M.celt.decode_pulses32.n_5>:

   // -- process n = 5
   n_5:
      $celt.ncwrs5(r4, r0, r1, r2, decode_pulses32_n_5_lb1)
842027f8:	2f 00 20 e4 	r0 = Null + 1;
842027fc:	00 00 30 01 	r1 = Null + 0;
84202800:	aa 2a 00 fd 	r2 = Null + 715827883;
84202804:	ab aa 40 01 
84202808:	6f 00 16 98 	rMAC = r4 * r4 (int);
8420280c:	0e 00 00 dd 	if EQ jump $M.celt.decode_pulses32.decode_pulses32_n_5_lb1;
84202810:	05 00 21 01 	r0 = rMAC + 5;
84202814:	00 00 11 03 	rMAC = rMAC + rMAC;
84202818:	4f 00 31 94 	r1 = rMAC * r2 (frac);
8420281c:	03 00 33 99 	r1 = r1 * 3 (int);
84202820:	1f 00 03 20 	Null = r1 - rMAC;
84202824:	41 00 22 94 	if NE r0 = r0 * r2 (frac);
84202828:	1f 00 03 20 	Null = r1 - rMAC;
8420282c:	40 00 11 94 	if EQ rMAC = rMAC * r2 (frac);
84202830:	2f 00 11 cc 	rMAC = rMAC * r0 (SS);
84202834:	20 00 21 8d 	r0 = rMAC LSHIFT 32;
84202838:	00 00 31 8d 	r1 = rMAC LSHIFT 0;
8420283c:	af 00 22 e4 	r0 = r0 + 2;
84202840:	00 00 30 07 	r1 = r1 + Null + Carry;

84202844 <$M.celt.decode_pulses32.decode_pulses32_n_5_lb1>:
      call $celt.ec_dec_uint;
84202844:	fd fd f0 e1 	call $celt.ec_dec_uint;
      r4 = M[FP + TEMP + 0];
84202848:	08 00 68 f1 	r4 = M[FP + 0x8];
      r6 = r0;
8420284c:	0f 00 82 00 	r6 = r0 + Null;
      r7 = r1;
84202850:	0f 00 93 00 	r7 = r1 + Null;
      call $celt.cwrsi5;
84202854:	47 01 f0 e1 	call $celt.cwrsi5;
   jump end;
84202858:	17 00 f0 dd 	jump $M.celt.decode_pulses32.end;

8420285c <$M.celt.decode_pulses32.default>:

   // -- process n > 5
   default:
      M[FP + TEMP + MK2] = r5;
8420285c:	10 00 7c f1 	M[FP + 0x10] = r5;
      push I7;
84202860:	00 00 71 f3 	push I7;
      r0 = M[r5 + $celt.dec.UVECTOR_FIELD];
84202864:	c8 00 27 d1 	r0 = M[r5 + 200];
      I7 = r0;//&$celt.dec.uvector;
84202868:	2f 00 70 50 	I7 = Null + r0;
      M[FP + TEMP + 3*MK1] = r0;
8420286c:	14 00 2c f1 	M[FP + 0x14] = r0;
      push r5;
84202870:	00 00 70 f3 	push r5;
      call $celt.ncwrs_urow;
84202874:	c9 01 f0 e1 	call $celt.ncwrs_urow;
      pop r5;
84202878:	00 00 74 f3 	pop r5;
      call $celt.ec_dec_uint;
8420287c:	ef fd f0 e1 	call $celt.ec_dec_uint;
      r4 = M[FP + TEMP + 3*MK1];
84202880:	14 00 68 f1 	r4 = M[FP + 0x14];
      I5 = r4;
84202884:	6f 00 50 50 	I5 = Null + r4;
      #if defined(KAL_ARCH3) || defined(KAL_ARCH4) || defined(KAL_ARCH5)
         I7 = M[SP - MK1];
84202888:	fc ff 79 f1 	I7 = M[SP + -0x4];
      #else
         I7 = plook 0;
      #endif
      r4 = M[FP + TEMP + 0];
8420288c:	08 00 68 f1 	r4 = M[FP + 0x8];
      r3 = M[FP + TEMP + MK1];
84202890:	0c 00 58 f1 	r3 = M[FP + 0xc];
      M3 = r3;
84202894:	5f 00 b0 50 	M3 = Null + r3;
      r6 = r0;
84202898:	0f 00 82 00 	r6 = r0 + Null;
      r7 = r1;
8420289c:	0f 00 93 00 	r7 = r1 + Null;
      push r5;
842028a0:	00 00 70 f3 	push r5;
      call $celt.cwrsi;
842028a4:	99 01 f0 e1 	call $celt.cwrsi;
      pop r5;
842028a8:	00 00 74 f3 	pop r5;
      r5 = M[FP + TEMP + MK2];
842028ac:	10 00 78 f1 	r5 = M[FP + 0x10];
      pop I7;
842028b0:	00 00 75 f3 	pop I7;

842028b4 <$M.celt.decode_pulses32.end>:
   end:
   r4 = M[FP + TEMP + 0];
842028b4:	08 00 68 f1 	r4 = M[FP + 0x8];
   r3 = M[FP + TEMP + MK1];
842028b8:	0c 00 58 f1 	r3 = M[FP + 0xc];
   SP = SP - STACK_FRAME_SIZE;
842028bc:	f0 ff 03 f1 	SP = SP + -16;
   popm <FP,rLink>;
842028c0:	01 20 04 f1 	popm <FP, rLink>;
   rts;
842028c4:	0f 00 0d dc 	rts;

842028c8 <$celt.decode_pulses>:
#if defined(PATCH_LIBS)
   LIBS_PUSH_REGS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.DECODE_PULSES.PATCH_ID_0)     // celt_patchers
#endif

   // zero output for zero pulses
   Null = r4;
842028c8:	0f 00 06 00 	Null = r4 + Null;
   if NZ jump decode;
842028cc:	07 00 10 dd 	if NE jump $M.celt.decode_pulses.decode;
      r10 = r3;
842028d0:	0f 00 c5 00 	r10 = r3 + Null;
      r0 = 0;
842028d4:	00 00 20 01 	r0 = Null + 0;
      I6 = I7;
842028d8:	0f 00 67 58 	I6 = I7 + Null;
      do zero_k_lp;
842028dc:	02 00 f0 e5 	do $M.celt.decode_pulses.zero_k_lp;
         M[I6, MK1] = r0;
842028e0:	a9 00 00 03 	Null = Null + Null, M[I6,4] = r0;

842028e4 <$M.celt.decode_pulses.zero_k_lp>:
      zero_k_lp:
      rts;
842028e4:	0f 00 0d dc 	rts;

842028e8 <$M.celt.decode_pulses.decode>:
   decode:
   push rlink;
842028e8:	00 00 d0 f3 	push rLink;
   // NOTE: no state should be below this point
   // does it fit into a 32-bit unsigned number?
   $celt.fits_in32(r3, r4, r0, decode_pulses_lb1, decode_pulses_lb2)
842028ec:	0e 00 05 21 	Null = r3 - 14;
842028f0:	0b 00 40 dd 	if NEG jump $M.celt.decode_pulses.decode_pulses_lb1;
842028f4:	0f 00 20 00 	r0 = Null + Null;
842028f8:	0e 00 06 21 	Null = r4 - 14;
842028fc:	0e 00 50 dd 	if POS jump $M.celt.decode_pulses.decode_pulses_lb2;
84202900:	18 02 27 d1 	r0 = M[r5 + 536];
84202904:	02 00 66 91 	r4 = r4 ASHIFT 2;
84202908:	00 00 26 d3 	r0 = M[r0 + r4];
8420290c:	fe 00 66 91 	r4 = r4 ASHIFT -2;
84202910:	5f 00 02 20 	Null = r0 - r3;
84202914:	04 00 20 00 	if NEG r0 = Null + Null;
84202918:	07 00 f0 dd 	jump $M.celt.decode_pulses.decode_pulses_lb2;

8420291c <$M.celt.decode_pulses.decode_pulses_lb1>:
8420291c:	1c 02 27 d1 	r0 = M[r5 + 540];
84202920:	02 00 55 91 	r3 = r3 ASHIFT 2;
84202924:	00 00 25 d3 	r0 = M[r0 + r3];
84202928:	fe 00 55 91 	r3 = r3 ASHIFT -2;
8420292c:	6f 00 02 20 	Null = r0 - r4;
84202930:	04 00 20 00 	if NEG r0 = Null + Null;

84202934 <$M.celt.decode_pulses.decode_pulses_lb2>:
84202934:	0f 00 02 00 	Null = r0 + Null;
   if Z jump split_it;
84202938:	04 00 00 dd 	if EQ jump $M.celt.decode_pulses.split_it;
         // yes, it does
         call $celt.decode_pulses32;
8420293c:	66 ff f0 e1 	call $celt.decode_pulses32;
         jump $pop_rLink_and_rts;
84202940:	03 00 00 fd 	jump (m) 0x3b020;
84202944:	21 b0 f0 dd 

84202948 <$M.celt.decode_pulses.split_it>:

   // No, it doesnt,
   split_it:
      push I7;
84202948:	00 00 71 f3 	push I7;
      push r3;
8420294c:	00 00 50 f3 	push r3;
      push r4;
84202950:	00 00 60 f3 	push r4;

      r1 = 0;
84202954:	00 00 30 01 	r1 = Null + 0;
      r0 = r4 + 1;
84202958:	2f 00 26 e4 	r0 = r4 + 1;
      call $celt.ec_dec_uint;
8420295c:	b7 fd f0 e1 	call $celt.ec_dec_uint;
         r4 = r0;
         call $celt.decode_pulses;
         r0 = plook 0;
         r1 = plook 1;
      #else
         r3 = M[SP - MK2];
84202960:	f8 ff 58 f1 	r3 = M[SP + -0x8];
         r3 = r3 + 1;
84202964:	2f 00 55 e4 	r3 = r3 + 1;
         r3 = r3 LSHIFT -1;
84202968:	ff 00 55 8d 	r3 = r3 LSHIFT -1;
         r4 = r0;
8420296c:	0f 00 62 00 	r4 = r0 + Null;
         call $celt.decode_pulses;
84202970:	d6 ff f0 e1 	call $celt.decode_pulses;
         r0 = M[SP - MK1];
84202974:	fc ff 28 f1 	r0 = M[SP + -0x4];
         r1 = M[SP - MK2];
84202978:	f8 ff 38 f1 	r1 = M[SP + -0x8];
      #endif
      Words2Addr(r3);
8420297c:	02 00 55 91 	r3 = r3 ASHIFT 2;
      I7 = I7 + r3;
84202980:	00 00 75 5b 	I7 = I7 + r3;
      Addr2Words(r3);
84202984:	fe 00 55 91 	r3 = r3 ASHIFT -2;
      r4 = r0 - r4;
84202988:	6f 00 62 20 	r4 = r0 - r4;
      r3 = r1 - r3;
8420298c:	5f 00 53 20 	r3 = r1 - r3;
      call $celt.decode_pulses;
84202990:	ce ff f0 e1 	call $celt.decode_pulses;
      pop r4;
84202994:	00 00 64 f3 	pop r4;
      pop r3;
84202998:	00 00 54 f3 	pop r3;
      pop I7;
8420299c:	00 00 75 f3 	pop I7;
   jump $pop_rLink_and_rts;
842029a0:	03 00 00 fd 	jump (m) 0x3b020;
842029a4:	21 b0 f0 dd 

842029a8 <$celt.encode_pulses>:
#if defined(PATCH_LIBS)
   LIBS_PUSH_REGS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.ENCODE_PULSES.PATCH_ID_0)     // celt_patchers
#endif
   
   // zero output for zero pulses
   Null = r4;
842029a8:	0f 00 06 00 	Null = r4 + Null;
   if Z rts;
842029ac:	00 00 0d dc 	if EQ rts;
   push rlink;
842029b0:	00 00 d0 f3 	push rLink;
   // NOTE: no state should be below this point
   // does it fit into a 32-bit unsigned number?
   $celt.fits_in32(r3, r4, r0, encode_pulses_lb1, encode_pulses_lb2)
842029b4:	0e 00 05 21 	Null = r3 - 14;
842029b8:	0b 00 40 dd 	if NEG jump $M.celt.encode_pulses.encode_pulses_lb1;
842029bc:	0f 00 20 00 	r0 = Null + Null;
842029c0:	0e 00 06 21 	Null = r4 - 14;
842029c4:	0e 00 50 dd 	if POS jump $M.celt.encode_pulses.encode_pulses_lb2;
842029c8:	18 02 27 d1 	r0 = M[r5 + 536];
842029cc:	02 00 66 91 	r4 = r4 ASHIFT 2;
842029d0:	00 00 26 d3 	r0 = M[r0 + r4];
842029d4:	fe 00 66 91 	r4 = r4 ASHIFT -2;
842029d8:	5f 00 02 20 	Null = r0 - r3;
842029dc:	04 00 20 00 	if NEG r0 = Null + Null;
842029e0:	07 00 f0 dd 	jump $M.celt.encode_pulses.encode_pulses_lb2;

842029e4 <$M.celt.encode_pulses.encode_pulses_lb1>:
842029e4:	1c 02 27 d1 	r0 = M[r5 + 540];
842029e8:	02 00 55 91 	r3 = r3 ASHIFT 2;
842029ec:	00 00 25 d3 	r0 = M[r0 + r3];
842029f0:	fe 00 55 91 	r3 = r3 ASHIFT -2;
842029f4:	6f 00 02 20 	Null = r0 - r4;
842029f8:	04 00 20 00 	if NEG r0 = Null + Null;

842029fc <$M.celt.encode_pulses.encode_pulses_lb2>:
842029fc:	0f 00 02 00 	Null = r0 + Null;
   if Z jump split_it;
84202a00:	04 00 00 dd 	if EQ jump $M.celt.encode_pulses.split_it;

   // yes, it does
   call $celt.encode_pulses32;
84202a04:	d5 02 f0 e1 	call $celt.encode_pulses32;
   jump $pop_rLink_and_rts;
84202a08:	03 00 00 fd 	jump (m) 0x3b020;
84202a0c:	21 b0 f0 dd 

84202a10 <$M.celt.encode_pulses.split_it>:

   // No, it doesnt,
   split_it:

      push I7;
84202a10:	00 00 71 f3 	push I7;
      push r3;
84202a14:	00 00 50 f3 	push r3;
      push r4;
84202a18:	00 00 60 f3 	push r4;
      I6 = I7;
84202a1c:	0f 00 67 58 	I6 = I7 + Null;
      r3 = r3 + 1;
84202a20:	2f 00 55 e4 	r3 = r3 + 1;
      r3 = r3 LSHIFT -1;
84202a24:	ff 00 55 8d 	r3 = r3 LSHIFT -1;
      r10 = r3;
84202a28:	0f 00 c5 00 	r10 = r3 + Null;
      r1 = 0, r0 = M[I6, MK1];
84202a2c:	29 00 33 23 	r1 = r1 - r1, r0 = M[I6,4];
      do calc_count_loop;
84202a30:	04 00 f0 e5 	do $M.celt.encode_pulses.calc_count_loop;
         Null = r0;
84202a34:	0f 00 02 00 	Null = r0 + Null;
         if NEG r0 = -r0;
84202a38:	24 00 20 20 	if NEG r0 = Null - r0;
         r1 = r1 + r0, r0 = M[I6, MK1];
84202a3c:	29 00 32 03 	r1 = r1 + r0, r0 = M[I6,4];

84202a40 <$M.celt.encode_pulses.calc_count_loop>:
      calc_count_loop:
      M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FL + MK1] = Null;
84202a40:	d8 01 07 d5 	M[r5 + 472] = Null;
      M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FL + 0] = r1;
84202a44:	d4 01 37 d5 	M[r5 + 468] = r1;
      r4 = r4 + 1;
84202a48:	2f 00 66 e4 	r4 = r4 + 1;
      M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FT + 0] = r4;
84202a4c:	cc 01 67 d5 	M[r5 + 460] = r4;
      M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FT + MK1] = Null;
84202a50:	d0 01 07 d5 	M[r5 + 464] = Null;
      push r1;
84202a54:	00 00 30 f3 	push r1;
      push r3;
84202a58:	00 00 50 f3 	push r3;
      call $celt.ec_enc_uint;
84202a5c:	9d fe f0 e1 	call $celt.ec_enc_uint;
      pop r3;
84202a60:	00 00 54 f3 	pop r3;
      pop r4;
84202a64:	00 00 64 f3 	pop r4;
      call $celt.encode_pulses;
84202a68:	d0 ff f0 e1 	call $celt.encode_pulses;

    #if !defined(KAL_ARCH3) && !defined(KAL_ARCH4) && !defined(KAL_ARCH5)
      r0 = plook 0;
      r1 = plook 1;
    #else
      r0 = M[SP - MK1];
84202a6c:	fc ff 28 f1 	r0 = M[SP + -0x4];
      r1 = M[SP - MK2];
84202a70:	f8 ff 38 f1 	r1 = M[SP + -0x8];
    #endif

      Words2Addr(r3);
84202a74:	02 00 55 91 	r3 = r3 ASHIFT 2;
      I7 = I7 + r3;
84202a78:	00 00 75 5b 	I7 = I7 + r3;
      Addr2Words(r3);
84202a7c:	fe 00 55 91 	r3 = r3 ASHIFT -2;
      r4 = r0 - r4;
84202a80:	6f 00 62 20 	r4 = r0 - r4;
      r3 = r1 - r3;
84202a84:	5f 00 53 20 	r3 = r1 - r3;
      call $celt.encode_pulses;
84202a88:	c8 ff f0 e1 	call $celt.encode_pulses;
      pop r4;
84202a8c:	00 00 64 f3 	pop r4;
      pop r3;
84202a90:	00 00 54 f3 	pop r3;
      pop I7;
84202a94:	00 00 75 f3 	pop I7;
   jump $pop_rLink_and_rts;
84202a98:	03 00 00 fd 	jump (m) 0x3b020;
84202a9c:	21 b0 f0 dd 

84202aa0 <$celt.cwrsi2>:

#if defined(PATCH_LIBS)
   LIBS_PUSH_REGS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.CWRSI2.PATCH_ID_0)     // celt_patchers
#endif
   
   r0 = r4 + 1;
84202aa0:	2f 00 26 e4 	r0 = r4 + 1;
   $celt.ucwrs2(r0, r3)
84202aa4:	2f 00 52 00 	r3 = r0 + r0;
84202aa8:	3f 00 55 e4 	r3 = r3 - 1;
84202aac:	04 00 50 00 	if NEG r3 = Null + Null;
   Null = r6 - r3;
84202ab0:	5f 00 08 20 	Null = r6 - r3;
   Null = r7 - Borrow;
84202ab4:	0f 00 09 24 	Null = r7 - Null - Borrow;
   if NEG r3 = 0;
84202ab8:	04 00 50 00 	if NEG r3 = Null + Null;
   r6 = r6 - r3;
84202abc:	00 00 85 23 	r6 = r6 - r3;
   r2 = r6 + 1;
84202ac0:	2f 00 48 e4 	r2 = r6 + 1;
   r2 = r2 LSHIFT -1;
84202ac4:	ff 00 44 8d 	r2 = r2 LSHIFT -1;
   $celt.ucwrs2(r2, r1)
84202ac8:	4f 00 34 00 	r1 = r2 + r2;
84202acc:	3f 00 33 e4 	r1 = r1 - 1;
84202ad0:	04 00 30 00 	if NEG r1 = Null + Null;
   r0 = r4 - r2;
84202ad4:	4f 00 26 20 	r0 = r4 - r2;
   Null = r3;
84202ad8:	0f 00 05 00 	Null = r3 + Null;
   if NZ r0 = -r0;
84202adc:	21 00 20 20 	if NE r0 = Null - r0;
   r6 = r6 - r1, M[I7, MK1] = r0;
84202ae0:	ad 00 83 23 	r6 = r6 - r1, M[I7,4] = r0;
   $celt.cwrsi1(r2, r6, r3)
84202ae4:	8f 00 50 20 	r3 = Null - r6;
84202ae8:	5f 00 14 00 	rMAC = r2 + r3;
84202aec:	00 00 51 8b 	r3 = r3 XOR rMAC;
   M[I7, -MK1] = r3;
84202af0:	df 00 00 03 	Null = Null + Null, M[I7,-4] = r3;
   rts;
84202af4:	0f 00 0d dc 	rts;

84202af8 <$celt.cwrsi3>:
#endif
  
   // push rLink onto stack
   .CONST TMP                  (0 + 2)*ADDR_PER_WORD;
   .CONST STACK_FRAME_SIZE     3*ADDR_PER_WORD;
   pushm <FP(=SP), rLink>;
84202af8:	01 20 00 f1 	pushm <FP(=SP), rLink>;
   SP = SP + STACK_FRAME_SIZE;
84202afc:	0c 00 03 f1 	SP = SP + 12;
   r3 = r4 + 1;
84202b00:	2f 00 56 e4 	r3 = r4 + 1;
   $celt.ucwrs3(r3, r0, r1,  cwrsi3_lbl1)
84202b04:	00 00 20 01 	r0 = Null + 0;
84202b08:	00 00 30 01 	r1 = Null + 0;
84202b0c:	3f 00 15 e4 	rMAC = r3 - 1;
84202b10:	06 00 40 dd 	if NEG jump $M.celt.cwrsi3.cwrsi3_lbl1;
84202b14:	1f 00 15 cc 	rMAC = r3 * rMAC (SS);
84202b18:	20 00 21 8d 	r0 = rMAC LSHIFT 32;
84202b1c:	00 00 31 8d 	r1 = rMAC LSHIFT 0;
84202b20:	2f 00 22 e4 	r0 = r0 + 1;
84202b24:	00 00 30 07 	r1 = r1 + Null + Carry;

84202b28 <$M.celt.cwrsi3.cwrsi3_lbl1>:
   M[FP + TMP + 0]  = r0;
84202b28:	08 00 2c f1 	M[FP + 0x8] = r0;
   M[FP + TMP + MK1]  = r1;
84202b2c:	0c 00 3c f1 	M[FP + 0xc] = r1;
   M[FP + TMP + MK2]  = r4;
84202b30:	10 00 6c f1 	M[FP + 0x10] = r4;
   M0 = 0;
84202b34:	00 00 80 51 	M0 = Null + 0;
   Null = r6 - r0;
84202b38:	2f 00 08 20 	Null = r6 - r0;
   Null = r7 - r1 - borrow;
84202b3c:	3f 00 09 24 	Null = r7 - r1 - Borrow;
   if NEG jump chng1_end;
84202b40:	04 00 40 dd 	if NEG jump $M.celt.cwrsi3.chng1_end;
      M0 = 1;
84202b44:	01 00 80 51 	M0 = Null + 1;
      r6 = r6 - r0;
84202b48:	00 00 82 23 	r6 = r6 - r0;
      r7 = r7 - r1 - borrow;
84202b4c:	00 00 93 27 	r7 = r7 - r1 - Borrow;

84202b50 <$M.celt.cwrsi3.chng1_end>:
   chng1_end:
   r2 = 0;
84202b50:	00 00 40 01 	r2 = Null + 0;
   Null = r6 - 1;
84202b54:	3f 00 08 e4 	Null = r6 - 1;
   Null = r7 - r1 - borrow;
84202b58:	3f 00 09 24 	Null = r7 - r1 - Borrow;
   if NEG jump chng2_end;
84202b5c:	1f 00 40 dd 	if NEG jump $M.celt.cwrsi3.chng2_end;
      r0 = r6 + r6;
84202b60:	8f 00 28 00 	r0 = r6 + r6;
      r1 = r7 + r7 + Carry;
84202b64:	9f 00 39 04 	r1 = r7 + r7 + Carry;
      r0 = r0 - 1;
84202b68:	3f 00 22 e4 	r0 = r0 - 1;
      r1 = r1 - Borrow;
84202b6c:	00 00 30 27 	r1 = r1 - Null - Borrow;
      M1 = r7;
84202b70:	9f 00 90 50 	M1 = Null + r7;
      $celt.ISQRT32(cwrsi3_lbl2, cwrsi3_lbl3)
84202b74:	0f 00 13 00 	rMAC = r1 + Null;
84202b78:	00 05 e2 8d 	rMAC0 = r0 LSHIFT 0;
84202b7c:	0f 00 51 d8 	r3 = SIGNDET rMAC;
84202b80:	3e 00 55 65 	r3 = 62 - r3;
84202b84:	ff 00 55 8d 	r3 = r3 LSHIFT -1;
84202b88:	00 00 40 01 	r2 = Null + 0;
84202b8c:	2f 00 c5 e4 	r10 = r3 + 1;
84202b90:	01 00 55 e9 	r3 = 0x1 LSHIFT r3;
84202b94:	0e 00 f0 e5 	do $M.celt.cwrsi3.cwrsi3_lbl2;
84202b98:	4f 00 64 00 	r4 = r2 + r2;
84202b9c:	00 00 65 03 	r4 = r4 + r3;
84202ba0:	19 00 ac 21 	r8 = r10 - 25;
84202ba4:	af 00 96 8c 	r7 = r4 LSHIFT r8;
84202ba8:	3f 00 ac e4 	r8 = r10 - 1;
84202bac:	00 00 6a 8f 	r4 = r4 LSHIFT r8;
84202bb0:	6f 00 02 20 	Null = r0 - r4;
84202bb4:	9f 00 03 24 	Null = r1 - r7 - Borrow;
84202bb8:	04 00 40 dd 	if NEG jump $M.celt.cwrsi3.cwrsi3_lbl3;
84202bbc:	00 00 45 03 	r2 = r2 + r3;
84202bc0:	00 00 26 23 	r0 = r0 - r4;
84202bc4:	00 00 39 27 	r1 = r1 - r7 - Borrow;

84202bc8 <$M.celt.cwrsi3.cwrsi3_lbl3>:
84202bc8:	ff 00 55 8d 	r3 = r3 LSHIFT -1;

84202bcc <$M.celt.cwrsi3.cwrsi3_lbl2>:
      r2 = r2 + 1;
84202bcc:	2f 00 44 e4 	r2 = r2 + 1;
      r2 = r2 LSHIFT -1;
84202bd0:	ff 00 44 8d 	r2 = r2 LSHIFT -1;
      r7 = M1;
84202bd4:	9f 00 90 44 	r7 = Null + M1;

84202bd8 <$M.celt.cwrsi3.chng2_end>:
   chng2_end:
   $celt.ucwrs3(r2, r0, r1,  cwrsi3_lbl4)
84202bd8:	00 00 20 01 	r0 = Null + 0;
84202bdc:	00 00 30 01 	r1 = Null + 0;
84202be0:	3f 00 14 e4 	rMAC = r2 - 1;
84202be4:	06 00 40 dd 	if NEG jump $M.celt.cwrsi3.cwrsi3_lbl4;
84202be8:	1f 00 14 cc 	rMAC = r2 * rMAC (SS);
84202bec:	20 00 21 8d 	r0 = rMAC LSHIFT 32;
84202bf0:	00 00 31 8d 	r1 = rMAC LSHIFT 0;
84202bf4:	2f 00 22 e4 	r0 = r0 + 1;
84202bf8:	00 00 30 07 	r1 = r1 + Null + Carry;

84202bfc <$M.celt.cwrsi3.cwrsi3_lbl4>:
   r6 = r6 - r0;
84202bfc:	00 00 82 23 	r6 = r6 - r0;
   r7 = r7 - r1 - borrow;
84202c00:	00 00 93 27 	r7 = r7 - r1 - Borrow;
   r0 = M[FP + TMP + MK2];
84202c04:	10 00 28 f1 	r0 = M[FP + 0x10];
   r0 = r2 - r0;
84202c08:	2f 00 24 20 	r0 = r2 - r0;
   Null = M0;
84202c0c:	00 00 08 47 	Null = Null + M0;
   if Z r0 = -r0;
84202c10:	20 00 20 20 	if EQ r0 = Null - r0;
   M[I7, MK1] = r0;
84202c14:	ad 00 00 03 	Null = Null + Null, M[I7,4] = r0;
   r4 = r2;
84202c18:	0f 00 64 00 	r4 = r2 + Null;
   call $celt.cwrsi2;
84202c1c:	a1 ff f0 e1 	call $celt.cwrsi2;
   r0 = M[I7, -MK1];
84202c20:	2f 00 00 03 	Null = Null + Null, r0 = M[I7,-4];
   SP = SP - STACK_FRAME_SIZE;
84202c24:	f4 ff 03 f1 	SP = SP + -12;
   popm <FP,rLink>;
84202c28:	01 20 04 f1 	popm <FP, rLink>;
   rts;
84202c2c:	0f 00 0d dc 	rts;

84202c30 <$celt.cwrsi4>:
#endif
   
   // push rLink onto stack
   .CONST TMP                  (0 + 2)*ADDR_PER_WORD;
   .CONST STACK_FRAME_SIZE     3*ADDR_PER_WORD;
   pushm <FP(=SP), rLink>;
84202c30:	01 20 00 f1 	pushm <FP(=SP), rLink>;
   SP = SP + STACK_FRAME_SIZE;
84202c34:	0c 00 03 f1 	SP = SP + 12;
   r3 = r4 + 1;
84202c38:	2f 00 56 e4 	r3 = r4 + 1;
   $celt.ucwrs4(r3, r0, r1, r2, cwrsi4_lbl1)
84202c3c:	00 00 30 01 	r1 = Null + 0;
84202c40:	0f 00 25 00 	r0 = r3 + Null;
84202c44:	12 00 00 dd 	if EQ jump $M.celt.cwrsi4.cwrsi4_lbl1;
84202c48:	aa 2a 00 fd 	r2 = Null + 715827883;
84202c4c:	ab aa 40 01 
84202c50:	5f 00 15 00 	rMAC = r3 + r3;
84202c54:	03 00 11 21 	rMAC = rMAC - 3;
84202c58:	00 00 15 9b 	rMAC = rMAC * r3 (int);
84202c5c:	bf 00 11 e4 	rMAC = rMAC + 4;
84202c60:	4f 00 31 94 	r1 = rMAC * r2 (frac);
84202c64:	03 00 33 99 	r1 = r1 * 3 (int);
84202c68:	1f 00 03 20 	Null = r1 - rMAC;
84202c6c:	41 00 22 94 	if NE r0 = r0 * r2 (frac);
84202c70:	1f 00 03 20 	Null = r1 - rMAC;
84202c74:	40 00 11 94 	if EQ rMAC = rMAC * r2 (frac);
84202c78:	2f 00 11 cc 	rMAC = rMAC * r0 (SS);
84202c7c:	20 00 21 8d 	r0 = rMAC LSHIFT 32;
84202c80:	00 00 31 8d 	r1 = rMAC LSHIFT 0;
84202c84:	3f 00 22 e4 	r0 = r0 - 1;
84202c88:	00 00 30 27 	r1 = r1 - Null - Borrow;

84202c8c <$M.celt.cwrsi4.cwrsi4_lbl1>:
   M[FP + TMP + 0]  = r0;
84202c8c:	08 00 2c f1 	M[FP + 0x8] = r0;
   M[FP + TMP + MK1]  = r1;
84202c90:	0c 00 3c f1 	M[FP + 0xc] = r1;
   M[FP + TMP + MK2]  = r4;
84202c94:	10 00 6c f1 	M[FP + 0x10] = r4;
   M0 = 0;
84202c98:	00 00 80 51 	M0 = Null + 0;
   Null = r6 - r0;
84202c9c:	2f 00 08 20 	Null = r6 - r0;
   Null = r7 - r1 - borrow;
84202ca0:	3f 00 09 24 	Null = r7 - r1 - Borrow;
   if NEG jump chng1_end;
84202ca4:	04 00 40 dd 	if NEG jump $M.celt.cwrsi4.chng1_end;
      M0 = 1;
84202ca8:	01 00 80 51 	M0 = Null + 1;
      r6 = r6 - r0;
84202cac:	00 00 82 23 	r6 = r6 - r0;
      r7 = r7 - r1 - borrow;
84202cb0:	00 00 93 27 	r7 = r7 - r1 - Borrow;

84202cb4 <$M.celt.cwrsi4.chng1_end>:
   chng1_end:
   r10 = 0;
84202cb4:	00 00 c0 01 	r10 = Null + 0;
   r8 = r4;
84202cb8:	0f 00 a6 00 	r8 = r4 + Null;

84202cbc <$M.celt.cwrsi4.cwrsi4_loop1>:
   cwrsi4_loop1:
      r4 = r10 + r8;
84202cbc:	af 00 6c 00 	r4 = r10 + r8;
      r4 = r4 LSHIFT -1;
84202cc0:	ff 00 66 8d 	r4 = r4 LSHIFT -1;
      $celt.ucwrs4(r4, r0, r1, r2, cwrsi4_lbl2)
84202cc4:	00 00 30 01 	r1 = Null + 0;
84202cc8:	0f 00 26 00 	r0 = r4 + Null;
84202ccc:	12 00 00 dd 	if EQ jump $M.celt.cwrsi4.cwrsi4_lbl2;
84202cd0:	aa 2a 00 fd 	r2 = Null + 715827883;
84202cd4:	ab aa 40 01 
84202cd8:	6f 00 16 00 	rMAC = r4 + r4;
84202cdc:	03 00 11 21 	rMAC = rMAC - 3;
84202ce0:	00 00 16 9b 	rMAC = rMAC * r4 (int);
84202ce4:	bf 00 11 e4 	rMAC = rMAC + 4;
84202ce8:	4f 00 31 94 	r1 = rMAC * r2 (frac);
84202cec:	03 00 33 99 	r1 = r1 * 3 (int);
84202cf0:	1f 00 03 20 	Null = r1 - rMAC;
84202cf4:	41 00 22 94 	if NE r0 = r0 * r2 (frac);
84202cf8:	1f 00 03 20 	Null = r1 - rMAC;
84202cfc:	40 00 11 94 	if EQ rMAC = rMAC * r2 (frac);
84202d00:	2f 00 11 cc 	rMAC = rMAC * r0 (SS);
84202d04:	20 00 21 8d 	r0 = rMAC LSHIFT 32;
84202d08:	00 00 31 8d 	r1 = rMAC LSHIFT 0;
84202d0c:	3f 00 22 e4 	r0 = r0 - 1;
84202d10:	00 00 30 27 	r1 = r1 - Null - Borrow;

84202d14 <$M.celt.cwrsi4.cwrsi4_lbl2>:
      r2 = r6 - r0;
84202d14:	2f 00 48 20 	r2 = r6 - r0;
      r3 = r7 - r1 - Borrow;
84202d18:	3f 00 59 24 	r3 = r7 - r1 - Borrow;
      if NEG jump pos_part;
84202d1c:	07 00 40 dd 	if NEG jump $M.celt.cwrsi4.pos_part;
         r2 = r3 OR r2;
84202d20:	4f 00 45 84 	r2 = r3 OR r2;
         if Z jump cwrsi4_loop1_end;
84202d24:	07 00 00 dd 	if EQ jump $M.celt.cwrsi4.cwrsi4_loop1_end;
         Null = r4 - r8;
84202d28:	af 00 06 20 	Null = r4 - r8;
         if POS jump cwrsi4_loop1_end;
84202d2c:	05 00 50 dd 	if POS jump $M.celt.cwrsi4.cwrsi4_loop1_end;
         r10 = r4 + 1;
84202d30:	2f 00 c6 e4 	r10 = r4 + 1;
      jump cwrsi4_loop1;
84202d34:	e2 ff f0 dd 	jump $M.celt.cwrsi4.cwrsi4_loop1;

84202d38 <$M.celt.cwrsi4.pos_part>:
      pos_part:
          r8 = r4 - 1;
84202d38:	3f 00 a6 e4 	r8 = r4 - 1;
   jump cwrsi4_loop1;
84202d3c:	e0 ff f0 dd 	jump $M.celt.cwrsi4.cwrsi4_loop1;

84202d40 <$M.celt.cwrsi4.cwrsi4_loop1_end>:
   cwrsi4_loop1_end:

   r6 = r6 - r0;
84202d40:	00 00 82 23 	r6 = r6 - r0;
   r7 = r7 - r1 - borrow;
84202d44:	00 00 93 27 	r7 = r7 - r1 - Borrow;
   r0 = M[FP + TMP + MK2];
84202d48:	10 00 28 f1 	r0 = M[FP + 0x10];
   r0 = r4 - r0;
84202d4c:	2f 00 26 20 	r0 = r4 - r0;
   Null = M0;
84202d50:	00 00 08 47 	Null = Null + M0;
   if Z r0 = -r0;
84202d54:	20 00 20 20 	if EQ r0 = Null - r0;
   M[I7, MK1] = r0;
84202d58:	ad 00 00 03 	Null = Null + Null, M[I7,4] = r0;
   call $celt.cwrsi3;
84202d5c:	67 ff f0 e1 	call $celt.cwrsi3;
   r0 = M[I7, -MK1];
84202d60:	2f 00 00 03 	Null = Null + Null, r0 = M[I7,-4];
   SP = SP - STACK_FRAME_SIZE;
84202d64:	f4 ff 03 f1 	SP = SP + -12;
   popm <FP,rLink>;
84202d68:	01 20 04 f1 	popm <FP, rLink>;
   rts;
84202d6c:	0f 00 0d dc 	rts;

84202d70 <$celt.cwrsi5>:
#endif
  
     // push rLink onto stack
   .CONST TMP                 (0 + 2)*ADDR_PER_WORD;
   .CONST STACK_FRAME_SIZE     3*ADDR_PER_WORD;
   pushm <FP(=SP), rLink>;
84202d70:	01 20 00 f1 	pushm <FP(=SP), rLink>;
   SP = SP + STACK_FRAME_SIZE;
84202d74:	0c 00 03 f1 	SP = SP + 12;
   r3 = r4 + 1;
84202d78:	2f 00 56 e4 	r3 = r4 + 1;
   $celt.ucwrs5(r3, r0, r1, r2, cwrsi5_lbl1)
84202d7c:	00 00 30 01 	r1 = Null + 0;
84202d80:	0f 00 25 00 	r0 = r3 + Null;
84202d84:	13 00 00 dd 	if EQ jump $M.celt.cwrsi5.cwrsi5_lbl1;
84202d88:	aa 2a 00 fd 	r2 = Null + 715827883;
84202d8c:	ab aa 40 01 
84202d90:	cf 00 15 e4 	rMAC = r3 - 2;
84202d94:	00 00 15 9b 	rMAC = rMAC * r3 (int);
84202d98:	05 00 11 01 	rMAC = rMAC + 5;
84202d9c:	00 00 15 9b 	rMAC = rMAC * r3 (int);
84202da0:	df 00 11 e4 	rMAC = rMAC - 4;
84202da4:	4f 00 31 94 	r1 = rMAC * r2 (frac);
84202da8:	03 00 33 99 	r1 = r1 * 3 (int);
84202dac:	1f 00 03 20 	Null = r1 - rMAC;
84202db0:	41 00 22 94 	if NE r0 = r0 * r2 (frac);
84202db4:	1f 00 03 20 	Null = r1 - rMAC;
84202db8:	40 00 11 94 	if EQ rMAC = rMAC * r2 (frac);
84202dbc:	2f 00 11 cc 	rMAC = rMAC * r0 (SS);
84202dc0:	20 00 21 8d 	r0 = rMAC LSHIFT 32;
84202dc4:	00 00 31 8d 	r1 = rMAC LSHIFT 0;
84202dc8:	2f 00 22 e4 	r0 = r0 + 1;
84202dcc:	00 00 30 07 	r1 = r1 + Null + Carry;

84202dd0 <$M.celt.cwrsi5.cwrsi5_lbl1>:
   M[FP + TMP + 0]  = r0;
84202dd0:	08 00 2c f1 	M[FP + 0x8] = r0;
   M[FP + TMP + MK1]  = r1;
84202dd4:	0c 00 3c f1 	M[FP + 0xc] = r1;
   M[FP + TMP + MK2]  = r4;
84202dd8:	10 00 6c f1 	M[FP + 0x10] = r4;

   M0 = 0;
84202ddc:	00 00 80 51 	M0 = Null + 0;
   Null = r6 - r0;
84202de0:	2f 00 08 20 	Null = r6 - r0;
   Null = r7 - r1 - borrow;
84202de4:	3f 00 09 24 	Null = r7 - r1 - Borrow;
   if NEG jump chng1_end;
84202de8:	04 00 40 dd 	if NEG jump $M.celt.cwrsi5.chng1_end;
      M0 = 1;
84202dec:	01 00 80 51 	M0 = Null + 1;
      r6 = r6 - r0;
84202df0:	00 00 82 23 	r6 = r6 - r0;
      r7 = r7 - r1 - borrow;
84202df4:	00 00 93 27 	r7 = r7 - r1 - Borrow;

84202df8 <$M.celt.cwrsi5.chng1_end>:
   chng1_end:
   r10 = 0;
84202df8:	00 00 c0 01 	r10 = Null + 0;
   r8 = r4;
84202dfc:	0f 00 a6 00 	r8 = r4 + Null;

84202e00 <$M.celt.cwrsi5.cwrsi5_loop1>:
   cwrsi5_loop1:
      r4 = r10 + r8;
84202e00:	af 00 6c 00 	r4 = r10 + r8;
      r4 = r4 LSHIFT -1;
84202e04:	ff 00 66 8d 	r4 = r4 LSHIFT -1;
      $celt.ucwrs5(r4, r0, r1, r2, cwrsi5_lbl2)
84202e08:	00 00 30 01 	r1 = Null + 0;
84202e0c:	0f 00 26 00 	r0 = r4 + Null;
84202e10:	13 00 00 dd 	if EQ jump $M.celt.cwrsi5.cwrsi5_lbl2;
84202e14:	aa 2a 00 fd 	r2 = Null + 715827883;
84202e18:	ab aa 40 01 
84202e1c:	cf 00 16 e4 	rMAC = r4 - 2;
84202e20:	00 00 16 9b 	rMAC = rMAC * r4 (int);
84202e24:	05 00 11 01 	rMAC = rMAC + 5;
84202e28:	00 00 16 9b 	rMAC = rMAC * r4 (int);
84202e2c:	df 00 11 e4 	rMAC = rMAC - 4;
84202e30:	4f 00 31 94 	r1 = rMAC * r2 (frac);
84202e34:	03 00 33 99 	r1 = r1 * 3 (int);
84202e38:	1f 00 03 20 	Null = r1 - rMAC;
84202e3c:	41 00 22 94 	if NE r0 = r0 * r2 (frac);
84202e40:	1f 00 03 20 	Null = r1 - rMAC;
84202e44:	40 00 11 94 	if EQ rMAC = rMAC * r2 (frac);
84202e48:	2f 00 11 cc 	rMAC = rMAC * r0 (SS);
84202e4c:	20 00 21 8d 	r0 = rMAC LSHIFT 32;
84202e50:	00 00 31 8d 	r1 = rMAC LSHIFT 0;
84202e54:	2f 00 22 e4 	r0 = r0 + 1;
84202e58:	00 00 30 07 	r1 = r1 + Null + Carry;

84202e5c <$M.celt.cwrsi5.cwrsi5_lbl2>:
      r2 = r6 - r0;
84202e5c:	2f 00 48 20 	r2 = r6 - r0;
      r3 = r7 - r1 - Borrow;
84202e60:	3f 00 59 24 	r3 = r7 - r1 - Borrow;
      if NEG jump pos_part;
84202e64:	07 00 40 dd 	if NEG jump $M.celt.cwrsi5.pos_part;
         r2 = r3 OR r2;
84202e68:	4f 00 45 84 	r2 = r3 OR r2;
         if Z jump cwrsi5_loop1_end;
84202e6c:	07 00 00 dd 	if EQ jump $M.celt.cwrsi5.cwrsi5_loop1_end;
         Null = r4 - r8;
84202e70:	af 00 06 20 	Null = r4 - r8;
         if POS jump cwrsi5_loop1_end;
84202e74:	05 00 50 dd 	if POS jump $M.celt.cwrsi5.cwrsi5_loop1_end;
         r10 = r4 + 1;
84202e78:	2f 00 c6 e4 	r10 = r4 + 1;
      jump cwrsi5_loop1;
84202e7c:	e1 ff f0 dd 	jump $M.celt.cwrsi5.cwrsi5_loop1;

84202e80 <$M.celt.cwrsi5.pos_part>:
      pos_part:
         r8 = r4 - 1;
84202e80:	3f 00 a6 e4 	r8 = r4 - 1;
   jump cwrsi5_loop1;
84202e84:	df ff f0 dd 	jump $M.celt.cwrsi5.cwrsi5_loop1;

84202e88 <$M.celt.cwrsi5.cwrsi5_loop1_end>:

   cwrsi5_loop1_end:
   r6 = r6 - r0;
84202e88:	00 00 82 23 	r6 = r6 - r0;
   r7 = r7 - r1 - borrow;
84202e8c:	00 00 93 27 	r7 = r7 - r1 - Borrow;
   r0 = M[FP + TMP + MK2];
84202e90:	10 00 28 f1 	r0 = M[FP + 0x10];
   r0 = r4 - r0;
84202e94:	2f 00 26 20 	r0 = r4 - r0;
   Null = M0;
84202e98:	00 00 08 47 	Null = Null + M0;
   if Z r0 = -r0;
84202e9c:	20 00 20 20 	if EQ r0 = Null - r0;
   M[I7, MK1] = r0;
84202ea0:	ad 00 00 03 	Null = Null + Null, M[I7,4] = r0;
   call $celt.cwrsi4;
84202ea4:	63 ff f0 e1 	call $celt.cwrsi4;
   r0 = M[I7, -MK1];
84202ea8:	2f 00 00 03 	Null = Null + Null, r0 = M[I7,-4];
   SP = SP - STACK_FRAME_SIZE;
84202eac:	f4 ff 03 f1 	SP = SP + -12;
   popm <FP,rLink>;
84202eb0:	01 20 04 f1 	popm <FP, rLink>;
   rts;
84202eb4:	0f 00 0d dc 	rts;

84202eb8 <$celt.uprev>:

#if defined(PATCH_LIBS)
   LIBS_PUSH_REGS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.UPREV.PATCH_ID_0)     // celt_patchers
#endif
  
  I2 = I3;
84202eb8:	0f 00 23 58 	I2 = I3 + Null;
     r1 = r5,  r5 = M[I2, M0];
  uprev_loop:
  M[I3, M0] = r2;
  M[I3, M0] = r3;
#else // K32
  M0 = 2*ADDR_PER_WORD;
84202ebc:	08 00 80 51 	M0 = Null + 8;
  r10 = r10 - 1,  r0 = M[I2, M0]; //0 ->1
84202ec0:	3f 28 cc e4 	r10 = r10 - 1, r0 = M[I2,M0];
  r4 = M[I2, M0];  //2->3
84202ec4:	00 68 00 02 	Null = Null + Null, r4 = M[I2,M0];
  do uprev_loop;
84202ec8:	04 00 f0 e5 	do $M.celt.uprev.uprev_loop;
     r6 = r4 - r0;
84202ecc:	2f 00 86 20 	r6 = r4 - r0;
     r2 = r6 - r2, M[I3, M0] = r2;
84202ed0:	4f cc 48 20 	r2 = r6 - r2, M[I3,M0] = r2;
     r0 = r4, r4 = M[I2, M0];
84202ed4:	0f 68 26 00 	r0 = r4 + Null, r4 = M[I2,M0];

84202ed8 <$M.celt.uprev.uprev_loop>:
  uprev_loop:
  M[I3, M0] = r2;
84202ed8:	00 cc 00 02 	Null = Null + Null, M[I3,M0] = r2;
#endif // K32

  rts;
84202edc:	0f 00 0d dc 	rts;

84202ee0 <$celt.unext>:

#if defined(PATCH_LIBS)
   LIBS_PUSH_REGS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.UNEXT.PATCH_ID_0)     // celt_patchers
#endif
  
  I2 = I3;
84202ee0:	0f 00 23 58 	I2 = I3 + Null;
     r1 = r5,  r5 = M[I2, M0];
  unext_loop:
  M[I3, M0] = r2;
  M[I3, M0] = r3;
#else // K32
  M0 = 2*ADDR_PER_WORD;
84202ee4:	08 00 80 51 	M0 = Null + 8;
  r10 = r10 - 1, r0 = M[I2, M0]; //0 ->1
84202ee8:	3f 28 cc e4 	r10 = r10 - 1, r0 = M[I2,M0];
  r4 = M[I2, M0];  //2->3
84202eec:	00 68 00 02 	Null = Null + Null, r4 = M[I2,M0];
  do unext_loop;
84202ef0:	04 00 f0 e5 	do $M.celt.unext.unext_loop;
     r6 = r4 + r0;
84202ef4:	2f 00 86 00 	r6 = r4 + r0;
     r2 = r6 + r2, M[I3, M0] = r2;
84202ef8:	4f cc 48 00 	r2 = r6 + r2, M[I3,M0] = r2;
     r0 = r4, r4 = M[I2, M0];
84202efc:	0f 68 26 00 	r0 = r4 + Null, r4 = M[I2,M0];

84202f00 <$M.celt.unext.unext_loop>:
  unext_loop:
  M[I3, M0] = r2;  
84202f00:	00 cc 00 02 	Null = Null + Null, M[I3,M0] = r2;

#endif // K32
  rts;
84202f04:	0f 00 0d dc 	rts;

84202f08 <$celt.cwrsi>:

   //r4 = k
   //I7 = y
   //I5 = u (32 bit
   //M3 = n
   push rlink;
84202f08:	00 00 d0 f3 	push rLink;
   Words2Addr(r4);
84202f0c:	02 00 66 91 	r4 = r4 ASHIFT 2;
   r8 = I5 + r4;
84202f10:	6f 00 a5 48 	r8 = I5 + r4;
   r8 = r8 + r4;
84202f14:	00 00 a6 03 	r8 = r8 + r4;
   Addr2Words(r4);
84202f18:	fe 00 66 91 	r4 = r4 ASHIFT -2;
      I3 = I5;
      pushm <r0, r1, r4, r6, r7>;
      call $celt.uprev;
      popm <r0, r1, r4, r6, r7>;
#else // K32
   M2 = -2*ADDR_PER_WORD;
84202f1c:	f8 ff a0 51 	M2 = Null + -8;

84202f20 <$M.celt.cwrsi.cwrsi_loop>:
   cwrsi_loop:
      r0 = M[r8 + MK2];
84202f20:	08 00 2a d1 	r0 = M[r8 + 8];
      M0 = 0;
84202f24:	00 00 80 51 	M0 = Null + 0;
      Null = r6 - r0;
84202f28:	2f 00 08 20 	Null = r6 - r0;
      if NC jump chng1_end;
84202f2c:	03 00 30 dd 	if NC jump $M.celt.cwrsi.chng1_end;
         M0 = 1;
84202f30:	01 00 80 51 	M0 = Null + 1;
         r6 = r6 - r0;
84202f34:	00 00 82 23 	r6 = r6 - r0;

84202f38 <$M.celt.cwrsi.chng1_end>:
      chng1_end:
      r0 = M[r8 + 0];
84202f38:	00 00 2a d1 	r0 = M[r8 + 0];
      I2 = r8 - 2*ADDR_PER_WORD;
84202f3c:	08 00 2a 71 	I2 = r8 - 8;

84202f40 <$M.celt.cwrsi.cwrsi_loop2>:
      cwrsi_loop2:
        r2 = r6 - r0, r0 = M[I2, M2];
84202f40:	2f 2a 48 20 	r2 = r6 - r0, r0 = M[I2,M2];
      if NC jump cwrsi_loop2;
84202f44:	ff ff 30 dd 	if NC jump $M.celt.cwrsi.cwrsi_loop2;
      r8 = I2 + 4*ADDR_PER_WORD;
84202f48:	10 00 a2 49 	r8 = I2 + 16;
      r6 = r2;
84202f4c:	0f 00 84 00 	r6 = r2 + Null;
      r3 = r8 - I5;
84202f50:	5f 00 5a 64 	r3 = r8 - I5;
      Addr2Words(r3);
84202f54:	fe 00 55 91 	r3 = r3 ASHIFT -2;
      r3 = r3 LSHIFT -1;
84202f58:	ff 00 55 8d 	r3 = r3 LSHIFT -1;
      r4 = r4 - r3;
84202f5c:	00 00 65 23 	r4 = r4 - r3;
      Null = M0;
84202f60:	00 00 08 47 	Null = Null + M0;
      if NZ r4 = -r4;
84202f64:	61 00 60 20 	if NE r4 = Null - r4;
      M[I7, MK1] = r4;
84202f68:	ed 00 00 03 	Null = Null + Null, M[I7,4] = r4;
      r4 = r3;
84202f6c:	0f 00 65 00 	r4 = r3 + Null;
      r10 = r4 + 2;
84202f70:	af 00 c6 e4 	r10 = r4 + 2;
      r2 = 0;
84202f74:	00 00 40 01 	r2 = Null + 0;
      I3 = I5;
84202f78:	0f 00 35 58 	I3 = I5 + Null;
      pushm <r4, r6>;
84202f7c:	40 01 00 f1 	pushm <r4, r6>;
      call $celt.uprev;
84202f80:	ce ff f0 e1 	call $celt.uprev;
      popm  <r4, r6>;
84202f84:	40 01 04 f1 	popm <r4, r6>;
#endif
     M3 = M3 - 1;
84202f88:	01 00 bb 79 	M3 = M3 - 1;

   if NZ jump cwrsi_loop;
84202f8c:	e5 ff 10 dd 	if NE jump $M.celt.cwrsi.cwrsi_loop;


   jump $pop_rLink_and_rts;
84202f90:	03 00 00 fd 	jump (m) 0x3b020;
84202f94:	21 b0 f0 dd 

84202f98 <$celt.ncwrs_urow>:
   //r4 = k
   //r3 = n
   //len=_k+2;
   .CONST TEMP                 (0 + 2)*ADDR_PER_WORD;
   .CONST STACK_FRAME_SIZE     4*ADDR_PER_WORD;
   pushm <FP(=SP), rLink>;
84202f98:	01 20 00 f1 	pushm <FP(=SP), rLink>;
   SP = SP + STACK_FRAME_SIZE;
84202f9c:	10 00 03 f1 	SP = SP + 16;
   Words2Addr(r4);
84202fa0:	02 00 66 91 	r4 = r4 ASHIFT 2;
   I6 = I7 + r4;
84202fa4:	6f 00 67 58 	I6 = I7 + r4;
   I6 = I6 + r4;
84202fa8:	00 00 66 5b 	I6 = I6 + r4;
   r8 = I7;
84202fac:	7f 00 a0 44 	r8 = Null + I7;
   Addr2Words(r4);
84202fb0:	fe 00 66 91 	r4 = r4 ASHIFT -2;
   M3 = r4 + 2;
84202fb4:	02 00 b6 51 	M3 = r4 + 2;
   M[r8 + 0] = Null;
84202fb8:	00 00 0a d5 	M[r8 + 0] = Null;
   M[r8 + MK1] = Null;
84202fbc:	04 00 0a d5 	M[r8 + 4] = Null;
   r0 = 1;
84202fc0:	2f 00 20 e4 	r0 = Null + 1;
   M[r8 + MK2] = r0;
84202fc4:	08 00 2a d5 	M[r8 + 8] = r0;
   M[r8 + 3*MK1] = Null;
84202fc8:	0c 00 0a d5 	M[r8 + 12] = Null;

   Addr2Words(r3);
84202fcc:	fe 00 55 91 	r3 = r3 ASHIFT -2;
   Null = r3 - 7;
84202fd0:	07 00 05 21 	Null = r3 - 7;
   if NEG jump path1;
84202fd4:	2b 00 40 dd 	if NEG jump $M.celt.ncwrs_urow.path1;
   Null = r4 - 256;
84202fd8:	00 01 06 21 	Null = r4 - 256;
   if POS jump path1;
84202fdc:	29 00 50 dd 	if POS jump $M.celt.ncwrs_urow.path1;

84202fe0 <$M.celt.ncwrs_urow.path2>:
   path2: /*n>6 && k<=255*/
      r0 = r3 + r3;
84202fe0:	5f 00 25 00 	r0 = r3 + r3;
      r0 = r0 - 1;
84202fe4:	3f 00 22 e4 	r0 = r0 - 1;
      M[r8 + 4*MK1] = r0;
84202fe8:	10 00 2a d5 	M[r8 + 16] = r0;
      r1 = 0;
84202fec:	00 00 30 01 	r1 = Null + 0;
      M[r8 + 5*MK1] = r1;
84202ff0:	14 00 3a d5 	M[r8 + 20] = r1;
      M3 = r4 + -1;
84202ff4:	ff ff b6 51 	M3 = r4 + -1;
      if LE jump end;
84202ff8:	35 00 d0 dd 	if LE jump $M.celt.ncwrs_urow.end;
      I3 = r8 + 6*ADDR_PER_WORD;
84202ffc:	18 00 3a 51 	I3 = r8 + 24;
      r4 = 1;
84203000:	2f 00 60 e4 	r4 = Null + 1;
      r5 = 0;
84203004:	00 00 70 01 	r5 = Null + 0;
      r2 = r0;
84203008:	0f 00 42 00 	r2 = r0 + Null;
      r3 = r1;
8420300c:	0f 00 53 00 	r3 = r1 + Null;
      M[FP + TEMP + 0] = r2;  //UM1
84203010:	08 00 4c f1 	M[FP + 0x8] = r2;
      M[FP + TEMP + MK1] = r3;  //uM1
84203014:	0c 00 5c f1 	M[FP + 0xc] = r3;
      M[FP + TEMP + MK2] = r4;  //um2
84203018:	10 00 6c f1 	M[FP + 0x10] = r4;
      M[FP + TEMP + 3*MK1] = r5;  //um2
8420301c:	14 00 7c f1 	M[FP + 0x14] = r5;
      r10 = FP + TEMP + 2*MK1;
84203020:	10 00 c7 f1 	r10 = FP + 16;
      I2 = r10;
84203024:	cf 00 20 50 	I2 = Null + r10;
      r10 = 2; //is not a do loop
84203028:	af 00 c0 e4 	r10 = Null + 2;
      M2 = 1;
8420302c:	01 00 a0 51 	M2 = Null + 1;

84203030 <$M.celt.ncwrs_urow.path2_unext_loop>:
      path2_unext_loop:
         r4 = M[I2, MK1];                //um2 2 ->3
84203030:	00 69 00 03 	Null = Null + Null, r4 = M[I2,4];
         r5 = M[I2, -MK1];               //um2 3->2
84203034:	00 7b 00 03 	Null = Null + Null, r5 = M[I2,-4];
         call $celt.imusdiv32;
84203038:	c8 0a f0 e1 	call $celt.imusdiv32;
         r2 = r2 + r4;
8420303c:	00 00 46 03 	r2 = r2 + r4;
         r3 = r3 + r5 + Carry, M[I2, MK1] = r2; //um2 2 ->3
84203040:	00 c9 57 07 	r3 = r3 + r5 + Carry, M[I2,4] = r2;
         M[I2, -MK1] = r3;                       //um2 3 ->2
84203044:	00 db 00 03 	Null = Null + Null, M[I2,-4] = r3;
         r10 = r10 + M2, M[I3, MK1] = r2;
84203048:	00 cd ca 47 	r10 = r10 + M2, M[I3,4] = r2;
         M3 = M3 - M2, M[I3, MK1] = r3;
8420304c:	00 dd ba 7f 	M3 = M3 - M2, M[I3,4] = r3;
         if Z jump end;
84203050:	1f 00 00 dd 	if EQ jump $M.celt.ncwrs_urow.end;
         r5 = M[I2, -MK1];               //2->1 dummy
84203054:	00 7b 00 03 	Null = Null + Null, r5 = M[I2,-4];
         r5 = M[I2, -MK1];               //um1 1->0
84203058:	00 7b 00 03 	Null = Null + Null, r5 = M[I2,-4];
         r4 = M[I2, 0];                //um1 0->0
8420305c:	00 68 00 03 	Null = Null + Null, r4 = M[I2,0];
         call $celt.imusdiv32;
84203060:	be 0a f0 e1 	call $celt.imusdiv32;

         r2 = r2 + r4;
84203064:	00 00 46 03 	r2 = r2 + r4;
         r3 = r3 + r5 + Carry, M[I2, MK1] = r2;  //um2 0 ->1
84203068:	00 c9 57 07 	r3 = r3 + r5 + Carry, M[I2,4] = r2;
         M[I2, MK1] = r3;                        //um2 1 ->2
8420306c:	00 d9 00 03 	Null = Null + Null, M[I2,4] = r3;
         r10 = r10 + M2, M[I3, MK1] = r2;
84203070:	00 cd ca 47 	r10 = r10 + M2, M[I3,4] = r2;
         M3 = M3 - M2, M[I3, MK1] = r3;
84203074:	00 dd ba 7f 	M3 = M3 - M2, M[I3,4] = r3;
      if NZ jump path2_unext_loop;
84203078:	ee ff 10 dd 	if NE jump $M.celt.ncwrs_urow.path2_unext_loop;
      jump end;
8420307c:	14 00 f0 dd 	jump $M.celt.ncwrs_urow.end;

84203080 <$M.celt.ncwrs_urow.path1>:
   path1: /*n<=6 || k>255*/
      r10 = r4 - 1;
84203080:	3f 00 c6 e4 	r10 = r4 - 1;
      I3 = r8 + 4*ADDR_PER_WORD;
84203084:	10 00 3a 51 	I3 = r8 + 16;
      r0 = 3;
84203088:	03 00 20 01 	r0 = Null + 3;
      r1 = 2;
8420308c:	af 00 30 e4 	r1 = Null + 2;
      r2 = 0;
84203090:	00 00 40 01 	r2 = Null + 0;
      do set_uk_2_plus_loop;
84203094:	03 00 f0 e5 	do $M.celt.ncwrs_urow.set_uk_2_plus_loop;
         r0 = r0 + r1, M[I3, MK1] = r0;
84203098:	00 ad 23 03 	r0 = r0 + r1, M[I3,4] = r0;
         M[I3, MK1] = r2;
8420309c:	00 cd 00 03 	Null = Null + Null, M[I3,4] = r2;

842030a0 <$M.celt.ncwrs_urow.set_uk_2_plus_loop>:
      set_uk_2_plus_loop:
      M[I3, MK1] = r0;
842030a0:	00 ad 00 03 	Null = Null + Null, M[I3,4] = r0;
      M[I3, MK2] = r2;
842030a4:	00 ce 00 03 	Null = Null + Null, M[I3,8] = r2;
      M3 = r3 - 2;
842030a8:	02 00 b5 71 	M3 = r3 - 2;
      M2 = r4 + 1;
842030ac:	01 00 a6 51 	M2 = r4 + 1;

842030b0 <$M.celt.ncwrs_urow.path1_unext_loop>:
      path1_unext_loop:
         r10 = M2;
842030b0:	af 00 c0 44 	r10 = Null + M2;
         r3 = 0;
842030b4:	00 00 50 01 	r3 = Null + 0;
         r2 = 1;
842030b8:	2f 00 40 e4 	r2 = Null + 1;
         I3 = I7 + 2*ADDR_PER_WORD;
842030bc:	08 00 37 59 	I3 = I7 + 8;
         call $celt.unext;
842030c0:	88 ff f0 e1 	call $celt.unext;
         M3 = M3 - 1;
842030c4:	01 00 bb 79 	M3 = M3 - 1;
      if NZ jump path1_unext_loop;
842030c8:	fa ff 10 dd 	if NE jump $M.celt.ncwrs_urow.path1_unext_loop;

842030cc <$M.celt.ncwrs_urow.end>:
   end:
   r0 = M[I6, MK1];
842030cc:	29 00 00 03 	Null = Null + Null, r0 = M[I6,4];
   r1 = M[I6, MK1];
842030d0:	39 00 00 03 	Null = Null + Null, r1 = M[I6,4];
   r2 = M[I6, MK1];
842030d4:	49 00 00 03 	Null = Null + Null, r2 = M[I6,4];
   r3 = M[I6, MK1];
842030d8:	59 00 00 03 	Null = Null + Null, r3 = M[I6,4];
   r0 = r0 + r2;
842030dc:	00 00 24 03 	r0 = r0 + r2;
   r1 = r1 + r3 + Carry;
842030e0:	00 00 35 07 	r1 = r1 + r3 + Carry;
   SP = SP - STACK_FRAME_SIZE;
842030e4:	f0 ff 03 f1 	SP = SP + -16;
   popm <FP,rLink>;
842030e8:	01 20 04 f1 	popm <FP, rLink>;
   rts;
842030ec:	0f 00 0d dc 	rts;

842030f0 <$celt.alg_unquant>:

#if defined(PATCH_LIBS)
   LIBS_PUSH_REGS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.ALG_UNQUANT.PATCH_ID_0)     // celt_patchers
#endif   

   r0 = M0;
842030f0:	8f 00 20 44 	r0 = Null + M0;
   .CONST TEMP                 (0 + 2)*ADDR_PER_WORD;
   .CONST STACK_FRAME_SIZE     4*ADDR_PER_WORD;
   pushm <FP(=SP), rLink>;
842030f4:	01 20 00 f1 	pushm <FP(=SP), rLink>;
   SP = SP + STACK_FRAME_SIZE;
842030f8:	10 00 03 f1 	SP = SP + 16;
   M[FP + TEMP + 0] = r0;
842030fc:	08 00 2c f1 	M[FP + 0x8] = r0;
   r0 = I5;
84203100:	5f 00 20 44 	r0 = Null + I5;
   M[FP + TEMP + MK1] = r0;
84203104:	0c 00 2c f1 	M[FP + 0xc] = r0;
   M[FP + TEMP + MK2] = r3;
84203108:	10 00 5c f1 	M[FP + 0x10] = r3;
   $celt.get_pulses(r4, r1, get_pulses_lbl1)
8420310c:	fd 00 36 8d 	r1 = r4 LSHIFT -3;
84203110:	05 00 00 dd 	if EQ jump $M.celt.alg_unquant.get_pulses_lbl1;
84203114:	3f 00 33 e4 	r1 = r1 - 1;
84203118:	07 00 66 81 	r4 = r4 AND 0x7;
8420311c:	08 00 66 01 	r4 = r4 + 8;
84203120:	00 00 63 8f 	r4 = r4 LSHIFT r1;

84203124 <$M.celt.alg_unquant.get_pulses_lbl1>:
   M[FP + TEMP + 3*MK1] = r4;
84203124:	14 00 6c f1 	M[FP + 0x14] = r4;

   r0 = M[r5 + $celt.dec.ALG_UNQUANT_ST_FIELD];
84203128:	c4 00 27 d1 	r0 = M[r5 + 196];
   I7 = r0;
8420312c:	2f 00 70 50 	I7 = Null + r0;
   call  $celt.decode_pulses;
84203130:	e6 fd f0 e1 	call $celt.decode_pulses;
   r3 = M[FP + TEMP + MK2];
84203134:	10 00 58 f1 	r3 = M[FP + 0x10];
   r4 = M[FP + TEMP + 3*MK1];
84203138:	14 00 68 f1 	r4 = M[FP + 0x14];

   // calc enrgy of output
   r10 = r3 - 1;
8420313c:	3f 00 c5 e4 	r10 = r3 - 1;
   r0 = M[r5 + $celt.dec.ALG_UNQUANT_ST_FIELD];
84203140:	c4 00 27 d1 	r0 = M[r5 + 196];
   I7 = r0;
84203144:	2f 00 70 50 	I7 = Null + r0;
   rMAC = 0, r0 = M[I7, MK1];
84203148:	2d 00 11 23 	rMAC = rMAC - rMAC, r0 = M[I7,4];
   do calc_en_lp;
8420314c:	02 00 f0 e5 	do $M.celt.alg_unquant.calc_en_lp;
      rMAC = rMAC + r0 * r0, r0 = M[I7, MK1];
84203150:	2d 00 22 af 	rMAC = rMAC + r0 * r0 (SS), r0 = M[I7,4];

84203154 <$M.celt.alg_unquant.calc_en_lp>:
   calc_en_lp:
   rMAC = rMAC + r0 * r0;
84203154:	2f 00 12 ac 	rMAC = rMAC + r0 * r0 (SS);

   // normalise residual
   r0 = M[FP + TEMP + MK1];
84203158:	0c 00 28 f1 	r0 = M[FP + 0xc];
   I5 = r0;
8420315c:	2f 00 50 50 	I5 = Null + r0;
   r0 = M[r5 + $celt.dec.ALG_UNQUANT_ST_FIELD];
84203160:	c4 00 27 d1 	r0 = M[r5 + 196];
   I7 = r0;
84203164:	2f 00 70 50 	I7 = Null + r0;
   call $celt.normalise_residual;
84203168:	97 06 f0 e1 	call $celt.normalise_residual;
   Null = M[FP + TEMP + 0];
8420316c:	08 00 08 f1 	Null = M[FP + 0x8];
   if Z jump end;
84203170:	08 00 00 dd 	if EQ jump $M.celt.alg_unquant.end;

   // rotation if required
   r6 = M[FP + TEMP];
84203174:	08 00 88 f1 	r6 = M[FP + 0x8];
   r0 = M[FP + TEMP + MK1];
84203178:	0c 00 28 f1 	r0 = M[FP + 0xc];
   I5 = r0;
8420317c:	2f 00 50 50 	I5 = Null + r0;
   r3 = M[FP + TEMP + MK2];
84203180:	10 00 58 f1 	r3 = M[FP + 0x10];
   r4 = M[FP + TEMP + 3*MK1];
84203184:	14 00 68 f1 	r4 = M[FP + 0x14];
   r7 = -1;
84203188:	3f 00 90 e4 	r7 = Null - 1;
   call $celt.exp_rotation;
8420318c:	b6 06 f0 e1 	call $celt.exp_rotation;

84203190 <$M.celt.alg_unquant.end>:
   end:
   SP = SP - STACK_FRAME_SIZE;
84203190:	f0 ff 03 f1 	SP = SP + -16;
   popm <FP,rLink>;
84203194:	01 20 04 f1 	popm <FP, rLink>;
   rts;
84203198:	0f 00 0d dc 	rts;

8420319c <$celt.icwrs2>:

#if defined(PATCH_LIBS)
   LIBS_PUSH_REGS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.ICWRS2.PATCH_ID_0)     // celt_patchers
#endif  
   
   I7 = I7 + MK1;
8420319c:	04 00 77 59 	I7 = I7 + 4;
   r0 = M[I7, -MK1];
842031a0:	2f 00 00 03 	Null = Null + Null, r0 = M[I7,-4];
   $celt.icwrs1(r0, r4, r6)
842031a4:	2f 00 80 e4 	r6 = Null + 1;
842031a8:	0f 00 62 00 	r4 = r0 + Null;
842031ac:	05 00 80 00 	if POS r6 = Null + Null;
842031b0:	61 00 60 20 	if NE r4 = Null - r4;
   $celt.ucwrs2(r4, r0)
842031b4:	6f 00 26 00 	r0 = r4 + r4;
842031b8:	3f 00 22 e4 	r0 = r0 - 1;
842031bc:	04 00 20 00 	if NEG r0 = Null + Null;
   r6 = r6 + r0, r1 = M[I7, 0];
842031c0:	3c 00 82 03 	r6 = r6 + r0, r1 = M[I7,0];
   Null = r1;
842031c4:	0f 00 03 00 	Null = r1 + Null;
   if POS jump end;
842031c8:	08 00 50 dd 	if POS jump $M.celt.icwrs2.end;
      r4 = r4 - r1;
842031cc:	00 00 63 23 	r4 = r4 - r1;
      r0 = r4 + 1;
842031d0:	2f 00 26 e4 	r0 = r4 + 1;
      $celt.ucwrs2(r0, r2)
842031d4:	2f 00 42 00 	r2 = r0 + r0;
842031d8:	3f 00 44 e4 	r2 = r2 - 1;
842031dc:	04 00 40 00 	if NEG r2 = Null + Null;
      r6 = r6 + r2;
842031e0:	00 00 84 03 	r6 = r6 + r2;
      rts;
842031e4:	0f 00 0d dc 	rts;

842031e8 <$M.celt.icwrs2.end>:
   end:
   r4 = r4 + r1;
842031e8:	00 00 63 03 	r4 = r4 + r1;
   rts;
842031ec:	0f 00 0d dc 	rts;

842031f0 <$celt.icwrs3>:

#if defined(PATCH_LIBS)
   LIBS_PUSH_REGS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.ICWRS3.PATCH_ID_0)     // celt_patchers
#endif  
   
   push rlink;
842031f0:	00 00 d0 f3 	push rLink;
   I7 = I7 + MK1;
842031f4:	04 00 77 59 	I7 = I7 + 4;
   call $celt.icwrs2;
842031f8:	e9 ff f0 e1 	call $celt.icwrs2;
   I7 = I7 - MK1;
842031fc:	04 00 77 79 	I7 = I7 - 4;
   $celt.ucwrs3(r4, r0, r1, icwrs3_lbl1)
84203200:	00 00 20 01 	r0 = Null + 0;
84203204:	00 00 30 01 	r1 = Null + 0;
84203208:	3f 00 16 e4 	rMAC = r4 - 1;
8420320c:	06 00 40 dd 	if NEG jump $M.celt.icwrs3.icwrs3_lbl1;
84203210:	1f 00 16 cc 	rMAC = r4 * rMAC (SS);
84203214:	20 00 21 8d 	r0 = rMAC LSHIFT 32;
84203218:	00 00 31 8d 	r1 = rMAC LSHIFT 0;
8420321c:	2f 00 22 e4 	r0 = r0 + 1;
84203220:	00 00 30 07 	r1 = r1 + Null + Carry;

84203224 <$M.celt.icwrs3.icwrs3_lbl1>:
   r6 = r6 + r0, r2 = M[I7, 0];
84203224:	4c 00 82 03 	r6 = r6 + r0, r2 = M[I7,0];
   r7 = r1 + Carry;
84203228:	0f 00 93 04 	r7 = r1 + Null + Carry;
   Null = r2;
8420322c:	0f 00 04 00 	Null = r2 + Null;
   if POS jump end;
84203230:	10 00 50 dd 	if POS jump $M.celt.icwrs3.end;
      r4 = r4 - r2;
84203234:	00 00 64 23 	r4 = r4 - r2;
      r0 = r4 + 1;
84203238:	2f 00 26 e4 	r0 = r4 + 1;
      $celt.ucwrs3(r0, r1, r2, icwrs3_lbl2)
8420323c:	00 00 30 01 	r1 = Null + 0;
84203240:	00 00 40 01 	r2 = Null + 0;
84203244:	3f 00 12 e4 	rMAC = r0 - 1;
84203248:	06 00 40 dd 	if NEG jump $M.celt.icwrs3.icwrs3_lbl2;
8420324c:	1f 00 12 cc 	rMAC = r0 * rMAC (SS);
84203250:	20 00 31 8d 	r1 = rMAC LSHIFT 32;
84203254:	00 00 41 8d 	r2 = rMAC LSHIFT 0;
84203258:	2f 00 33 e4 	r1 = r1 + 1;
8420325c:	00 00 40 07 	r2 = r2 + Null + Carry;

84203260 <$M.celt.icwrs3.icwrs3_lbl2>:
      r6 = r6 + r1;
84203260:	00 00 83 03 	r6 = r6 + r1;
      r7 = r7 + r2 + Carry;
84203264:	00 00 94 07 	r7 = r7 + r2 + Carry;
      jump $pop_rLink_and_rts;
84203268:	03 00 00 fd 	jump (m) 0x3b020;
8420326c:	21 b0 f0 dd 

84203270 <$M.celt.icwrs3.end>:
   end:
   r4 = r4 + r2;
84203270:	00 00 64 03 	r4 = r4 + r2;
   jump $pop_rLink_and_rts;
84203274:	03 00 00 fd 	jump (m) 0x3b020;
84203278:	21 b0 f0 dd 

8420327c <$celt.icwrs4>:

#if defined(PATCH_LIBS)
   LIBS_PUSH_REGS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.ICWRS4.PATCH_ID_0)     // celt_patchers
#endif 
   
   push rlink;
8420327c:	00 00 d0 f3 	push rLink;
   I7 = I7 + MK1;
84203280:	04 00 77 59 	I7 = I7 + 4;
   call $celt.icwrs3;
84203284:	db ff f0 e1 	call $celt.icwrs3;
   I7 = I7 - MK1;
84203288:	04 00 77 79 	I7 = I7 - 4;
   $celt.ucwrs4(r4, r0, r1, r2, icwrs4_lbl1)
8420328c:	00 00 30 01 	r1 = Null + 0;
84203290:	0f 00 26 00 	r0 = r4 + Null;
84203294:	12 00 00 dd 	if EQ jump $M.celt.icwrs4.icwrs4_lbl1;
84203298:	aa 2a 00 fd 	r2 = Null + 715827883;
8420329c:	ab aa 40 01 
842032a0:	6f 00 16 00 	rMAC = r4 + r4;
842032a4:	03 00 11 21 	rMAC = rMAC - 3;
842032a8:	00 00 16 9b 	rMAC = rMAC * r4 (int);
842032ac:	bf 00 11 e4 	rMAC = rMAC + 4;
842032b0:	4f 00 31 94 	r1 = rMAC * r2 (frac);
842032b4:	03 00 33 99 	r1 = r1 * 3 (int);
842032b8:	1f 00 03 20 	Null = r1 - rMAC;
842032bc:	41 00 22 94 	if NE r0 = r0 * r2 (frac);
842032c0:	1f 00 03 20 	Null = r1 - rMAC;
842032c4:	40 00 11 94 	if EQ rMAC = rMAC * r2 (frac);
842032c8:	2f 00 11 cc 	rMAC = rMAC * r0 (SS);
842032cc:	20 00 21 8d 	r0 = rMAC LSHIFT 32;
842032d0:	00 00 31 8d 	r1 = rMAC LSHIFT 0;
842032d4:	3f 00 22 e4 	r0 = r0 - 1;
842032d8:	00 00 30 27 	r1 = r1 - Null - Borrow;

842032dc <$M.celt.icwrs4.icwrs4_lbl1>:
   r6 = r6 + r0, r2 = M[I7, 0];
842032dc:	4c 00 82 03 	r6 = r6 + r0, r2 = M[I7,0];
   r7 = r1 + Carry;
842032e0:	0f 00 93 04 	r7 = r1 + Null + Carry;
   Null = r2;
842032e4:	0f 00 04 00 	Null = r2 + Null;
   if POS jump end;
842032e8:	1b 00 50 dd 	if POS jump $M.celt.icwrs4.end;
      r4 = r4 - r2;
842032ec:	00 00 64 23 	r4 = r4 - r2;
      r0 = r4 + 1;
842032f0:	2f 00 26 e4 	r0 = r4 + 1;
      $celt.ucwrs4(r0, r1, r2, r3, icwrs4_lbl2)
842032f4:	00 00 40 01 	r2 = Null + 0;
842032f8:	0f 00 32 00 	r1 = r0 + Null;
842032fc:	12 00 00 dd 	if EQ jump $M.celt.icwrs4.icwrs4_lbl2;
84203300:	aa 2a 00 fd 	r3 = Null + 715827883;
84203304:	ab aa 50 01 
84203308:	2f 00 12 00 	rMAC = r0 + r0;
8420330c:	03 00 11 21 	rMAC = rMAC - 3;
84203310:	00 00 12 9b 	rMAC = rMAC * r0 (int);
84203314:	bf 00 11 e4 	rMAC = rMAC + 4;
84203318:	5f 00 41 94 	r2 = rMAC * r3 (frac);
8420331c:	03 00 44 99 	r2 = r2 * 3 (int);
84203320:	1f 00 04 20 	Null = r2 - rMAC;
84203324:	51 00 33 94 	if NE r1 = r1 * r3 (frac);
84203328:	1f 00 04 20 	Null = r2 - rMAC;
8420332c:	50 00 11 94 	if EQ rMAC = rMAC * r3 (frac);
84203330:	3f 00 11 cc 	rMAC = rMAC * r1 (SS);
84203334:	20 00 31 8d 	r1 = rMAC LSHIFT 32;
84203338:	00 00 41 8d 	r2 = rMAC LSHIFT 0;
8420333c:	3f 00 33 e4 	r1 = r1 - 1;
84203340:	00 00 40 27 	r2 = r2 - Null - Borrow;

84203344 <$M.celt.icwrs4.icwrs4_lbl2>:
      r6 = r6 + r1;
84203344:	00 00 83 03 	r6 = r6 + r1;
      r7 = r7 + r2 + Carry;
84203348:	00 00 94 07 	r7 = r7 + r2 + Carry;
      jump $pop_rLink_and_rts;
8420334c:	03 00 00 fd 	jump (m) 0x3b020;
84203350:	21 b0 f0 dd 

84203354 <$M.celt.icwrs4.end>:
   end:
   r4 = r4 + r2;
84203354:	00 00 64 03 	r4 = r4 + r2;
   jump $pop_rLink_and_rts;
84203358:	03 00 00 fd 	jump (m) 0x3b020;
8420335c:	21 b0 f0 dd 

84203360 <$celt.icwrs5>:

#if defined(PATCH_LIBS)
   LIBS_PUSH_REGS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.ICWRS5.PATCH_ID_0)     // celt_patchers
#endif 
   
   push rlink;
84203360:	00 00 d0 f3 	push rLink;
   I7 = I7 + MK1;
84203364:	04 00 77 59 	I7 = I7 + 4;
   call $celt.icwrs4;
84203368:	c5 ff f0 e1 	call $celt.icwrs4;
   I7 = I7 - MK1;
8420336c:	04 00 77 79 	I7 = I7 - 4;
   $celt.ucwrs5(r4, r0, r1, r2, icwrs5_lbl1)
84203370:	00 00 30 01 	r1 = Null + 0;
84203374:	0f 00 26 00 	r0 = r4 + Null;
84203378:	13 00 00 dd 	if EQ jump $M.celt.icwrs5.icwrs5_lbl1;
8420337c:	aa 2a 00 fd 	r2 = Null + 715827883;
84203380:	ab aa 40 01 
84203384:	cf 00 16 e4 	rMAC = r4 - 2;
84203388:	00 00 16 9b 	rMAC = rMAC * r4 (int);
8420338c:	05 00 11 01 	rMAC = rMAC + 5;
84203390:	00 00 16 9b 	rMAC = rMAC * r4 (int);
84203394:	df 00 11 e4 	rMAC = rMAC - 4;
84203398:	4f 00 31 94 	r1 = rMAC * r2 (frac);
8420339c:	03 00 33 99 	r1 = r1 * 3 (int);
842033a0:	1f 00 03 20 	Null = r1 - rMAC;
842033a4:	41 00 22 94 	if NE r0 = r0 * r2 (frac);
842033a8:	1f 00 03 20 	Null = r1 - rMAC;
842033ac:	40 00 11 94 	if EQ rMAC = rMAC * r2 (frac);
842033b0:	2f 00 11 cc 	rMAC = rMAC * r0 (SS);
842033b4:	20 00 21 8d 	r0 = rMAC LSHIFT 32;
842033b8:	00 00 31 8d 	r1 = rMAC LSHIFT 0;
842033bc:	2f 00 22 e4 	r0 = r0 + 1;
842033c0:	00 00 30 07 	r1 = r1 + Null + Carry;

842033c4 <$M.celt.icwrs5.icwrs5_lbl1>:
   r6 = r6 + r0, r2 = M[I7, 0];
842033c4:	4c 00 82 03 	r6 = r6 + r0, r2 = M[I7,0];
   r7 = r1 + Carry;
842033c8:	0f 00 93 04 	r7 = r1 + Null + Carry;
   Null = r2;
842033cc:	0f 00 04 00 	Null = r2 + Null;
   if POS jump end;
842033d0:	1c 00 50 dd 	if POS jump $M.celt.icwrs5.end;
      r4 = r4 - r2;
842033d4:	00 00 64 23 	r4 = r4 - r2;
      r0 = r4 + 1;
842033d8:	2f 00 26 e4 	r0 = r4 + 1;
      $celt.ucwrs5(r0, r1, r2, r3, icwrs5_lbl2)
842033dc:	00 00 40 01 	r2 = Null + 0;
842033e0:	0f 00 32 00 	r1 = r0 + Null;
842033e4:	13 00 00 dd 	if EQ jump $M.celt.icwrs5.icwrs5_lbl2;
842033e8:	aa 2a 00 fd 	r3 = Null + 715827883;
842033ec:	ab aa 50 01 
842033f0:	cf 00 12 e4 	rMAC = r0 - 2;
842033f4:	00 00 12 9b 	rMAC = rMAC * r0 (int);
842033f8:	05 00 11 01 	rMAC = rMAC + 5;
842033fc:	00 00 12 9b 	rMAC = rMAC * r0 (int);
84203400:	df 00 11 e4 	rMAC = rMAC - 4;
84203404:	5f 00 41 94 	r2 = rMAC * r3 (frac);
84203408:	03 00 44 99 	r2 = r2 * 3 (int);
8420340c:	1f 00 04 20 	Null = r2 - rMAC;
84203410:	51 00 33 94 	if NE r1 = r1 * r3 (frac);
84203414:	1f 00 04 20 	Null = r2 - rMAC;
84203418:	50 00 11 94 	if EQ rMAC = rMAC * r3 (frac);
8420341c:	3f 00 11 cc 	rMAC = rMAC * r1 (SS);
84203420:	20 00 31 8d 	r1 = rMAC LSHIFT 32;
84203424:	00 00 41 8d 	r2 = rMAC LSHIFT 0;
84203428:	2f 00 33 e4 	r1 = r1 + 1;
8420342c:	00 00 40 07 	r2 = r2 + Null + Carry;

84203430 <$M.celt.icwrs5.icwrs5_lbl2>:
      r6 = r6 + r1;
84203430:	00 00 83 03 	r6 = r6 + r1;
      r7 = r7 + r2 + Carry;
84203434:	00 00 94 07 	r7 = r7 + r2 + Carry;
      jump $pop_rLink_and_rts;
84203438:	03 00 00 fd 	jump (m) 0x3b020;
8420343c:	21 b0 f0 dd 

84203440 <$M.celt.icwrs5.end>:
   end:
   r4 = r4 + r2;
84203440:	00 00 64 03 	r4 = r4 + r2;
   jump $pop_rLink_and_rts;
84203444:	03 00 00 fd 	jump (m) 0x3b020;
84203448:	21 b0 f0 dd 

8420344c <$celt.icwrs>:

#if defined(PATCH_LIBS)
   LIBS_PUSH_REGS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.ICWRS.PATCH_ID_0)     // celt_patchers
#endif 
   
   push rlink;
8420344c:	00 00 d0 f3 	push rLink;

   I2 = I5;
84203450:	0f 00 25 58 	I2 = I5 + Null;
   M0 = MK1;
84203454:	04 00 80 51 	M0 = Null + 4;
   r2 = 0;
84203458:	00 00 40 01 	r2 = Null + 0;
   r10 = r4, M[I2, M0] = r2;
8420345c:	0f c8 c6 00 	r10 = r4 + Null, M[I2,M0] = r2;
   r0 = 1, M[I2, M0] = r2; 
84203460:	2f c8 20 e4 	r0 = Null + 1, M[I2,M0] = r2;
   r1 = r0 + r0, M[I2, M0] = r0;
84203464:	2f a8 32 00 	r1 = r0 + r0, M[I2,M0] = r0;
   do init_u_loop;
84203468:	03 00 f0 e5 	do $M.celt.icwrs.init_u_loop;
      r0 = r0 + r1, M[I2, M0] = r2;
8420346c:	00 c8 23 02 	r0 = r0 + r1, M[I2,M0] = r2;
      M[I2, M0] = r0;
84203470:	00 a8 00 02 	Null = Null + Null, M[I2,M0] = r0;

84203474 <$M.celt.icwrs.init_u_loop>:
   init_u_loop:
   I7 = I7 - MK1;
84203474:	04 00 77 79 	I7 = I7 - 4;
   I7 = I7 + r3, M[I2, M0] = r2;
84203478:	00 c8 75 5a 	I7 = I7 + r3, M[I2,M0] = r2;
   r2 = M[I7, -MK1];
8420347c:	4f 00 00 03 	Null = Null + Null, r2 = M[I7,-4];
   $celt.icwrs1(r2, r8, r6)
84203480:	2f 00 80 e4 	r6 = Null + 1;
84203484:	0f 00 a4 00 	r8 = r2 + Null;
84203488:	05 00 80 00 	if POS r6 = Null + Null;
8420348c:	a1 00 a0 20 	if NE r8 = Null - r8;
   r8 = r8 + r8;
84203490:	00 00 aa 03 	r8 = r8 + r8;
   Words2Addr(r8);
84203494:	02 00 aa 91 	r8 = r8 ASHIFT 2;
   r8 = I5 + r8;
84203498:	af 00 a5 48 	r8 = I5 + r8;
   r0 = M[r8 + 0];
8420349c:	00 00 2a d1 	r0 = M[r8 + 0];
   r6 = r6 + r0;
842034a0:	00 00 82 03 	r6 = r6 + r0;
   r7 = 0, r0 = M[I7, -MK1];
842034a4:	2f 00 99 23 	r7 = r7 - r7, r0 = M[I7,-4];
   r1  = r0 + r0;
842034a8:	2f 00 32 00 	r1 = r0 + r0;
   if POS jump index_up;
842034ac:	06 00 50 dd 	if POS jump $M.celt.icwrs.index_up;
      r1 = -r1;
842034b0:	3f 00 30 20 	r1 = Null - r1;
      r2 = r1 + 2;
842034b4:	af 00 43 e4 	r2 = r1 + 2;
      Words2Addr(r2);
842034b8:	02 00 44 91 	r2 = r2 ASHIFT 2;
      r0 = M[r8 + r2];
842034bc:	4f 00 2a d0 	r0 = M[r8 + r2];
      r6 = r6 + r0;
842034c0:	00 00 82 03 	r6 = r6 + r0;

842034c4 <$M.celt.icwrs.index_up>:
   index_up:
   Words2Addr(r1);
842034c4:	02 00 33 91 	r1 = r1 ASHIFT 2;
   r8 = r8 + r1;
842034c8:	00 00 a3 03 	r8 = r8 + r1;
   M3 = r3 - 2*ADDR_PER_WORD;
842034cc:	08 00 b5 71 	M3 = r3 - 8;
   M1 = r4 + 2;
842034d0:	02 00 96 51 	M1 = r4 + 2;

842034d4 <$M.celt.icwrs.index_up_loop>:
   index_up_loop:
       r2 = 0;
842034d4:	00 00 40 01 	r2 = Null + 0;
       r3 = 0;
842034d8:	00 00 50 01 	r3 = Null + 0;
       r10 = M1;
842034dc:	9f 00 c0 44 	r10 = Null + M1;
       I3 = I5;
842034e0:	0f 00 35 58 	I3 = I5 + Null;
       pushm<r6, r7>;
842034e4:	00 03 00 f1 	pushm <r6, r7>;
       call $celt.unext;
842034e8:	7e fe f0 e1 	call $celt.unext;
       popm<r6, r7>;
842034ec:	00 03 04 f1 	popm <r6, r7>;
       r0 = M[r8 + 0];
842034f0:	00 00 2a d1 	r0 = M[r8 + 0];
       r1 = M[r8 + MK1];
842034f4:	04 00 3a d1 	r1 = M[r8 + 4];
       r6 = r6 + r0;
842034f8:	00 00 82 03 	r6 = r6 + r0;
       r7 = r7 + r1 + Carry, r5 = M[I7, -MK1];
842034fc:	7f 00 93 07 	r7 = r7 + r1 + Carry, r5 = M[I7,-4];
       r5 = r5 + r5;
84203500:	00 00 77 03 	r5 = r5 + r5;
       if POS jump end_update;
84203504:	09 00 50 dd 	if POS jump $M.celt.icwrs.end_update;
          r5 = -r5;
84203508:	7f 00 70 20 	r5 = Null - r5;
          r2 = r5 + 2; 
8420350c:	af 00 47 e4 	r2 = r5 + 2;
          Words2Addr(r2);
84203510:	02 00 44 91 	r2 = r2 ASHIFT 2;
          r0 = M[r8 + r2]; 
84203514:	4f 00 2a d0 	r0 = M[r8 + r2];
          r2 = r2 + ADDR_PER_WORD;
84203518:	bf 00 44 e4 	r2 = r2 + 4;
          r1 = M[r8 + r2];
8420351c:	4f 00 3a d0 	r1 = M[r8 + r2];
          r6 = r6 + r0;
84203520:	00 00 82 03 	r6 = r6 + r0;
          r7 = r7 + r1 + Carry;
84203524:	00 00 93 07 	r7 = r7 + r1 + Carry;

84203528 <$M.celt.icwrs.end_update>:
       end_update:
       Words2Addr(r5);
84203528:	02 00 77 91 	r5 = r5 ASHIFT 2;
       r8 = r8 + r5;
8420352c:	00 00 a7 03 	r8 = r8 + r5;
       M3 = M3 - ADDR_PER_WORD;  //1
84203530:	04 00 bb 79 	M3 = M3 - 4;
  if NZ jump index_up_loop;
84203534:	e8 ff 10 dd 	if NE jump $M.celt.icwrs.index_up_loop;
  r0 = M[r8 + 0];
84203538:	00 00 2a d1 	r0 = M[r8 + 0];
  r1 = M[r8 +   MK1];
8420353c:	04 00 3a d1 	r1 = M[r8 + 4];
  r2 = M[r8 + 2*MK1];
84203540:	08 00 4a d1 	r2 = M[r8 + 8];
  r3 = M[r8 + 3*MK1];
84203544:	0c 00 5a d1 	r3 = M[r8 + 12];
  r0 = r0 + r2;
84203548:	00 00 24 03 	r0 = r0 + r2;
  r1 = r1 + r3 + Carry;
8420354c:	00 00 35 07 	r1 = r1 + r3 + Carry;
  jump $pop_rLink_and_rts;
84203550:	03 00 00 fd 	jump (m) 0x3b020;
84203554:	21 b0 f0 dd 

84203558 <$celt.encode_pulses32>:

#if defined(PATCH_LIBS)
   LIBS_PUSH_REGS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.ENCODE_PULSES32.PATCH_ID_0)     // celt_patchers
#endif 
   
   push rlink;
84203558:	00 00 d0 f3 	push rLink;
#ifndef CELT_USE_EXTERNAL_MEMORY
   .VAR jump_table[5]  = &n_1, &n_2, &n_3, &n_4, n_5;
#endif   
   // save nr of pulses and bins
   pushm<r3, r4, r5>;
8420355c:	e0 00 00 f1 	pushm <r3, r4, r5>;
   push I7;
84203560:	00 00 71 f3 	push I7;
   
#if defined (KAL_ARCH4) || defined (KAL_ARCH5)
   r3 = r3 ASHIFT 2;
84203564:	02 00 55 91 	r3 = r3 ASHIFT 2;
   Null = r3 - 6*4; // ARCH4/5: 4 AU per program word
84203568:	18 00 05 21 	Null = r3 - 24;
#else
   Null = r3 - 6; // else: 1 AU per program word
#endif   
   if POS jump default;
8420356c:	50 00 50 dd 	if POS jump $M.celt.encode_pulses32.default;
   Null = r3 - 1;
84203570:	3f 00 05 e4 	Null = r3 - 1;
   if NEG call $error;
84203574:	03 00 00 fd 	if NEG call (m) 0x3ac3e;
84203578:	3f ac 40 e1 
   // jump to proper function based on number of outputs
   // all can be processed using default (takes more cycles)
#ifdef CELT_USE_EXTERNAL_MEMORY
   r0 = M[r5 + $celt.enc.ENC_JUMP_TABLE_FIELD];
8420357c:	24 02 27 d1 	r0 = M[r5 + 548];
   r0 = r0 - MK1;
84203580:	df 00 22 e4 	r0 = r0 - 4;
   r0 = M[r3 + r0];
84203584:	2f 00 25 d0 	r0 = M[r3 + r0];
#else
   r0 = M[r3 + (jump_table-MK1)];
#endif
   jump r0;
84203588:	0f 00 02 dc 	jump r0;

8420358c <$M.celt.encode_pulses32.n_1>:

   // -- process n = 1
   n_1:
      r0 = M[I7, 0];
8420358c:	2c 00 00 03 	Null = Null + Null, r0 = M[I7,0];
      $celt.icwrs1(r0, r4, r6)
84203590:	2f 00 80 e4 	r6 = Null + 1;
84203594:	0f 00 62 00 	r4 = r0 + Null;
84203598:	05 00 80 00 	if POS r6 = Null + Null;
8420359c:	61 00 60 20 	if NE r4 = Null - r4;
      r0 = 1;
842035a0:	2f 00 20 e4 	r0 = Null + 1;
      M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FTB + 0] = r0;
842035a4:	e4 01 27 d5 	M[r5 + 484] = r0;
      M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FL + 0] = r6;
842035a8:	d4 01 87 d5 	M[r5 + 468] = r6;
      M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FL + MK1] = Null;
842035ac:	d8 01 07 d5 	M[r5 + 472] = Null;
      
      call $celt.ec_enc_bits;
842035b0:	ac fb f0 e1 	call $celt.ec_enc_bits;
   jump $pop_rLink_and_rts;
842035b4:	03 00 00 fd 	jump (m) 0x3b020;
842035b8:	21 b0 f0 dd 

842035bc <$M.celt.encode_pulses32.n_2>:

   // -- process n = 2
   n_2:
      call $celt.icwrs2;
842035bc:	f8 fe f0 e1 	call $celt.icwrs2;
      $celt.ncwrs2(r4, r0)
842035c0:	2f 00 20 e4 	r0 = Null + 1;
842035c4:	0f 00 06 00 	Null = r4 + Null;
842035c8:	61 00 26 00 	if NE r0 = r4 + r4;
842035cc:	21 00 22 00 	if NE r0 = r0 + r0;
      r1 = 0;
842035d0:	00 00 30 01 	r1 = Null + 0;
      r7 = 0;
842035d4:	00 00 90 01 	r7 = Null + 0;
   jump end;
842035d8:	3a 00 f0 dd 	jump $M.celt.encode_pulses32.end;

842035dc <$M.celt.encode_pulses32.n_3>:

   // -- process n = 3
   n_3:
      call $celt.icwrs3;
842035dc:	05 ff f0 e1 	call $celt.icwrs3;
      $celt.ncwrs3(r4, r0, r1, encode_pulses32_n_3_lb1)
842035e0:	2f 00 20 e4 	r0 = Null + 1;
842035e4:	00 00 30 01 	r1 = Null + 0;
842035e8:	0f 00 16 00 	rMAC = r4 + Null;
842035ec:	07 00 00 dd 	if EQ jump $M.celt.encode_pulses32.encode_pulses32_n_3_lb1;
842035f0:	00 00 11 03 	rMAC = rMAC + rMAC;
842035f4:	1f 00 16 cc 	rMAC = r4 * rMAC (SS);
842035f8:	20 00 21 8d 	r0 = rMAC LSHIFT 32;
842035fc:	00 00 31 8d 	r1 = rMAC LSHIFT 0;
84203600:	af 00 22 e4 	r0 = r0 + 2;
84203604:	00 00 30 07 	r1 = r1 + Null + Carry;

84203608 <$M.celt.encode_pulses32.encode_pulses32_n_3_lb1>:
   jump end;
84203608:	2e 00 f0 dd 	jump $M.celt.encode_pulses32.end;

8420360c <$M.celt.encode_pulses32.n_4>:

   // -- process n = 4
   n_4:
      call $celt.icwrs4;
8420360c:	1c ff f0 e1 	call $celt.icwrs4;
      $celt.ncwrs4(r4, r0, r1, r2, encode_pulses32_n_4_lb1)
84203610:	2f 00 20 e4 	r0 = Null + 1;
84203614:	00 00 30 01 	r1 = Null + 0;
84203618:	aa 2a 00 fd 	r2 = Null + 715827883;
8420361c:	ab aa 40 01 
84203620:	04 00 16 99 	rMAC = r4 * 4 (int);
84203624:	0c 00 00 dd 	if EQ jump $M.celt.encode_pulses32.encode_pulses32_n_4_lb1;
84203628:	6f 00 26 98 	r0 = r4 * r4 (int);
8420362c:	af 00 22 e4 	r0 = r0 + 2;
84203630:	4f 00 31 94 	r1 = rMAC * r2 (frac);
84203634:	03 00 33 99 	r1 = r1 * 3 (int);
84203638:	1f 00 03 20 	Null = r1 - rMAC;
8420363c:	41 00 22 94 	if NE r0 = r0 * r2 (frac);
84203640:	1f 00 03 20 	Null = r1 - rMAC;
84203644:	40 00 11 94 	if EQ rMAC = rMAC * r2 (frac);
84203648:	2f 00 11 cc 	rMAC = rMAC * r0 (SS);
8420364c:	20 00 21 8d 	r0 = rMAC LSHIFT 32;
84203650:	00 00 31 8d 	r1 = rMAC LSHIFT 0;

84203654 <$M.celt.encode_pulses32.encode_pulses32_n_4_lb1>:
   jump end;
84203654:	1b 00 f0 dd 	jump $M.celt.encode_pulses32.end;

84203658 <$M.celt.encode_pulses32.n_5>:

   // -- process n = 5
   n_5:
      call $celt.icwrs5;
84203658:	42 ff f0 e1 	call $celt.icwrs5;
      $celt.ncwrs5(r4, r0, r1, r2, decode_pulses32_n_5_lb1)
8420365c:	2f 00 20 e4 	r0 = Null + 1;
84203660:	00 00 30 01 	r1 = Null + 0;
84203664:	aa 2a 00 fd 	r2 = Null + 715827883;
84203668:	ab aa 40 01 
8420366c:	6f 00 16 98 	rMAC = r4 * r4 (int);
84203670:	0e 00 00 dd 	if EQ jump $M.celt.encode_pulses32.decode_pulses32_n_5_lb1;
84203674:	05 00 21 01 	r0 = rMAC + 5;
84203678:	00 00 11 03 	rMAC = rMAC + rMAC;
8420367c:	4f 00 31 94 	r1 = rMAC * r2 (frac);
84203680:	03 00 33 99 	r1 = r1 * 3 (int);
84203684:	1f 00 03 20 	Null = r1 - rMAC;
84203688:	41 00 22 94 	if NE r0 = r0 * r2 (frac);
8420368c:	1f 00 03 20 	Null = r1 - rMAC;
84203690:	40 00 11 94 	if EQ rMAC = rMAC * r2 (frac);
84203694:	2f 00 11 cc 	rMAC = rMAC * r0 (SS);
84203698:	20 00 21 8d 	r0 = rMAC LSHIFT 32;
8420369c:	00 00 31 8d 	r1 = rMAC LSHIFT 0;
842036a0:	af 00 22 e4 	r0 = r0 + 2;
842036a4:	00 00 30 07 	r1 = r1 + Null + Carry;

842036a8 <$M.celt.encode_pulses32.decode_pulses32_n_5_lb1>:
   jump end;
842036a8:	06 00 f0 dd 	jump $M.celt.encode_pulses32.end;

842036ac <$M.celt.encode_pulses32.default>:

   // -- process n > 5
   default:
      r0 = M[r5 + $celt.enc.UVECTOR_FIELD];
842036ac:	c8 00 27 d1 	r0 = M[r5 + 200];
      I5 = r0;
842036b0:	2f 00 50 50 	I5 = Null + r0;
      push r5; // r5 needs to be preserved
842036b4:	00 00 70 f3 	push r5;
      call $celt.icwrs;
842036b8:	65 ff f0 e1 	call $celt.icwrs;
      pop r5;
842036bc:	00 00 74 f3 	pop r5;

842036c0 <$M.celt.encode_pulses32.end>:
   end:
      M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FT + 0] = r0;
842036c0:	cc 01 27 d5 	M[r5 + 460] = r0;
      M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FT + MK1] = r1;
842036c4:	d0 01 37 d5 	M[r5 + 464] = r1;
      M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FL + 0] = r6;
842036c8:	d4 01 87 d5 	M[r5 + 468] = r6;
      M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FL + MK1] = r7;
842036cc:	d8 01 97 d5 	M[r5 + 472] = r7;
      call $celt.ec_enc_uint;
842036d0:	80 fb f0 e1 	call $celt.ec_enc_uint;

      pop I7;
842036d4:	00 00 75 f3 	pop I7;
      popm<r3, r4, r5>;
842036d8:	e0 00 04 f1 	popm <r3, r4, r5>;

   jump $pop_rLink_and_rts;
842036dc:	03 00 00 fd 	jump (m) 0x3b020;
842036e0:	21 b0 f0 dd 

842036e4 <$celt.transient_analysis>:
842036e4:	d8 00 27 d1 	r0 = M[r5 + 216];
#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.TRANSIENT_ANALYSIS.PATCH_ID_0,r1)     // celt_patchers
#endif   

   r0 = M[r5 + $celt.enc.PREEMPH_LEFT_AUDIO_FIELD];
   I0 = r0;
842036e8:	2f 00 00 50 	I0 = Null + r0;
   r4 = M[r5 + $celt.enc.MODE_OVERLAP_FIELD];
842036ec:	40 00 67 d1 	r4 = M[r5 + 64];
   r0 =  M[r5 + $celt.enc.MODE_AUDIO_FRAME_SIZE_FIELD];
842036f0:	44 00 27 d1 	r0 = M[r5 + 68];
   r4 = r4 + r0;
842036f4:	00 00 62 03 	r4 = r4 + r0;
   M0 = 1 * ADDR_PER_WORD;
842036f8:	04 00 80 51 	M0 = Null + 4;
   r10 = r4 - 1;
842036fc:	3f 00 c6 e4 	r10 = r4 - 1;
   r1 = M[r5 + $celt.enc.TRANSIENT_PROC_FIELD];
84203700:	e4 00 37 d1 	r1 = M[r5 + 228];
   I1 = r1 , r0 = M[I0, M0];
84203704:	3f 20 10 50 	I1 = Null + r1, r0 = M[I0,M0];
   r1 = r0;
84203708:	0f 00 32 00 	r1 = r0 + Null;
   r7 = 0;
8420370c:	00 00 90 01 	r7 = Null + 0;
   do abs1_loop;
84203710:	05 00 f0 e5 	do $M.celt.transient_analysis.abs1_loop;
      if NEG r1 = -r1, r0 = M[I0, M0];
84203714:	34 20 30 20 	if NEG r1 = Null - r1, r0 = M[I0,M0];
      Null = r7 - r1;
84203718:	3f 00 09 20 	Null = r7 - r1;
      if NEG r7 = r1;          // r7 = max(abs(PREEMPH_LEFT))
8420371c:	04 00 93 00 	if NEG r7 = r1 + Null;
      r1 = r0, M[I1, M0] = r1; // TRANSIENT_PROC[] = abs(PREEMPH_LEFT[])
84203720:	0f b4 32 00 	r1 = r0 + Null, M[I1,M0] = r1;

84203724 <$M.celt.transient_analysis.abs1_loop>:
   abs1_loop:
   if NEG r1 = -r1;
84203724:	34 00 30 20 	if NEG r1 = Null - r1;
   M[I1, M0] = r1;
84203728:	00 b4 00 02 	Null = Null + Null, M[I1,M0] = r1;
   r0 = signdet r7;
8420372c:	0f 00 29 d8 	r0 = SIGNDET r7;
   r0 = r0 - $celt.MDCT_headroom_bits;
84203730:	05 00 22 21 	r0 = r0 - 5;
   Null = r7;
84203734:	0f 00 09 00 	Null = r7 + Null;
   if Z r0 = 0;
84203738:	00 00 20 00 	if EQ r0 = Null + Null;
   M[r5 + $celt.enc.MAX_SBAND + 0] = r0;
8420373c:	f8 01 27 d5 	M[r5 + 504] = r0;

   
   Null = M[r5 + $celt.enc.CELT_CHANNELS_FIELD];
84203740:	08 00 07 d1 	Null = M[r5 + 8];
   if Z jump end_rch_proc;
84203744:	14 00 00 dd 	if EQ jump $M.celt.transient_analysis.end_rch_proc;
      r0 = M[r5 + $celt.enc.PREEMPH_RIGHT_AUDIO_FIELD];
84203748:	24 01 27 d1 	r0 = M[r5 + 292];
      I0 = r0;      
8420374c:	2f 00 00 50 	I0 = Null + r0;
      r10 = r4, r0 = M[I0, M0];   
84203750:	0f 20 c6 00 	r10 = r4 + Null, r0 = M[I0,M0];
      r1 = M[r5 + $celt.enc.TRANSIENT_PROC_FIELD];
84203754:	e4 00 37 d1 	r1 = M[r5 + 228];
      I1 = r1;
84203758:	3f 00 10 50 	I1 = Null + r1;
      r7 = 0;
8420375c:	00 00 90 01 	r7 = Null + 0;
      do abs2_loop;
84203760:	08 00 f0 e5 	do $M.celt.transient_analysis.abs2_loop;
         r0 = r0 + Null, r1 = M[I1, 0];
84203764:	00 34 20 03 	r0 = r0 + Null, r1 = M[I1,0];
         if NEG r0 = -r0;
84203768:	24 00 20 20 	if NEG r0 = Null - r0;
         Null = r7 - r0;
8420376c:	2f 00 09 20 	Null = r7 - r0;
         if NEG r7 = r0;                 // r7 = max(abs(PREEMPH_RIGHT))
84203770:	04 00 92 00 	if NEG r7 = r0 + Null;
         Null = r1 - r0;
84203774:	2f 00 03 20 	Null = r1 - r0;
         if NEG r1 = r0, r0 = M[I0, M0]; // TRANSIENT_PROC[] = max( abs(PREEMPH_LEFT), abs(PREEMPH_RIGHT) )
84203778:	04 20 32 00 	if NEG r1 = r0 + Null, r0 = M[I0,M0];
         M[I1, MK1] = r1;         
8420377c:	00 b5 00 03 	Null = Null + Null, M[I1,4] = r1;

84203780 <$M.celt.transient_analysis.abs2_loop>:
      abs2_loop:
      r0 = signdet r7;
84203780:	0f 00 29 d8 	r0 = SIGNDET r7;
      r0 = r0 - $celt.MDCT_headroom_bits;
84203784:	05 00 22 21 	r0 = r0 - 5;
      Null = r7;
84203788:	0f 00 09 00 	Null = r7 + Null;
      if Z r0 = 0;
8420378c:	00 00 20 00 	if EQ r0 = Null + Null;
      M[r5 + $celt.enc.MAX_SBAND + ADDR_PER_WORD] = r0;
84203790:	fc 01 27 d5 	M[r5 + 508] = r0;

84203794 <$M.celt.transient_analysis.end_rch_proc>:
   end_rch_proc:
   r1 = M[r5 + $celt.enc.TRANSIENT_PROC_FIELD];//&$celt.enc.begin;
84203794:	e4 00 37 d1 	r1 = M[r5 + 228];
   I1 = r1;
84203798:	3f 00 10 50 	I1 = Null + r1;
   I0 = r1;
8420379c:	3f 00 00 50 	I0 = Null + r1;
   r10 = r4 - 1;
842037a0:	3f 00 c6 e4 	r10 = r4 - 1;
   r1 = 0, r0 = M[I0, M0];
842037a4:	0f 20 30 00 	r1 = Null + Null, r0 = M[I0,M0];
   Null = r1 - r0;
842037a8:	2f 00 03 20 	Null = r1 - r0;
   do max_loop;
842037ac:	03 00 f0 e5 	do $M.celt.transient_analysis.max_loop;
      if NEG r1 = r0, r0 = M[I0, M0];
842037b0:	04 20 32 00 	if NEG r1 = r0 + Null, r0 = M[I0,M0];
      Null = r1 - r0, M[I1, M0] = r1;
842037b4:	2f b4 03 20 	Null = r1 - r0, M[I1,M0] = r1;

842037b8 <$M.celt.transient_analysis.max_loop>:
   max_loop:
   if NEG r1 = r0;
842037b8:	04 00 32 00 	if NEG r1 = r0 + Null;
   M[I1, M0] = r1;
842037bc:	00 b4 00 02 	Null = Null + Null, M[I1,M0] = r1;

   M[r5 + $celt.enc.SHORT_BLOCKS_FIELD] = Null;
842037c0:	58 01 07 d5 	M[r5 + 344] = Null;
   r0 = M[r5 + $celt.enc.MODE_NB_SHORT_MDCTS_FIELD];
842037c4:	58 00 27 d1 	r0 = M[r5 + 88];
   Null = r0 - 2;
842037c8:	cf 00 02 e4 	Null = r0 - 2;
   if NEG rts;
842037cc:	04 00 0d dc 	if NEG rts;

   r2 = r1*0.2(frac);
842037d0:	99 19 00 fd 	r2 = r1 * 0.200000000186264514923095703125 (frac);
842037d4:	9a 99 43 95 
   r6 = M[r5 + $celt.enc.TRANSIENT_PROC_FIELD];  //&$celt.enc.begin;
842037d8:	e4 00 87 d1 	r6 = M[r5 + 228];
   I0 = r6 + 8 * ADDR_PER_WORD;
842037dc:	20 00 08 51 	I0 = r6 + 32;
   I1 = r6;
842037e0:	8f 00 10 50 	I1 = Null + r6;
   r10 = r4 - 16;
842037e4:	10 00 c6 21 	r10 = r4 - 16;
   r0 = M[I0, M0];
842037e8:	00 20 00 02 	Null = Null + Null, r0 = M[I0,M0];
   do search_loop;
842037ec:	03 00 f0 e5 	do $M.celt.transient_analysis.search_loop;
      Null = r0 - r2, r0 = M[I0, M0];
842037f0:	4f 20 02 20 	Null = r0 - r2, r0 = M[I0,M0];
      if NEG I1 = I0;
842037f4:	04 00 10 58 	if NEG I1 = I0 + Null;

842037f8 <$M.celt.transient_analysis.search_loop>:
   search_loop:
   r2 = I1 - r6;
842037f8:	8f 00 41 68 	r2 = I1 - r6;
   r2 = r2 - 2 * ADDR_PER_WORD;
842037fc:	08 00 44 21 	r2 = r2 - 8;
   r0 = 0;
84203800:	00 00 20 01 	r0 = Null + 0;
   r3 = r2 - 32 * ADDR_PER_WORD;
84203804:	80 00 54 21 	r3 = r2 - 128;
   if NEG rts;
84203808:	04 00 0d dc 	if NEG rts;
   rMAC = 0;      // r2 = n, r1 = max = begin[len-1]
8420380c:	00 00 10 01 	rMAC = Null + 0;
   rMAC0 = r1;
84203810:	00 05 e3 8d 	rMAC0 = r1 LSHIFT 0;
   r3 = r2 + r6;
84203814:	8f 00 54 00 	r3 = r2 + r6;
   r0 = M[r3 -1*ADDR_PER_WORD];
84203818:	fc ff 25 d1 	r0 = M[r3 + -4];
   r0 = r0 LSHIFT -1;
8420381c:	ff 00 22 8d 	r0 = r0 LSHIFT -1;
   r0 = r0 + $celt.HALF_Q15_LSB_DIV2;
84203820:	00 40 22 01 	r0 = r0 + 16384;
   Div = rMAC/r0;
84203824:	00 00 12 d9 	Div = rMAC / r0;
   // ratio = ((begin[len - 1]) / (1 + begin[n - 16]));
   r0 = DivResult;  // output format = QX.1, ie a ratio of 2.0 will yield an integer of 4
84203828:	01 00 20 d9 	r0 = DivResult;
   Null = r0 - 10; // 5.0 
8420382c:	0a 00 02 21 	Null = r0 - 10;
   if NEG rts;
84203830:	04 00 0d dc 	if NEG rts;
   r8 = r2;
84203834:	0f 00 a4 00 	r8 = r2 + Null;
   Addr2Words(r2);      
84203838:	fe 00 44 91 	r2 = r2 ASHIFT -2;
   M[r5 + $celt.enc.TRANSIENT_TIME_FIELD] = r2;   
8420383c:	64 01 47 d5 	M[r5 + 356] = r2;
   r1 = 3;
84203840:	03 00 30 01 	r1 = Null + 3;
   Null = r0 - $celt.SQRT_2048_MULT2;
84203844:	5a 00 02 21 	Null = r0 - 90;
   if NEG r1 = 0;
84203848:	04 00 30 00 	if NEG r1 = Null + Null;
   M[r5 + $celt.enc.TRANSIENT_SHIFT_FIELD] = r1;
8420384c:	68 01 37 d5 	M[r5 + 360] = r1;
   if Z jump end;
84203850:	1c 00 00 dd 	if EQ jump $M.celt.transient_analysis.end;
   
   r7 = M[r5 + $celt.enc.CELT_CHANNELS_FIELD];
84203854:	08 00 97 d1 	r7 = M[r5 + 8];
   r6 = M[r5 + $celt.enc.PREEMPH_LEFT_AUDIO_FIELD];
84203858:	d8 00 87 d1 	r6 = M[r5 + 216];
#ifdef CELT_USE_EXTERNAL_MEMORY
   r0 = M[r5 + $celt.enc.PTR_INV_TRANSIENT_WINDOW_TABLE_FIELD];
8420385c:	0c 02 27 d1 	r0 = M[r5 + 524];
   I7 = r0;
84203860:	2f 00 70 50 	I7 = Null + r0;

84203864 <$M.celt.transient_analysis.chan_win_loop>:
#endif // CELT_USE_EXTERNAL_MEMORY   
   chan_win_loop:
#ifdef CELT_USE_EXTERNAL_MEMORY
      I4 = I7;
84203864:	0f 00 47 58 	I4 = I7 + Null;
#else
      I4 = &$celt.inv_transientWindow;
#endif
      I0 = r6 + r8;
84203868:	af 00 08 50 	I0 = r6 + r8;
      I0 = I0 - 16 * ADDR_PER_WORD;
8420386c:	40 00 00 79 	I0 = I0 - 64;
      I1 = I0;
84203870:	0f 00 10 58 	I1 = I0 + Null;
      r10 = 15;
84203874:	0f 00 c0 01 	r10 = Null + 15;
      r0 = M[I0, MK1], r1 = M[I4, MK1];
84203878:	31 21 00 03 	Null = Null + Null, r0 = M[I0,4], r1 = M[I4,4];
      r3 = r0 * r1 (frac);
8420387c:	3f 00 52 94 	r3 = r0 * r1 (frac);
      do tran_win_loop;
84203880:	03 00 f0 e5 	do $M.celt.transient_analysis.tran_win_loop;
         r0 = M[I0, MK1], r1 = M[I4, MK1];
84203884:	31 21 00 03 	Null = Null + Null, r0 = M[I0,4], r1 = M[I4,4];
         r3 = r0 * r1 (frac), M[I1, M0] = r3;
84203888:	3f d4 52 94 	r3 = r0 * r1 (frac), M[I1,M0] = r3;

8420388c <$M.celt.transient_analysis.tran_win_loop>:
      tran_win_loop:
      M[I1, M0] = r3;
8420388c:	00 d4 00 02 	Null = Null + Null, M[I1,M0] = r3;
      r1 = 0.125;
84203890:	00 10 00 fd 	r1 = Null + 268435456;
84203894:	00 00 30 01 
      r10 = r4 - r2, r0 = M[I0, M0];
84203898:	4f 20 c6 20 	r10 = r4 - r2, r0 = M[I0,M0];
      r10 = r10 - 1;
8420389c:	3f 00 cc e4 	r10 = r10 - 1;
      do tran_wing_loop;
842038a0:	03 00 f0 e5 	do $M.celt.transient_analysis.tran_wing_loop;
         r3 = r1 * r0 (frac), r0 = M[I0, M0];
842038a4:	2f 20 53 94 	r3 = r1 * r0 (frac), r0 = M[I0,M0];
         M[I1, M0] = r3;
842038a8:	00 d4 00 02 	Null = Null + Null, M[I1,M0] = r3;

842038ac <$M.celt.transient_analysis.tran_wing_loop>:
      tran_wing_loop:
      r3 = r1 * r0 (frac);
842038ac:	2f 00 53 94 	r3 = r1 * r0 (frac);
      M[I1, M0] = r3;
842038b0:	00 d4 00 02 	Null = Null + Null, M[I1,M0] = r3;
      r6 = M[r5 + $celt.enc.PREEMPH_RIGHT_AUDIO_FIELD];
842038b4:	24 01 87 d1 	r6 = M[r5 + 292];
      r7 = r7 - 1;
842038b8:	3f 00 99 e4 	r7 = r7 - 1;
   if POS jump chan_win_loop;
842038bc:	ea ff 50 dd 	if POS jump $M.celt.transient_analysis.chan_win_loop;

842038c0 <$M.celt.transient_analysis.end>:
   end:
   r0 = $celt.FLAG_SHORT;
842038c0:	00 08 20 01 	r0 = Null + 2048;
   M[r5 + $celt.enc.SHORT_BLOCKS_FIELD] = r0;
842038c4:	58 01 27 d5 	M[r5 + 344] = r0;
   r0 = $celt.FLAG_FOLD;
842038c8:	00 04 20 01 	r0 = Null + 1024;
   M[r5 + $celt.enc.HAS_FOLD_FIELD] = r0;   
842038cc:	60 01 27 d5 	M[r5 + 352] = r0;
   rts;
842038d0:	0f 00 0d dc 	rts;

842038d4 <$celt.transient_synthesis>:

#if defined(PATCH_LIBS)
   LIBS_PUSH_R0_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.TRANSIENT_SYNTHESIS.PATCH_ID_0,r4)     // celt_patchers
#endif 
   
   r4 = M[r5 + $celt.dec.MODE_AUDIO_FRAME_SIZE_FIELD];
842038d4:	44 00 67 d1 	r4 = M[r5 + 68];
   r3 = M[r5 + $celt.dec.MODE_OVERLAP_FIELD];
842038d8:	40 00 57 d1 	r3 = M[r5 + 64];
   
   // copy output to scratch
   r2 = M[r5 + $celt.dec.TRANSIENT_PROC_FIELD];
842038dc:	f0 00 47 d1 	r2 = M[r5 + 240];
   M3 = r2;
842038e0:	4f 00 b0 50 	M3 = Null + r2;
   I1 = r2; //scratch memory
842038e4:	4f 00 10 50 	I1 = Null + r2;
   r10 = r4;                  //r10 = N
842038e8:	0f 00 c6 00 	r10 = r4 + Null;
   I4 = I5;                   //I4 = save(I5)
842038ec:	0f 00 45 58 	I4 = I5 + Null;
   I3 = I0;                   //I3 = save(I0)
842038f0:	0f 00 30 58 	I3 = I0 + Null;
   do read_buf_loop;
842038f4:	03 00 f0 e5 	do $M.celt.transient_synthesis.read_buf_loop;
      r2 = M[I5, MK1];
842038f8:	45 00 00 03 	Null = Null + Null, r2 = M[I5,4];
      M[I1, MK1] = r2;   
842038fc:	00 c5 00 03 	Null = Null + Null, M[I1,4] = r2;

84203900 <$M.celt.transient_synthesis.read_buf_loop>:
   read_buf_loop:
   
   // copy hist to scratch
   r10 = r3;
84203900:	0f 00 c5 00 	r10 = r3 + Null;
   do read_hist_loop;
84203904:	03 00 f0 e5 	do $M.celt.transient_synthesis.read_hist_loop;
      r2 = M[I0, MK1];
84203908:	00 41 00 03 	Null = Null + Null, r2 = M[I0,4];
      M[I1, MK1] = r2;   
8420390c:	00 c5 00 03 	Null = Null + Null, M[I1,4] = r2;

84203910 <$M.celt.transient_synthesis.read_hist_loop>:
   read_hist_loop:
   
   //apply transient window and shift to first 16 samples
   r2 = M[r5 + $celt.dec.TRANSIENT_TIME_FIELD];
84203910:	64 01 47 d1 	r2 = M[r5 + 356];
   Words2Addr(r2);
84203914:	02 00 44 91 	r2 = r2 ASHIFT 2;
   I1 = M3 - (16*ADDR_PER_WORD);
84203918:	40 00 1b 79 	I1 = M3 - 64;
   I1 = I1 + r2;     //16 samples before t time
8420391c:	00 00 14 5b 	I1 = I1 + r2;
   r10 = 16;                               //wlen
84203920:	10 00 c0 01 	r10 = Null + 16;
#ifdef CELT_USE_EXTERNAL_MEMORY
   r1 = M[r5 + $celt.dec.PTR_TRANSIENT_WINDOW_TABLE_FIELD];
84203924:	0c 02 37 d1 	r1 = M[r5 + 524];
   I6 = r1;
84203928:	3f 00 60 50 	I6 = Null + r1;
#else // CELT_USE_EXTERNAL_MEMORY
   I6 = &$celt.transientWindow;         //w
#endif // CELT_USE_EXTERNAL_MEMORY
   r6 = 1.0;                               
8420392c:	ff 7f 00 fd 	r6 = Null + 2147483647;
84203930:	ff ff 80 01 
   do transient_win_loop;
84203934:	07 00 f0 e5 	do $M.celt.transient_synthesis.transient_win_loop;
      r2 = M[I1, 0], r1 = M[I6, MK1];        //r2 = x , r1 = w
84203938:	39 44 00 03 	Null = Null + Null, r2 = M[I1,0], r1 = M[I6,4];
      rMAC = r1*r2;                        //rMAC = x*w
8420393c:	4f 00 13 cc 	rMAC = r1 * r2 (SS);
      rMAC = rMAC ASHIFT r0 (56bit);               //rMAC = x*w<<n
84203940:	00 00 12 93 	rMAC = rMAC ASHIFT r0 (56bit);
      rMAC = rMAC - r1*r2;                 //rMAC = x*w((1<<n) - 1)
84203944:	4f 00 13 bc 	rMAC = rMAC - r1 * r2 (SS);
      rMAC = rMAC + r6*r2;                 //rMAC = x*(1+w*((1<<n) - 1)
84203948:	4f 00 18 ac 	rMAC = rMAC + r6 * r2 (SS);
      M[I1, MK1] = rMAC;                     //save
8420394c:	00 95 00 03 	Null = Null + Null, M[I1,4] = rMAC;

84203950 <$M.celt.transient_synthesis.transient_win_loop>:
   transient_win_loop:
   // apply transient shift to the rest of buffer
   r10 = r3 + r4;                           //r10 = N + O
84203950:	6f 00 c5 00 	r10 = r3 + r4;
   r1 = M[r5 + $celt.dec.TRANSIENT_TIME_FIELD];
84203954:	64 01 37 d1 	r1 = M[r5 + 356];
   r10 = r10 - r1; //r10 = N + O -t
84203958:	00 00 c3 23 	r10 = r10 - r1;
   r10 = r10 - 1;
8420395c:	3f 00 cc e4 	r10 = r10 - 1;
   r1 = M[I1, 0];                           //x
84203960:	00 34 00 03 	Null = Null + Null, r1 = M[I1,0];
   I6 = I1 + 1*ADDR_PER_WORD;                              
84203964:	04 00 61 59 	I6 = I1 + 4;
   M0 = MK1;
84203968:	04 00 80 51 	M0 = Null + 4;
   do shift_transient_loop;
8420396c:	03 00 f0 e5 	do $M.celt.transient_synthesis.shift_transient_loop;
      r1 = r1 ASHIFT r0, r2 = M[I6, MK1];    //r1=x<<n, r2 = next x
84203970:	49 00 32 93 	r1 = r1 ASHIFT r0, r2 = M[I6,4];
      r1 = r2, M[I1, M0] = r1;             //save previous, x=next x
84203974:	0f b4 34 00 	r1 = r2 + Null, M[I1,M0] = r1;

84203978 <$M.celt.transient_synthesis.shift_transient_loop>:
   shift_transient_loop:
   r1 = r1 ASHIFT r0;
84203978:	00 00 32 93 	r1 = r1 ASHIFT r0;
   M[I1, M0] = r1;
8420397c:	00 b4 00 02 	Null = Null + Null, M[I1,M0] = r1;
   
   //write back from processed buffer to output
   I1 = M3; //scratch memory
84203980:	0f 00 1b 58 	I1 = M3 + Null;
   I5 = I4;
84203984:	0f 00 54 58 	I5 = I4 + Null;
   I0 = I3;
84203988:	0f 00 03 58 	I0 = I3 + Null;
   r10 = r4;
8420398c:	0f 00 c6 00 	r10 = r4 + Null;
   do write_buf_loop;
84203990:	03 00 f0 e5 	do $M.celt.transient_synthesis.write_buf_loop;
      r2 = M[I1, MK1];
84203994:	00 45 00 03 	Null = Null + Null, r2 = M[I1,4];
      M[I5, MK1] = r2;   
84203998:	c5 00 00 03 	Null = Null + Null, M[I5,4] = r2;

8420399c <$M.celt.transient_synthesis.write_buf_loop>:
   write_buf_loop:
   //write back from processed buffer to hist buf
   r10 = r3;
8420399c:	0f 00 c5 00 	r10 = r3 + Null;
   do write_hist_loop;
842039a0:	03 00 f0 e5 	do $M.celt.transient_synthesis.write_hist_loop;
      r2 = M[I1, MK1];
842039a4:	00 45 00 03 	Null = Null + Null, r2 = M[I1,4];
      M[I0, MK1] = r2;   
842039a8:	00 c1 00 03 	Null = Null + Null, M[I0,4] = r2;

842039ac <$M.celt.transient_synthesis.write_hist_loop>:
   write_hist_loop:
   rts;
842039ac:	0f 00 0d dc 	rts;

842039b0 <$celt.mdct_shape>:
#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.MDCT_SHAPE.PATCH_ID_0,r4)     // celt_patchers
#endif 
   
   // push rLink onto stack
   push rlink;
842039b0:	00 00 d0 f3 	push rLink;
   
   r0 = M[r5 + $celt.dec.CELT_CHANNELS_FIELD];
842039b4:	08 00 27 d1 	r0 = M[r5 + 8];
   I6 = r0 + 1;
842039b8:	01 00 62 51 	I6 = r0 + 1;
   r0 = M[r5 + $celt.dec.MODE_NB_SHORT_MDCTS_FIELD];
842039bc:	58 00 27 d1 	r0 = M[r5 + 88];
   M0 = r0;
842039c0:	2f 00 80 50 	M0 = Null + r0;
   Words2Addr(r0);
842039c4:	02 00 22 91 	r0 = r0 ASHIFT 2;
   M3 = r0;
842039c8:	2f 00 b0 50 	M3 = Null + r0;
   r0 = M[r5 + $celt.dec.MODE_SHORT_MDCT_SIZE_FIELD];
842039cc:	5c 00 27 d1 	r0 = M[r5 + 92];
   I7 = r0;
842039d0:	2f 00 70 50 	I7 = Null + r0;
   r4 = M[r5 + $celt.dec.MDCT_WEIGHT_SHIFT_FIELD];
842039d4:	6c 01 67 d1 	r4 = M[r5 + 364];
   r4 = -r4;
842039d8:	6f 00 60 20 	r4 = Null - r4;
   r0 = M[r5 + $celt.dec.MDCT_WEIGHT_POS_FIELD];
842039dc:	70 01 27 d1 	r0 = M[r5 + 368];
   M1 = r0 + 1; //end point
842039e0:	01 00 92 51 	M1 = r0 + 1;
   Words2Addr(r0);
842039e4:	02 00 22 91 	r0 = r0 ASHIFT 2;
   M2 = r0 + ADDR_PER_WORD;
842039e8:	04 00 a2 51 	M2 = r0 + 4;
   r0 = M[r5 + $celt.dec.NORM_FREQ_FIELD];
842039ec:	cc 00 27 d1 	r0 = M[r5 + 204];
   I3 = r0 + M2; //X
842039f0:	af 00 32 54 	I3 = r0 + M2;
   NULL = r8;
842039f4:	0f 00 0a 00 	Null = r8 + Null;
   if Z jump setup_done;   
842039f8:	03 00 00 dd 	if EQ jump $M.celt.mdct_shape.chan_shape_loop;
      I3 = r0 + M3;
842039fc:	bf 00 32 54 	I3 = r0 + M3;
      M1 = M0 - M1;
84203a00:	9f 00 98 7c 	M1 = M0 - M1;

84203a04 <$M.celt.mdct_shape.chan_shape_loop>:
   setup_done:   
   chan_shape_loop:
      M2 = M1;
84203a04:	0f 00 a9 58 	M2 = M1 + Null;
      r0 = M2;
84203a08:	af 00 20 44 	r0 = Null + M2;

84203a0c <$M.celt.mdct_shape.block_loop>:
      block_loop: 
         r10 = I7 - 1;
84203a0c:	01 00 c7 69 	r10 = I7 - 1;
         Words2Addr(r0);
84203a10:	02 00 22 91 	r0 = r0 ASHIFT 2;
         I4 = I3 - r0;
84203a14:	2f 00 43 78 	I4 = I3 - r0;
         I2 = I4;
84203a18:	0f 00 24 58 	I2 = I4 + Null;
         r0 = M[I2, M3];
84203a1c:	00 2b 00 02 	Null = Null + Null, r0 = M[I2,M3];
         do shift_loop;
84203a20:	03 00 f0 e5 	do $M.celt.mdct_shape.shift_loop;
            r1 = r0 ASHIFT r4, r0 = M[I2, M3];
84203a24:	6f 2b 32 90 	r1 = r0 ASHIFT r4, r0 = M[I2,M3];
            M[I4, M3] = r1;
84203a28:	b3 00 00 02 	Null = Null + Null, M[I4,M3] = r1;

84203a2c <$M.celt.mdct_shape.shift_loop>:
         shift_loop:
         r1 = r0 ASHIFT r4; 
84203a2c:	6f 00 32 90 	r1 = r0 ASHIFT r4;
         M[I4, M3] = r1;
84203a30:	b3 00 00 02 	Null = Null + Null, M[I4,M3] = r1;
         M2 = M2 - 1;
84203a34:	01 00 aa 79 	M2 = M2 - 1;
	 r0 = M2;
84203a38:	af 00 20 44 	r0 = Null + M2;
      if NZ jump block_loop;
84203a3c:	f4 ff 10 dd 	if NE jump $M.celt.mdct_shape.block_loop;
      r0 = M[r5 + $celt.dec.MODE_MDCT_SIZE_FIELD];
84203a40:	44 00 27 d1 	r0 = M[r5 + 68];
      Words2Addr(r0);
84203a44:	02 00 22 91 	r0 = r0 ASHIFT 2;
      I3 = I3 + r0;
84203a48:	00 00 32 5b 	I3 = I3 + r0;
      I6 = I6 - 1;
84203a4c:	01 00 66 79 	I6 = I6 - 1;
   if NZ jump chan_shape_loop;
84203a50:	ed ff 10 dd 	if NE jump $M.celt.mdct_shape.chan_shape_loop;
   call $celt.renormalise_bands;
84203a54:	e2 03 f0 e1 	call $celt.renormalise_bands;
   // pop rLink from stack
   jump $pop_rLink_and_rts;
84203a58:	03 00 00 fd 	jump (m) 0x3b020;
84203a5c:	21 b0 f0 dd 

84203a60 <$celt.transient_block_process>:
#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.TRANSIENT_BLOCK_PROCESS.PATCH_ID_0,r2)     // celt_patchers
#endif 
   
   // push rLink onto stack
    push rlink;
84203a60:	00 00 d0 f3 	push rLink;
    r2 = 0;  // 
84203a64:	00 00 40 01 	r2 = Null + 0;
    r3 = 1;  //
84203a68:	2f 00 50 e4 	r3 = Null + 1;
    Null = M[r5 + $celt.enc.TRANSIENT_SHIFT_FIELD];
84203a6c:	68 01 07 d1 	Null = M[r5 + 360];
    if NZ jump  set_weight_pos;
84203a70:	29 00 10 dd 	if NE jump $M.celt.transient_block_process.set_weight_pos;
    r4 = M[r5 + $celt.enc.NORM_FREQ_FIELD];
84203a74:	cc 00 67 d1 	r4 = M[r5 + 204];
    I2 = r4;
84203a78:	6f 00 20 50 	I2 = Null + r4;
    r6 = M[r5 + $celt.enc.MODE_NB_SHORT_MDCTS_FIELD];
84203a7c:	58 00 87 d1 	r6 = M[r5 + 88];
    M0 = r6;
84203a80:	8f 00 80 50 	M0 = Null + r6;
    Words2Addr(r6);
84203a84:	02 00 88 91 	r6 = r6 ASHIFT 2;
    M3 = r6;
84203a88:	8f 00 b0 50 	M3 = Null + r6;
    Addr2Words(r6);
84203a8c:	fe 00 88 91 	r6 = r6 ASHIFT -2;
    M2 = 1;
84203a90:	01 00 a0 51 	M2 = Null + 1;
    r7 = 1.0; //sum(m)
84203a94:	ff 7f 00 fd 	r7 = Null + 2147483647;
84203a98:	ff ff 90 01 
    r1 = 1.0/64;    
84203a9c:	00 02 00 fd 	r1 = Null + 33554432;
84203aa0:	00 00 30 01 

84203aa4 <$M.celt.transient_block_process.block_loop>:
    block_loop:
       r10 = M[r5 + $celt.enc.MODE_SHORT_MDCT_SIZE_FIELD];
84203aa4:	5c 00 c7 d1 	r10 = M[r5 + 92];
       r10 = r10 - M2, r0 = M[I2, M3];
84203aa8:	00 2b ca 66 	r10 = r10 - M2, r0 = M[I2,M3];
       rMAC = 0;
84203aac:	00 00 10 01 	rMAC = Null + 0;
       do calc_abssum_loop;
84203ab0:	04 00 f0 e5 	do $M.celt.transient_block_process.calc_abssum_loop;
          Null = r0;
84203ab4:	0f 00 02 00 	Null = r0 + Null;
          if NEG r0 = -r0;
84203ab8:	24 00 20 20 	if NEG r0 = Null - r0;
          rMAC = rMAC + r0*r1, r0 = M[I2, M3];
84203abc:	3f 2b 12 ac 	rMAC = rMAC + r0 * r1 (SS), r0 = M[I2,M3];

84203ac0 <$M.celt.transient_block_process.calc_abssum_loop>:
       calc_abssum_loop:
       Null = r0;
84203ac0:	0f 00 02 00 	Null = r0 + Null;
       if NEG r0 = -r0;
84203ac4:	24 00 20 20 	if NEG r0 = Null - r0;
       rMAC = rMAC + r0*r1, r0 = M[I2, M3];
84203ac8:	3f 2b 12 ac 	rMAC = rMAC + r0 * r1 (SS), r0 = M[I2,M3];
       r4 = r4 + ADDR_PER_WORD;
84203acc:	bf 00 66 e4 	r4 = r4 + 4;
       I2 = r4;
84203ad0:	6f 00 20 50 	I2 = Null + r4;
       r8 = r7 ASHIFT 3;
84203ad4:	03 00 a9 91 	r8 = r7 ASHIFT 3;
       Null = rMAC - r8;
84203ad8:	af 00 01 20 	Null = rMAC - r8;
       if LE jump check_lower_w;
84203adc:	04 00 d0 dd 	if LE jump $M.celt.transient_block_process.check_lower_w;
          r2 = 2;
84203ae0:	af 00 40 e4 	r2 = Null + 2;
          r3 = M0 - r6;
84203ae4:	8f 00 58 68 	r3 = M0 - r6;
          jump end;
84203ae8:	08 00 f0 dd 	jump $M.celt.transient_block_process.end;

84203aec <$M.celt.transient_block_process.check_lower_w>:
       check_lower_w:
       Null = r2 - 2;
84203aec:	cf 00 04 e4 	Null = r2 - 2;
       if POS jump end;
84203af0:	06 00 50 dd 	if POS jump $M.celt.transient_block_process.end;
       r8 = r7 ASHIFT 1;
84203af4:	01 00 a9 91 	r8 = r7 ASHIFT 1;
       Null = rMAC - r8;
84203af8:	af 00 01 20 	Null = rMAC - r8;
       if LE jump end;
84203afc:	03 00 d0 dd 	if LE jump $M.celt.transient_block_process.end;
          r2 = 1;
84203b00:	2f 00 40 e4 	r2 = Null + 1;
          r3 = M0 - r6;        
84203b04:	8f 00 58 68 	r3 = M0 - r6;

84203b08 <$M.celt.transient_block_process.end>:
    end:
    r7 = rMAC;
84203b08:	0f 00 91 00 	r7 = rMAC + Null;
    r6 = r6 - 1;
84203b0c:	3f 00 88 e4 	r6 = r6 - 1;
    if NZ jump block_loop;
84203b10:	e5 ff 10 dd 	if NE jump $M.celt.transient_block_process.block_loop;

84203b14 <$M.celt.transient_block_process.set_weight_pos>:
    set_weight_pos:
    r8 = $celt.CELT_ENCODER;
84203b14:	2f 00 a0 e4 	r8 = Null + 1;
    r3 = r3 - 1;
84203b18:	3f 00 55 e4 	r3 = r3 - 1;
    M[r5 + $celt.enc.MDCT_WEIGHT_POS_FIELD] = r3;
84203b1c:	70 01 57 d5 	M[r5 + 368] = r3;
    M[r5 + $celt.enc.MDCT_WEIGHT_SHIFT_FIELD] = r2;
84203b20:	6c 01 47 d5 	M[r5 + 364] = r2;
    if NZ call  $celt.mdct_shape;
84203b24:	a3 ff 10 e1 	if NE call $celt.mdct_shape;
    

   // pop rLink from stack
   jump $pop_rLink_and_rts;
84203b28:	03 00 00 fd 	jump (m) 0x3b020;
84203b2c:	21 b0 f0 dd 

84203b30 <$celt.unquant_coarse_energy>:
84203b30:	01 20 00 f1 	pushm <FP(=SP), rLink>;
   .CONST BETA                 (1 + 2)*ADDR_PER_WORD;
   .CONST PREV                 (2 + 2)*ADDR_PER_WORD;
   .CONST CH                   (4 + 2)*ADDR_PER_WORD;
   .CONST STACK_FRAME_SIZE     5*ADDR_PER_WORD;
   pushm <FP(=SP), rLink>;
   SP = SP + STACK_FRAME_SIZE;
84203b34:	14 00 03 f1 	SP = SP + 20;
   // calc budget
   r1 = M[r5 + $celt.dec.CELT_CODEC_FRAME_SIZE_FIELD];
84203b38:	04 00 37 d1 	r1 = M[r5 + 4];
   r1 = r1 LSHIFT 2;
84203b3c:	02 00 33 8d 	r1 = r1 LSHIFT 2;
   I5 = r1 - 8; // I5:budget
84203b40:	08 00 53 71 	I5 = r1 - 8;
   
   // reset prev for both channels
   M[FP + PREV] = Null;
84203b44:	10 00 0c f1 	M[FP + 0x10] = Null;
   M[FP + PREV + MK1] = Null;
84203b48:	14 00 0c f1 	M[FP + 0x14] = Null;
   
   r1 = M[r5 + $celt.dec.MODE_PROB_ADDR_FIELD];
84203b4c:	6c 00 37 d1 	r1 = M[r5 + 108];
   I2 = r1;
84203b50:	3f 00 20 50 	I2 = Null + r1;
   r0 = M[r5 + $celt.dec.MODE_NB_EBANDS_FIELD];
84203b54:	48 00 27 d1 	r0 = M[r5 + 72];
   Words2Addr(r0);
84203b58:	02 00 22 91 	r0 = r0 ASHIFT 2;
   I6 = r0;
84203b5c:	2f 00 60 50 	I6 = Null + r0;
   r0 = M[r5 + $celt.dec.MODE_E_PRED_COEF_FIELD];
84203b60:	50 00 27 d1 	r0 = M[r5 + 80];
   // calc coef
   Null = M[r5 + $celt.dec.INTRA_ENER_FIELD];
84203b64:	54 01 07 d1 	Null = M[r5 + 340];
   if Z jump intra_end;
84203b68:	04 00 00 dd 	if EQ jump $M.celt.unquant_coarse_energy.intra_end;
      r0 = I6 + I6;
84203b6c:	6f 00 26 4c 	r0 = I6 + I6;
      I2 = I2 + r0;
84203b70:	00 00 22 5b 	I2 = I2 + r0;
      r0 = 0;
84203b74:	00 00 20 01 	r0 = Null + 0;

84203b78 <$M.celt.unquant_coarse_energy.intra_end>:
   intra_end:
   M[FP + COEF] = r0;
84203b78:	08 00 2c f1 	M[FP + 0x8] = r0;
   r0 = r0 * 0.8 (frac);
84203b7c:	66 66 00 fd 	r0 = r0 * 0.799999999813735485076904296875 (frac);
84203b80:	66 66 22 95 
   M[FP + BETA] = r0;
84203b84:	0c 00 2c f1 	M[FP + 0xc] = r0;
   r0 = M[r5 + $celt.dec.TEMP_VECT_FIELD];
84203b88:	34 01 27 d1 	r0 = M[r5 + 308];
   I4 = r0;
84203b8c:	2f 00 40 50 	I4 = Null + r0;
   M3 = ADDR_PER_WORD;
84203b90:	04 00 b0 51 	M3 = Null + 4;

84203b94 <$M.celt.unquant_coarse_energy.get_q_loop>:
   get_q_loop:
      r4 = 0;
84203b94:	00 00 60 01 	r4 = Null + 0;
      call $celt.ec_dec_tell;
84203b98:	75 f9 f0 e1 	call $celt.ec_dec_tell;
      r1 = -M3, r2 = M[I2, M3];
84203b9c:	bf 4b 30 64 	r1 = Null - M3, r2 = M[I2,M3];
      Null = r0 - I5, r3 = M[I2, M3];
84203ba0:	5f 5b 02 64 	Null = r0 - I5, r3 = M[I2,M3];
      if LE call $celt.ec_laplace_decode_start;
84203ba4:	49 07 d0 e1 	if LE call $celt.ec_laplace_decode_start;
      NULL = M[r5 + $celt.dec.CELT_CHANNELS_FIELD];      
84203ba8:	08 00 07 d1 	Null = M[r5 + 8];
      if Z jump ch_end_loop;
84203bac:	07 00 00 dd 	if EQ jump $M.celt.unquant_coarse_energy.ch_end_loop;
         I2 = I2 - 2*ADDR_PER_WORD;
84203bb0:	08 00 22 79 	I2 = I2 - 8;
         r4 = 0, M[I4, MK1] = r1;
84203bb4:	b1 00 66 23 	r4 = r4 - r4, M[I4,4] = r1;
         call $celt.ec_dec_tell;
84203bb8:	6d f9 f0 e1 	call $celt.ec_dec_tell;
         r1 = -M3, r2 = M[I2, M3];
84203bbc:	bf 4b 30 64 	r1 = Null - M3, r2 = M[I2,M3];
         Null = r0 - I5, r3 = M[I2, M3];
84203bc0:	5f 5b 02 64 	Null = r0 - I5, r3 = M[I2,M3];
         if LE call $celt.ec_laplace_decode_start;
84203bc4:	41 07 d0 e1 	if LE call $celt.ec_laplace_decode_start;

84203bc8 <$M.celt.unquant_coarse_energy.ch_end_loop>:
      ch_end_loop:
      I6 = I6 - M3, M[I4, M3] = r1;
84203bc8:	b3 00 6b 7e 	I6 = I6 - M3, M[I4,M3] = r1;
   if NZ jump get_q_loop; 
84203bcc:	f2 ff 10 dd 	if NE jump $M.celt.unquant_coarse_energy.get_q_loop;

//   M2 = 0;
#ifdef CELT_USE_EXTERNAL_MEMORY
   r0 = M[r5 + $celt.enc.PTR_EMEANS_TABLE_FIELD];
84203bd0:	14 02 27 d1 	r0 = M[r5 + 532];
   I2 = r0;
84203bd4:	2f 00 20 50 	I2 = Null + r0;
#else // CELT_USE_EXTERNAL_MEMORY
   I2 = &$celt.eMeans;
#endif // CELT_USE_EXTERNAL_MEMORY
   r0 = M[r5 + $celt.dec.OLD_EBAND_LEFT_FIELD];
84203bd8:	8c 00 27 d1 	r0 = M[r5 + 140];
   I3 = r0; 
84203bdc:	2f 00 30 50 	I3 = Null + r0;
   r0 = FP + PREV;
84203be0:	10 00 27 f1 	r0 = FP + 16;
   I4 = r0;
84203be4:	2f 00 40 50 	I4 = Null + r0;
   r0 = M[r5 + $celt.dec.TEMP_VECT_FIELD];
84203be8:	34 01 27 d1 	r0 = M[r5 + 308];
   I5 = r0;
84203bec:	2f 00 50 50 	I5 = Null + r0;
   r0 = M[r5 + $celt.dec.CELT_CHANNELS_FIELD];
84203bf0:	08 00 27 d1 	r0 = M[r5 + 8];
   Words2Addr(r0);
84203bf4:	02 00 22 91 	r0 = r0 ASHIFT 2;
   M3 = r0 + ADDR_PER_WORD;
84203bf8:	04 00 b2 51 	M3 = r0 + 4;
   M0 = ADDR_PER_WORD;
84203bfc:	04 00 80 51 	M0 = Null + 4;
   r8 = (DAWTH-8);
84203c00:	18 00 a0 01 	r8 = Null + 24;
   r7 = M[FP + COEF];
84203c04:	08 00 98 f1 	r7 = M[FP + 0x8];
   r0 = FP + BETA;
84203c08:	0c 00 27 f1 	r0 = FP + 12;
   I7 = r0;
84203c0c:	2f 00 70 50 	I7 = Null + r0;
   r0 = M[r5 + $celt.dec.CELT_CHANNELS_FIELD];
84203c10:	08 00 27 d1 	r0 = M[r5 + 8];
   I6 = r0;
84203c14:	2f 00 60 50 	I6 = Null + r0;

84203c18 <$M.celt.unquant_coarse_energy.loop_decode_coarse>:
   /* Decode at a fixed coarse resolution */
   loop_decode_coarse:
      r10 = M[r5 + $celt.dec.MODE_NB_EBANDS_FIELD];
84203c18:	48 00 c7 d1 	r10 = M[r5 + 72];
      do coarse_loop;
84203c1c:	0c 00 f0 e5 	do $M.celt.unquant_coarse_energy.coarse_loop;
         r1 = M[I5, M3], r0 = M[I2, M0];      
84203c20:	37 28 00 02 	Null = Null + Null, r0 = M[I2,M0], r1 = M[I5,M3];
         r1 = r1 ASHIFT r8, r4 = M[I4, 0];                                      
84203c24:	60 00 3a 93 	r1 = r1 ASHIFT r8, r4 = M[I4,0];
         r4 = r4 + r0, r2 = M[I3, 0];              //r4 = m+ p, r2 =b
84203c28:	00 4c 62 03 	r4 = r4 + r0, r2 = M[I3,0];
         r4 = r4 + r1;                             //r4 = m+p+q
84203c2c:	00 00 63 03 	r4 = r4 + r1;
         r3 = r2 - r0;                             //r3 = b -m
84203c30:	2f 00 54 20 	r3 = r2 - r0;
         r3 = r3 * r7 (frac);                      //r3 = (b-m)*c
84203c34:	00 00 59 97 	r3 = r3 * r7 (frac);
         r3 = r3 + r4;                             //r3 -->b
84203c38:	00 00 56 03 	r3 = r3 + r4;
         rMAC = r0*r7, r0 = M[I7, 0];
84203c3c:	2c 00 29 cf 	rMAC = r0 * r7 (SS), r0 = M[I7,0];
         rMAC = rMAC + r1*r0, M[I3, MK1] = r3;       //save C-Energy
84203c40:	00 dd 32 af 	rMAC = rMAC + r1 * r0 (SS), M[I3,4] = r3;
         r4 = r4 - rMAC;
84203c44:	00 00 61 23 	r4 = r4 - rMAC;
         M[I4, 0] = r4;                            //save prev
84203c48:	e0 00 00 03 	Null = Null + Null, M[I4,0] = r4;

84203c4c <$M.celt.unquant_coarse_energy.coarse_loop>:
      coarse_loop:         
      I6 = I6 - 1;
84203c4c:	01 00 66 79 	I6 = I6 - 1;
   if NEG jump cleanup;
84203c50:	0a 00 40 dd 	if NEG jump $M.celt.unquant_coarse_energy.cleanup;
#ifdef CELT_USE_EXTERNAL_MEMORY
   r0 = M[r5 + $celt.enc.PTR_EMEANS_TABLE_FIELD];
84203c54:	14 02 27 d1 	r0 = M[r5 + 532];
   I2 = r0;
84203c58:	2f 00 20 50 	I2 = Null + r0;
#else // CELT_USE_EXTERNAL_MEMORY
   I2 = &$celt.eMeans;
#endif // CELT_USE_EXTERNAL_MEMORY
   r0 = M[r5 + $celt.dec.OLD_EBAND_LEFT_FIELD];
84203c5c:	8c 00 27 d1 	r0 = M[r5 + 140];
   I3 = r0 + ($celt.MAX_BANDS*ADDR_PER_WORD);
84203c60:	64 00 32 51 	I3 = r0 + 100;

   r0 = FP + PREV;
84203c64:	10 00 27 f1 	r0 = FP + 16;
   I4 = r0 + ADDR_PER_WORD;
84203c68:	04 00 42 51 	I4 = r0 + 4;
   r0 = M[r5 + $celt.dec.TEMP_VECT_FIELD];
84203c6c:	34 01 27 d1 	r0 = M[r5 + 308];
   I5 = r0 + ADDR_PER_WORD;
84203c70:	04 00 52 51 	I5 = r0 + 4;
   jump loop_decode_coarse;
84203c74:	e9 ff f0 dd 	jump $M.celt.unquant_coarse_energy.loop_decode_coarse;

84203c78 <$M.celt.unquant_coarse_energy.cleanup>:

cleanup:
   SP = SP - STACK_FRAME_SIZE;
84203c78:	ec ff 03 f1 	SP = SP + -20;
   popm <FP,rLink>;
84203c7c:	01 20 04 f1 	popm <FP, rLink>;
   rts;
84203c80:	0f 00 0d dc 	rts;

84203c84 <$celt.unquant_fine_energy>:
#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.UNQUANT_FINE_ENERGY.PATCH_ID_0,r2)     // celt_patchers
#endif 
   
   // push rLink onto stack
   push rlink;
84203c84:	00 00 d0 f3 	push rLink;
   r0 = M[r5 + $celt.dec.MODE_NB_EBANDS_FIELD];
84203c88:	48 00 27 d1 	r0 = M[r5 + 72];
   M3 = r0;
84203c8c:	2f 00 b0 50 	M3 = Null + r0;
   r0 = M[r5 + $celt.dec.FINE_QUANT_FIELD];
84203c90:	08 01 27 d1 	r0 = M[r5 + 264];
   I2 = r0;
84203c94:	2f 00 20 50 	I2 = Null + r0;
   r0 = M[r5 + $celt.dec.OLD_EBAND_LEFT_FIELD];
84203c98:	8c 00 27 d1 	r0 = M[r5 + 140];
   I3 = r0;
84203c9c:	2f 00 30 50 	I3 = Null + r0;
   I4 = r0 + ($celt.MAX_BANDS*ADDR_PER_WORD);
84203ca0:	64 00 42 51 	I4 = r0 + 100;
   M0 = 1;
84203ca4:	01 00 80 51 	M0 = Null + 1;
   r0 = M[r5 + $celt.dec.CELT_CHANNELS_FIELD];
84203ca8:	08 00 27 d1 	r0 = M[r5 + 8];
   I6 = r0;
84203cac:	2f 00 60 50 	I6 = Null + r0;

84203cb0 <$M.celt.unquant_fine_energy.fine_unquant_loop>:
   fine_unquant_loop:
      r2 = M[I2, MK1];
84203cb0:	00 49 00 03 	Null = Null + Null, r2 = M[I2,4];
      M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FTB] = r2;
84203cb4:	e4 01 47 d5 	M[r5 + 484] = r2;
      if LE jump b_loop;
84203cb8:	17 00 d0 dd 	if LE jump $M.celt.unquant_fine_energy.b_loop;
         call $celt.ec_dec_bits;
84203cbc:	98 f8 f0 e1 	call $celt.ec_dec_bits;
         r1 = r0 + r0;
84203cc0:	2f 00 32 00 	r1 = r0 + r0;
         r1 = r1 + 1;
84203cc4:	2f 00 33 e4 	r1 = r1 + 1;
         r2 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FTB];
84203cc8:	e4 01 47 d1 	r2 = M[r5 + 484];
         r2 = (DAWTH-9) - r2;
84203ccc:	17 00 44 65 	r2 = 23 - r2;
         r1 = r1 ASHIFT r2, r0 = M[I3, 0];
84203cd0:	00 2c 34 93 	r1 = r1 ASHIFT r2, r0 = M[I3,0];
#ifdef K32
         r1 = r1 - 0x800000;
84203cd4:	80 00 00 fd 	r1 = r1 - 8388608;
84203cd8:	00 00 33 21 
#else
         r1 = r1 - 0x8000;
#endif
         r0 = r0 + r1;
84203cdc:	00 00 23 03 	r0 = r0 + r1;
         Null = I6, M[I3, 0] = r0;
84203ce0:	00 ac 06 47 	Null = Null + I6, M[I3,0] = r0;
         if Z jump b_loop;
84203ce4:	0c 00 00 dd 	if EQ jump $M.celt.unquant_fine_energy.b_loop;
            call $celt.ec_dec_bits;
84203ce8:	8d f8 f0 e1 	call $celt.ec_dec_bits;
            r1 = r0 + r0;
84203cec:	2f 00 32 00 	r1 = r0 + r0;
            r1 = r1 + 1;
84203cf0:	2f 00 33 e4 	r1 = r1 + 1;
            r2 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FTB];
84203cf4:	e4 01 47 d1 	r2 = M[r5 + 484];
            r2 = (DAWTH-9) - r2;
84203cf8:	17 00 44 65 	r2 = 23 - r2;
            r1 = r1 ASHIFT r2;
84203cfc:	00 00 34 93 	r1 = r1 ASHIFT r2;
            r1 = r1 - M0, r0 = M[I4, 0];
84203d00:	20 00 38 67 	r1 = r1 - M0, r0 = M[I4,0];
#ifdef K32
         r1 = r1 - 0x800000;
84203d04:	80 00 00 fd 	r1 = r1 - 8388608;
84203d08:	00 00 33 21 
#else
         r1 = r1 - 0x8000;
#endif
            r0 = r0 + r1;
84203d0c:	00 00 23 03 	r0 = r0 + r1;
            M[I4, 0] = r0;
84203d10:	a0 00 00 03 	Null = Null + Null, M[I4,0] = r0;

84203d14 <$M.celt.unquant_fine_energy.b_loop>:
      b_loop:
      M3 = M3 - M0, r0 = M[I4, MK1], r1 = M[I3, MK1];
84203d14:	21 3d b8 7f 	M3 = M3 - M0, r1 = M[I3,4], r0 = M[I4,4];
   if NZ jump fine_unquant_loop;
84203d18:	e6 ff 10 dd 	if NE jump $M.celt.unquant_fine_energy.fine_unquant_loop;

   // pop rLink from stack
   jump $pop_rLink_and_rts;
84203d1c:	03 00 00 fd 	jump (m) 0x3b020;
84203d20:	21 b0 f0 dd 

84203d24 <$celt.quant_bands>:
   .CONST CUR_B      1*ADDR_PER_WORD;
   .CONST BAL        2*ADDR_PER_WORD;
   .CONST STACK_USED 3*ADDR_PER_WORD;

   // push rLink onto stack
   push rlink;
84203d24:	00 00 d0 f3 	push rLink;
   // save the frame pointer and reserve stack space here before the loop starts
   pushm<FP(=SP)>;
84203d28:	01 00 00 f1 	pushm <FP(=SP)>;
   SP = SP + STACK_USED;
84203d2c:	0c 00 03 f1 	SP = SP + 12;

   r0 = M[r5 + $celt.dec.MODE_NB_EBANDS_FIELD];
84203d30:	48 00 27 d1 	r0 = M[r5 + 72];
   Words2Addr(r0);
84203d34:	02 00 22 91 	r0 = r0 ASHIFT 2;
   M3 = r0;
84203d38:	2f 00 b0 50 	M3 = Null + r0;
   I7 = M3;
84203d3c:	0f 00 7b 58 	I7 = M3 + Null;
   //calc nr of Blocks
   r3 = M[r5 + $celt.dec.MODE_NB_SHORT_MDCTS_FIELD];
84203d40:	58 00 57 d1 	r3 = M[r5 + 88];
   r2 = 1;
84203d44:	2f 00 40 e4 	r2 = Null + 1;
   Null = M[r5 + $celt.dec.SHORT_BLOCKS_FIELD];
84203d48:	58 01 07 d1 	Null = M[r5 + 344];
   if NZ r2 = r3;
84203d4c:	01 00 45 00 	if NE r2 = r3 + Null;
   M[FP + CUR_B] = r2;
84203d50:	04 00 4c f1 	M[FP + 0x4] = r2;
   r1 = 0;
84203d54:	00 00 30 01 	r1 = Null + 0;
   M[FP + BAL] = r1;
84203d58:	08 00 3c f1 	M[FP + 0x8] = r1;

   r1 = M[r5 + $celt.dec.CELT_CODEC_FRAME_SIZE_FIELD];
84203d5c:	04 00 37 d1 	r1 = M[r5 + 4];
   r1 = r1 LSHIFT (3+$celt.BITRES);
84203d60:	07 00 33 8d 	r1 = r1 LSHIFT 7;
   I6 = r1; //total bits in the frame (fractional)
84203d64:	3f 00 60 50 	I6 = Null + r1;
   r0 = M[r5 + $celt.dec.PULSES_FIELD];
84203d68:	04 01 27 d1 	r0 = M[r5 + 260];
   I3 = r0;
84203d6c:	2f 00 30 50 	I3 = Null + r0;
   r0 = M[r5 + $celt.dec.MODE_EBANDS_ADDR_FIELD];
84203d70:	60 00 27 d1 	r0 = M[r5 + 96];
   I2 = r0;
84203d74:	2f 00 20 50 	I2 = Null + r0;

84203d78 <$M.celt.quant_bands.quant_bands_main_loop>:
   quant_bands_main_loop:
      // get bit used so far
      r4 = $celt.BITRES;
84203d78:	bf 00 60 e4 	r4 = Null + 4;
      r0 = M[r5 + $celt.dec.TELL_FUNC_FIELD];
84203d7c:	30 00 27 d1 	r0 = M[r5 + 48];
      call r0;
84203d80:	0f 00 02 e0 	call r0;

      // update balance
      r1 = M[FP + BAL];
84203d84:	08 00 38 f1 	r1 = M[FP + 0x8];
      r2 = I7 - M3;
84203d88:	bf 00 47 6c 	r2 = I7 - M3;
      if Z r1 = r0;
84203d8c:	00 00 32 00 	if EQ r1 = r0 + Null;
      M[FP + BAL] = r1;
84203d90:	08 00 3c f1 	M[FP + 0x8] = r1;
      r1 = r1 - r0;
84203d94:	00 00 32 23 	r1 = r1 - r0;

      // update remaining bits
      I5 = I6 - r0;
84203d98:	2f 00 56 78 	I5 = I6 - r0;
      I5 = I5 - 1;
84203d9c:	01 00 55 79 	I5 = I5 - 1;

      //curr_balance = balance / curr_balance;
      r3 = 1;
84203da0:	2f 00 50 e4 	r3 = Null + 1;
      Null = r1;
84203da4:	0f 00 03 00 	Null = r1 + Null;
      if NEG r3 = - r3;
84203da8:	54 00 50 20 	if NEG r3 = Null - r3;
      r1 = r1 * r3(int);
84203dac:	00 00 35 9b 	r1 = r1 * r3 (int);
      Null  =   M3 - 3*ADDR_PER_WORD; //TODO:BC7OPT-max
84203db0:	0c 00 0b 69 	Null = M3 - 12;
      if NEG jump chk_2;
84203db4:	05 00 40 dd 	if NEG jump $M.celt.quant_bands.chk_2;
         r1 = r1 -1;
84203db8:	3f 00 33 e4 	r1 = r1 - 1;
         r1 = r1 * (1.0/3.0)(frac);
84203dbc:	aa 2a 00 fd 	r1 = r1 * 0.3333333334885537624359130859375 (frac);
84203dc0:	ab aa 33 95 
         jump end_cur_calc;
84203dc4:	04 00 f0 dd 	jump $M.celt.quant_bands.end_cur_calc;

84203dc8 <$M.celt.quant_bands.chk_2>:
      chk_2:
      Null = M3 - 2*ADDR_PER_WORD;
84203dc8:	08 00 0b 69 	Null = M3 - 8;
      if NZ jump end_cur_calc;
84203dcc:	02 00 10 dd 	if NE jump $M.celt.quant_bands.end_cur_calc;
         r1 = r1 ASHIFT -1;
84203dd0:	ff 00 33 91 	r1 = r1 ASHIFT -1;

84203dd4 <$M.celt.quant_bands.end_cur_calc>:
      end_cur_calc:
      r1 = r1 * r3(int);
84203dd4:	00 00 35 9b 	r1 = r1 * r3 (int);

      //calc number of pulses for this band (n)
      r0 = M[r5 + $celt.dec.PULSES_FIELD];
84203dd8:	04 01 27 d1 	r0 = M[r5 + 260];
      r3 = r0 + I7;
84203ddc:	7f 00 52 44 	r3 = r0 + I7;
      r3 = r3 - M3;
84203de0:	00 00 5b 67 	r3 = r3 - M3;
      r0 = M[FP + BAL];
84203de4:	08 00 28 f1 	r0 = M[FP + 0x8];
      r3 = M[r3];
84203de8:	00 00 50 d3 	r3 = M[r3 + Null];
      push r3;
84203dec:	00 00 50 f3 	push r3;
      r3 = r0 + r3;
84203df0:	5f 00 52 00 	r3 = r0 + r3;
      M[FP + BAL] = r3;
84203df4:	08 00 5c f1 	M[FP + 0x8] = r3;
      pop r3;
84203df8:	00 00 54 f3 	pop r3;
      r1 = r1 + r3;
84203dfc:	00 00 35 03 	r1 = r1 + r3;
      call $celt.bits2pulses;
84203e00:	41 02 f0 e1 	call $celt.bits2pulses;
      Words2Addr(r0);
84203e04:	02 00 22 91 	r0 = r0 ASHIFT 2;
      //r0 = n
      r2 = M[r4 + r0];
84203e08:	2f 00 46 d0 	r2 = M[r4 + r0];
      I5 = I5 - r2;
84203e0c:	00 00 54 7b 	I5 = I5 - r2;

84203e10 <$M.celt.quant_bands.loop_rem_bits>:
      loop_rem_bits:
         Null = I5;
84203e10:	00 00 05 47 	Null = Null + I5;
         if POS jump end_loop_rem_bits;
84203e14:	08 00 50 dd 	if POS jump $M.celt.quant_bands.end_loop_rem_bits;
         Null = r0 - Null;
84203e18:	0f 00 02 20 	Null = r0 - Null;
         if LE jump end_loop_rem_bits;
84203e1c:	06 00 d0 dd 	if LE jump $M.celt.quant_bands.end_loop_rem_bits;
            I5 = I5 + r2;
84203e20:	00 00 54 5b 	I5 = I5 + r2;
            r0 = r0 - ADDR_PER_WORD;
84203e24:	df 00 22 e4 	r0 = r0 - 4;
            r2 = M[r4 + r0];
84203e28:	2f 00 46 d0 	r2 = M[r4 + r0];
            I5 = I5 - r2;
84203e2c:	00 00 54 7b 	I5 = I5 - r2;
         jump loop_rem_bits;
84203e30:	f8 ff f0 dd 	jump $M.celt.quant_bands.loop_rem_bits;

84203e34 <$M.celt.quant_bands.end_loop_rem_bits>:
      end_loop_rem_bits:

      // save some registers into stack

      push r5;
84203e34:	00 00 70 f3 	push r5;
      pushm<I2, I5, I6, I7, M3>;
84203e38:	e4 08 01 f1 	pushm <I2, I5, I6, I7, M3>;

      r2 = M[FP + CUR_B];
84203e3c:	04 00 48 f1 	r2 = M[FP + 0x4];
      r1 = M[I2, MK1];
84203e40:	00 39 00 03 	Null = Null + Null, r1 = M[I2,4];
      r3 = M[I2, -MK1];
84203e44:	00 5b 00 03 	Null = Null + Null, r3 = M[I2,-4];
      r3 = r3 - r1;
84203e48:	00 00 53 23 	r3 = r3 - r1;
      r4 = M[r5 + $celt.dec.NORM_FREQ_FIELD];
84203e4c:	cc 00 67 d1 	r4 = M[r5 + 204];
      Words2Addr(r1);
84203e50:	02 00 33 91 	r1 = r1 ASHIFT 2;
      I5 = r4 + r1;//X+eBands[i]
84203e54:	3f 00 56 50 	I5 = r4 + r1;
      // I5 = start of band
      // r0 = number of pulses (AU)
      // r1 = start bin no (AU)
      // r3 = band width
      // r2 = nr of Blocks
      Addr2Words(r0);
84203e58:	fe 00 22 91 	r0 = r0 ASHIFT -2;
      r4 = r0 - Null;
84203e5c:	0f 00 62 20 	r4 = r0 - Null;
      if LE jump intra_act;
84203e60:	07 00 d0 dd 	if LE jump $M.celt.quant_bands.intra_act;
         //calc spread
         M0 = r2;
84203e64:	4f 00 80 50 	M0 = Null + r2;
         Null = M[r5 + $celt.dec.HAS_FOLD_FIELD];
84203e68:	60 01 07 d1 	Null = M[r5 + 352];
         if Z M0 = M0 - M0;
84203e6c:	80 00 88 7c 	if EQ M0 = M0 - M0;
         //call  $celt.alg_unquant;
         r0 = M[r5 + $celt.dec.ALG_QUANT_FUNC_FIELD];
84203e70:	34 00 27 d1 	r0 = M[r5 + 52];
         call r0;
84203e74:	0f 00 02 e0 	call r0;
         jump end_act;
84203e78:	05 00 f0 dd 	jump $M.celt.quant_bands.end_act;

84203e7c <$M.celt.quant_bands.intra_act>:
      intra_act:
         r0 = M[r5 + $celt.dec.NORM_FIELD];
84203e7c:	10 01 27 d1 	r0 = M[r5 + 272];
         I3 = r0;
84203e80:	2f 00 30 50 	I3 = Null + r0;
         Addr2Words(r1);
84203e84:	fe 00 33 91 	r1 = r1 ASHIFT -2;
         call $celt.intra_fold;
84203e88:	f5 02 f0 e1 	call $celt.intra_fold;

84203e8c <$M.celt.quant_bands.end_act>:
      end_act:

      // restore trashed register
       popm<I2, I5, I6, I7, M3>;
84203e8c:	e4 08 05 f1 	popm <I2, I5, I6, I7, M3>;
       pop r5;
84203e90:	00 00 74 f3 	pop r5;

      // get start and end of band (again!)
      r1 = M[I2, MK1];
84203e94:	00 39 00 03 	Null = Null + Null, r1 = M[I2,4];
      r3 = M[I2, 0];
84203e98:	00 58 00 03 	Null = Null + Null, r3 = M[I2,0];

      // calc norm for next folded band
      // calc only when needed!
      r0 = M[r5 + $celt.dec.MODE_NB_EBANDS_FIELD];
84203e9c:	48 00 27 d1 	r0 = M[r5 + 72];
      Words2Addr(r0);
84203ea0:	02 00 22 91 	r0 = r0 ASHIFT 2;
      r0 = r0 - M3;
84203ea4:	00 00 2b 67 	r0 = r0 - M3;
      r2 = M[r5 + $celt.dec.MODE_EBNADS_DIF_SQRT_ADDR_FIELD];
84203ea8:	74 00 47 d1 	r2 = M[r5 + 116];
      r4 = M[r2 + 0]; //shift
84203eac:	00 00 64 d1 	r4 = M[r2 + 0];
      r2 = r2 + ADDR_PER_WORD;
84203eb0:	bf 00 44 e4 	r2 = r2 + 4;
      r6 = M[r2 + r0]; //gain
84203eb4:	2f 00 84 d0 	r6 = M[r2 + r0];
      r10 = r3 - r1;
84203eb8:	3f 00 c5 20 	r10 = r3 - r1;
      r10 = r10 - 1;
84203ebc:	3f 00 cc e4 	r10 = r10 - 1;
      r0 = M[r5 + $celt.dec.NORM_FIELD];
84203ec0:	10 01 27 d1 	r0 = M[r5 + 272];
      Words2Addr(r1);
84203ec4:	02 00 33 91 	r1 = r1 ASHIFT 2;
      I3  = r1 + r0;
84203ec8:	2f 00 33 50 	I3 = r1 + r0;
      r0 = M[r5 + $celt.dec.NORM_FREQ_FIELD];
84203ecc:	cc 00 27 d1 	r0 = M[r5 + 204];
      I4  = r0 + r1;
84203ed0:	3f 00 42 50 	I4 = r0 + r1;
      r0 = M[I4, MK1];
84203ed4:	21 00 00 03 	Null = Null + Null, r0 = M[I4,4];
      rMAC = r0 * r6; //6 bit less than c TODO:
84203ed8:	8f 00 12 cc 	rMAC = r0 * r6 (SS);
      do norm_loop;
84203edc:	03 00 f0 e5 	do $M.celt.quant_bands.norm_loop;
         rMAC = rMAC ASHIFT r4 (56bit), r0 = M[I4, MK1];
84203ee0:	21 00 16 93 	rMAC = rMAC ASHIFT r4 (56bit), r0 = M[I4,4];
         rMAC = r0 * r6, M[I3, MK1] = rMAC;
84203ee4:	00 9d 28 cf 	rMAC = r0 * r6 (SS), M[I3,4] = rMAC;

84203ee8 <$M.celt.quant_bands.norm_loop>:
      norm_loop:
      rMAC = rMAC ASHIFT r4 (56bit);
84203ee8:	00 00 16 93 	rMAC = rMAC ASHIFT r4 (56bit);
      M[I3, MK1] = rMAC;
84203eec:	00 9d 00 03 	Null = Null + Null, M[I3,4] = rMAC;

      M3 = M3 - ADDR_PER_WORD;
84203ef0:	04 00 bb 79 	M3 = M3 - 4;
   if NZ jump quant_bands_main_loop;
84203ef4:	a1 ff 10 dd 	if NE jump $M.celt.quant_bands.quant_bands_main_loop;

   // restore the stack pointer
   SP = SP - STACK_USED;
84203ef8:	f4 ff 03 f1 	SP = SP + -12;
   popm<FP>;
84203efc:	00 40 06 f1 	popm <FP>;

   // pop rLink from stack
   jump $pop_rLink_and_rts;
84203f00:	03 00 00 fd 	jump (m) 0x3b020;
84203f04:	21 b0 f0 dd 

84203f08 <$celt.unquant_bands_stereo>:

#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.UNQUANT_BANDS_STEREO.PATCH_ID_0,r3)     // celt_patchers
#endif 

   r0 = $celt.CELT_DECODER;
84203f08:	00 00 20 01 	r0 = Null + 0;
   jump set_codec;
84203f0c:	02 00 f0 dd 	jump $M.celt.unquant_bands_stereo.set_codec;

84203f10 <$celt.quant_bands_stereo>:
   
   // -- entry point for quant (encoder)
   $celt.quant_bands_stereo:
   r0 = $celt.CELT_ENCODER;
84203f10:	2f 00 20 e4 	r0 = Null + 1;

84203f14 <$M.celt.unquant_bands_stereo.set_codec>:
   .CONST CODEC            22*ADDR_PER_WORD;
   .CONST STACK_USED       23*ADDR_PER_WORD;
   

   // push rLink onto stack
   push rlink;
84203f14:	00 00 d0 f3 	push rLink;
   // save the frame pointer and reserve stack space here before the loop starts
   pushm<FP(=SP)>; 
84203f18:	01 00 00 f1 	pushm <FP(=SP)>;
   SP = SP + STACK_USED; 
84203f1c:	5c 00 03 f1 	SP = SP + 92;
   
   M[FP + CODEC] = r0;
84203f20:	58 00 2c f1 	M[FP + 0x58] = r0;
   r0 = M[r5 + $celt.dec.MODE_NB_EBANDS_FIELD];
84203f24:	48 00 27 d1 	r0 = M[r5 + 72];
   Words2Addr(r0);
84203f28:	02 00 22 91 	r0 = r0 ASHIFT 2;
   M3 = r0;
84203f2c:	2f 00 b0 50 	M3 = Null + r0;
   I7 = M3;
84203f30:	0f 00 7b 58 	I7 = M3 + Null;

   //calc nr of Blocks
   r3 = M[r5 + $celt.dec.MODE_NB_SHORT_MDCTS_FIELD];
84203f34:	58 00 57 d1 	r3 = M[r5 + 88];
   r2 = 1;
84203f38:	2f 00 40 e4 	r2 = Null + 1;
   Null = M[r5 + $celt.dec.SHORT_BLOCKS_FIELD];
84203f3c:	58 01 07 d1 	Null = M[r5 + 344];
   if NZ r2 = r3;
84203f40:	01 00 45 00 	if NE r2 = r3 + Null;
   M[FP + CUR_B] = r2;
84203f44:	4c 00 4c f1 	M[FP + 0x4c] = r2;
   r1 = 0;
84203f48:	00 00 30 01 	r1 = Null + 0;
   M[FP + BAL] = r1;
84203f4c:	50 00 3c f1 	M[FP + 0x50] = r1;
   r1 = M[r5 + $celt.dec.CELT_CODEC_FRAME_SIZE_FIELD];
84203f50:	04 00 37 d1 	r1 = M[r5 + 4];
   r1 = r1 LSHIFT (3+$celt.BITRES);
84203f54:	07 00 33 8d 	r1 = r1 LSHIFT 7;
   I6 = r1; //total bits in the frame (fractional)
84203f58:	3f 00 60 50 	I6 = Null + r1;
   r0 = M[r5 + $celt.dec.PULSES_FIELD];
84203f5c:	04 01 27 d1 	r0 = M[r5 + 260];
   I3 = r0;
84203f60:	2f 00 30 50 	I3 = Null + r0;
   r0 = M[r5 + $celt.dec.MODE_EBANDS_ADDR_FIELD];
84203f64:	60 00 27 d1 	r0 = M[r5 + 96];
   I2 = r0;
84203f68:	2f 00 20 50 	I2 = Null + r0;

84203f6c <$M.celt.unquant_bands_stereo.quant_bands_main_loop>:


quant_bands_main_loop:

      // get bit used so far
      r4 = $celt.BITRES;
84203f6c:	bf 00 60 e4 	r4 = Null + 4;
      r0 = M[r5 + $celt.dec.TELL_FUNC_FIELD];
84203f70:	30 00 27 d1 	r0 = M[r5 + 48];
      call r0; 
84203f74:	0f 00 02 e0 	call r0;

      // update balance
      r1 = M[FP + BAL];
84203f78:	50 00 38 f1 	r1 = M[FP + 0x50];
      r2 = I7 - M3;
84203f7c:	bf 00 47 6c 	r2 = I7 - M3;
      if Z r1 = r0;
84203f80:	00 00 32 00 	if EQ r1 = r0 + Null;
      M[FP + BAL] = r1;
84203f84:	50 00 3c f1 	M[FP + 0x50] = r1;
      r1 = r1 - r0;
84203f88:	00 00 32 23 	r1 = r1 - r0;

      // update remaining bits
      I5 = I6 - r0;
84203f8c:	2f 00 56 78 	I5 = I6 - r0;
      I5 = I5 - 1;
84203f90:	01 00 55 79 	I5 = I5 - 1;

      //curr_balance = balance / curr_balance;
      r3 = 1;
84203f94:	2f 00 50 e4 	r3 = Null + 1;
      Null = r1;
84203f98:	0f 00 03 00 	Null = r1 + Null;
      if NEG r3 = - r3;
84203f9c:	54 00 50 20 	if NEG r3 = Null - r3;
      r1 = r1 * r3(int);
84203fa0:	00 00 35 9b 	r1 = r1 * r3 (int);
      Null  =   M3 - 3*ADDR_PER_WORD; //TODO:BC7OPT-max
84203fa4:	0c 00 0b 69 	Null = M3 - 12;
      if NEG jump chk_2;
84203fa8:	05 00 40 dd 	if NEG jump $M.celt.unquant_bands_stereo.chk_2;
         r1 = r1 -1;
84203fac:	3f 00 33 e4 	r1 = r1 - 1;
         r1 = r1 * (1.0/3.0)(frac);
84203fb0:	aa 2a 00 fd 	r1 = r1 * 0.3333333334885537624359130859375 (frac);
84203fb4:	ab aa 33 95 
         jump end_cur_calc;
84203fb8:	04 00 f0 dd 	jump $M.celt.unquant_bands_stereo.end_cur_calc;

84203fbc <$M.celt.unquant_bands_stereo.chk_2>:
      chk_2:
      Null = M3 - 2*ADDR_PER_WORD;
84203fbc:	08 00 0b 69 	Null = M3 - 8;
      if NZ jump end_cur_calc;
84203fc0:	02 00 10 dd 	if NE jump $M.celt.unquant_bands_stereo.end_cur_calc;
         r1 = r1 ASHIFT -1;
84203fc4:	ff 00 33 91 	r1 = r1 ASHIFT -1;

84203fc8 <$M.celt.unquant_bands_stereo.end_cur_calc>:
      end_cur_calc:
      r1 = r1 * r3(int);
84203fc8:	00 00 35 9b 	r1 = r1 * r3 (int);

      r0 = M[I2, MK1];
84203fcc:	00 29 00 03 	Null = Null + Null, r0 = M[I2,4];
      M[FP + S_BAND] = r0;
84203fd0:	20 00 2c f1 	M[FP + 0x20] = r0;
      r3 = M[I2, 0];
84203fd4:	00 58 00 03 	Null = Null + Null, r3 = M[I2,0];
      r0 = r3 - r0;
84203fd8:	2f 00 25 20 	r0 = r3 - r0;
      rMAC = 0;
84203fdc:	00 00 10 01 	rMAC = Null + 0;
      rMAC0 = r0;
84203fe0:	00 05 e2 8d 	rMAC0 = r0 LSHIFT 0;
      M[FP + N_BAND] = r0;
84203fe4:	1c 00 2c f1 	M[FP + 0x1c] = r0;

      //calc number of pulses for this band (n)
      r0 = M[r5 + $celt.dec.PULSES_FIELD];
84203fe8:	04 01 27 d1 	r0 = M[r5 + 260];
      r3 = r0 + I7;
84203fec:	7f 00 52 44 	r3 = r0 + I7;
      r3 = r3 - M3;
84203ff0:	00 00 5b 67 	r3 = r3 - M3;
      r0 = M[FP + BAL];
84203ff4:	50 00 28 f1 	r0 = M[FP + 0x50];
      r3 = M[r3];       // r3 = pulses[I7-M3]
84203ff8:	00 00 50 d3 	r3 = M[r3 + Null];
      r0 = r0 + r3;     // r0 = r0 + pulses[I7-M3]
84203ffc:	00 00 25 03 	r0 = r0 + r3;
      M[FP + BAL] = r0;
84204000:	50 00 2c f1 	M[FP + 0x50] = r0;

      r8 = I5 + 1;
84204004:	01 00 a5 49 	r8 = I5 + 1;
      r1 = r1 + r3;
84204008:	00 00 35 03 	r1 = r1 + r3;
      if NEG r1 = 0;
8420400c:	04 00 30 00 	if NEG r1 = Null + Null;
      Null = r8 - r1;
84204010:	3f 00 0a 20 	Null = r8 - r1;
      if POS r8 = r1;
84204014:	05 00 a3 00 	if POS r8 = r1 + Null;
      M[FP + VB] = r8;
84204018:	38 00 ac f1 	M[FP + 0x38] = r8;

      r0 = $celt.BITRES;
8420401c:	bf 00 20 e4 	r0 = Null + 4;
      call $celt.log2_frac;
84204020:	b3 06 f0 e1 	call $celt.log2_frac;
      r0 = $celt.QTHETA_OFFSET - r0;
84204024:	28 00 22 65 	r0 = 40 - r0;
      r1 = M[FP + N_BAND];
84204028:	1c 00 38 f1 	r1 = M[FP + 0x1c];
      r2 = r1 - 1;
8420402c:	3f 00 43 e4 	r2 = r1 - 1;
      r1 = r2 + r2;
84204030:	4f 00 34 00 	r1 = r2 + r2;
      r1 = r1 * r0(int);
84204034:	00 00 32 9b 	r1 = r1 * r0 (int);
      r1 = r8 - r1;
84204038:	3f 00 3a 20 	r1 = r8 - r1;
      if NEG r1 = 0;
8420403c:	04 00 30 00 	if NEG r1 = Null + Null;

      r2 = r2 LSHIFT 5;
84204040:	05 00 44 8d 	r2 = r2 LSHIFT 5;
      rMAC = 0;
84204044:	00 00 10 01 	rMAC = Null + 0;
      rMAC0 = r1;
84204048:	00 05 e3 8d 	rMAC0 = r1 LSHIFT 0;
      Div = rMAC / r2;
8420404c:	00 00 14 d9 	Div = rMAC / r2;
      r7 = r8 LSHIFT (-$celt.BITRES);
84204050:	fc 00 9a 8d 	r7 = r8 LSHIFT -4;
      r7 = r7 - 1;
84204054:	3f 00 99 e4 	r7 = r7 - 1;
      if NEG r7 = 0;
84204058:	04 00 90 00 	if NEG r7 = Null + Null;
      r0 = DivResult;
8420405c:	01 00 20 d9 	r0 = DivResult;
      Null = r0 - r7;
84204060:	9f 00 02 20 	Null = r0 - r7;
      if POS r0 = r7;
84204064:	05 00 29 00 	if POS r0 = r7 + Null;
      r1 = r0 - 14;
84204068:	0e 00 32 21 	r1 = r0 - 14;
      if POS r0 = r0 - r1;
8420406c:	35 00 22 20 	if POS r0 = r0 - r1;
      M[FP + QB] = r0;
84204070:	54 00 2c f1 	M[FP + 0x54] = r0;
      r1 = 1 LSHIFT r0;
84204074:	01 00 32 e9 	r1 = 0x1 LSHIFT r0;
      r1 = r1 + 1;
84204078:	2f 00 33 e4 	r1 = r1 + 1;
      rMAC = 0;
8420407c:	00 00 10 01 	rMAC = Null + 0;
      rMAC0 = r1;
84204080:	00 05 e3 8d 	rMAC0 = r1 LSHIFT 0;
      r0 = $celt.BITRES;
84204084:	bf 00 20 e4 	r0 = Null + 4;
      call $celt.log2_frac;
84204088:	99 06 f0 e1 	call $celt.log2_frac;
      M[FP + QALLOC] = r0;
8420408c:	24 00 2c f1 	M[FP + 0x24] = r0;

      // -- save some registers

      // to guaranteen we will always have the same push sequence for different chips, avoid using "pushm" here
      // I5, I6, I7, I2, M3, r5
      r3 = I5;
84204090:	5f 00 50 44 	r3 = Null + I5;
      M[FP + RM_BITS] = r3;
84204094:	04 00 5c f1 	M[FP + 0x4] = r3;
      r3 = I6;
84204098:	6f 00 50 44 	r3 = Null + I6;
      M[FP + TOTOAL_BITS] = r3;
8420409c:	08 00 5c f1 	M[FP + 0x8] = r3;
      r3 = I7;
842040a0:	7f 00 50 44 	r3 = Null + I7;
      M[FP + NB_EBAND] = r3;
842040a4:	0c 00 5c f1 	M[FP + 0xc] = r3;
      r3 = I2;
842040a8:	2f 00 50 44 	r3 = Null + I2;
      M[FP + ADDR_EBAND] = r3;
842040ac:	10 00 5c f1 	M[FP + 0x10] = r3;
      r3 = M3;
842040b0:	bf 00 50 44 	r3 = Null + M3;
      M[FP + NB_EBAND_RM] = r3;
842040b4:	14 00 5c f1 	M[FP + 0x14] = r3;
      M[FP + CODEC_STRUC] = r5;
842040b8:	18 00 7c f1 	M[FP + 0x18] = r5;

      // -- stereo processing required for encode
      Null = M[FP + CODEC];
842040bc:	58 00 08 f1 	Null = M[FP + 0x58];
      if Z jump is_dec1;
842040c0:	88 00 00 dd 	if EQ jump $M.celt.unquant_bands_stereo.is_dec1;

842040c4 <$M.celt.unquant_bands_stereo.is_enc1>:
      is_enc1:
         Null = M[FP + QB];
842040c4:	54 00 08 f1 	Null = M[FP + 0x54];
         if NZ jump end_calc_st_coeff;
842040c8:	2a 00 10 dd 	if NE jump $M.celt.unquant_bands_stereo.end_calc_st_coeff;

            // -- calc mid/side coeffs
            r2 = I7 - M3;
842040cc:	bf 00 47 6c 	r2 = I7 - M3;
            r2 = r2 + r2;
842040d0:	00 00 44 03 	r2 = r2 + r2;
            r0 = M[r5 + $celt.enc.BANDE_FIELD];
842040d4:	d0 00 27 d1 	r0 = M[r5 + 208];
            I4 = r0 + r2;
842040d8:	4f 00 42 50 	I4 = r0 + r2;
            r3 = M[I4, MK1];
842040dc:	51 00 00 03 	Null = Null + Null, r3 = M[I4,4];
            r4 = M[I4, MK1];
842040e0:	61 00 00 03 	Null = Null + Null, r4 = M[I4,4];

            I4 = I4 + ($celt.MAX_BANDS*2)*ADDR_PER_WORD;
842040e4:	c8 00 44 59 	I4 = I4 + 200;
            r0 = M[I4, MK1];
842040e8:	21 00 00 03 	Null = Null + Null, r0 = M[I4,4];
            r1 = M[I4, MK1];
842040ec:	31 00 00 03 	Null = Null + Null, r1 = M[I4,4];
            r2 = r4 - r1;
842040f0:	3f 00 46 20 	r2 = r4 - r1;
            if POS r2 = 0;
842040f4:	05 00 40 00 	if POS r2 = Null + Null;
            r1 = r1 - r4;
842040f8:	00 00 36 23 	r1 = r1 - r4;
            if POS r1 = 0;
842040fc:	05 00 30 00 	if POS r1 = Null + Null;
            r0 = r0 ASHIFT r1;
84204100:	00 00 23 93 	r0 = r0 ASHIFT r1;
            r3 = r3 ASHIFT r2;
84204104:	00 00 54 93 	r3 = r3 ASHIFT r2;
            push r0;
84204108:	00 00 20 f3 	push r0;
            push r3;
8420410c:	00 00 50 f3 	push r3;
            rMAC = r0 * r0;
84204110:	2f 00 12 cc 	rMAC = r0 * r0 (SS);
            rMAC = rMAC + r3 * r3;
84204114:	5f 00 15 ac 	rMAC = rMAC + r3 * r3 (SS);
            r0 = rMAC;
84204118:	0f 00 21 00 	r0 = rMAC + Null;
            $celt.sqrt
8420411c:	01 10 01 f1 	pushm <I0, L0>;
84204120:	00 00 c0 51 	L0 = Null + 0;
84204124:	00 00 a2 f3 	push B0;
84204128:	00 00 00 f3 	push Null;
8420412c:	00 00 a6 f3 	pop B0;
84204130:	07 00 00 fd 	call 0x74370;
84204134:	70 43 f0 e1 
84204138:	00 00 a6 f3 	pop B0;
8420413c:	01 10 05 f1 	popm <I0, L0>;
            pop r4;
84204140:	00 00 64 f3 	pop r4;
            pop r2;
84204144:	00 00 44 f3 	pop r2;
            r3 = r1;
84204148:	0f 00 53 00 	r3 = r1 + Null;
            if Z jump end_calc_st_coeff;
8420414c:	09 00 00 dd 	if EQ jump $M.celt.unquant_bands_stereo.end_calc_st_coeff;
            rMAC = r2 ASHIFT -1;
84204150:	ff 00 e4 91 	rMAC = r2 ASHIFT -1 (MI);
            Div = rMAC / r3;
84204154:	00 00 15 d9 	Div = rMAC / r3;
            r0 = DivResult;
84204158:	01 00 20 d9 	r0 = DivResult;
            rMAC = r4 ASHIFT -1;
8420415c:	ff 00 e6 91 	rMAC = r4 ASHIFT -1 (MI);
            Div = rMAC / r3;
84204160:	00 00 15 d9 	Div = rMAC / r3;
            r1 = DivResult;
84204164:	01 00 30 d9 	r1 = DivResult;
            r1 = -r1;
84204168:	3f 00 30 20 	r1 = Null - r1;
            jump st_mix_enc;
8420416c:	05 00 f0 dd 	jump $M.celt.unquant_bands_stereo.st_mix_enc;

84204170 <$M.celt.unquant_bands_stereo.end_calc_st_coeff>:
         end_calc_st_coeff:
         r0 = -0.707106781186548;
84204170:	7d a5 00 fd 	r0 = Null + -1518500250;
84204174:	66 86 20 01 
         r1 = 0.707106781186548;
84204178:	82 5a 00 fd 	r1 = Null + 1518500250;
8420417c:	9a 79 30 01 

84204180 <$M.celt.unquant_bands_stereo.st_mix_enc>:
         st_mix_enc:

         // -- ms stereo per band
         r3 = M[FP + S_BAND];
84204180:	20 00 58 f1 	r3 = M[FP + 0x20];
         Words2Addr(r3);
84204184:	02 00 55 91 	r3 = r3 ASHIFT 2;
         r10 = M[FP + N_BAND];
84204188:	1c 00 c8 f1 	r10 = M[FP + 0x1c];
         r10 = r10 - 1;
8420418c:	3f 00 cc e4 	r10 = r10 - 1;
         r2 = M[r5 + $celt.dec.NORM_FREQ_FIELD];
84204190:	cc 00 47 d1 	r2 = M[r5 + 204];
         I3  = r3 + r2;
84204194:	4f 00 35 50 	I3 = r3 + r2;
         r4 = M[r5 +  $celt.dec.MODE_MDCT_SIZE_FIELD];
84204198:	44 00 67 d1 	r4 = M[r5 + 68];
         Words2Addr(r4);
8420419c:	02 00 66 91 	r4 = r4 ASHIFT 2;
         I4 = I3 + r4;
842041a0:	6f 00 43 58 	I4 = I3 + r4;
         I6 = I3;
842041a4:	0f 00 63 58 	I6 = I3 + Null;
         I7 = I4;
842041a8:	0f 00 74 58 	I7 = I4 + Null;
         r2 = M[I3, MK1], r3 = M[I4, MK1];
842041ac:	51 4d 00 03 	Null = Null + Null, r2 = M[I3,4], r3 = M[I4,4];
         r0 = r0 * 0.707106781186548;
842041b0:	82 5a 00 fd 	r0 = r0 * 0.707106781192123889923095703125 (SS);
842041b4:	9a 79 22 cd 
         r1 = r1 * 0.707106781186548;
842041b8:	82 5a 00 fd 	r1 = r1 * 0.707106781192123889923095703125 (SS);
842041bc:	9a 79 33 cd 

         rMAC = r3 * r1;
842041c0:	3f 00 15 cc 	rMAC = r3 * r1 (SS);
         do mid_side_loop0;
842041c4:	05 00 f0 e5 	do $M.celt.unquant_bands_stereo.mid_side_loop0;
            rMAC = rMAC - r2 * r0;
842041c8:	2f 00 14 bc 	rMAC = rMAC - r2 * r0 (SS);
            rMAC = r3 * r1, M[I6, MK1] = rMAC;
842041cc:	99 00 53 cf 	rMAC = r3 * r1 (SS), M[I6,4] = rMAC;
            rMAC = rMAC + r2 * r0, r2 = M[I3, MK1], r3 = M[I4, MK1];
842041d0:	51 4d 42 af 	rMAC = rMAC + r2 * r0 (SS), r2 = M[I3,4], r3 = M[I4,4];
            rMAC = r3 * r1, M[I7, MK1] = rMAC;
842041d4:	9d 00 53 cf 	rMAC = r3 * r1 (SS), M[I7,4] = rMAC;

842041d8 <$M.celt.unquant_bands_stereo.mid_side_loop0>:
         mid_side_loop0:
         rMAC = rMAC - r2 * r0;
842041d8:	2f 00 14 bc 	rMAC = rMAC - r2 * r0 (SS);
         rMAC = r3 * r1, M[I6, MK1] = rMAC;
842041dc:	99 00 53 cf 	rMAC = r3 * r1 (SS), M[I6,4] = rMAC;
         rMAC = rMAC + r2 * r0;
842041e0:	2f 00 14 ac 	rMAC = rMAC + r2 * r0 (SS);
         M[I7, MK1] = rMAC;
842041e4:	9d 00 00 03 	Null = Null + Null, M[I7,4] = rMAC;

         // -- renormalise left band
         r3= M[FP + N_BAND];
842041e8:	1c 00 58 f1 	r3 = M[FP + 0x1c];
         M3 = r3;
842041ec:	5f 00 b0 50 	M3 = Null + r3;
         r1 = M[FP + S_BAND];
842041f0:	20 00 38 f1 	r1 = M[FP + 0x20];
         Words2Addr(r1);
842041f4:	02 00 33 91 	r1 = r1 ASHIFT 2;
         r0 = M[r5 + $celt.dec.NORM_FREQ_FIELD];
842041f8:	cc 00 27 d1 	r0 = M[r5 + 204];
         I5  = r1 + r0;
842041fc:	2f 00 53 50 	I5 = r1 + r0;
         M0 = 1;
84204200:	01 00 80 51 	M0 = Null + 1;
         r7 = 1.0;
84204204:	ff 7f 00 fd 	r7 = Null + 2147483647;
84204208:	ff ff 90 01 
         call $celt.renormalise_vector;
8420420c:	38 02 f0 e1 	call $celt.renormalise_vector;
         push r1;
84204210:	00 00 30 f3 	push r1;

         // -- renormalise right band
         r3 = M[FP + N_BAND];
84204214:	1c 00 58 f1 	r3 = M[FP + 0x1c];
         M3 = r3;
84204218:	5f 00 b0 50 	M3 = Null + r3;
         r1 = M[FP + S_BAND];
8420421c:	20 00 38 f1 	r1 = M[FP + 0x20];
         Words2Addr(r1);
84204220:	02 00 33 91 	r1 = r1 ASHIFT 2;
         r0 = M[r5 + $celt.dec.NORM_FREQ_FIELD];
84204224:	cc 00 27 d1 	r0 = M[r5 + 204];
         I5  = r1 + r0;
84204228:	2f 00 53 50 	I5 = r1 + r0;
         r4 = M[r5 +  $celt.dec.MODE_MDCT_SIZE_FIELD];
8420422c:	44 00 67 d1 	r4 = M[r5 + 68];
         Words2Addr(r4);
84204230:	02 00 66 91 	r4 = r4 ASHIFT 2;
         I5 = I5 + r4;
84204234:	00 00 56 5b 	I5 = I5 + r4;
         M0 = 1;
84204238:	01 00 80 51 	M0 = Null + 1;
         r7 = 1.0;
8420423c:	ff 7f 00 fd 	r7 = Null + 2147483647;
84204240:	ff ff 90 01 
         call $celt.renormalise_vector;
84204244:	2a 02 f0 e1 	call $celt.renormalise_vector;

         // -- calc atan(E_L/E_R)
         r6 = r1;
84204248:	0f 00 83 00 	r6 = r1 + Null;
         pop r1;
8420424c:	00 00 34 f3 	pop r1;
         r0 = M[FP + QB];
84204250:	54 00 28 f1 	r0 = M[FP + 0x54];
         if Z jump qb_z;
84204254:	25 00 00 dd 	if EQ jump $M.celt.unquant_bands_stereo.qb_z;
         push r5;
84204258:	00 00 70 f3 	push r5;

         // some optimisation
         r5 = 0;
8420425c:	00 00 70 01 	r5 = Null + 0;
         NULL = r1 OR r6;
84204260:	8f 00 03 84 	Null = r1 OR r6;
         if Z jump calc_lr_ratio;
84204264:	08 00 00 dd 	if EQ jump $M.celt.unquant_bands_stereo.calc_lr_ratio;
         r5 = 0.25;
84204268:	00 20 00 fd 	r5 = Null + 536870912;
8420426c:	00 00 70 01 
         Null = r1 - r6;
84204270:	8f 00 03 20 	Null = r1 - r6;
         if Z jump calc_lr_ratio;
84204274:	04 00 00 dd 	if EQ jump $M.celt.unquant_bands_stereo.calc_lr_ratio;
         // now calc E_L/E_R
         r5 = r1;
84204278:	0f 00 73 00 	r5 = r1 + Null;
         call $math.atan;
8420427c:	07 00 00 fd 	call 0x74698;
84204280:	98 46 f0 e1 

84204284 <$M.celt.unquant_bands_stereo.calc_lr_ratio>:
         calc_lr_ratio:
            r3 = r5 * 0.003906251396735(frac);
84204284:	80 00 00 fd 	r3 = r5 * 0.0039062513969838619232177734375 (frac);
84204288:	03 00 57 95 
         pop r5;
8420428c:	00 00 74 f3 	pop r5;
         r0 = M[FP + QB];
84204290:	54 00 28 f1 	r0 = M[FP + 0x54];
         if Z jump qb_z;
84204294:	15 00 00 dd 	if EQ jump $M.celt.unquant_bands_stereo.qb_z;
         r1 = r0 - 14;
84204298:	0e 00 32 21 	r1 = r0 - 14;
         r2 = -r1;
8420429c:	3f 00 40 20 	r2 = Null - r1;
         r1 = 1.0 ASHIFT r1;
842042a0:	ff 7f 00 fd 	r1 = 0x7fffffff ASHIFT r1;
842042a4:	ff ff 33 ed 
#ifdef K32
#ifdef K32_BITEXACT
         r1 = r1 ASHIFT -8;
842042a8:	f8 00 33 91 	r1 = r1 ASHIFT -8;
#endif	 
#endif
         r3 = r3 * r1(frac);
842042ac:	00 00 53 97 	r3 = r3 * r1 (frac);
         r2 = r3 ASHIFT r2;
842042b0:	4f 00 45 90 	r2 = r3 ASHIFT r2;
#ifdef K32         
#ifndef K32_BITEXACT
         r2 = r2 LSHIFT -8; 
#endif	 
#endif                      
         M[FP + ITHETA] = r2; // SGTBD: ITHETA big difference between ARCH3 and ARCH4
842042b4:	34 00 4c f1 	M[FP + 0x34] = r2;
         r0 = 1 ASHIFT r0;
842042b8:	01 00 22 ed 	r0 = 0x1 ASHIFT r0;
         r0 = r0 + 1;         
842042bc:	2f 00 22 e4 	r0 = r0 + 1;
         M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FT + 0] = r0;
842042c0:	cc 01 27 d5 	M[r5 + 460] = r0;
         M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FT + 1*MK1] = Null;
842042c4:	d0 01 07 d5 	M[r5 + 464] = Null;
#ifdef K32         
#ifndef K32_BITEXACT
         r3 = r3 LSHIFT -8; // .fl is a 24-bit integer
#endif	 
#endif                  
         M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FL + 0] = r3;
842042c8:	d4 01 57 d5 	M[r5 + 468] = r3;
         M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FL + 1*MK1] = Null;
842042cc:	d8 01 07 d5 	M[r5 + 472] = Null;
         r2 = M[r5 + $celt.dec.EC_UINT_FUNC_FIELD];
842042d0:	38 00 47 d1 	r2 = M[r5 + 56];
         call r2;
842042d4:	0f 00 04 e0 	call r2;
         r0 = M[FP + ITHETA];
842042d8:	34 00 28 f1 	r0 = M[FP + 0x34];
         jump test_itheta;
842042dc:	14 00 f0 dd 	jump $M.celt.unquant_bands_stereo.test_itheta;

842042e0 <$M.celt.unquant_bands_stereo.is_dec1>:
      is_dec1:
      r0 = M[FP + QB];
842042e0:	54 00 28 f1 	r0 = M[FP + 0x54];
      if NZ jump nzqb_dec;
842042e4:	07 00 10 dd 	if NE jump $M.celt.unquant_bands_stereo.nzqb_dec;

842042e8 <$M.celt.unquant_bands_stereo.qb_z>:
      qb_z:
         r0 = 0;
842042e8:	00 00 20 01 	r0 = Null + 0;
         M[FP + ITHETA] = r0;
842042ec:	34 00 2c f1 	M[FP + 0x34] = r0;

842042f0 <$M.celt.unquant_bands_stereo.is_ztheta>:
      is_ztheta:
         r0 = 32767;     //mid
842042f0:	ff 7f 20 01 	r0 = Null + 32767;
         r1 = 0;         //side
842042f4:	00 00 30 01 	r1 = Null + 0;
         r2 = -10000;    //delta
842042f8:	f0 d8 40 01 	r2 = Null + -10000;
      jump set_st;
842042fc:	12 00 f0 dd 	jump $M.celt.unquant_bands_stereo.set_st;

84204300 <$M.celt.unquant_bands_stereo.nzqb_dec>:
      nzqb_dec:
         r0 = M[FP + QB];
84204300:	54 00 28 f1 	r0 = M[FP + 0x54];
         r1 = 14 - r0;
84204304:	0e 00 32 65 	r1 = 14 - r0;
         push r1;
84204308:	00 00 30 f3 	push r1;
         r1 = 1 LSHIFT r0;
8420430c:	01 00 32 e9 	r1 = 0x1 LSHIFT r0;
         r0 = r1 + 1;
84204310:	2f 00 23 e4 	r0 = r1 + 1;
         r1 = 0;
84204314:	00 00 30 01 	r1 = Null + 0;
         r2 = M[r5 + $celt.dec.EC_UINT_FUNC_FIELD];
84204318:	38 00 47 d1 	r2 = M[r5 + 56];
         call r2;
8420431c:	0f 00 04 e0 	call r2;
         pop r1;
84204320:	00 00 34 f3 	pop r1;
         r0 = r0 LSHIFT r1;
84204324:	00 00 23 8f 	r0 = r0 LSHIFT r1;
         M[FP + ITHETA]  = r0;
84204328:	34 00 2c f1 	M[FP + 0x34] = r0;

8420432c <$M.celt.unquant_bands_stereo.test_itheta>:
         test_itheta:
         if Z jump is_ztheta;
8420432c:	f1 ff 00 dd 	if EQ jump $M.celt.unquant_bands_stereo.is_ztheta;
         Null = r0 - 16384;
84204330:	00 40 02 21 	Null = r0 - 16384;
         if NZ jump calc_ims;
84204334:	08 00 10 dd 	if NE jump $M.celt.unquant_bands_stereo.calc_ims;
             r0 = 0;     //mid
84204338:	00 00 20 01 	r0 = Null + 0;
             r1 = 32767; //side
8420433c:	ff 7f 30 01 	r1 = Null + 32767;
             r2 = 10000; //delta
84204340:	10 27 40 01 	r2 = Null + 10000;

84204344 <$M.celt.unquant_bands_stereo.set_st>:
          set_st:
             M[FP + IMID] = r0;
84204344:	28 00 2c f1 	M[FP + 0x28] = r0;
             M[FP + ISIDE] = r1;
84204348:	2c 00 3c f1 	M[FP + 0x2c] = r1;
             M[FP + DELTA] = r2;
8420434c:	30 00 4c f1 	M[FP + 0x30] = r2;
         jump end_ims;
84204350:	17 00 f0 dd 	jump $M.celt.unquant_bands_stereo.end_ims;

84204354 <$M.celt.unquant_bands_stereo.calc_ims>:
         calc_ims:
         call $celt.bitexact_cos;
84204354:	1f 06 f0 e1 	call $celt.bitexact_cos;
         M[FP + IMID] = r2;
84204358:	28 00 4c f1 	M[FP + 0x28] = r2;
         rMAC = 0;
8420435c:	00 00 10 01 	rMAC = Null + 0;
         rMAC0 = r2;
84204360:	00 05 e4 8d 	rMAC0 = r2 LSHIFT 0;
         r0 = $celt.BITRES+2;
84204364:	06 00 20 01 	r0 = Null + 6;
         call $celt.log2_frac;
84204368:	e1 05 f0 e1 	call $celt.log2_frac;
         push r0;
8420436c:	00 00 20 f3 	push r0;

         r0 = M[FP + ITHETA];
84204370:	34 00 28 f1 	r0 = M[FP + 0x34];
         r0 = 16384 - r0;
84204374:	00 40 22 65 	r0 = 16384 - r0;
         call $celt.bitexact_cos;
84204378:	16 06 f0 e1 	call $celt.bitexact_cos;
         M[FP + ISIDE] = r2;
8420437c:	2c 00 4c f1 	M[FP + 0x2c] = r2;
         rMAC = 0;
84204380:	00 00 10 01 	rMAC = Null + 0;
         rMAC0 = r2;
84204384:	00 05 e4 8d 	rMAC0 = r2 LSHIFT 0;
         r0 = $celt.BITRES+2;
84204388:	06 00 20 01 	r0 = Null + 6;
         call $celt.log2_frac;
8420438c:	d8 05 f0 e1 	call $celt.log2_frac;
         pop r1;
84204390:	00 00 34 f3 	pop r1;
         r0 = r0 - r1;
84204394:	00 00 23 23 	r0 = r0 - r1;
         r1 = M[FP + N_BAND];
84204398:	1c 00 38 f1 	r1 = M[FP + 0x1c];
         r1 = r1 - 1;
8420439c:	3f 00 33 e4 	r1 = r1 - 1;
         r0 = r0*r1(int);
842043a0:	00 00 23 9b 	r0 = r0 * r1 (int);
         r0 = r0 ASHIFT -2;
842043a4:	fe 00 22 91 	r0 = r0 ASHIFT -2;
         M[FP + DELTA] = r0;
842043a8:	30 00 2c f1 	M[FP + 0x30] = r0;

842043ac <$M.celt.unquant_bands_stereo.end_ims>:
      end_ims:

      // restore trashed registers
      // retrieve the values in I6, I7, M3
      r3 = M[FP + TOTOAL_BITS];
842043ac:	08 00 58 f1 	r3 = M[FP + 0x8];
      I6 = r3;
842043b0:	5f 00 60 50 	I6 = Null + r3;
      r3 = M[FP + NB_EBAND];
842043b4:	0c 00 58 f1 	r3 = M[FP + 0xc];
      I7 = r3;
842043b8:	5f 00 70 50 	I7 = Null + r3;
      r3 = M[FP + NB_EBAND_RM];
842043bc:	14 00 58 f1 	r3 = M[FP + 0x14];
      M3 = r3;
842043c0:	5f 00 b0 50 	M3 = Null + r3;

      // -- calc pulses allocated to L and R
      r0 = M[FP + VB];
842043c4:	38 00 28 f1 	r0 = M[FP + 0x38];
      r4 = M[FP + QALLOC];
842043c8:	24 00 68 f1 	r4 = M[FP + 0x24];
      r3 = M[FP + DELTA];
842043cc:	30 00 58 f1 	r3 = M[FP + 0x30];
      r2 = r0 - r4;
842043d0:	6f 00 42 20 	r2 = r0 - r4;
      r1 = r4 ASHIFT -1;
842043d4:	ff 00 36 91 	r1 = r4 ASHIFT -1;
      r1 = r0 - r1;
842043d8:	3f 00 32 20 	r1 = r0 - r1;
      r1 = r1 - r3;
842043dc:	00 00 35 23 	r1 = r1 - r3;
      r1 = r1 ASHIFT -1;
842043e0:	ff 00 33 91 	r1 = r1 ASHIFT -1;
      if NEG r1 = 0;
842043e4:	04 00 30 00 	if NEG r1 = Null + Null;
      Null = r1 - r2;
842043e8:	4f 00 03 20 	Null = r1 - r2;
      if POS r1 = r2;
842043ec:	05 00 34 00 	if POS r1 = r2 + Null;
      M[FP + MBITS] = r1;
842043f0:	44 00 3c f1 	M[FP + 0x44] = r1;
      r2 = r2 - r1;
842043f4:	00 00 43 23 	r2 = r2 - r1;
      M[FP + SBITS] = r2;
842043f8:	48 00 4c f1 	M[FP + 0x48] = r2;
      r2 = I7 - M3;
842043fc:	bf 00 47 6c 	r2 = I7 - M3;
      call $celt.bits2pulses;
84204400:	c1 00 f0 e1 	call $celt.bits2pulses;
      M[FP + Q1] = r0;
84204404:	3c 00 2c f1 	M[FP + 0x3c] = r0;
      r1 = M[FP + SBITS];
84204408:	48 00 38 f1 	r1 = M[FP + 0x48];
      r2 = I7 - M3;
8420440c:	bf 00 47 6c 	r2 = I7 - M3;
      call $celt.bits2pulses;
84204410:	bd 00 f0 e1 	call $celt.bits2pulses;
      M[FP + Q2] = r0;               //q2=r0
84204414:	40 00 2c f1 	M[FP + 0x40] = r0;
      r2 = M[FP + Q1];               //q1=r2
84204418:	3c 00 48 f1 	r2 = M[FP + 0x3c];
      Words2Addr(r0);
8420441c:	02 00 22 91 	r0 = r0 ASHIFT 2;
      r1 = M[r4 + r0];          //curbits=r3
84204420:	2f 00 36 d0 	r1 = M[r4 + r0];
      Addr2Words(r0);
84204424:	fe 00 22 91 	r0 = r0 ASHIFT -2;
      // restore I5
      r3 = M[FP + RM_BITS];
84204428:	04 00 58 f1 	r3 = M[FP + 0x4];
      I5 = r3;
8420442c:	5f 00 50 50 	I5 = Null + r3;

      Words2Addr(r2);
84204430:	02 00 44 91 	r2 = r2 ASHIFT 2;
      r3 = M[r4 + r2];
84204434:	4f 00 56 d0 	r3 = M[r4 + r2];
      Addr2Words(r2);
84204438:	fe 00 44 91 	r2 = r2 ASHIFT -2;
      r3 = r3 + r1;
8420443c:	00 00 53 03 	r3 = r3 + r1;
      r1 = M[FP + QALLOC];
84204440:	24 00 38 f1 	r1 = M[FP + 0x24];
      r3 = r3 + r1;
84204444:	00 00 53 03 	r3 = r3 + r1;

84204448 <$M.celt.unquant_bands_stereo.rem_loop_start>:
      rem_loop_start:
      I5 = I5 - r3;
84204448:	00 00 55 7b 	I5 = I5 - r3;
      if POS jump end_rem_loop;
8420444c:	14 00 50 dd 	if POS jump $M.celt.unquant_bands_stereo.end_rem_loop;
         Null = r0 + r2;
84204450:	4f 00 02 00 	Null = r0 + r2;
         if LE jump end_rem_loop;
84204454:	12 00 d0 dd 	if LE jump $M.celt.unquant_bands_stereo.end_rem_loop;
         I5 = I5 + r3;
84204458:	00 00 55 5b 	I5 = I5 + r3;
         r3 = 1;
8420445c:	2f 00 50 e4 	r3 = Null + 1;
         Null = r2 - r0;  //q1-q2
84204460:	2f 00 04 20 	Null = r2 - r0;
         if LE r3 = 0;    //r3 = q>q2
84204464:	0d 00 50 00 	if LE r3 = Null + Null;
         r1 = r3 XOR 1;   //r1 = q1<=q2
84204468:	01 00 35 89 	r1 = r3 XOR 0x1;
         r2 = r2 - r3;    //q1=q1 - q1>q2
8420446c:	00 00 45 23 	r2 = r2 - r3;
         r0 = r0 - r1;    //q2=q2 - q1<=q2
84204470:	00 00 23 23 	r0 = r0 - r1;
         Words2Addr(r0);
84204474:	02 00 22 91 	r0 = r0 ASHIFT 2;
         Words2Addr(r2);
84204478:	02 00 44 91 	r2 = r2 ASHIFT 2;
         r3 = M[r4 + r0];
8420447c:	2f 00 56 d0 	r3 = M[r4 + r0];
         r1 = M[r4 + r2];
84204480:	4f 00 36 d0 	r1 = M[r4 + r2];
         Addr2Words(r0);
84204484:	fe 00 22 91 	r0 = r0 ASHIFT -2;
         Addr2Words(r2);
84204488:	fe 00 44 91 	r2 = r2 ASHIFT -2;
         r3 = r3 + r1;
8420448c:	00 00 53 03 	r3 = r3 + r1;
         r1 = M[FP + QALLOC];
84204490:	24 00 38 f1 	r1 = M[FP + 0x24];
         r3 = r3 + r1;
84204494:	00 00 53 03 	r3 = r3 + r1;
         jump rem_loop_start;
84204498:	ec ff f0 dd 	jump $M.celt.unquant_bands_stereo.rem_loop_start;

8420449c <$M.celt.unquant_bands_stereo.end_rem_loop>:
      end_rem_loop:
      M[FP + Q2] = r0;
8420449c:	40 00 2c f1 	M[FP + 0x40] = r0;
      r0 = r2;
842044a0:	0f 00 24 00 	r0 = r2 + Null;
      // push I5
      r3 = I5;
842044a4:	5f 00 50 44 	r3 = Null + I5;
      M[FP + RM_BITS] = r3;
842044a8:	04 00 5c f1 	M[FP + 0x4] = r3;

      // save some registers into stack
      r2 = M[FP + CUR_B];
842044ac:	4c 00 48 f1 	r2 = M[FP + 0x4c];
      r1 = M[FP + S_BAND];
842044b0:	20 00 38 f1 	r1 = M[FP + 0x20];
      r3 = M[FP + N_BAND];
842044b4:	1c 00 58 f1 	r3 = M[FP + 0x1c];
      r4 = M[r5 + $celt.dec.NORM_FREQ_FIELD];
842044b8:	cc 00 67 d1 	r4 = M[r5 + 204];
      Words2Addr(r1);
842044bc:	02 00 33 91 	r1 = r1 ASHIFT 2;
      I5 = r4 + r1;//X+eBands[i]
842044c0:	3f 00 56 50 	I5 = r4 + r1;
      // I5 = start of band
      // r0 = number of pulses
      // r1 = start bin no
      // r3 = band width
      // r2 = nr of Blocks
      r4 = r0 - Null;
842044c4:	0f 00 62 20 	r4 = r0 - Null;
      if LE jump intra_act;
842044c8:	07 00 d0 dd 	if LE jump $M.celt.unquant_bands_stereo.intra_act;
         //calc spread
         M0 = r2;
842044cc:	4f 00 80 50 	M0 = Null + r2;
         Null = M[r5 + $celt.dec.HAS_FOLD_FIELD];
842044d0:	60 01 07 d1 	Null = M[r5 + 352];
         if Z M0 = M0 - M0;
842044d4:	80 00 88 7c 	if EQ M0 = M0 - M0;
         r0 = M[r5 + $celt.dec.ALG_QUANT_FUNC_FIELD];
842044d8:	34 00 27 d1 	r0 = M[r5 + 52];
         call r0;
842044dc:	0f 00 02 e0 	call r0;
         jump end_act;
842044e0:	05 00 f0 dd 	jump $M.celt.unquant_bands_stereo.end_act;

842044e4 <$M.celt.unquant_bands_stereo.intra_act>:
      intra_act:
         r0 = M[r5 + $celt.dec.NORM_FIELD];
842044e4:	10 01 27 d1 	r0 = M[r5 + 272];
         I3 = r0;
842044e8:	2f 00 30 50 	I3 = Null + r0;
         Addr2Words(r1);
842044ec:	fe 00 33 91 	r1 = r1 ASHIFT -2;
         call $celt.intra_fold;
842044f0:	5b 01 f0 e1 	call $celt.intra_fold;

842044f4 <$M.celt.unquant_bands_stereo.end_act>:
      end_act:

      // restore I5, I6, I7, M3, r5
      r3 = M[FP + RM_BITS];
842044f4:	04 00 58 f1 	r3 = M[FP + 0x4];
      I5 = r3;
842044f8:	5f 00 50 50 	I5 = Null + r3;
      r3 = M[FP + TOTOAL_BITS];
842044fc:	08 00 58 f1 	r3 = M[FP + 0x8];
      I6 = r3;
84204500:	5f 00 60 50 	I6 = Null + r3;
      r3 = M[FP + NB_EBAND];
84204504:	0c 00 58 f1 	r3 = M[FP + 0xc];
      I7 = r3;
84204508:	5f 00 70 50 	I7 = Null + r3;
      r3 = M[FP + NB_EBAND_RM];
8420450c:	14 00 58 f1 	r3 = M[FP + 0x14];
      M3 = r3;
84204510:	5f 00 b0 50 	M3 = Null + r3;
      r5 = M[FP + CODEC_STRUC];
84204514:	18 00 78 f1 	r5 = M[FP + 0x18];

84204518 <$M.celt.unquant_bands_stereo.second_ch>:

      second_ch:
         r0 = M[FP + Q2];
84204518:	40 00 28 f1 	r0 = M[FP + 0x40];
         // save I5, I6, I7, M3, r5 into stack
         r3 = I5;
8420451c:	5f 00 50 44 	r3 = Null + I5;
         M[FP + RM_BITS] = r3;
84204520:	04 00 5c f1 	M[FP + 0x4] = r3;
         r3 = I6;
84204524:	6f 00 50 44 	r3 = Null + I6;
         M[FP + TOTOAL_BITS] = r3;
84204528:	08 00 5c f1 	M[FP + 0x8] = r3;
         r3 = I7;
8420452c:	7f 00 50 44 	r3 = Null + I7;
         M[FP + NB_EBAND] = r3;
84204530:	0c 00 5c f1 	M[FP + 0xc] = r3;
         r3 = M3;
84204534:	bf 00 50 44 	r3 = Null + M3;
         M[FP + NB_EBAND_RM] = r3;
84204538:	14 00 5c f1 	M[FP + 0x14] = r3;
         M[FP + CODEC_STRUC] = r5;
8420453c:	18 00 7c f1 	M[FP + 0x18] = r5;

         r2 = M[FP + CUR_B];
84204540:	4c 00 48 f1 	r2 = M[FP + 0x4c];
         r1 = M[FP + S_BAND];
84204544:	20 00 38 f1 	r1 = M[FP + 0x20];
         r3 = M[FP + N_BAND];
84204548:	1c 00 58 f1 	r3 = M[FP + 0x1c];
         r4 = M[r5 + $celt.dec.NORM_FREQ_FIELD];
8420454c:	cc 00 67 d1 	r4 = M[r5 + 204];
         Words2Addr(r1);
84204550:	02 00 33 91 	r1 = r1 ASHIFT 2;
         I5 = r4 + r1;//X+eBands[i]
84204554:	3f 00 56 50 	I5 = r4 + r1;
         r4 = M[r5 +  $celt.dec.MODE_MDCT_SIZE_FIELD];
84204558:	44 00 67 d1 	r4 = M[r5 + 68];
         Words2Addr(r4);
8420455c:	02 00 66 91 	r4 = r4 ASHIFT 2;
         I5 = I5 + r4;
84204560:	00 00 56 5b 	I5 = I5 + r4;
         // I5 = start of band
         // r0 = number of pulses
         // r1 = start bin no (AU)
         // r3 = band width
         // r2 = nr of Blocks
         r4 = r0 - Null;
84204564:	0f 00 62 20 	r4 = r0 - Null;
         if LE jump zeroside;
84204568:	07 00 d0 dd 	if LE jump $M.celt.unquant_bands_stereo.zeroside;
            //calc spread
            M0 = r2;
8420456c:	4f 00 80 50 	M0 = Null + r2;
            Null = M[r5 + $celt.dec.HAS_FOLD_FIELD];
84204570:	60 01 07 d1 	Null = M[r5 + 352];
            if Z M0 = M0 - M0;
84204574:	80 00 88 7c 	if EQ M0 = M0 - M0;
            //call  $celt.alg_unquant;
            r0 = M[r5 + $celt.dec.ALG_QUANT_FUNC_FIELD];
84204578:	34 00 27 d1 	r0 = M[r5 + 52];
            call r0;
8420457c:	0f 00 02 e0 	call r0;
            jump end_act2;
84204580:	05 00 f0 dd 	jump $M.celt.unquant_bands_stereo.end_act2;

84204584 <$M.celt.unquant_bands_stereo.zeroside>:
         zeroside:
         r10 = r3;
84204584:	0f 00 c5 00 	r10 = r3 + Null;
         r0 = 0;
84204588:	00 00 20 01 	r0 = Null + 0;
         do zers_loop;
8420458c:	02 00 f0 e5 	do $M.celt.unquant_bands_stereo.end_act2;
            M[I5, MK1] = r0;
84204590:	a5 00 00 03 	Null = Null + Null, M[I5,4] = r0;

84204594 <$M.celt.unquant_bands_stereo.end_act2>:
         zers_loop:

      end_act2:

      // restore I5, r5
      r3 = M[FP + RM_BITS];
84204594:	04 00 58 f1 	r3 = M[FP + 0x4];
      I5 = r3;
84204598:	5f 00 50 50 	I5 = Null + r3;
      r5 = M[FP + CODEC_STRUC];
8420459c:	18 00 78 f1 	r5 = M[FP + 0x18];

      // get start and end of band (again!)
      r1 = M[FP + S_BAND];
842045a0:	20 00 38 f1 	r1 = M[FP + 0x20];
      r10 = M[FP + N_BAND];
842045a4:	1c 00 c8 f1 	r10 = M[FP + 0x1c];
      // calc norm for next folded band
      r0 = M[r5 + $celt.dec.MODE_NB_EBANDS_FIELD];
842045a8:	48 00 27 d1 	r0 = M[r5 + 72];
      r2 = M[FP + NB_EBAND_RM];  // M3
842045ac:	14 00 48 f1 	r2 = M[FP + 0x14];
      Words2Addr(r0);
842045b0:	02 00 22 91 	r0 = r0 ASHIFT 2;
      r0 = r0 - r2;
842045b4:	00 00 24 23 	r0 = r0 - r2;
      r2 = M[r5 + $celt.dec.MODE_EBNADS_DIF_SQRT_ADDR_FIELD];
842045b8:	74 00 47 d1 	r2 = M[r5 + 116];
      r4 = M[r2 + 0]; //shift
842045bc:	00 00 64 d1 	r4 = M[r2 + 0];
      r2 = r2 + ADDR_PER_WORD;
842045c0:	bf 00 44 e4 	r2 = r2 + 4;
      r6 = M[r2 + r0]; //gain
842045c4:	2f 00 84 d0 	r6 = M[r2 + r0];
      r10 = r10 - 1;
842045c8:	3f 00 cc e4 	r10 = r10 - 1;
      r0 = M[r5 + $celt.dec.NORM_FIELD];
842045cc:	10 01 27 d1 	r0 = M[r5 + 272];
      Words2Addr(r1);
842045d0:	02 00 33 91 	r1 = r1 ASHIFT 2;
      I3  = r1 + r0;
842045d4:	2f 00 33 50 	I3 = r1 + r0;
      r0 = M[r5 + $celt.dec.NORM_FREQ_FIELD];
842045d8:	cc 00 27 d1 	r0 = M[r5 + 204];
      I4  = r0 + r1;
842045dc:	3f 00 42 50 	I4 = r0 + r1;
      r0 = M[I4, MK1];
842045e0:	21 00 00 03 	Null = Null + Null, r0 = M[I4,4];
      rMAC = r0 * r6; //6 bit less than c
842045e4:	8f 00 12 cc 	rMAC = r0 * r6 (SS);
      do norm_loop;
842045e8:	03 00 f0 e5 	do $M.celt.unquant_bands_stereo.norm_loop;
         rMAC = rMAC ASHIFT r4 (56bit), r0 = M[I4, MK1];
842045ec:	21 00 16 93 	rMAC = rMAC ASHIFT r4 (56bit), r0 = M[I4,4];
         rMAC = r0 * r6, M[I3, MK1] = rMAC;
842045f0:	00 9d 28 cf 	rMAC = r0 * r6 (SS), M[I3,4] = rMAC;

842045f4 <$M.celt.unquant_bands_stereo.norm_loop>:
      norm_loop:
      rMAC = rMAC ASHIFT r4 (56bit);
842045f4:	00 00 16 93 	rMAC = rMAC ASHIFT r4 (56bit);
      M[I3, MK1] = rMAC;
842045f8:	00 9d 00 03 	Null = Null + Null, M[I3,4] = rMAC;

      r1 = M[FP + S_BAND];
842045fc:	20 00 38 f1 	r1 = M[FP + 0x20];
      r10 = M[FP + N_BAND];
84204600:	1c 00 c8 f1 	r10 = M[FP + 0x1c];
      r10 = r10 - 1;
84204604:	3f 00 cc e4 	r10 = r10 - 1;
      r0 = M[r5 + $celt.dec.NORM_FREQ_FIELD];
84204608:	cc 00 27 d1 	r0 = M[r5 + 204];
      Words2Addr(r1);
8420460c:	02 00 33 91 	r1 = r1 ASHIFT 2;
      I3  = r1 + r0;
84204610:	2f 00 33 50 	I3 = r1 + r0;
      r4 = M[r5 +  $celt.dec.MODE_MDCT_SIZE_FIELD];
84204614:	44 00 67 d1 	r4 = M[r5 + 68];
      Words2Addr(r4);
84204618:	02 00 66 91 	r4 = r4 ASHIFT 2;
      I4 = I3 + r4;
8420461c:	6f 00 43 58 	I4 = I3 + r4;
      I6 = I3;
84204620:	0f 00 63 58 	I6 = I3 + Null;
      I7 = I4;
84204624:	0f 00 74 58 	I7 = I4 + Null;
      r0 = M[FP + IMID];
84204628:	28 00 28 f1 	r0 = M[FP + 0x28];
      r1 = M[FP + ISIDE];
8420462c:	2c 00 38 f1 	r1 = M[FP + 0x2c];
      r0 = r0 ASHIFT (DAWTH-16);
84204630:	10 00 22 91 	r0 = r0 ASHIFT 16;
      r1 = r1 ASHIFT (DAWTH-16);
84204634:	10 00 33 91 	r1 = r1 ASHIFT 16;
      r0 = r0 * 0.707106781186548 (frac);
84204638:	82 5a 00 fd 	r0 = r0 * 0.707106781192123889923095703125 (frac);
8420463c:	9a 79 22 95 
      r1 = r1 * 0.707106781186548 (frac);
84204640:	82 5a 00 fd 	r1 = r1 * 0.707106781192123889923095703125 (frac);
84204644:	9a 79 33 95 
      r2 = M[I3, MK1], r3 = M[I4, MK1];
84204648:	51 4d 00 03 	Null = Null + Null, r2 = M[I3,4], r3 = M[I4,4];
      rMAC = r2 * r0;
8420464c:	2f 00 14 cc 	rMAC = r2 * r0 (SS);
      do mid_side_loop;
84204650:	05 00 f0 e5 	do $M.celt.unquant_bands_stereo.mid_side_loop;
         rMAC = rMAC - r3 * r1;
84204654:	3f 00 15 bc 	rMAC = rMAC - r3 * r1 (SS);
         rMAC = r3 * r1, M[I6, MK1] = rMAC;
84204658:	99 00 53 cf 	rMAC = r3 * r1 (SS), M[I6,4] = rMAC;
         rMAC = rMAC + r2 * r0, r2 = M[I3, MK1], r3 = M[I4, MK1];
8420465c:	51 4d 42 af 	rMAC = rMAC + r2 * r0 (SS), r2 = M[I3,4], r3 = M[I4,4];
         rMAC = r2 * r0, M[I7, MK1] = rMAC;
84204660:	9d 00 42 cf 	rMAC = r2 * r0 (SS), M[I7,4] = rMAC;

84204664 <$M.celt.unquant_bands_stereo.mid_side_loop>:
      mid_side_loop:
      rMAC = rMAC - r3 * r1;
84204664:	3f 00 15 bc 	rMAC = rMAC - r3 * r1 (SS);
      rMAC = r3 * r1, M[I6, MK1] = rMAC;
84204668:	99 00 53 cf 	rMAC = r3 * r1 (SS), M[I6,4] = rMAC;
      rMAC = rMAC + r2 * r0;
8420466c:	2f 00 14 ac 	rMAC = rMAC + r2 * r0 (SS);
      M[I7, MK1] = rMAC;
84204670:	9d 00 00 03 	Null = Null + Null, M[I7,4] = rMAC;

      //  I5 = buffer address
      //  M3 = width of the current band
      //  M0 = strides (1)
      //  r7 = value (1.0)
      r3= M[FP + N_BAND];
84204674:	1c 00 58 f1 	r3 = M[FP + 0x1c];
      M3 = r3;
84204678:	5f 00 b0 50 	M3 = Null + r3;
      r1 = M[FP + S_BAND];
8420467c:	20 00 38 f1 	r1 = M[FP + 0x20];
      r0 = M[r5 + $celt.dec.NORM_FREQ_FIELD];
84204680:	cc 00 27 d1 	r0 = M[r5 + 204];
      Words2Addr(r1);
84204684:	02 00 33 91 	r1 = r1 ASHIFT 2;
      I5  = r1 + r0;
84204688:	2f 00 53 50 	I5 = r1 + r0;
      M0 = 1;
8420468c:	01 00 80 51 	M0 = Null + 1;
      r7 = 1.0;
84204690:	ff 7f 00 fd 	r7 = Null + 2147483647;
84204694:	ff ff 90 01 
      call $celt.renormalise_vector;
84204698:	15 01 f0 e1 	call $celt.renormalise_vector;

      //  I5 = buffer address
      //  M3 = width of the current band
      //  M0 = strides (1)
      //  r7 = value (1.0)
      r3= M[FP + N_BAND];
8420469c:	1c 00 58 f1 	r3 = M[FP + 0x1c];
      M3 = r3;
842046a0:	5f 00 b0 50 	M3 = Null + r3;
      r1 = M[FP + S_BAND];
842046a4:	20 00 38 f1 	r1 = M[FP + 0x20];
      r0 = M[r5 + $celt.dec.NORM_FREQ_FIELD];
842046a8:	cc 00 27 d1 	r0 = M[r5 + 204];
      Words2Addr(r1);
842046ac:	02 00 33 91 	r1 = r1 ASHIFT 2;
      I5  = r1 + r0;
842046b0:	2f 00 53 50 	I5 = r1 + r0;
      r4 = M[r5 +  $celt.dec.MODE_MDCT_SIZE_FIELD];
842046b4:	44 00 67 d1 	r4 = M[r5 + 68];
      Words2Addr(r4);
842046b8:	02 00 66 91 	r4 = r4 ASHIFT 2;
      I5 = I5 + r4;
842046bc:	00 00 56 5b 	I5 = I5 + r4;
      M0 = 1;
842046c0:	01 00 80 51 	M0 = Null + 1;
      r7 = 1.0;
842046c4:	ff 7f 00 fd 	r7 = Null + 2147483647;
842046c8:	ff ff 90 01 
      call $celt.renormalise_vector;
842046cc:	08 01 f0 e1 	call $celt.renormalise_vector;

      // pop I6, I7, I2, M3
      r3 = M[FP + TOTOAL_BITS];
842046d0:	08 00 58 f1 	r3 = M[FP + 0x8];
      I6 = r3;
842046d4:	5f 00 60 50 	I6 = Null + r3;
      r3 = M[FP + NB_EBAND];
842046d8:	0c 00 58 f1 	r3 = M[FP + 0xc];
      I7 = r3;
842046dc:	5f 00 70 50 	I7 = Null + r3;
      r3 = M[FP + ADDR_EBAND];
842046e0:	10 00 58 f1 	r3 = M[FP + 0x10];
      I2 = r3;
842046e4:	5f 00 20 50 	I2 = Null + r3;
      r3 = M[FP + NB_EBAND_RM];
842046e8:	14 00 58 f1 	r3 = M[FP + 0x14];
      M3 = r3 - ADDR_PER_WORD;
842046ec:	04 00 b5 71 	M3 = r3 - 4;

   if NZ jump quant_bands_main_loop;
842046f0:	1f fe 10 dd 	if NE jump $M.celt.unquant_bands_stereo.quant_bands_main_loop;

   // restore the stack pointer
   SP = SP - STACK_USED;
842046f4:	a4 ff 03 f1 	SP = SP + -92;
   popm<FP>;
842046f8:	00 40 06 f1 	popm <FP>;


   // pop rLink from stack
   jump $pop_rLink_and_rts;
842046fc:	03 00 00 fd 	jump (m) 0x3b020;
84204700:	21 b0 f0 dd 

84204704 <$celt.bits2pulses>:

#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.BITS2PULSES.PATCH_ID_0,r4)     // celt_patchers
#endif
   
   r4 = M[r5 + $celt.dec.MODE_BITS_VECTORS_ADDR_FIELD];
84204704:	70 00 67 d1 	r4 = M[r5 + 112];
   r0 = M[r4 + r2]; // AU units
84204708:	4f 00 26 d0 	r0 = M[r4 + r2];
   r4 = r4 + r0;
8420470c:	00 00 62 03 	r4 = r4 + r0;
   r10 = $celt.MAX_PSEUDOLOG;
84204710:	06 00 c0 01 	r10 = Null + 6;
   r6 = 0; //lo
84204714:	00 00 80 01 	r6 = Null + 0;
   r7 = $celt.MAX_PSEUDO - 1;
84204718:	27 00 90 01 	r7 = Null + 39;
   do find_lo_hi;
8420471c:	0a 00 f0 e5 	do $M.celt.bits2pulses.find_lo_hi;
      r0 = r6 + r7;
84204720:	9f 00 28 00 	r0 = r6 + r7;
      r0 = r0 LSHIFT -1;
84204724:	ff 00 22 8d 	r0 = r0 LSHIFT -1;
      Words2Addr(r0);
84204728:	02 00 22 91 	r0 = r0 ASHIFT 2;
      r2 = M[r4 + r0];
8420472c:	2f 00 46 d0 	r2 = M[r4 + r0];
      Addr2Words(r0);
84204730:	fe 00 22 91 	r0 = r0 ASHIFT -2;
      Null = r2 - r1;
84204734:	3f 00 04 20 	Null = r2 - r1;
      if POS r7 = r0;
84204738:	05 00 92 00 	if POS r7 = r0 + Null;
      Null = r2 - r1;
8420473c:	3f 00 04 20 	Null = r2 - r1;
      if NEG r6 = r0;
84204740:	04 00 82 00 	if NEG r6 = r0 + Null;

84204744 <$M.celt.bits2pulses.find_lo_hi>:
   find_lo_hi:

   Words2Addr(r6);
84204744:	02 00 88 91 	r6 = r6 ASHIFT 2;
   Words2Addr(r7);
84204748:	02 00 99 91 	r7 = r7 ASHIFT 2;
   r2 = M[r4+r6];
8420474c:	8f 00 46 d0 	r2 = M[r4 + r6];
   r0 = M[r4+r7];
84204750:	9f 00 26 d0 	r0 = M[r4 + r7];
   Addr2Words(r6);
84204754:	fe 00 88 91 	r6 = r6 ASHIFT -2;
   Addr2Words(r7);
84204758:	fe 00 99 91 	r7 = r7 ASHIFT -2;
   r2 = r2+r0;
8420475c:	00 00 42 03 	r2 = r2 + r0;
   r2 = r2 - r1;
84204760:	00 00 43 23 	r2 = r2 - r1;
   r0 = r6;
84204764:	0f 00 28 00 	r0 = r6 + Null;
   r2 = r2 - r1;
84204768:	00 00 43 23 	r2 = r2 - r1;
   if NEG r0 = r7;
8420476c:	04 00 29 00 	if NEG r0 = r7 + Null;
   rts;
84204770:	0f 00 0d dc 	rts;

84204774 <$celt.unquant_energy_finalise>:
#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.UNQUANT_ENERGY_FINALISE.PATCH_ID_0,r4)     // celt_patchers
#endif
   
   // push rLink onto stack
   push rlink;
84204774:	00 00 d0 f3 	push rLink;

   // work out bits left
   r4 = 0;
84204778:	00 00 60 01 	r4 = Null + 0;
   call $celt.ec_dec_tell;
8420477c:	7c f6 f0 e1 	call $celt.ec_dec_tell;
   r1 = M[r5 + $celt.dec.CELT_CODEC_FRAME_SIZE_FIELD];
84204780:	04 00 37 d1 	r1 = M[r5 + 4];
   r1 = r1 * 8(int);
84204784:	08 00 33 99 	r1 = r1 * 8 (int);
   M2 = r1 - r0;
84204788:	2f 00 a3 70 	M2 = r1 - r0;

   r0 = M[r5 + $celt.dec.CELT_CHANNELS_FIELD];
8420478c:	08 00 27 d1 	r0 = M[r5 + 8];
   I6 = r0;
84204790:	2f 00 60 50 	I6 = Null + r0;
   M3 = 1;
84204794:	01 00 b0 51 	M3 = Null + 1;

84204798 <$M.celt.unquant_energy_finalise.prio_loop>:
   prio_loop:
      r10 = M[r5 + $celt.dec.MODE_NB_EBANDS_FIELD];
84204798:	48 00 c7 d1 	r10 = M[r5 + 72];
      r0 = M[r5 + $celt.dec.FINE_QUANT_FIELD];
8420479c:	08 01 27 d1 	r0 = M[r5 + 264];
      I2 = r0;
842047a0:	2f 00 20 50 	I2 = Null + r0;
      r0 = M[r5 + $celt.dec.OLD_EBAND_LEFT_FIELD];
842047a4:	8c 00 27 d1 	r0 = M[r5 + 140];
      I3 = r0;
842047a8:	2f 00 30 50 	I3 = Null + r0;
      I4 = r0 + ($celt.MAX_BANDS*ADDR_PER_WORD);
842047ac:	64 00 42 51 	I4 = r0 + 100;
      r0 = M[r5 + $celt.dec.FINE_PRIORITY_FIELD];
842047b0:	0c 01 27 d1 	r0 = M[r5 + 268];
      I5 = r0;
842047b4:	2f 00 50 50 	I5 = Null + r0;
      do finalise_loop;
842047b8:	1f 00 f0 e5 	do $M.celt.unquant_energy_finalise.end_finalise_loop;
         r0 = M[r5 + $celt.dec.CELT_CHANNELS_FIELD];
842047bc:	08 00 27 d1 	r0 = M[r5 + 8];
         Null = M2 - r0;
842047c0:	2f 00 0a 68 	Null = M2 - r0;
         if LE jump end_finalise_loop;
842047c4:	1c 00 d0 dd 	if LE jump $M.celt.unquant_energy_finalise.end_finalise_loop;
         r0 = M[I2, 0], r1 = M[I5, 0];
842047c8:	34 28 00 03 	Null = Null + Null, r0 = M[I2,0], r1 = M[I5,0];
         Null = r0 - 7;
842047cc:	07 00 02 21 	Null = r0 - 7;
         if POS jump next_fin;
842047d0:	16 00 50 dd 	if POS jump $M.celt.unquant_energy_finalise.next_fin;
         Null = r1 - M3;
842047d4:	bf 00 03 64 	Null = r1 - M3;
         if Z jump next_fin;
842047d8:	14 00 00 dd 	if EQ jump $M.celt.unquant_energy_finalise.next_fin;
            r2 = 1;
842047dc:	2f 00 40 e4 	r2 = Null + 1;
            M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FTB] = r2;
842047e0:	e4 01 47 d5 	M[r5 + 484] = r2;
            call $celt.ec_dec_bits;
842047e4:	ce f5 f0 e1 	call $celt.ec_dec_bits;
            //calc offset
            r0 = r0 + r0, r2 = M[I2, 0];
842047e8:	00 48 22 03 	r0 = r0 + r0, r2 = M[I2,0];
            r0 = r0 - 1;
842047ec:	3f 00 22 e4 	r0 = r0 - 1;
            r2 = (DAWTH-10) - r2;
842047f0:	16 00 44 65 	r2 = 22 - r2;
            r0 = r0 ASHIFT r2, r1 = M[I3, 0];
842047f4:	00 3c 24 93 	r0 = r0 ASHIFT r2, r1 = M[I3,0];
            r0 = r0 + r1;
842047f8:	00 00 23 03 	r0 = r0 + r1;
            M2 = M2 -1;
842047fc:	01 00 aa 79 	M2 = M2 - 1;
            Null = I6, M[I3, 0] = r0;
84204800:	00 ac 06 47 	Null = Null + I6, M[I3,0] = r0;
            if Z jump next_fin;
84204804:	09 00 00 dd 	if EQ jump $M.celt.unquant_energy_finalise.next_fin;
            call $celt.ec_dec_bits;
84204808:	c5 f5 f0 e1 	call $celt.ec_dec_bits;
            r0 = r0 + r0, r2 = M[I2, 0];
8420480c:	00 48 22 03 	r0 = r0 + r0, r2 = M[I2,0];
            r0 = r0 - 1;
84204810:	3f 00 22 e4 	r0 = r0 - 1;
            r2 = (DAWTH-10) - r2;
84204814:	16 00 44 65 	r2 = 22 - r2;
            r0 = r0 ASHIFT r2, r1 = M[I4, 0];
84204818:	30 00 24 93 	r0 = r0 ASHIFT r2, r1 = M[I4,0];
            r0 = r0 + r1;
8420481c:	00 00 23 03 	r0 = r0 + r1;
            M[I4, 0] = r0;
84204820:	a0 00 00 03 	Null = Null + Null, M[I4,0] = r0;
            M2 = M2 -1;
84204824:	01 00 aa 79 	M2 = M2 - 1;

84204828 <$M.celt.unquant_energy_finalise.next_fin>:
            next_fin:
            r0 = M[I2, MK1], r1 = M[I5, MK1];
84204828:	35 29 00 03 	Null = Null + Null, r0 = M[I2,4], r1 = M[I5,4];
            r0 = M[I3, MK1];
8420482c:	00 2d 00 03 	Null = Null + Null, r0 = M[I3,4];
            r1 = M[I4, MK1];
84204830:	31 00 00 03 	Null = Null + Null, r1 = M[I4,4];

84204834 <$M.celt.unquant_energy_finalise.end_finalise_loop>:
        finalise_loop:
        end_finalise_loop:
   M3 = M3 - 1;
84204834:	01 00 bb 79 	M3 = M3 - 1;
   if Z jump prio_loop;
84204838:	d8 ff 00 dd 	if EQ jump $M.celt.unquant_energy_finalise.prio_loop;

   
   // calculate non-logarithmic bans Energies
   r0 = M[r5 + $celt.dec.OLD_EBAND_LEFT_FIELD];
8420483c:	8c 00 27 d1 	r0 = M[r5 + 140];
   I3 = r0;
84204840:	2f 00 30 50 	I3 = Null + r0;
   r0 = M[r5 + $celt.dec.BANDE_FIELD];
84204844:	d0 00 27 d1 	r0 = M[r5 + 208];
   I2 = r0;
84204848:	2f 00 20 50 	I2 = Null + r0;
   I4 = I2 + ($celt.MAX_BANDS*ADDR_PER_WORD);
8420484c:	64 00 42 59 	I4 = I2 + 100;
   r0 = M[r5 + $celt.dec.CELT_CHANNELS_FIELD];
84204850:	08 00 27 d1 	r0 = M[r5 + 8];
   M3 = r0 + 1;
84204854:	01 00 b2 51 	M3 = r0 + 1;
   r8 = M[r5 + $celt.dec.CELT_MODE_OBJECT_FIELD];
84204858:	00 00 a7 d1 	r8 = M[r5 + 0];
   I7 = r5 + $celt.dec.SCRATCHVAR_MAX_SBAND;
8420485c:	f0 01 77 51 	I7 = r5 + 496;

84204860 <$M.celt.unquant_energy_finalise.calc_ebands>:
   calc_ebands:
   I6 = -100;
84204860:	9c ff 60 51 	I6 = Null + -100;
   r10 = M[r5 + $celt.dec.MODE_NB_EBANDS_FIELD];
84204864:	48 00 c7 d1 	r10 = M[r5 + 72];
   do comp_ebands_loop_ch;
84204868:	14 00 f0 e5 	do $M.celt.unquant_energy_finalise.comp_ebands_loop_ch;
      r0 = M[I3, 0];
8420486c:	00 2c 00 03 	Null = Null + Null, r0 = M[I3,0];
      r4 = 0;
84204870:	00 00 60 01 	r4 = Null + 0;
      r1 = r0 ASHIFT -(DAWTH-8);
84204874:	e8 00 32 91 	r1 = r0 ASHIFT -24;
      if NEG jump calc_log;
84204878:	04 00 40 dd 	if NEG jump $M.celt.unquant_energy_finalise.calc_log;
         r4 = r1 + 1;
8420487c:	2f 00 63 e4 	r4 = r1 + 1;
         r1 = r4 ASHIFT (DAWTH-8);
84204880:	18 00 36 91 	r1 = r4 ASHIFT 24;
         r0 = r0 - r1;
84204884:	00 00 23 23 	r0 = r0 - r1;

84204888 <$M.celt.unquant_energy_finalise.calc_log>:
      calc_log:
      call $math.pow2_table;
84204888:	07 00 00 fd 	call 0x74514;
8420488c:	14 45 f0 e1 
      r4 = r4 - 12;
84204890:	0c 00 66 21 	r4 = r4 - 12;
      // store E in the form of a gain and a shift value
      M[I4, MK1] = r4;
84204894:	e1 00 00 03 	Null = Null + Null, M[I4,4] = r4;
      M[I2, MK1] = r0;
84204898:	00 a9 00 03 	Null = Null + Null, M[I2,4] = r0;
      Null = r4 - I6;
8420489c:	6f 00 06 64 	Null = r4 - I6;
      if POS I6 = r4;
842048a0:	65 00 60 50 	if POS I6 = Null + r4;
      // minimum energy clipping
      r0 = M[I3, 0];
842048a4:	00 2c 00 03 	Null = Null + Null, r0 = M[I3,0];
      r1 = r0 + 0.0546875;
842048a8:	00 07 00 fd 	r1 = r0 + 117440512;
842048ac:	00 00 32 01 
      if NEG r0 = r0 - r1;
842048b0:	34 00 22 20 	if NEG r0 = r0 - r1;
      M[I3, MK1] = r0;
842048b4:	00 ad 00 03 	Null = Null + Null, M[I3,4] = r0;

842048b8 <$M.celt.unquant_energy_finalise.comp_ebands_loop_ch>:
   comp_ebands_loop_ch:
   r0 = I6;
842048b8:	6f 00 20 44 	r0 = Null + I6;

   M[I7, MK1] = r0;
842048bc:	ad 00 00 03 	Null = Null + Null, M[I7,4] = r0;

   r0 = M[r5 + $celt.dec.OLD_EBAND_LEFT_FIELD];
842048c0:	8c 00 27 d1 	r0 = M[r5 + 140];
   I3 = r0 + ($celt.MAX_BANDS*ADDR_PER_WORD);
842048c4:	64 00 32 51 	I3 = r0 + 100;
   r0 = M[r5 + $celt.dec.BANDE_FIELD];
842048c8:	d0 00 27 d1 	r0 = M[r5 + 208];
   I2 = r0 + (2*$celt.MAX_BANDS*ADDR_PER_WORD);
842048cc:	c8 00 22 51 	I2 = r0 + 200;
   I4 = I2 + ($celt.MAX_BANDS*ADDR_PER_WORD);
842048d0:	64 00 42 59 	I4 = I2 + 100;
   M3 = M3 - 1;
842048d4:	01 00 bb 79 	M3 = M3 - 1;
   if NZ jump calc_ebands;
842048d8:	e2 ff 10 dd 	if NE jump $M.celt.unquant_energy_finalise.calc_ebands;

   // pop rLink from stack
   jump $pop_rLink_and_rts;
842048dc:	03 00 00 fd 	jump (m) 0x3b020;
842048e0:	21 b0 f0 dd 

842048e4 <$celt.denormalise_bands>:
#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.DENORMALISE_BANDS.PATCH_ID_0,r6)     // celt_patchers
#endif
   
   // push rLink onto stack
   push rlink;
842048e4:	00 00 d0 f3 	push rLink;

   r0 = M[r5 + $celt.dec.CELT_CHANNELS_FIELD];
842048e8:	08 00 27 d1 	r0 = M[r5 + 8];
   M3 = r0 + 1;
842048ec:	01 00 b2 51 	M3 = r0 + 1;
   r0 = M[r5 + $celt.dec.MODE_NB_EBANDS_FIELD];
842048f0:	48 00 27 d1 	r0 = M[r5 + 72];
   M0 = r0;
842048f4:	2f 00 80 50 	M0 = Null + r0;
   r0 = M[r5 + $celt.dec.MODE_EBANDS_ADDR_FIELD];
842048f8:	60 00 27 d1 	r0 = M[r5 + 96];
   I2 = r0;
842048fc:	2f 00 20 50 	I2 = Null + r0;
   r0 = M[r5 + $celt.dec.BANDE_FIELD];
84204900:	d0 00 27 d1 	r0 = M[r5 + 208];
   I4 = r0;
84204904:	2f 00 40 50 	I4 = Null + r0;
   I6 = I4 + ($celt.MAX_BANDS*ADDR_PER_WORD);
84204908:	64 00 64 59 	I6 = I4 + 100;
   r0 = M[r5 + $celt.dec.NORM_FREQ_FIELD];
8420490c:	cc 00 27 d1 	r0 = M[r5 + 204];
   I3 = r0;
84204910:	2f 00 30 50 	I3 = Null + r0;
   r0 = M[r5 + $celt.dec.FREQ_FIELD];
84204914:	14 01 27 d1 	r0 = M[r5 + 276];
   I5 = r0;
84204918:	2f 00 50 50 	I5 = Null + r0;
   M1 = MK1;
8420491c:	04 00 90 51 	M1 = Null + 4;
   r6 = 1;
84204920:	2f 00 80 e4 	r6 = Null + 1;
#ifdef K32
   r7 = 0x40000000;
84204924:	00 40 00 fd 	r7 = Null + 1073741824;
84204928:	00 00 90 01 
#else
   r7 = 0x400000;
#endif   
   I7 = r5 + $celt.dec.SCRATCHVAR_MAX_SBAND;
8420492c:	f0 01 77 51 	I7 = r5 + 496;

84204930 <$M.celt.denormalise_bands.chan_denorm_loop>:
   chan_denorm_loop:
      M2 = M0;
84204930:	0f 00 a8 58 	M2 = M0 + Null;

84204934 <$M.celt.denormalise_bands.band_denorm_loop>:
      band_denorm_loop:
         // process band
         r2 = M[I6, MK1];
84204934:	49 00 00 03 	Null = Null + Null, r2 = M[I6,4];
         r3 = M[I7, 0];
84204938:	5c 00 00 03 	Null = Null + Null, r3 = M[I7,0];
         r2 = r2 - 1;
8420493c:	3f 00 44 e4 	r2 = r2 - 1;
         r2 = r2 - r3;
84204940:	00 00 45 23 	r2 = r2 - r3;
         r8 = (2-DAWTH) - r2;
84204944:	e2 ff a4 65 	r8 = -30 - r2;
         r8 = r7 ASHIFT r8;
84204948:	af 00 a9 90 	r8 = r7 ASHIFT r8;
         r0 = M[I2, MK1];
8420494c:	00 29 00 03 	Null = Null + Null, r0 = M[I2,4];
         r1 = M[I2, 0];
84204950:	00 38 00 03 	Null = Null + Null, r1 = M[I2,0];
         r10 = r1 - r0, r0 = M[I3, M1];
84204954:	2f 2d c3 20 	r10 = r1 - r0, r0 = M[I3,M1];
         r10 = r10 - r6, r4 = M[I4, M1];
84204958:	61 00 c8 22 	r10 = r10 - r6, r4 = M[I4,M1];
         rMAC = r4 * r0;
8420495c:	2f 00 16 cc 	rMAC = r4 * r0 (SS);
         rMAC = rMAC + r7*r8;
84204960:	af 00 19 ac 	rMAC = rMAC + r7 * r8 (SS);
         do denorm_band_loop;
84204964:	04 00 f0 e5 	do $M.celt.denormalise_bands.denorm_band_loop;
            rMAC = rMAC ASHIFT r2 (56bit), r0 = M[I3, M1];
84204968:	00 2d 14 92 	rMAC = rMAC ASHIFT r2 (56bit), r0 = M[I3,M1];
            rMAC = r4 * r0,  M[I5, M1] = rMAC;
8420496c:	95 00 62 ce 	rMAC = r4 * r0 (SS), M[I5,M1] = rMAC;
            rMAC = rMAC + r7*r8;
84204970:	af 00 19 ac 	rMAC = rMAC + r7 * r8 (SS);

84204974 <$M.celt.denormalise_bands.denorm_band_loop>:
         denorm_band_loop:
         rMAC = rMAC ASHIFT r2 (56bit);
84204974:	00 00 14 93 	rMAC = rMAC ASHIFT r2 (56bit);
         M[I5, MK1] = rMAC;
84204978:	95 00 00 03 	Null = Null + Null, M[I5,4] = rMAC;
      M2 = M2 - 1;
8420497c:	01 00 aa 79 	M2 = M2 - 1;
      if NZ jump band_denorm_loop;
84204980:	ed ff 10 dd 	if NE jump $M.celt.denormalise_bands.band_denorm_loop;
      // zero the rest
      r0 = M[I2, MK1];
84204984:	00 29 00 03 	Null = Null + Null, r0 = M[I2,4];
      r1 = M[I2, 0];
84204988:	00 38 00 03 	Null = Null + Null, r1 = M[I2,0];
      r10 = r1 - r0;
8420498c:	2f 00 c3 20 	r10 = r1 - r0;
      r0 = 0;
84204990:	00 00 20 01 	r0 = Null + 0;
      do zero_last_band_loop;
84204994:	02 00 f0 e5 	do $M.celt.denormalise_bands.zero_last_band_loop;
         M[I5, MK1] = r0;
84204998:	a5 00 00 03 	Null = Null + Null, M[I5,4] = r0;

8420499c <$M.celt.denormalise_bands.zero_last_band_loop>:
      zero_last_band_loop:
      // set regs for next channel if necessary
      r0 = M[r5 + $celt.dec.BANDE_FIELD];
8420499c:	d0 00 27 d1 	r0 = M[r5 + 208];
      I4 = r0 + (2*$celt.MAX_BANDS*ADDR_PER_WORD);
842049a0:	c8 00 42 51 	I4 = r0 + 200;
      I6 = I4 + ($celt.MAX_BANDS*ADDR_PER_WORD);
842049a4:	64 00 64 59 	I6 = I4 + 100;
      r0 = M[r5 + $celt.dec.NORM_FREQ_FIELD];
842049a8:	cc 00 27 d1 	r0 = M[r5 + 204];
      r1 = M[r5 + $celt.dec.MODE_AUDIO_FRAME_SIZE_FIELD];
842049ac:	44 00 37 d1 	r1 = M[r5 + 68];
      Words2Addr(r1);
842049b0:	02 00 33 91 	r1 = r1 ASHIFT 2;
      I3 = r0 + r1;
842049b4:	3f 00 32 50 	I3 = r0 + r1;
      r0 = M[r5 + $celt.dec.FREQ2_FIELD];
842049b8:	18 01 27 d1 	r0 = M[r5 + 280];
      I5 = r0;
842049bc:	2f 00 50 50 	I5 = Null + r0;
      r0 = M[r5 + $celt.dec.MODE_EBANDS_ADDR_FIELD];
842049c0:	60 00 27 d1 	r0 = M[r5 + 96];
      I2 = r0;
842049c4:	2f 00 20 50 	I2 = Null + r0;
      r3 = M[I7, MK1];
842049c8:	5d 00 00 03 	Null = Null + Null, r3 = M[I7,4];
   M3 = M3 - 1;
842049cc:	01 00 bb 79 	M3 = M3 - 1;
   if NZ jump chan_denorm_loop;
842049d0:	d8 ff 10 dd 	if NE jump $M.celt.denormalise_bands.chan_denorm_loop;

   // pop rLink from stack
   jump $pop_rLink_and_rts;
842049d4:	03 00 00 fd 	jump (m) 0x3b020;
842049d8:	21 b0 f0 dd 

842049dc <$celt.renormalise_bands>:
#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.RENORMALISE_BANDS.PATCH_ID_0,r1)     // celt_patchers
#endif
   
   // push rLink onto stack
   push rlink;
842049dc:	00 00 d0 f3 	push rLink;

   r0 = M[r5 + $celt.dec.MODE_NB_EBANDS_FIELD];
842049e0:	48 00 27 d1 	r0 = M[r5 + 72];
   I7 = r0;
842049e4:	2f 00 70 50 	I7 = Null + r0;
   r0 = M[r5 + $celt.dec.MODE_EBANDS_ADDR_FIELD];
842049e8:	60 00 27 d1 	r0 = M[r5 + 96];
   I3 = r0;
842049ec:	2f 00 30 50 	I3 = Null + r0;
   r0 = M[r5 + $celt.dec.CELT_CHANNELS_FIELD];
842049f0:	08 00 27 d1 	r0 = M[r5 + 8];
   I6 = r0 + 1;
842049f4:	01 00 62 51 	I6 = r0 + 1;
   r7 = 1.0;
842049f8:	ff 7f 00 fd 	r7 = Null + 2147483647;
842049fc:	ff ff 90 01 
   r0 = M[r5 + $celt.dec.NORM_FREQ_FIELD];
84204a00:	cc 00 27 d1 	r0 = M[r5 + 204];
   I5 = r0;
84204a04:	2f 00 50 50 	I5 = Null + r0;

84204a08 <$M.celt.renormalise_bands.chan_renorm_loop>:
   chan_renorm_loop:
      M2 = I7;
84204a08:	0f 00 a7 58 	M2 = I7 + Null;

84204a0c <$M.celt.renormalise_bands.band_norm_loop>:
      band_norm_loop:
         r0 = M[I3, MK1];
84204a0c:	00 2d 00 03 	Null = Null + Null, r0 = M[I3,4];
         r1 = M[I3, 0];
84204a10:	00 3c 00 03 	Null = Null + Null, r1 = M[I3,0];
         r6 = r1 - r0;
84204a14:	2f 00 83 20 	r6 = r1 - r0;
         M3 = r6;
84204a18:	8f 00 b0 50 	M3 = Null + r6;
         Words2Addr(r6);
84204a1c:	02 00 88 91 	r6 = r6 ASHIFT 2;
         M0 = 1;
84204a20:	01 00 80 51 	M0 = Null + 1;
         call $celt.renormalise_vector;
84204a24:	32 00 f0 e1 	call $celt.renormalise_vector;
         I5 = I5 + r6;
84204a28:	00 00 58 5b 	I5 = I5 + r6;
         M2 = M2 -1;
84204a2c:	01 00 aa 79 	M2 = M2 - 1;
      if NZ jump band_norm_loop;
84204a30:	f7 ff 10 dd 	if NE jump $M.celt.renormalise_bands.band_norm_loop;
      r0 = M[r5 + $celt.dec.MODE_EBANDS_ADDR_FIELD];
84204a34:	60 00 27 d1 	r0 = M[r5 + 96];
      r1 = M[r5 + $celt.dec.MODE_MDCT_SIZE_FIELD];
84204a38:	44 00 37 d1 	r1 = M[r5 + 68];
      I3 = r0;
84204a3c:	2f 00 30 50 	I3 = Null + r0;
      r0 = M[r5 + $celt.dec.NORM_FREQ_FIELD];
84204a40:	cc 00 27 d1 	r0 = M[r5 + 204];
      Words2Addr(r1);
84204a44:	02 00 33 91 	r1 = r1 ASHIFT 2;
      I5 = r0 + r1;
84204a48:	3f 00 52 50 	I5 = r0 + r1;
      I6 = I6 - 1;
84204a4c:	01 00 66 79 	I6 = I6 - 1;
   if NZ jump chan_renorm_loop;
84204a50:	ee ff 10 dd 	if NE jump $M.celt.renormalise_bands.chan_renorm_loop;

   // pop rLink from stack
   jump $pop_rLink_and_rts;
84204a54:	03 00 00 fd 	jump (m) 0x3b020;
84204a58:	21 b0 f0 dd 

84204a5c <$celt.intra_fold>:
84204a5c:	00 00 d0 f3 	push rLink;
#endif
        
   push rlink;   
   //for this app B = 1 or 2 , //TODO: add support of 3 and 4 short blocks
#ifdef CELT_USE_EXTERNAL_MEMORY
   r4 = M[r5 + $celt.dec.PTR_INV2_TABLE_FIELD];
84204a60:	20 02 67 d1 	r4 = M[r5 + 544];
   r4 = r4 - MK1;
84204a64:	df 00 66 e4 	r4 = r4 - 4;
#else
   .VAR inv2[] = 1.0, 1.0/2+(1.0e-7), 1.0/3+(1.0e-7), 1.0/4+(1.0e-7), 1.0/5+(1.0e-7), 1.0/6+(1.0e-7), 1.0/7+(1.0e-7), 1.0/8+(1.0e-7);
#endif
   r0 = r2 + 1;
84204a68:	2f 00 24 e4 	r0 = r2 + 1;
   r0 = r0 LSHIFT -1;
84204a6c:	ff 00 22 8d 	r0 = r0 LSHIFT -1;
   r0 = r0 + r1;
84204a70:	00 00 23 03 	r0 = r0 + r1;
   Words2Addr(r2);
84204a74:	02 00 44 91 	r2 = r2 ASHIFT 2;
#ifdef CELT_USE_EXTERNAL_MEMORY
   r4 = M[r2 + r4];
84204a78:	6f 00 64 d0 	r4 = M[r2 + r4];
#else
   r4 = M[r2 + (inv2-MK1)];
#endif
   Addr2Words(r2);
84204a7c:	fe 00 44 91 	r2 = r2 ASHIFT -2;
   r0 = r0 * r4 (frac);
84204a80:	00 00 26 97 	r0 = r0 * r4 (frac);
   r0 = r0 - 1;                  // nb=num_blocks=r2, sb=start_bin=r1, bw=width of band=r3
84204a84:	3f 00 22 e4 	r0 = r0 - 1;
   r0 = r0 * r2 (int);           // r0 = ( ( (nb+1)*2+sb )*inv2[nb] - 1) * nb
84204a88:	00 00 24 9b 	r0 = r0 * r2 (int);
   r4 = r1 - r0;
84204a8c:	2f 00 63 20 	r4 = r1 - r0;
   I6 = I5;
84204a90:	0f 00 65 58 	I6 = I5 + Null;
   r0 = r4 + r3;
84204a94:	5f 00 26 00 	r0 = r4 + r3;
   Words2Addr(r4);
84204a98:	02 00 66 91 	r4 = r4 ASHIFT 2;
   I2 = I3 + r4; //y
84204a9c:	6f 00 23 58 	I2 = I3 + r4;
   Null = r0 - r1;
84204aa0:	3f 00 02 20 	Null = r0 - r1;
   if GT jump set_z;
84204aa4:	07 00 c0 dd 	if GT jump $M.celt.intra_fold.set_z;
   r10 = r3 - 1;
84204aa8:	3f 00 c5 e4 	r10 = r3 - 1;
   
   // fold previous band into current band
   r0 = M[I2, MK1];
84204aac:	00 29 00 03 	Null = Null + Null, r0 = M[I2,4];
   do fold_loop;
84204ab0:	02 00 f0 e5 	do $M.celt.intra_fold.fold_loop;
      r0 = M[I2, MK1], M[I6, MK1] = r0;
84204ab4:	a9 29 00 03 	Null = Null + Null, r0 = M[I2,4], M[I6,4] = r0;

84204ab8 <$M.celt.intra_fold.fold_loop>:
   fold_loop:
   M[I6, MK1] = r0;
84204ab8:	a9 00 00 03 	Null = Null + Null, M[I6,4] = r0;
   jump end_fold;
84204abc:	05 00 f0 dd 	jump $M.celt.intra_fold.end_fold;

84204ac0 <$M.celt.intra_fold.set_z>:
   
   // zero the band
   set_z:
   r10 = r3;
84204ac0:	0f 00 c5 00 	r10 = r3 + Null;
   r0 = 0;
84204ac4:	00 00 20 01 	r0 = Null + 0;
   do z_loop;
84204ac8:	02 00 f0 e5 	do $M.celt.intra_fold.end_fold;
      M[I6, MK1] = r0;
84204acc:	a9 00 00 03 	Null = Null + Null, M[I6,4] = r0;

84204ad0 <$M.celt.intra_fold.end_fold>:
   z_loop: 
   end_fold:
   
   // folding is done, now renormalise to band energy
   M3 = r3;
84204ad0:	5f 00 b0 50 	M3 = Null + r3;
   M0 = 1;
84204ad4:	01 00 80 51 	M0 = Null + 1;
   r7 = 1.0;
84204ad8:	ff 7f 00 fd 	r7 = Null + 2147483647;
84204adc:	ff ff 90 01 
   call $celt.renormalise_vector;
84204ae0:	03 00 f0 e1 	call $celt.renormalise_vector;
   jump $pop_rLink_and_rts;
84204ae4:	03 00 00 fd 	jump (m) 0x3b020;
84204ae8:	21 b0 f0 dd 

84204aec <$celt.renormalise_vector>:

#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.RENORMALISE_VECTOR.PATCH_ID_0,r8)     // celt_patchers
#endif
   
   push rlink;
84204aec:	00 00 d0 f3 	push rLink;
   rMAC = 0;  //TODO:check if rMAC0 = 1 can be enough
84204af0:	00 00 10 01 	rMAC = Null + 0;
#ifdef K32
   r0 = M0;
84204af4:	8f 00 20 44 	r0 = Null + M0;
   Words2Addr(r0);
84204af8:	02 00 22 91 	r0 = r0 ASHIFT 2;
   M0 = r0;
84204afc:	2f 00 80 50 	M0 = Null + r0;
#endif
   r0 = 1;
84204b00:	2f 00 20 e4 	r0 = Null + 1;
   rMAC0 = r0;
84204b04:	00 05 e2 8d 	rMAC0 = r0 LSHIFT 0;
   r10 = M3 - 1;
84204b08:	01 00 cb 69 	r10 = M3 - 1;
   I2 = I5;
84204b0c:	0f 00 25 58 	I2 = I5 + Null;
   r0 = M[I2, M0];
84204b10:	00 28 00 02 	Null = Null + Null, r0 = M[I2,M0];
   do calc_e_lp;
84204b14:	02 00 f0 e5 	do $M.celt.renormalise_vector.calc_e_lp;
      rMAC = rMAC + r0 * r0, r0 = M[I2, M0];      
84204b18:	2f 28 12 ac 	rMAC = rMAC + r0 * r0 (SS), r0 = M[I2,M0];

84204b1c <$M.celt.renormalise_vector.calc_e_lp>:
   calc_e_lp:
   rMAC = rMAC + r0 * r0;
84204b1c:	2f 00 12 ac 	rMAC = rMAC + r0 * r0 (SS);
   r8 = signdet rMAC;
84204b20:	0f 00 a1 d8 	r8 = SIGNDET rMAC;
   r8 = r8 AND (-2);
84204b24:	ff ff 00 fd 	r8 = r8 AND 0xfffffffe;
84204b28:	fe ff aa 81 
   r8 = r8 - 2;
84204b2c:	cf 00 aa e4 	r8 = r8 - 2;
   r0 = rMAC ASHIFT r8;
84204b30:	af 00 21 90 	r0 = rMAC ASHIFT r8;
   $celt.sqrt()
84204b34:	01 10 01 f1 	pushm <I0, L0>;
84204b38:	00 00 c0 51 	L0 = Null + 0;
84204b3c:	00 00 a2 f3 	push B0;
84204b40:	00 00 00 f3 	push Null;
84204b44:	00 00 a6 f3 	pop B0;
84204b48:	07 00 00 fd 	call 0x74370;
84204b4c:	70 43 f0 e1 
84204b50:	00 00 a6 f3 	pop B0;
84204b54:	01 10 05 f1 	popm <I0, L0>;
   push r1;
84204b58:	00 00 30 f3 	push r1;
   r4 = 1.0;
84204b5c:	ff 7f 00 fd 	r4 = Null + 2147483647;
84204b60:	ff ff 60 01 
   Null = r1 - 0.2;
84204b64:	99 19 00 fd 	Null = r1 - 429496730;
84204b68:	9a 99 03 21 
   if NEG jump too_small;
84204b6c:	05 00 40 dd 	if NEG jump $M.celt.renormalise_vector.too_small;
      rMAC = 0.125;
84204b70:	00 10 00 fd 	rMAC = Null + 268435456;
84204b74:	00 00 10 01 
      Div = rMAC / r1;
84204b78:	00 00 13 d9 	Div = rMAC / r1;
      r4 = DivResult;
84204b7c:	01 00 60 d9 	r4 = DivResult;

84204b80 <$M.celt.renormalise_vector.too_small>:
   too_small:
   r1 = r8 + 2;
84204b80:	af 00 3a e4 	r1 = r8 + 2;
   r0 = r1 ASHIFT -1;
84204b84:	ff 00 23 91 	r0 = r1 ASHIFT -1;
   r8 = 1 - r0;
84204b88:	01 00 a2 65 	r8 = 1 - r0;
   r1 = r4 * r7 (frac);
84204b8c:	9f 00 36 94 	r1 = r4 * r7 (frac);
   r10 = M3 - 1;
84204b90:	01 00 cb 69 	r10 = M3 - 1;
   I2 = I5;
84204b94:	0f 00 25 58 	I2 = I5 + Null;
   I4 = I5, r4 = M[I2, M0];
84204b98:	0f 68 45 58 	I4 = I5 + Null, r4 = M[I2,M0];
   rMAC = r4*r1;
84204b9c:	3f 00 16 cc 	rMAC = r4 * r1 (SS);
   do re_norm_lp;
84204ba0:	03 00 f0 e5 	do $M.celt.renormalise_vector.re_norm_lp;
      rMAC = rMAC ASHIFT r0 (56bit), r4 = M[I2, M0];
84204ba4:	00 68 12 92 	rMAC = rMAC ASHIFT r0 (56bit), r4 = M[I2,M0];
      rMAC = r4*r1, M[I4, M0] = rMAC;
84204ba8:	90 00 63 ce 	rMAC = r4 * r1 (SS), M[I4,M0] = rMAC;

84204bac <$M.celt.renormalise_vector.re_norm_lp>:
   re_norm_lp:
   rMAC = rMAC ASHIFT r0 (56bit);
84204bac:	00 00 12 93 	rMAC = rMAC ASHIFT r0 (56bit);
   M[I4, M0] = rMAC;
84204bb0:	90 00 00 02 	Null = Null + Null, M[I4,M0] = rMAC;
   pop r1;
84204bb4:	00 00 34 f3 	pop r1;
   r1 = r1 ASHIFT r8;
84204bb8:	00 00 3a 93 	r1 = r1 ASHIFT r8;
   jump $pop_rLink_and_rts;
84204bbc:	03 00 00 fd 	jump (m) 0x3b020;
84204bc0:	21 b0 f0 dd 

84204bc4 <$celt.normalise_residual>:
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.NORMALISE_RESIDUAL.PATCH_ID_0,r8)     // celt_patchers
#endif
   
   .CONST TEMP                 (0 + 2)*ADDR_PER_WORD;
   .CONST STACK_FRAME_SIZE     1*ADDR_PER_WORD;
   pushm <FP(=SP), rLink>;
84204bc4:	01 20 00 f1 	pushm <FP(=SP), rLink>;
   SP = SP + STACK_FRAME_SIZE;
84204bc8:	04 00 03 f1 	SP = SP + 4;
   M[FP + TEMP] = r3;
84204bcc:	08 00 5c f1 	M[FP + 0x8] = r3;
   r8 = signdet rMAC;
84204bd0:	0f 00 a1 d8 	r8 = SIGNDET rMAC;
   r8 = r8 AND 0xFE;
84204bd4:	fe 00 aa 81 	r8 = r8 AND 0xfe;
   r8 = r8 - 2;
84204bd8:	cf 00 aa e4 	r8 = r8 - 2;
   r0 = rMAC ASHIFT r8;
84204bdc:	af 00 21 90 	r0 = rMAC ASHIFT r8;
   $celt.sqrt()
84204be0:	01 10 01 f1 	pushm <I0, L0>;
84204be4:	00 00 c0 51 	L0 = Null + 0;
84204be8:	00 00 a2 f3 	push B0;
84204bec:	00 00 00 f3 	push Null;
84204bf0:	00 00 a6 f3 	pop B0;
84204bf4:	07 00 00 fd 	call 0x74370;
84204bf8:	70 43 f0 e1 
84204bfc:	00 00 a6 f3 	pop B0;
84204c00:	01 10 05 f1 	popm <I0, L0>;
   r0 = 1.0;
84204c04:	ff 7f 00 fd 	r0 = Null + 2147483647;
84204c08:	ff ff 20 01 
   Null = r1 - 0.2;
84204c0c:	99 19 00 fd 	Null = r1 - 429496730;
84204c10:	9a 99 03 21 
   if NEG jump too_small;
84204c14:	05 00 40 dd 	if NEG jump $M.celt.normalise_residual.too_small;
      rMAC = 0.125;
84204c18:	00 10 00 fd 	rMAC = Null + 268435456;
84204c1c:	00 00 10 01 
      Div = rMAC / r1;
84204c20:	00 00 13 d9 	Div = rMAC / r1;
      r0 = DivResult;
84204c24:	01 00 20 d9 	r0 = DivResult;

84204c28 <$M.celt.normalise_residual.too_small>:
   too_small:
   r8 = r8 + 2;
84204c28:	af 00 aa e4 	r8 = r8 + 2;
   r8 = r8 ASHIFT -1;
84204c2c:	ff 00 aa 91 	r8 = r8 ASHIFT -1;
   // r8 = shift
   // r0 = gain
   r3 = M[FP + TEMP];
84204c30:	08 00 58 f1 	r3 = M[FP + 0x8];
   r10 = r3 -1;
84204c34:	3f 00 c5 e4 	r10 = r3 - 1;
   I3 = I7;
84204c38:	0f 00 37 58 	I3 = I7 + Null;
   r1 = M[I3, MK1];
84204c3c:	00 3d 00 03 	Null = Null + Null, r1 = M[I3,4];
   rMAC = r1 * r0;
84204c40:	2f 00 13 cc 	rMAC = r1 * r0 (SS);
   do normalise_residual_loop;
84204c44:	03 00 f0 e5 	do $M.celt.normalise_residual.normalise_residual_loop;
      rMAC = rMAC ASHIFT r8 (56bit),  r1 = M[I3, M0];     
84204c48:	00 3c 1a 92 	rMAC = rMAC ASHIFT r8 (56bit), r1 = M[I3,M0];
      rMAC = r1 * r0, M[I5, MK1] = rMAC;
84204c4c:	95 00 32 cf 	rMAC = r1 * r0 (SS), M[I5,4] = rMAC;

84204c50 <$M.celt.normalise_residual.normalise_residual_loop>:
   normalise_residual_loop:
   rMAC = rMAC ASHIFT r8 (56bit);
84204c50:	00 00 1a 93 	rMAC = rMAC ASHIFT r8 (56bit);
   M[I5, MK1] = rMAC;     
84204c54:	95 00 00 03 	Null = Null + Null, M[I5,4] = rMAC;
   SP = SP - STACK_FRAME_SIZE;
84204c58:	fc ff 03 f1 	SP = SP + -4;
   popm <FP,rLink>;
84204c5c:	01 20 04 f1 	popm <FP, rLink>;
   rts;
84204c60:	0f 00 0d dc 	rts;

84204c64 <$celt.exp_rotation>:
#endif
   
   //TODO: can devision, sin and cos calling be opimised?
   .CONST TEMP                 (0 + 2)*ADDR_PER_WORD;
   .CONST STACK_FRAME_SIZE     3*ADDR_PER_WORD;
   pushm <FP(=SP), rLink>;
84204c64:	01 20 00 f1 	pushm <FP(=SP), rLink>;
   SP = SP + STACK_FRAME_SIZE;
84204c68:	0c 00 03 f1 	SP = SP + 12;

   M[FP + TEMP + 0] = r3;
84204c6c:	08 00 5c f1 	M[FP + 0x8] = r3;

   r0 = r6 LSHIFT 3;
84204c70:	03 00 28 8d 	r0 = r6 LSHIFT 3;
   Null = r3 - r0;
84204c74:	2f 00 05 20 	Null = r3 - r0;
   if LE jump no_strike_update;
84204c78:	06 00 d0 dd 	if LE jump $M.celt.exp_rotation.no_strike_update;
      rMAC = 0;
84204c7c:	00 00 10 01 	rMAC = Null + 0;
      rMAC0 = r3;
84204c80:	00 05 e5 8d 	rMAC0 = r3 LSHIFT 0;
      Div = rMAC / r0;
84204c84:	00 00 12 d9 	Div = rMAC / r0;
      r0 = DivResult;
84204c88:	01 00 20 d9 	r0 = DivResult;
      r6 = r6 * r0 (int);
84204c8c:	00 00 82 9b 	r6 = r6 * r0 (int);

84204c90 <$M.celt.exp_rotation.no_strike_update>:
   no_strike_update:
   // calc gain
   rMAC = r3;           
84204c90:	0f 00 15 00 	rMAC = r3 + Null;
   r0 = r4 * 6 (int);   
84204c94:	06 00 26 99 	r0 = r4 * 6 (int);
   r0 = r0 + r3;       
84204c98:	00 00 25 03 	r0 = r0 + r3;
   r0 = r0 + 3;         
84204c9c:	03 00 22 01 	r0 = r0 + 3;
   r0 = r0 + r0;        
84204ca0:	00 00 22 03 	r0 = r0 + r0;
   Div = rMAC/r0;       
84204ca4:	00 00 12 d9 	Div = rMAC / r0;
   r0 = DivResult;      
84204ca8:	01 00 20 d9 	r0 = DivResult;
   r0 = r0 * r0 (frac); 
84204cac:	00 00 22 97 	r0 = r0 * r0 (frac);
   r0 = r0 * 0.25(frac); 
84204cb0:	00 20 22 95 	r0 = r0 * 0.25 (frac);
   r0 = 0.5 - r0;       
84204cb4:	00 40 00 fd 	r0 = 1073741824 - r0;
84204cb8:	00 00 22 65 
   push I0;
84204cbc:	00 00 01 f3 	push I0;
   push L0;
84204cc0:	00 00 c1 f3 	push L0;
   L0 = 0;
84204cc4:	00 00 c0 51 	L0 = Null + 0;
#ifdef BASE_REGISTER_MODE
   push B0;
84204cc8:	00 00 a2 f3 	push B0;
   push Null;
84204ccc:	00 00 00 f3 	push Null;
   pop B0;
84204cd0:	00 00 a6 f3 	pop B0;
#endif
   call $math.sin;
84204cd4:	07 00 00 fd 	call 0x74280;
84204cd8:	80 42 f0 e1 
   r8 = r1;            
84204cdc:	0f 00 a3 00 	r8 = r1 + Null;
   r0 = 0.5 - r0;
84204ce0:	00 40 00 fd 	r0 = 1073741824 - r0;
84204ce4:	00 00 22 65 
   call $math.sin;
84204ce8:	07 00 00 fd 	call 0x74280;
84204cec:	80 42 f0 e1 
   //r8 = sin
   //r1 = cos
#ifdef BASE_REGISTER_MODE
   pop B0;
84204cf0:	00 00 a6 f3 	pop B0;
#endif
   pop L0;
84204cf4:	00 00 c5 f3 	pop L0;
   pop I0;
84204cf8:	00 00 05 f3 	pop I0;
   Null = r7;
84204cfc:	0f 00 09 00 	Null = r7 + Null;
   if NEG r8 = -r8;
84204d00:	a4 00 a0 20 	if NEG r8 = Null - r8;
 
   // 1st rotation loop
   r10 = M[FP + TEMP + 0];
84204d04:	08 00 c8 f1 	r10 = M[FP + 0x8];
   r10 = r10 - r6;
84204d08:	00 00 c8 23 	r10 = r10 - r6;
   if LE jump end_rot_loop1;
84204d0c:	0c 00 d0 dd 	if LE jump $M.celt.exp_rotation.end_rot_loop1;
   I3 = I5;
84204d10:	0f 00 35 58 	I3 = I5 + Null;
   Words2Addr(r6);
84204d14:	02 00 88 91 	r6 = r6 ASHIFT 2;
   I6 = I3 + r6;
84204d18:	8f 00 63 58 	I6 = I3 + r6;
   do exp_rot_lp1;
84204d1c:	07 00 f0 e5 	do $M.celt.exp_rotation.exp_rot_lp1;
      r2 = M[I6, 0]; 
84204d20:	48 00 00 03 	Null = Null + Null, r2 = M[I6,0];
      rMAC = r2*r1, r0 = M[I3, 0];
84204d24:	00 2c 43 cf 	rMAC = r2 * r1 (SS), r0 = M[I3,0];
      rMAC = rMAC + r0*r8;
84204d28:	af 00 12 ac 	rMAC = rMAC + r0 * r8 (SS);
      rMAC = r0*r1, M[I6, MK1] = rMAC; 
84204d2c:	99 00 23 cf 	rMAC = r0 * r1 (SS), M[I6,4] = rMAC;
      rMAC = rMAC - r8*r2;
84204d30:	4f 00 1a bc 	rMAC = rMAC - r8 * r2 (SS);
      M[I3, MK1] = rMAC;//, r2 = M[I6, 0];
84204d34:	00 9d 00 03 	Null = Null + Null, M[I3,4] = rMAC;

84204d38 <$M.celt.exp_rotation.exp_rot_lp1>:
   exp_rot_lp1:
   Addr2Words(r6);
84204d38:	fe 00 88 91 	r6 = r6 ASHIFT -2;

84204d3c <$M.celt.exp_rotation.end_rot_loop1>:
   end_rot_loop1:
   
   // 2nd rotation loop
   r0 = M[FP + TEMP + 0];
84204d3c:	08 00 28 f1 	r0 = M[FP + 0x8];
   r2 = r6 + r6;
84204d40:	8f 00 48 00 	r2 = r6 + r6;
   r10 = r0 - r2;
84204d44:	4f 00 c2 20 	r10 = r0 - r2;
   if LE jump end_rot_loop2;
84204d48:	0d 00 d0 dd 	if LE jump $M.celt.exp_rotation.end_rot_loop2;
   r3 = r10 - 1;
84204d4c:	3f 00 5c e4 	r3 = r10 - 1;
   Words2Addr(r3);
84204d50:	02 00 55 91 	r3 = r3 ASHIFT 2;
   I3 = I5 + r3;
84204d54:	5f 00 35 58 	I3 = I5 + r3;
   Words2Addr(r6);
84204d58:	02 00 88 91 	r6 = r6 ASHIFT 2;
   I6 = I3 + r6;
84204d5c:	8f 00 63 58 	I6 = I3 + r6;
   do exp_rot_lp2;
84204d60:	07 00 f0 e5 	do $M.celt.exp_rotation.end_rot_loop2;
      r2 = M[I6, 0];
84204d64:	48 00 00 03 	Null = Null + Null, r2 = M[I6,0];
      rMAC = r2*r1, r0 = M[I3, 0];
84204d68:	00 2c 43 cf 	rMAC = r2 * r1 (SS), r0 = M[I3,0];
      rMAC = rMAC + r0*r8;
84204d6c:	af 00 12 ac 	rMAC = rMAC + r0 * r8 (SS);
      rMAC = r0*r1, M[I6, -MK1] = rMAC;
84204d70:	9b 00 23 cf 	rMAC = r0 * r1 (SS), M[I6,-4] = rMAC;
      rMAC = rMAC - r8*r2;
84204d74:	4f 00 1a bc 	rMAC = rMAC - r8 * r2 (SS);
      M[I3, -MK1] = rMAC;//, r2 = M[I6, 0];
84204d78:	00 9f 00 03 	Null = Null + Null, M[I3,-4] = rMAC;

84204d7c <$M.celt.exp_rotation.end_rot_loop2>:
   exp_rot_lp2:
   end_rot_loop2:
   SP = SP - STACK_FRAME_SIZE;
84204d7c:	f4 ff 03 f1 	SP = SP + -12;
   popm <FP,rLink>;
84204d80:	01 20 04 f1 	popm <FP, rLink>;
   rts;
84204d84:	0f 00 0d dc 	rts;

84204d88 <$celt.alg_quant>:
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.ALG_QUANT.PATCH_ID_0,r7)     // celt_patchers
#endif
   
   .CONST TEMP                 (0 + 2)*ADDR_PER_WORD;
   .CONST STACK_FRAME_SIZE     10*ADDR_PER_WORD;
   pushm <FP(=SP), rLink>;
84204d88:	01 20 00 f1 	pushm <FP(=SP), rLink>;
   SP = SP + STACK_FRAME_SIZE;
84204d8c:	28 00 03 f1 	SP = SP + 40;
   // 0 -> nrof pulses
   // 1 -> input buffer
   // 2 -> spread (int)
   // 3 -> nrof inputs
   // 4 -> 1/N    (FRAC)
   $celt.get_pulses(r4, r1, get_pulses_lbl1)
84204d90:	fd 00 36 8d 	r1 = r4 LSHIFT -3;
84204d94:	05 00 00 dd 	if EQ jump $M.celt.alg_quant.get_pulses_lbl1;
84204d98:	3f 00 33 e4 	r1 = r1 - 1;
84204d9c:	07 00 66 81 	r4 = r4 AND 0x7;
84204da0:	08 00 66 01 	r4 = r4 + 8;
84204da4:	00 00 63 8f 	r4 = r4 LSHIFT r1;

84204da8 <$M.celt.alg_quant.get_pulses_lbl1>:
   
   rMAC = 1;
84204da8:	2f 00 10 e4 	rMAC = Null + 1;
   r0 = r3 LSHIFT 15;
84204dac:	0f 00 25 8d 	r0 = r3 LSHIFT 15;
   Div = rMAC /r0;
84204db0:	00 00 12 d9 	Div = rMAC / r0;
   
   // rotation if required
   M[FP + TEMP + 0*ADDR_PER_WORD] = r4;
84204db4:	08 00 6c f1 	M[FP + 0x8] = r4;
   r0 = I5;
84204db8:	5f 00 20 44 	r0 = Null + I5;
   M[FP + TEMP + 1*ADDR_PER_WORD] = r0;
84204dbc:	0c 00 2c f1 	M[FP + 0xc] = r0;
   r6 = M0;
84204dc0:	8f 00 80 44 	r6 = Null + M0;
   M[FP + TEMP + 3*ADDR_PER_WORD] = r3;
84204dc4:	14 00 5c f1 	M[FP + 0x14] = r3;
   r7 = 1;
84204dc8:	2f 00 90 e4 	r7 = Null + 1;
   r0 = DivResult;
84204dcc:	01 00 20 d9 	r0 = DivResult;
   M[FP + TEMP + 4*ADDR_PER_WORD] = r0;
84204dd0:	18 00 2c f1 	M[FP + 0x18] = r0;
   M[FP + TEMP + 2*ADDR_PER_WORD] = r6;
84204dd4:	10 00 8c f1 	M[FP + 0x10] = r6;
   if NZ call $celt.exp_rotation;
84204dd8:	a3 ff 10 e1 	if NE call $celt.exp_rotation;
   r2 = M[r5 + $celt.enc.ALG_QUANT_ST_FIELD];
84204ddc:	c4 00 47 d1 	r2 = M[r5 + 196];
   I6 = r2;
84204de0:	4f 00 60 50 	I6 = Null + r2;
   r2 = 0;
84204de4:	00 00 40 01 	r2 = Null + 0;
   M0 = ADDR_PER_WORD;
84204de8:	04 00 80 51 	M0 = Null + 4;
   r0 = M[FP + TEMP + 1*ADDR_PER_WORD];
84204dec:	0c 00 28 f1 	r0 = M[FP + 0xc];
   r10 = M[FP + TEMP + 3*ADDR_PER_WORD];
84204df0:	14 00 c8 f1 	r10 = M[FP + 0x14];
   I3 = r0;
84204df4:	2f 00 30 50 	I3 = Null + r0;
   r10 = r10 - 1, r0 = M[I3, M0];
84204df8:	3f 2c cc e4 	r10 = r10 - 1, r0 = M[I3,M0];
#ifdef K32
   r0 = r0 ASHIFT -8;
84204dfc:	f8 00 22 91 	r0 = r0 ASHIFT -8;
#endif
   r3 = 0.00390625/2;//??4096; //0.00390625;
84204e00:	40 00 00 fd 	r3 = Null + 4194304;
84204e04:	00 00 50 01 
   r1 = M[r5 + $celt.enc.ABS_NORM_FIELD]; 
84204e08:	28 01 37 d1 	r1 = M[r5 + 296];
   I2 = r1;
84204e0c:	3f 00 20 50 	I2 = Null + r1;
   r1 = r0*r3(frac);
84204e10:	5f 00 32 94 	r1 = r0 * r3 (frac);
   do abs_norm_loop;
84204e14:	05 00 f0 e5 	do $M.celt.alg_quant.abs_norm_loop;
      if NEG r1 = -r1, r0 = M[I3, M0];
84204e18:	34 2c 30 20 	if NEG r1 = Null - r1, r0 = M[I3,M0];
#ifdef K32
   r0 = r0 ASHIFT -8;
84204e1c:	f8 00 22 91 	r0 = r0 ASHIFT -8;
#endif
      r1 = r0*r3(frac), M[I2, M0] = r1;      
84204e20:	5f b8 32 94 	r1 = r0 * r3 (frac), M[I2,M0] = r1;
      M[I6, M0] = r2;
84204e24:	c8 00 00 02 	Null = Null + Null, M[I6,M0] = r2;

84204e28 <$M.celt.alg_quant.abs_norm_loop>:
   abs_norm_loop:
   if NEG r1 = -r1;
84204e28:	34 00 30 20 	if NEG r1 = Null - r1;
   M[I2, M0] = r1;      
84204e2c:	00 b8 00 02 	Null = Null + Null, M[I2,M0] = r1;
   M[I6, M0] = r2;
84204e30:	c8 00 00 02 	Null = Null + Null, M[I6,M0] = r2;
   
   r0 = M[FP + TEMP + 0*ADDR_PER_WORD];
84204e34:	08 00 28 f1 	r0 = M[FP + 0x8];
   M2 = r0;
84204e38:	2f 00 a0 50 	M2 = Null + r0;
   r10 = M[FP + TEMP + 3*ADDR_PER_WORD];
84204e3c:	14 00 c8 f1 	r10 = M[FP + 0x14];
   M3 = r10;
84204e40:	cf 00 b0 50 	M3 = Null + r10;

#ifndef K32
   r7 = 0;
   r8 = 0;
#else
   rMAC = 0;
84204e44:	00 00 10 01 	rMAC = Null + 0;
   rMACB = 0;
84204e48:	00 00 f0 01 	rMACB = Null + 0;
#endif

   r2 = r10 LSHIFT -1;
84204e4c:	ff 00 4c 8d 	r2 = r10 LSHIFT -1;
   Null = r0 - r2;
84204e50:	4f 00 02 20 	Null = r0 - r2;
   if LE jump end_presearch;
84204e54:	23 00 d0 dd 	if LE jump $M.celt.alg_quant.end_presearch;
      r3 = M[r5 + $celt.enc.ABS_NORM_FIELD];
84204e58:	28 01 57 d1 	r3 = M[r5 + 296];
      I6 = r3;
84204e5c:	5f 00 60 50 	I6 = Null + r3;
      r10 = r10 - 1;
84204e60:	3f 00 cc e4 	r10 = r10 - 1;
      r4 = M[FP + TEMP + 0*ADDR_PER_WORD];
84204e64:	08 00 68 f1 	r4 = M[FP + 0x8];
      r0 = r0-r0, r1 = M[I6, M0];
84204e68:	38 00 22 22 	r0 = r0 - r0, r1 = M[I6,M0];
      do calc_sum_lp;
84204e6c:	02 00 f0 e5 	do $M.celt.alg_quant.calc_sum_lp;
         r0 = r0 + r1, r1 = M[I6, M0];
84204e70:	38 00 23 02 	r0 = r0 + r1, r1 = M[I6,M0];

84204e74 <$M.celt.alg_quant.calc_sum_lp>:
      calc_sum_lp:
      I6 = r3;
84204e74:	5f 00 60 50 	I6 = Null + r3;
      r0 = r0 + r1; // SGTBD: r0 differs by 1 after this line. this causes diferences downstream
84204e78:	00 00 23 03 	r0 = r0 + r1;
      NULL = r0 - M3; 
84204e7c:	bf 00 02 64 	Null = r0 - M3;
      if POS jump calc_inv;
84204e80:	08 00 50 dd 	if POS jump $M.celt.alg_quant.calc_inv;
          // empty or nearly empty band
          r0 = 1<<20;
84204e84:	10 00 00 fd 	r0 = Null + 1048576;
84204e88:	00 00 20 01 
          r1 = 0, M[I6, M0] = r0;
84204e8c:	a8 00 33 22 	r1 = r1 - r1, M[I6,M0] = r0;
          r10 = M3 - 1;
84204e90:	01 00 cb 69 	r10 = M3 - 1;
          do force_clear_band;
84204e94:	02 00 f0 e5 	do $M.celt.alg_quant.force_clear_band;
             M[I6, M0] = r1;
84204e98:	b8 00 00 02 	Null = Null + Null, M[I6,M0] = r1;

84204e9c <$M.celt.alg_quant.force_clear_band>:
          force_clear_band:
          I6 = r3;
84204e9c:	5f 00 60 50 	I6 = Null + r3;

84204ea0 <$M.celt.alg_quant.calc_inv>:
      calc_inv:
      r2 = r4 - 1;
84204ea0:	3f 00 46 e4 	r2 = r4 - 1;
      //rMAC = r2 LSHIFT 6;
      rMAC = r2 LSHIFT 5;//??3;
84204ea4:	05 00 e4 8d 	rMAC = r2 LSHIFT 5 (MI);
      Div = rMAC /r0;
84204ea8:	00 00 12 d9 	Div = rMAC / r0;
      r10 = M3;
84204eac:	bf 00 c0 44 	r10 = Null + M3;
#ifdef K32
      rMAC = 0;
84204eb0:	00 00 10 01 	rMAC = Null + 0;
      rMACB = 0;
84204eb4:	00 00 f0 01 	rMACB = Null + 0;
#endif
      r0 = M[r5 + $celt.enc.ALG_QUANT_ST_FIELD];
84204eb8:	c4 00 27 d1 	r0 = M[r5 + 196];
      I3 = r0;      
84204ebc:	2f 00 30 50 	I3 = Null + r0;
      r6 = DivResult;
84204ec0:	01 00 80 d9 	r6 = DivResult;
      do rcp_loop;
84204ec4:	07 00 f0 e5 	do $M.celt.alg_quant.end_presearch;
         r0 = M[I6, M0];
84204ec8:	28 00 00 02 	Null = Null + Null, r0 = M[I6,M0];
         r1 = r0 * r6 (frac);
84204ecc:	8f 00 32 94 	r1 = r0 * r6 (frac);
         r2 = r1 * r1 (int), M[I3, M0] = r1;
         r7 = r7 + r2;
         r2 = r1 * r0(int)(sat);
         r8 = r8 + r2;
#else
         r1 = r1 LSHIFT -6;
84204ed0:	fa 00 33 8d 	r1 = r1 LSHIFT -6;
         rMAC = rMAC + r1*r1, M[I3, M0] = r1;
84204ed4:	3f bc 13 ac 	rMAC = rMAC + r1 * r1 (SS), M[I3,M0] = r1;
         rMACB = rMACB + r1*r0;
84204ed8:	2f 00 03 ac 	rMACB = rMACB + r1 * r0 (SS);
#endif
         M2 = M2 - r1;
84204edc:	00 00 a3 7b 	M2 = M2 - r1;

84204ee0 <$M.celt.alg_quant.end_presearch>:
      rcp_loop:
   end_presearch:
#ifdef K32 
   r7 = rMAC ASHIFT 31;
84204ee0:	1f 00 91 91 	r7 = rMAC ASHIFT 31;
   r8 = rMACB ASHIFT 31;
84204ee4:	1f 00 af 91 	r8 = rMACB ASHIFT 31;

84204ee8 <$M.celt.alg_quant.fine_loop>:
   // r6 = best_num (unused)
   // r4 = best_den (unused)
   // M0 = 1 (AU)
   // M1 = best_id (unused)
   fine_loop:
      r0 = M2;
84204ee8:	af 00 20 44 	r0 = Null + M2;
      if LE jump end_fine_loop;
84204eec:	31 00 d0 dd 	if LE jump $M.celt.alg_quant.end_fine_loop;
      
      r4 = 0;
84204ef0:	00 00 60 01 	r4 = Null + 0;
#ifndef K32      
      r6 = -1.0;
#else
      r6 = -1.0 / 256;
84204ef4:	80 ff 00 fd 	r6 = Null + -8388608;
84204ef8:	00 00 80 01 
#endif
      r1 = M[FP + TEMP + 4*ADDR_PER_WORD];
84204efc:	18 00 38 f1 	r1 = M[FP + 0x18];
#ifdef K32
      r1 = r1 LSHIFT -8;
84204f00:	f8 00 33 8d 	r1 = r1 LSHIFT -8;
#endif
      r1 = r1 * r0 (int);
84204f04:	00 00 32 9b 	r1 = r1 * r0 (int);
      r1 = r1 LSHIFT -9;
84204f08:	f7 00 33 8d 	r1 = r1 LSHIFT -9;
      if Z r1 = 1;
84204f0c:	20 00 30 e4 	if EQ r1 = Null + 1;
      M1 = 0;
84204f10:	00 00 90 51 	M1 = Null + 0;
      r10 = M3;
84204f14:	bf 00 c0 44 	r10 = Null + M3;
      r0 = M[r5 + $celt.enc.ABS_NORM_FIELD];
84204f18:	28 01 27 d1 	r0 = M[r5 + 296];
      I6 = r0;
84204f1c:	2f 00 60 50 	I6 = Null + r0;
      r0 = M[r5 + $celt.enc.ALG_QUANT_ST_FIELD];
84204f20:	c4 00 27 d1 	r0 = M[r5 + 196];
      I3 = r0; 
84204f24:	2f 00 30 50 	I3 = Null + r0;
      r0 = r1 * r1 (int);
84204f28:	3f 00 23 98 	r0 = r1 * r1 (int);
      r7 = r7 + r0, r0 = M[I6, M0];
84204f2c:	28 00 92 02 	r7 = r7 + r0, r0 = M[I6,M0];
      push r5;
84204f30:	00 00 70 f3 	push r5;
      r5 = r1 * 2(int);
84204f34:	02 00 73 99 	r5 = r1 * 2 (int);
      r0 = r0 * r1(int);
84204f38:	00 00 23 9b 	r0 = r0 * r1 (int);
      do search_fine_loop;
84204f3c:	0d 00 f0 e5 	do $M.celt.alg_quant.search_fine_loop;
         r3 = r8 + r0, r0 = M[I3, M0];
84204f40:	2f 2c 5a 00 	r3 = r8 + r0, r0 = M[I3,M0];
         r0 = r0 * r5(int);
84204f44:	00 00 27 9b 	r0 = r0 * r5 (int);
         r2 = r7 + r0;
84204f48:	2f 00 49 00 	r2 = r7 + r0;
         rMAC = r3 * r3;
84204f4c:	5f 00 15 cc 	rMAC = r3 * r3 (SS);
#ifndef K32
   r3 = rMAC ASHIFT 6;
#else
   r3 = rMAC ASHIFT 14;
84204f50:	0e 00 51 91 	r3 = rMAC ASHIFT 14;
#endif
         rMAC = r3*r4;
84204f54:	6f 00 15 cc 	rMAC = r3 * r4 (SS);
         rMAC = rMAC - r6 * r2, r0 = M[I6, M0];
84204f58:	28 00 84 be 	rMAC = rMAC - r6 * r2 (SS), r0 = M[I6,M0];
         if LE jump b_loop;
84204f5c:	04 00 d0 dd 	if LE jump $M.celt.alg_quant.b_loop;
            r4 = r2;
84204f60:	0f 00 64 00 	r4 = r2 + Null;
            r6 = r3;
84204f64:	0f 00 85 00 	r6 = r3 + Null;
            M1 = M3 - r10;
84204f68:	cf 00 9b 78 	M1 = M3 - r10;

84204f6c <$M.celt.alg_quant.b_loop>:
         b_loop:
         r0 = r0 * r1(int);
84204f6c:	00 00 23 9b 	r0 = r0 * r1 (int);

84204f70 <$M.celt.alg_quant.search_fine_loop>:
      search_fine_loop:
      pop r5;
84204f70:	00 00 74 f3 	pop r5;

      r0 = M1;
84204f74:	9f 00 20 44 	r0 = Null + M1;
      Words2Addr(r0);
84204f78:	02 00 22 91 	r0 = r0 ASHIFT 2;
      r2 = M[r5 + $celt.enc.ABS_NORM_FIELD];
84204f7c:	28 01 47 d1 	r2 = M[r5 + 296];
      r3 = M[r0 + r2];
84204f80:	4f 00 52 d0 	r3 = M[r0 + r2];
      r3 = r1 * r3 (int);
84204f84:	5f 00 53 98 	r3 = r1 * r3 (int);
      r8 = r8 + r3;      
84204f88:	00 00 a5 03 	r8 = r8 + r3;
      r2 = M[r5 + $celt.enc.ALG_QUANT_ST_FIELD];
84204f8c:	c4 00 47 d1 	r2 = M[r5 + 196];
      r3 = M[r0 + r2];
84204f90:	4f 00 52 d0 	r3 = M[r0 + r2];
      rMAC = r1 * r3 (int);
84204f94:	5f 00 13 98 	rMAC = r1 * r3 (int);
      r7 = r7 + rMAC;
84204f98:	00 00 91 03 	r7 = r7 + rMAC;
      r7 = r7 + rMAC;
84204f9c:	00 00 91 03 	r7 = r7 + rMAC;
      r3 = r3 + r1;
84204fa0:	00 00 53 03 	r3 = r3 + r1;
      M[r0 + r2] = r3;
84204fa4:	4f 00 52 d4 	M[r0 + r2] = r3;
            
   M2 = M2 - r1;
84204fa8:	00 00 a3 7b 	M2 = M2 - r1;
   jump fine_loop;  
84204fac:	cf ff f0 dd 	jump $M.celt.alg_quant.fine_loop;

84204fb0 <$M.celt.alg_quant.end_fine_loop>:
   end_fine_loop:
   r7 = r7 + r7;
84204fb0:	00 00 99 03 	r7 = r7 + r7;
   M[FP + TEMP + 6*ADDR_PER_WORD] = r7;
84204fb4:	20 00 9c f1 	M[FP + 0x20] = r7;
   r0 = M[FP + TEMP + 1*ADDR_PER_WORD];
84204fb8:	0c 00 28 f1 	r0 = M[FP + 0xc];
   I5 = r0;
84204fbc:	2f 00 50 50 	I5 = Null + r0;
   I6 = I5;
84204fc0:	0f 00 65 58 	I6 = I5 + Null;
   r0 = M[r5 + $celt.enc.ALG_QUANT_ST_FIELD];
84204fc4:	c4 00 27 d1 	r0 = M[r5 + 196];
   I2 = r0;
84204fc8:	2f 00 20 50 	I2 = Null + r0;
   I3 = I2;
84204fcc:	0f 00 32 58 	I3 = I2 + Null;
   r10 = M3 - 2;
84204fd0:	02 00 cb 69 	r10 = M3 - 2;
   r0 = M[I6, M0];
84204fd4:	28 00 00 02 	Null = Null + Null, r0 = M[I6,M0];
   r0 = r0, r1 = M[I2, M0];
84204fd8:	00 38 20 02 	r0 = r0 + Null, r1 = M[I2,M0];
   if NEG r1 = -r1;
84204fdc:	34 00 30 20 	if NEG r1 = Null - r1;
   r0 = M[I6, M0];
84204fe0:	28 00 00 02 	Null = Null + Null, r0 = M[I6,M0];
   do ap_sign_loop;
84204fe4:	05 00 f0 e5 	do $M.celt.alg_quant.ap_sign_loop;
      r2 = r1, r1 = M[I2, M0];
84204fe8:	0f 38 43 00 	r2 = r1 + Null, r1 = M[I2,M0];
      r0 = r0 + Null;
84204fec:	00 00 20 03 	r0 = r0 + Null;
      if NEG r1 = -r1, M[I3, M0] = r2;      
84204ff0:	34 cc 30 20 	if NEG r1 = Null - r1, M[I3,M0] = r2;
       r0 = M[I6, M0];
84204ff4:	28 00 00 02 	Null = Null + Null, r0 = M[I6,M0];

84204ff8 <$M.celt.alg_quant.ap_sign_loop>:
   ap_sign_loop:
   r2 = r1, r1 = M[I2, M0];
84204ff8:	0f 38 43 00 	r2 = r1 + Null, r1 = M[I2,M0];
   r0 = r0 + Null;
84204ffc:	00 00 20 03 	r0 = r0 + Null;
   if NEG r1 = -r1, M[I3, M0] = r2; 
84205000:	34 cc 30 20 	if NEG r1 = Null - r1, M[I3,M0] = r2;
   M[I3, M0] = r1;
84205004:	00 bc 00 02 	Null = Null + Null, M[I3,M0] = r1;
   r0 = M[r5 + $celt.enc.ALG_QUANT_ST_FIELD];
84205008:	c4 00 27 d1 	r0 = M[r5 + 196];
   I7 = r0;
8420500c:	2f 00 70 50 	I7 = Null + r0;
   r3 = M[FP + TEMP + 3*ADDR_PER_WORD];
84205010:	14 00 58 f1 	r3 = M[FP + 0x14];
   r4 = M[FP + TEMP + 0*ADDR_PER_WORD];
84205014:	08 00 68 f1 	r4 = M[FP + 0x8];
   call $celt.encode_pulses;
84205018:	64 f6 f0 e1 	call $celt.encode_pulses;
   
   // normalise residual
   r0 = M[FP + TEMP + 6*ADDR_PER_WORD];
8420501c:	20 00 28 f1 	r0 = M[FP + 0x20];
   rMAC = 0;
84205020:	00 00 10 01 	rMAC = Null + 0;
   rMAC0 = r0;
84205024:	00 05 e2 8d 	rMAC0 = r0 LSHIFT 0;
   r0 = M[FP + TEMP + 1*ADDR_PER_WORD];
84205028:	0c 00 28 f1 	r0 = M[FP + 0xc];
   I5 = r0;
8420502c:	2f 00 50 50 	I5 = Null + r0;
   r0 = M[r5 + $celt.enc.ALG_QUANT_ST_FIELD];
84205030:	c4 00 27 d1 	r0 = M[r5 + 196];
   I7 = r0;
84205034:	2f 00 70 50 	I7 = Null + r0;
   r3 = M[FP + TEMP + 3*ADDR_PER_WORD];
84205038:	14 00 58 f1 	r3 = M[FP + 0x14];
   call $celt.normalise_residual;
8420503c:	e2 fe f0 e1 	call $celt.normalise_residual;
   Null = M[FP + TEMP + 0*ADDR_PER_WORD];
84205040:	08 00 08 f1 	Null = M[FP + 0x8];
   if Z jump exit;
84205044:	08 00 00 dd 	if EQ jump $M.celt.alg_quant.exit;
   
   // rotation if required
   r6 = M[FP + TEMP + 2*ADDR_PER_WORD];
84205048:	10 00 88 f1 	r6 = M[FP + 0x10];
   r0 = M[FP + TEMP + 1*ADDR_PER_WORD];
8420504c:	0c 00 28 f1 	r0 = M[FP + 0xc];
   I5 = r0;
84205050:	2f 00 50 50 	I5 = Null + r0;
   r3 = M[FP + TEMP + 3*ADDR_PER_WORD];
84205054:	14 00 58 f1 	r3 = M[FP + 0x14];
   r4 = M[FP + TEMP + 0*ADDR_PER_WORD];
84205058:	08 00 68 f1 	r4 = M[FP + 0x8];
   r7 = -1;
8420505c:	3f 00 90 e4 	r7 = Null - 1;
   call $celt.exp_rotation;
84205060:	01 ff f0 e1 	call $celt.exp_rotation;

84205064 <$M.celt.alg_quant.exit>:
exit: 
   SP = SP - STACK_FRAME_SIZE;
84205064:	d8 ff 03 f1 	SP = SP + -40;
   popm <FP,rLink>;
84205068:	01 20 04 f1 	popm <FP, rLink>;
   rts;
8420506c:	0f 00 0d dc 	rts;

84205070 <$celt.window_reshuffle>:
84205070:	40 00 97 d1 	r7 = M[r5 + 64];
#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.WINDOW_RESHUFFLE.PATCH_ID_0,r2)     // celt_patchers
#endif

   r7 = M[r5 + $celt.enc.MODE_OVERLAP_FIELD];   //OV
   r7 = r7 LSHIFT -1;                           //OV/2
84205074:	ff 00 99 8d 	r7 = r7 LSHIFT -1;
   Words2Addr(r7);
84205078:	02 00 99 91 	r7 = r7 ASHIFT 2;
   Words2Addr(r8);
8420507c:	02 00 aa 91 	r8 = r8 ASHIFT 2;
   I0 = r7 + I0;
84205080:	0f 00 09 54 	I0 = r7 + I0;
   I3 = I0 - ADDR_PER_WORD;                                 
84205084:	04 00 30 79 	I3 = I0 - 4;
   I1 = I3 + r8;                               
84205088:	af 00 13 58 	I1 = I3 + r8;
   I2 = I0 + r8;                                
8420508c:	af 00 20 58 	I2 = I0 + r8;
   r0 = M[r5 + $celt.enc.MODE_WINDOW_ADDR_FIELD];   
84205090:	68 00 27 d1 	r0 = M[r5 + 104];
   I4 = r0 + r7;                               
84205094:	9f 00 42 50 	I4 = r0 + r7;
   I5 = I4 - ADDR_PER_WORD;                                
84205098:	04 00 54 79 	I5 = I4 - 4;
   Addr2Words(r7);
8420509c:	fe 00 99 91 	r7 = r7 ASHIFT -2;
   M0 = 2 * ADDR_PER_WORD;
842050a0:	08 00 80 51 	M0 = Null + 8;
   M1 = -2 * ADDR_PER_WORD;
842050a4:	f8 ff 90 51 	M1 = Null + -8;
   M2 = 1 * ADDR_PER_WORD;
842050a8:	04 00 a0 51 	M2 = Null + 4;
   M3 = 1;
842050ac:	01 00 b0 51 	M3 = Null + 1;
   r10 = r7 LSHIFT -1;
842050b0:	ff 00 c9 8d 	r10 = r7 LSHIFT -1;
   r10 = r10 - M3, r0 = M[I4, M0], r2 = M[I1, M1];  
842050b4:	20 45 cb 66 	r10 = r10 - M3, r2 = M[I1,M1], r0 = M[I4,M0];
   rMAC = r0 * r2, r2 = M[I2, M0];
842050b8:	4f 48 12 cc 	rMAC = r0 * r2 (SS), r2 = M[I2,M0];
   r1 = M[I5, M1];
842050bc:	35 00 00 02 	Null = Null + Null, r1 = M[I5,M1];
   do window_rs1_loop;
842050c0:	06 00 f0 e5 	do $M.celt.window_reshuffle.window_rs1_loop;
      rMAC = rMAC + r1*r2, r2 = M[I0, M0];
842050c4:	4f 40 13 ac 	rMAC = rMAC + r1 * r2 (SS), r2 = M[I0,M0];
      rMAC = r2 * r0, M[I6, M2] = rMAC, r2 = M[I3, M1];
842050c8:	9a 4d 42 ce 	rMAC = r2 * r0 (SS), r2 = M[I3,M1], M[I6,M2] = rMAC;
      rMAC = rMAC - r1*r2,  r0 = M[I4, M0], r2 = M[I1, M1];
842050cc:	20 45 34 be 	rMAC = rMAC - r1 * r2 (SS), r2 = M[I1,M1], r0 = M[I4,M0];
      rMAC = r0*r2, M[I7, M2] = rMAC, r2 = M[I2, M0];
842050d0:	9e 48 24 ce 	rMAC = r0 * r2 (SS), r2 = M[I2,M0], M[I7,M2] = rMAC;
      r1 = M[I5, M1];
842050d4:	35 00 00 02 	Null = Null + Null, r1 = M[I5,M1];

842050d8 <$M.celt.window_reshuffle.window_rs1_loop>:
   window_rs1_loop:

   rMAC = rMAC + r1*r2, r2 = M[I0, M0];
842050d8:	4f 40 13 ac 	rMAC = rMAC + r1 * r2 (SS), r2 = M[I0,M0];
   rMAC = r2 * r0, M[I6, M2] = rMAC, r2 = M[I3, M1];
842050dc:	9a 4d 42 ce 	rMAC = r2 * r0 (SS), r2 = M[I3,M1], M[I6,M2] = rMAC;
   rMAC = rMAC - r1*r2;
842050e0:	4f 00 13 bc 	rMAC = rMAC - r1 * r2 (SS);
   M[I7, M2] = rMAC;   
842050e4:	9e 00 00 02 	Null = Null + Null, M[I7,M2] = rMAC;

   Addr2Words(r8);
842050e8:	fe 00 aa 91 	r8 = r8 ASHIFT -2;
   r10 = r8 LSHIFT -1;
842050ec:	ff 00 ca 8d 	r10 = r8 LSHIFT -1;
   r10 = r10 - r7;
842050f0:	00 00 c9 23 	r10 = r10 - r7;
   if LE jump end_flat_copy;
842050f4:	07 00 d0 dd 	if LE jump $M.celt.window_reshuffle.end_flat_copy;
   r10 = r10 - M3, r0 = M[I0, M0];
842050f8:	00 20 cb 66 	r10 = r10 - M3, r0 = M[I0,M0];
   do flat_copy_loop;
842050fc:	03 00 f0 e5 	do $M.celt.window_reshuffle.flat_copy_loop;
      r1 = M[I1, M1], M[I7, M2] = r0;
84205100:	ae 35 00 02 	Null = Null + Null, r1 = M[I1,M1], M[I7,M2] = r0;
      r0 = M[I0, M0], M[I6, M2] = r1;
84205104:	ba 20 00 02 	Null = Null + Null, r0 = M[I0,M0], M[I6,M2] = r1;

84205108 <$M.celt.window_reshuffle.flat_copy_loop>:
   flat_copy_loop:
   r1 = M[I1, M1], M[I7, M2] = r0;
84205108:	ae 35 00 02 	Null = Null + Null, r1 = M[I1,M1], M[I7,M2] = r0;
   M[I6, M2] = r1;   
8420510c:	ba 00 00 02 	Null = Null + Null, M[I6,M2] = r1;

84205110 <$M.celt.window_reshuffle.end_flat_copy>:
   end_flat_copy:

   r0 = M[r5 + $celt.enc.MODE_WINDOW_ADDR_FIELD];   
84205110:	68 00 27 d1 	r0 = M[r5 + 104];
   I4 = r0;                               //w1
84205114:	2f 00 40 50 	I4 = Null + r0;
   Words2Addr(r7);
84205118:	02 00 99 91 	r7 = r7 ASHIFT 2;
   I5 = I4 + r7;                          //w2
8420511c:	9f 00 54 58 	I5 = I4 + r7;
   I5 = I5 + r7;
84205120:	00 00 59 5b 	I5 = I5 + r7;
   I5 = I5 - ADDR_PER_WORD;
84205124:	04 00 55 79 	I5 = I5 - 4;
   Addr2Words(r7);
84205128:	fe 00 99 91 	r7 = r7 ASHIFT -2;
   r10 = r7 LSHIFT -1;
8420512c:	ff 00 c9 8d 	r10 = r7 LSHIFT -1;
   Words2Addr(r8);
84205130:	02 00 aa 91 	r8 = r8 ASHIFT 2;
   I2 = I0 - r8;                                 //xp2[-N2]
84205134:	af 00 20 78 	I2 = I0 - r8;
   I3 = I1 + r8;                                //xp1[N2]   
84205138:	af 00 31 58 	I3 = I1 + r8;
   
   r10 = r10 - M3, r0 = M[I5, M1], r2 = M[I1, M1];  
8420513c:	25 45 cb 66 	r10 = r10 - M3, r2 = M[I1,M1], r0 = M[I5,M1];
   rMAC = r0 * r2, r2 = M[I2, M0];
84205140:	4f 48 12 cc 	rMAC = r0 * r2 (SS), r2 = M[I2,M0];
   r1 = M[I4, M0];
84205144:	30 00 00 02 	Null = Null + Null, r1 = M[I4,M0];
   do window_rs2_loop;
84205148:	06 00 f0 e5 	do $M.celt.window_reshuffle.window_rs2_loop;
      rMAC = rMAC - r1*r2, r2 = M[I0, M0];
8420514c:	4f 40 13 bc 	rMAC = rMAC - r1 * r2 (SS), r2 = M[I0,M0];
      rMAC = r2 * r0, M[I6, M2] = rMAC, r2 = M[I3, M1];
84205150:	9a 4d 42 ce 	rMAC = r2 * r0 (SS), r2 = M[I3,M1], M[I6,M2] = rMAC;
      rMAC = rMAC + r1*r2,  r0 = M[I5, M1], r2 = M[I1, M1];
84205154:	25 45 34 ae 	rMAC = rMAC + r1 * r2 (SS), r2 = M[I1,M1], r0 = M[I5,M1];
      rMAC = r0*r2, M[I7, M2] = rMAC, r2 = M[I2, M0];
84205158:	9e 48 24 ce 	rMAC = r0 * r2 (SS), r2 = M[I2,M0], M[I7,M2] = rMAC;
      r1 = M[I4, M0];
8420515c:	30 00 00 02 	Null = Null + Null, r1 = M[I4,M0];

84205160 <$M.celt.window_reshuffle.window_rs2_loop>:
   window_rs2_loop:
   rMAC = rMAC - r1*r2, r2 = M[I0, M0];
84205160:	4f 40 13 bc 	rMAC = rMAC - r1 * r2 (SS), r2 = M[I0,M0];
   rMAC = r2 * r0, M[I6, M2] = rMAC, r2 = M[I3, M1];
84205164:	9a 4d 42 ce 	rMAC = r2 * r0 (SS), r2 = M[I3,M1], M[I6,M2] = rMAC;
   rMAC = rMAC + r1*r2, r2 = M[I1, M1];
84205168:	4f 45 13 ac 	rMAC = rMAC + r1 * r2 (SS), r2 = M[I1,M1];
   M[I7, M2] = rMAC;   
8420516c:	9e 00 00 02 	Null = Null + Null, M[I7,M2] = rMAC;

   // pop rLink from stack
   rts;
84205170:	0f 00 0d dc 	rts;

84205174 <$_celt_setup_thread_offload>:
84205174:	00 00 d0 f3 	push rLink;
$_celt_setup_thread_offload:
$celt_dec.setup_thread_offload:

   push rLink;
 
   r0 = &$fft.twiddle_real_address;
84205178:	7c 02 20 01 	r0 = Null + 636;
   call $_thread_offload_update_p1_dm_location;
8420517c:	20 04 00 fd 	call (m) $_thread_offload_update_p1_dm_location;
84205180:	dd 6b f0 e1 

   r0 = &$fft.twiddle_imag_address;
84205184:	80 02 20 01 	r0 = Null + 640;
   call $_thread_offload_update_p1_dm_location;
84205188:	20 04 00 fd 	call (m) $_thread_offload_update_p1_dm_location;
8420518c:	dd 6b f0 e1 

   r0 = &$math.fft_twiddle.twiddle_size;
84205190:	84 02 20 01 	r0 = Null + 644;
   call $_thread_offload_update_p1_dm_location;
84205194:	20 04 00 fd 	call (m) $_thread_offload_update_p1_dm_location;
84205198:	dd 6b f0 e1 

   r0 = &$math.fft_twiddle.twiddle_user;
8420519c:	88 02 20 01 	r0 = Null + 648;
   call $_thread_offload_update_p1_dm_location;
842051a0:	20 04 00 fd 	call (m) $_thread_offload_update_p1_dm_location;
842051a4:	dd 6b f0 e1 

   pop rLink;
842051a8:	00 00 d4 f3 	pop rLink;
   rts;
842051ac:	0f 00 0d dc 	rts;

842051b0 <$celt.compute_band_energies>:
842051b0:	00 00 d0 f3 	push rLink;
   
#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.COMPUTE_BAND_ENERGIES.PATCH_ID_0,r1)     // celt_patchers
#endif

   r0 = M[r5 + $celt.enc.MODE_NB_EBANDS_FIELD];
842051b4:	48 00 27 d1 	r0 = M[r5 + 72];
   M3 = r0;
842051b8:	2f 00 b0 50 	M3 = Null + r0;
   r0 = M[r5 + $celt.enc.MODE_EBANDS_ADDR_FIELD];
842051bc:	60 00 27 d1 	r0 = M[r5 + 96];
   I3 = r0;
842051c0:	2f 00 30 50 	I3 = Null + r0;
   I6 = r2;
842051c4:	4f 00 60 50 	I6 = Null + r2;

842051c8 <$M.celt.compute_band_energies.calc_bande_loop>:
   calc_bande_loop:
      r6 = 1;
842051c8:	2f 00 80 e4 	r6 = Null + 1;
      r0 = M[I3, MK1];
842051cc:	00 2d 00 03 	Null = Null + Null, r0 = M[I3,4];
      r1 = M[I3, 0];
842051d0:	00 3c 00 03 	Null = Null + Null, r1 = M[I3,0];
      r10 = r1 - r0;
842051d4:	2f 00 c3 20 	r10 = r1 - r0;
      r10 = r10 - 1;
842051d8:	3f 00 cc e4 	r10 = r10 - 1;
      rMAC = 0, r0 = M[I2, MK1];
842051dc:	00 29 11 23 	rMAC = rMAC - rMAC, r0 = M[I2,4];
      do calc_en_loop;
842051e0:	02 00 f0 e5 	do $M.celt.compute_band_energies.calc_en_loop;
         rMAC = rMAC + r0*r0, r0 = M[I2, MK1];
842051e4:	00 29 22 af 	rMAC = rMAC + r0 * r0 (SS), r0 = M[I2,4];

842051e8 <$M.celt.compute_band_energies.calc_en_loop>:
      calc_en_loop:
      rMAC = rMAC + r0*r0;
842051e8:	2f 00 12 ac 	rMAC = rMAC + r0 * r0 (SS);
      if Z rMAC = rMAC + r6*r6;
842051ec:	80 00 18 ac 	if EQ rMAC = rMAC + r6 * r6 (SS);
      r8 = signdet rMAC;
842051f0:	0f 00 a1 d8 	r8 = SIGNDET rMAC;
      r8 = r8 AND $celt.BANDS_PROC_LSB_FLAG;
842051f4:	ff ff 00 fd 	r8 = r8 AND 0xfffffffe;
842051f8:	fe ff aa 81 
      rMAC = rMAC ASHIFT r8 (56bit);
842051fc:	00 00 1a 93 	rMAC = rMAC ASHIFT r8 (56bit);
      push I3;
84205200:	00 00 31 f3 	push I3;
      call $math.sqrt48;
84205204:	07 00 00 fd 	call 0x743c8;
84205208:	c8 43 f0 e1 
      pop I3;
8420520c:	00 00 35 f3 	pop I3;
      r1 = r8 * (-0.5)(frac);
84205210:	00 c0 3a 95 	r1 = r8 * -0.5 (frac);
      M[I1, MK1] = r0;            //gain
84205214:	00 a5 00 03 	Null = Null + Null, M[I1,4] = r0;
      r1 = r1 - I6;
84205218:	00 00 36 67 	r1 = r1 - I6;
      M[I1, 0] = r1;            //shift
8420521c:	00 b4 00 03 	Null = Null + Null, M[I1,0] = r1;
      rMAC = r0;
84205220:	0f 00 12 00 	rMAC = r0 + Null;
      call $math.log2_table;
84205224:	07 00 00 fd 	call 0x745ac;
84205228:	ac 45 f0 e1 
      r1 = M[I1, MK1];
8420522c:	00 35 00 03 	Null = Null + Null, r1 = M[I1,4];
      r1 = r1 + 13;   //adjust scale 
84205230:	0d 00 33 01 	r1 = r1 + 13;
      r1 = r1 ASHIFT (DAWTH - 8);       
84205234:	18 00 33 91 	r1 = r1 ASHIFT 24;
      r0 = r0 + r1;
84205238:	00 00 23 03 	r0 = r0 + r1;
      M[I5, MK1] = r0;
8420523c:	a5 00 00 03 	Null = Null + Null, M[I5,4] = r0;
      M3 = M3 - 1;
84205240:	01 00 bb 79 	M3 = M3 - 1;
   if NZ jump calc_bande_loop;
84205244:	e1 ff 10 dd 	if NE jump $M.celt.compute_band_energies.calc_bande_loop;

   // pop rLink from stack
   jump $pop_rLink_and_rts;
84205248:	03 00 00 fd 	jump (m) 0x3b020;
8420524c:	21 b0 f0 dd 

84205250 <$celt.normalise_bands>:
.MODULE $M.celt.normalise_bands;
   .CODESEGMENT CELT_NORMALISE_BANDS_PM;
   .DATASEGMENT DM;
   $celt.normalise_bands:
   // push rLink onto stack
   push rlink;
84205250:	00 00 d0 f3 	push rLink;

#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.NORMALISE_BANDS.PATCH_ID_0,r1)     // celt_patchers
#endif
   
   r0 = M[r5 + $celt.enc.MODE_NB_EBANDS_FIELD];
84205254:	48 00 27 d1 	r0 = M[r5 + 72];
   M3 = r0;
84205258:	2f 00 b0 50 	M3 = Null + r0;
   r0 = M[r5 + $celt.enc.MODE_EBANDS_ADDR_FIELD];
8420525c:	60 00 27 d1 	r0 = M[r5 + 96];
   I3 = r0;
84205260:	2f 00 30 50 	I3 = Null + r0;
   I6 = r2;
84205264:	4f 00 60 50 	I6 = Null + r2;

84205268 <$M.celt.normalise_bands.norm_bands_loop>:
   norm_bands_loop:
      r0 = M[I3, MK1];
84205268:	00 2d 00 03 	Null = Null + Null, r0 = M[I3,4];
      r1 = M[I3, 0];
8420526c:	00 3c 00 03 	Null = Null + Null, r1 = M[I3,0];
      r10 = r1 - r0;
84205270:	2f 00 c3 20 	r10 = r1 - r0;
      r10 = r10 - 1;
84205274:	3f 00 cc e4 	r10 = r10 - 1;
      r0 = M[I1, MK1];   //gain
84205278:	00 25 00 03 	Null = Null + Null, r0 = M[I1,4];
      r1 = M[I1, MK1];   //shift
8420527c:	00 35 00 03 	Null = Null + Null, r1 = M[I1,4];
      r1 = r1 + I6;
84205280:	00 00 36 47 	r1 = r1 + I6;
      r1 = 1 - r1;
84205284:	01 00 33 65 	r1 = 1 - r1;
      rMAC = 0.125;
84205288:	00 10 00 fd 	rMAC = Null + 268435456;
8420528c:	00 00 10 01 
      Div = rMAC/ r0;
84205290:	00 00 12 d9 	Div = rMAC / r0;
      r0 = DivResult;
84205294:	01 00 20 d9 	r0 = DivResult;
      r2 = M[I2, MK1];
84205298:	00 49 00 03 	Null = Null + Null, r2 = M[I2,4];
      rMAC = r2 * r0;
8420529c:	2f 00 14 cc 	rMAC = r2 * r0 (SS);
      do normalize_band_loop;
842052a0:	03 00 f0 e5 	do $M.celt.normalise_bands.normalize_band_loop;
         rMAC = rMAC ASHIFT r1 (56bit), r2 = M[I2, MK1];
842052a4:	00 49 13 93 	rMAC = rMAC ASHIFT r1 (56bit), r2 = M[I2,4];
         rMAC = r2 * r0, M[I5, MK1] = rMAC;         
842052a8:	95 00 42 cf 	rMAC = r2 * r0 (SS), M[I5,4] = rMAC;

842052ac <$M.celt.normalise_bands.normalize_band_loop>:
      normalize_band_loop:
      rMAC = rMAC ASHIFT r1 (56bit);
842052ac:	00 00 13 93 	rMAC = rMAC ASHIFT r1 (56bit);
      M[I5, MK1] = rMAC; 
842052b0:	95 00 00 03 	Null = Null + Null, M[I5,4] = rMAC;
   M3 = M3 - 1;
842052b4:	01 00 bb 79 	M3 = M3 - 1;
   if NZ jump norm_bands_loop; 
842052b8:	ec ff 10 dd 	if NE jump $M.celt.normalise_bands.norm_bands_loop;
   r0 = M[I3, MK1];
842052bc:	00 2d 00 03 	Null = Null + Null, r0 = M[I3,4];
   r1 = M[I3, 0];
842052c0:	00 3c 00 03 	Null = Null + Null, r1 = M[I3,0];
   r10 = r1 - r0;
842052c4:	2f 00 c3 20 	r10 = r1 - r0;
   r0 = 0;
842052c8:	00 00 20 01 	r0 = Null + 0;
   do zero_last_band;
842052cc:	02 00 f0 e5 	do $M.celt.normalise_bands.zero_last_band;
       M[I5, MK1] = r0;
842052d0:	a5 00 00 03 	Null = Null + Null, M[I5,4] = r0;

842052d4 <$M.celt.normalise_bands.zero_last_band>:
   zero_last_band:
   
   // pop rLink from stack
   jump $pop_rLink_and_rts;
842052d4:	03 00 00 fd 	jump (m) 0x3b020;
842052d8:	21 b0 f0 dd 

842052dc <$celt.bands_process>:
.MODULE $M.celt.bands_process;
   .CODESEGMENT CELT_BAND_PROCESS_PM;
   .DATASEGMENT DM;
   $celt.bands_process:
   // push rLink onto stack
   push rlink;
842052dc:	00 00 d0 f3 	push rLink;
#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.BANDS_PROCESS.PATCH_ID_0,r2)     // celt_patchers
#endif
   
   // -- compute band energies (left channel)
   r2 = M[r5 + $celt.enc.MAX_SBAND + 0 * ADDR_PER_WORD];
842052e0:	f8 01 47 d1 	r2 = M[r5 + 504];
   r0 = M[r5 + $celt.enc.FREQ_FIELD];
842052e4:	14 01 27 d1 	r0 = M[r5 + 276];
   I2 = r0;
842052e8:	2f 00 20 50 	I2 = Null + r0;
   r0 = M[r5 + $celt.enc.BANDE_FIELD];
842052ec:	d0 00 27 d1 	r0 = M[r5 + 208];
   I1 = r0;
842052f0:	2f 00 10 50 	I1 = Null + r0;
   r0 = M[r5 + $celt.enc.LOG_BANDE_FIELD];
842052f4:	dc 00 27 d1 	r0 = M[r5 + 220];
   I5 = r0;
842052f8:	2f 00 50 50 	I5 = Null + r0;
   call $celt.compute_band_energies;
842052fc:	ad ff f0 e1 	call $celt.compute_band_energies;

   // -- nomalise bands (left channel)
   r2 = M[r5 + $celt.enc.MAX_SBAND + 0 * ADDR_PER_WORD];
84205300:	f8 01 47 d1 	r2 = M[r5 + 504];
   r0 = M[r5 + $celt.enc.FREQ_FIELD];
84205304:	14 01 27 d1 	r0 = M[r5 + 276];
   I2 = r0;
84205308:	2f 00 20 50 	I2 = Null + r0;
   r0 = M[r5 + $celt.enc.BANDE_FIELD];
8420530c:	d0 00 27 d1 	r0 = M[r5 + 208];
   I1 = r0;
84205310:	2f 00 10 50 	I1 = Null + r0;
   r0 = M[r5 + $celt.enc.NORM_FREQ_FIELD];
84205314:	cc 00 27 d1 	r0 = M[r5 + 204];
   I5 = r0;
84205318:	2f 00 50 50 	I5 = Null + r0;
   call $celt.normalise_bands;
8420531c:	cd ff f0 e1 	call $celt.normalise_bands;
   
   // -- return if it's mono encoding
   r0 = M[r5 + $celt.enc.CELT_CHANNELS_FIELD];
84205320:	08 00 27 d1 	r0 = M[r5 + 8];
   if Z  jump $pop_rLink_and_rts;
84205324:	03 00 00 fd 	if EQ jump (m) 0x3b020;
84205328:	21 b0 00 dd 
   
   // -- compute band energies (right channel)
   r2 = M[r5 + $celt.enc.MAX_SBAND + 1 * ADDR_PER_WORD];
8420532c:	fc 01 47 d1 	r2 = M[r5 + 508];
   r0 = M[r5 + $celt.enc.FREQ2_FIELD];
84205330:	18 01 27 d1 	r0 = M[r5 + 280];
   I2 = r0;
84205334:	2f 00 20 50 	I2 = Null + r0;
   r0 = M[r5 + $celt.enc.BANDE_FIELD];
84205338:	d0 00 27 d1 	r0 = M[r5 + 208];
   I1 = r0 + ($celt.MAX_BANDSx2 * MK1);
8420533c:	c8 00 12 51 	I1 = r0 + 200;
   
   r0 = M[r5 + $celt.enc.LOG_BANDE_FIELD];
84205340:	dc 00 27 d1 	r0 = M[r5 + 220];
   I5 = r0 + ($celt.MAX_BANDS * MK1);
84205344:	64 00 52 51 	I5 = r0 + 100;
   call $celt.compute_band_energies;
84205348:	9a ff f0 e1 	call $celt.compute_band_energies;

   // -- normalise bands (right channel)
   r2 = M[r5 + $celt.enc.MAX_SBAND + 1 * ADDR_PER_WORD];
8420534c:	fc 01 47 d1 	r2 = M[r5 + 508];
   r0 = M[r5 + $celt.enc.FREQ2_FIELD];
84205350:	18 01 27 d1 	r0 = M[r5 + 280];
   I2 = r0;
84205354:	2f 00 20 50 	I2 = Null + r0;
   r0 = M[r5 + $celt.enc.BANDE_FIELD];
84205358:	d0 00 27 d1 	r0 = M[r5 + 208];
   I1 = r0 + ($celt.MAX_BANDSx2 * MK1);
8420535c:	c8 00 12 51 	I1 = r0 + 200;
   
   r0 = M[r5 + $celt.enc.NORM_FREQ_FIELD];
84205360:	cc 00 27 d1 	r0 = M[r5 + 204];
   r1 = M[r5 + $celt.enc.MODE_MDCT_SIZE_FIELD];
84205364:	44 00 37 d1 	r1 = M[r5 + 68];
   Words2Addr(r1);
84205368:	02 00 33 91 	r1 = r1 ASHIFT 2;
   I5 = r0 + r1;
8420536c:	3f 00 52 50 	I5 = r0 + r1;
   call $celt.normalise_bands;
84205370:	b8 ff f0 e1 	call $celt.normalise_bands;
      
   // pop rLink from stack
   jump $pop_rLink_and_rts;
84205374:	03 00 00 fd 	jump (m) 0x3b020;
84205378:	21 b0 f0 dd 

8420537c <$celt.compute_allocation>:
8420537c:	00 00 d0 f3 	push rLink;
#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.COMPUTE_ALLOCATION.PATCH_ID_0,r4)     // celt_patchers
#endif

   // see how many bits used so far
   r4 = 0;
84205380:	00 00 60 01 	r4 = Null + 0;
   r0 = M[r5 + $celt.dec.TELL_FUNC_FIELD];
84205384:	30 00 27 d1 	r0 = M[r5 + 48];
   call r0;
84205388:	0f 00 02 e0 	call r0;

   // calc bits available
   r3 = M[r5 + $celt.dec.CELT_CODEC_FRAME_SIZE_FIELD];
8420538c:	04 00 57 d1 	r3 = M[r5 + 4];
   r3 = r3 * 8 (int);
84205390:	08 00 55 99 	r3 = r3 * 8 (int);
   r3 = r3 - r0;
84205394:	00 00 52 23 	r3 = r3 - r0;
   r3 = r3 - 1;
84205398:	3f 00 55 e4 	r3 = r3 - 1;
   r3 = r3 LSHIFT $celt.BITRES;
8420539c:	04 00 55 8d 	r3 = r3 LSHIFT 4;
   // init:  r6 = lo, r7 = hi
   r6 = 0;
842053a0:	00 00 80 01 	r6 = Null + 0;
   r7 = M[r5 + $celt.dec.MODE_NB_ALLOC_VECTORS_FIELD];
842053a4:	54 00 97 d1 	r7 = M[r5 + 84];
   r7 = r7 - 1;   
842053a8:	3f 00 99 e4 	r7 = r7 - 1;

842053ac <$M.celt.compute_allocation.find_lo_hi_loop>:
   find_lo_hi_loop:
   r0 = r7 - r6;
842053ac:	8f 00 29 20 	r0 = r7 - r6;
   Null = r0 - 1;
842053b0:	3f 00 02 e4 	Null = r0 - 1;
   if Z jump end_bits_loop;
842053b4:	16 00 00 dd 	if EQ jump $M.celt.compute_allocation.end_bits_loop;
      r4 = r6 + r7;
842053b8:	9f 00 68 00 	r4 = r6 + r7;
      r4 = r4 LSHIFT -1;
842053bc:	ff 00 66 8d 	r4 = r4 LSHIFT -1;
      r10 = M[r5 + $celt.dec.MODE_NB_EBANDS_FIELD];
842053c0:	48 00 c7 d1 	r10 = M[r5 + 72];
      r0 = r10*r4(int);
842053c4:	6f 00 2c 98 	r0 = r10 * r4 (int);
      Words2Addr(r0);
842053c8:	02 00 22 91 	r0 = r0 ASHIFT 2;
      r10 = r10 - 1;
842053cc:	3f 00 cc e4 	r10 = r10 - 1;
      r1 = M[r5 + $celt.dec.MODE_ALLOC_VECTORS_ADDR_FIELD];
842053d0:	64 00 37 d1 	r1 = M[r5 + 100];
      I6 = r1 + r0;
842053d4:	2f 00 63 50 	I6 = r1 + r0;
      r1 = r1 - r1, r0 = M[I6, MK1];      
842053d8:	29 00 33 23 	r1 = r1 - r1, r0 = M[I6,4];
      do bits1_loop;
842053dc:	02 00 f0 e5 	do $M.celt.compute_allocation.bits1_loop;
         r1 = r1 + r0, r0 = M[I6, MK1];
842053e0:	29 00 32 03 	r1 = r1 + r0, r0 = M[I6,4];

842053e4 <$M.celt.compute_allocation.bits1_loop>:
      bits1_loop:
      r1 = r1 + r0;
842053e4:	00 00 32 03 	r1 = r1 + r0;
      r2 = (1<<$celt.BITRES);
842053e8:	10 00 40 01 	r2 = Null + 16;
      r0 = M[r5 + $celt.dec.CELT_CHANNELS_FIELD];
842053ec:	08 00 27 d1 	r0 = M[r5 + 8];
      if NZ r2 = r2 + r2;
842053f0:	41 00 44 00 	if NE r2 = r2 + r2;
      r1 = r1 * r2 (int);
842053f4:	00 00 34 9b 	r1 = r1 * r2 (int);
      Null = r1 - r3;
842053f8:	5f 00 03 20 	Null = r1 - r3;
      if GT r7 = r4;
842053fc:	0c 00 96 00 	if GT r7 = r4 + Null;
      Null = r1 - r3;
84205400:	5f 00 03 20 	Null = r1 - r3;
      if LE r6 = r4;
84205404:	0d 00 86 00 	if LE r6 = r4 + Null;
   jump find_lo_hi_loop;
84205408:	e9 ff f0 dd 	jump $M.celt.compute_allocation.find_lo_hi_loop;

8420540c <$M.celt.compute_allocation.end_bits_loop>:
   end_bits_loop:
   r10 = M[r5 + $celt.dec.MODE_NB_EBANDS_FIELD];
8420540c:	48 00 c7 d1 	r10 = M[r5 + 72];
   r0 = r6*r10(int);
84205410:	cf 00 28 98 	r0 = r6 * r10 (int);
   Words2Addr(r0);
84205414:	02 00 22 91 	r0 = r0 ASHIFT 2;
   r1 = M[r5 + $celt.dec.MODE_ALLOC_VECTORS_ADDR_FIELD];
84205418:	64 00 37 d1 	r1 = M[r5 + 100];
   I5 = r0 + r1;
8420541c:	3f 00 52 50 	I5 = r0 + r1;
   r0 = r7*r10(int);
84205420:	cf 00 29 98 	r0 = r7 * r10 (int);
   Words2Addr(r0);
84205424:	02 00 22 91 	r0 = r0 ASHIFT 2;
   I6 = r0 + r1;
84205428:	3f 00 62 50 	I6 = r0 + r1;
   r0 = M[r5 + $celt.dec.BITS1_FIELD];
8420542c:	bc 00 27 d1 	r0 = M[r5 + 188];
   I2 = r0;
84205430:	2f 00 20 50 	I2 = Null + r0;
   r0 = M[r5 + $celt.dec.BITS2_FIELD];
84205434:	c0 00 27 d1 	r0 = M[r5 + 192];
   I3 = r0;
84205438:	2f 00 30 50 	I3 = Null + r0;
   r2 = 1;
8420543c:	2f 00 40 e4 	r2 = Null + 1;
   r0 = M[r5 + $celt.dec.CELT_CHANNELS_FIELD];
84205440:	08 00 27 d1 	r0 = M[r5 + 8];
   if NZ r2 = r2 + r2;
84205444:	41 00 44 00 	if NE r2 = r2 + r2;
   r10 = r10 - 1;
84205448:	3f 00 cc e4 	r10 = r10 - 1;
   r1 = M[I6, MK1];
8420544c:	39 00 00 03 	Null = Null + Null, r1 = M[I6,4];
   r1 = r1 * r2(int), r0 = M[I5, MK1];
84205450:	25 00 34 9b 	r1 = r1 * r2 (int), r0 = M[I5,4];
   do bits_loop;
84205454:	03 00 f0 e5 	do $M.celt.compute_allocation.bits_loop;
      r0 = r0 * r2(int), r1= M[I6, MK1], M[I3, MK1] = r1;
84205458:	39 bd 24 9b 	r0 = r0 * r2 (int), M[I3,4] = r1, r1 = M[I6,4];
      r1 = r1 * r2(int), r0= M[I5, MK1], M[I2, MK1] = r0;
8420545c:	25 a9 34 9b 	r1 = r1 * r2 (int), M[I2,4] = r0, r0 = M[I5,4];

84205460 <$M.celt.compute_allocation.bits_loop>:
   bits_loop:
   r0 = r0 * r2(int), M[I3, MK1] = r1;
84205460:	00 bd 24 9b 	r0 = r0 * r2 (int), M[I3,4] = r1;
   M[I2, MK1] = r0;
84205464:	00 a9 00 03 	Null = Null + Null, M[I2,4] = r0;
   
   call  $celt.interp_bits2pulses;
84205468:	03 00 f0 e1 	call $celt.interp_bits2pulses;

   // pop rLink from stack
   jump $pop_rLink_and_rts;
8420546c:	03 00 00 fd 	jump (m) 0x3b020;
84205470:	21 b0 f0 dd 

84205474 <$celt.interp_bits2pulses>:
   .CODESEGMENT CELT_INTERP_BITS2PULSES_PM;
   .DATASEGMENT DM;
   
   $celt.interp_bits2pulses:
   // push rLink onto stack
   push rlink;
84205474:	00 00 d0 f3 	push rLink;

#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.INTERP_BITS2PULSES.PATCH_ID_0,r6)     // celt_patchers
#endif
   
   r6 = 0;
84205478:	00 00 80 01 	r6 = Null + 0;
   r7 = 1<<$celt.BITRES;
8420547c:	10 00 90 01 	r7 = Null + 16;
   M0 = ADDR_PER_WORD;
84205480:	04 00 80 51 	M0 = Null + 4;

84205484 <$M.celt.interp_bits2pulses.find_hi_lo_loop>:
   find_hi_lo_loop:
   r0 = r7 - r6;
84205484:	8f 00 29 20 	r0 = r7 - r6;
   Null = r0 - 1;
84205488:	3f 00 02 e4 	Null = r0 - 1;
   if Z jump find_hi_lo_loop_end;
8420548c:	17 00 00 dd 	if EQ jump $M.celt.interp_bits2pulses.find_hi_lo_loop_end;
      r4 = r6 + r7;
84205490:	9f 00 68 00 	r4 = r6 + r7;
      r4 = r4 LSHIFT -1;
84205494:	ff 00 66 8d 	r4 = r4 LSHIFT -1;
      r10 = M[r5 + $celt.dec.MODE_NB_EBANDS_FIELD];
84205498:	48 00 c7 d1 	r10 = M[r5 + 72];
      r10 = r10 - 1;
8420549c:	3f 00 cc e4 	r10 = r10 - 1;
      r2 = 1<<$celt.BITRES;
842054a0:	10 00 40 01 	r2 = Null + 16;
      r2 = r2 - r4;
842054a4:	00 00 46 23 	r2 = r2 - r4;
      r0 = M[r5 + $celt.dec.BITS1_FIELD];
842054a8:	bc 00 27 d1 	r0 = M[r5 + 188];
      I2 = r0;
842054ac:	2f 00 20 50 	I2 = Null + r0;
      r0 = M[r5 + $celt.dec.BITS2_FIELD];
842054b0:	c0 00 27 d1 	r0 = M[r5 + 192];
      I3 = r0;
842054b4:	2f 00 30 50 	I3 = Null + r0;
      rMAC = 0, r0 = M[I2, MK1];
842054b8:	00 29 11 23 	rMAC = rMAC - rMAC, r0 = M[I2,4];
      rMAC = rMAC + r0*r2, r0 = M[I3, MK1];
842054bc:	00 2d 24 af 	rMAC = rMAC + r0 * r2 (SS), r0 = M[I3,4];
      do avg_loop1;
842054c0:	03 00 f0 e5 	do $M.celt.interp_bits2pulses.avg_loop1;
         rMAC = rMAC + r0*r4, r0 = M[I2, MK1];
842054c4:	00 29 26 af 	rMAC = rMAC + r0 * r4 (SS), r0 = M[I2,4];
         rMAC = rMAC + r0*r2, r0 = M[I3, MK1];
842054c8:	00 2d 24 af 	rMAC = rMAC + r0 * r2 (SS), r0 = M[I3,4];

842054cc <$M.celt.interp_bits2pulses.avg_loop1>:
      avg_loop1:
      rMAC = rMAC + r0*r4;
842054cc:	6f 00 12 ac 	rMAC = rMAC + r0 * r4 (SS);
      r0 = rMAC LSHIFT (DAWTH-1);
842054d0:	1f 00 21 8d 	r0 = rMAC LSHIFT 31;
      Null = r0 - r3;
842054d4:	5f 00 02 20 	Null = r0 - r3;
      if GT r7 = r4;
842054d8:	0c 00 96 00 	if GT r7 = r4 + Null;
      Null = r0 - r3;
842054dc:	5f 00 02 20 	Null = r0 - r3;
      if LE r6 = r4;
842054e0:	0d 00 86 00 	if LE r6 = r4 + Null;
   jump find_hi_lo_loop;
842054e4:	e8 ff f0 dd 	jump $M.celt.interp_bits2pulses.find_hi_lo_loop;

842054e8 <$M.celt.interp_bits2pulses.find_hi_lo_loop_end>:
   
   find_hi_lo_loop_end:
   r0 = M[r5 + $celt.dec.BITS1_FIELD];
842054e8:	bc 00 27 d1 	r0 = M[r5 + 188];
   I2 = r0;
842054ec:	2f 00 20 50 	I2 = Null + r0;
   r0 = M[r5 + $celt.dec.BITS2_FIELD];
842054f0:	c0 00 27 d1 	r0 = M[r5 + 192];
   I3 = r0;
842054f4:	2f 00 30 50 	I3 = Null + r0;
   r0 = M[r5 + $celt.dec.PULSES_FIELD];
842054f8:	04 01 27 d1 	r0 = M[r5 + 260];
   I4 = r0;
842054fc:	2f 00 40 50 	I4 = Null + r0;
   r10 = M[r5 + $celt.dec.MODE_NB_EBANDS_FIELD];
84205500:	48 00 c7 d1 	r10 = M[r5 + 72];
   r2 = 1<<$celt.BITRES;
84205504:	10 00 40 01 	r2 = Null + 16;
   r2 = r2 - r6;
84205508:	00 00 48 23 	r2 = r2 - r6;
   rMAC = 0, r0 = M[I2, MK1];
8420550c:	00 29 11 23 	rMAC = rMAC - rMAC, r0 = M[I2,4];
   do avg_loop2;
84205510:	05 00 f0 e5 	do $M.celt.interp_bits2pulses.avg_loop2;
      r0 = r0*r2 (int), r1 = M[I3, MK1];
84205514:	00 3d 24 9b 	r0 = r0 * r2 (int), r1 = M[I3,4];
      r1 = r1 * r6 (int);
84205518:	00 00 38 9b 	r1 = r1 * r6 (int);
      r4 = r1 + r0, r0 = M[I2, M0];
8420551c:	2f 28 63 00 	r4 = r1 + r0, r0 = M[I2,M0];
      rMAC = rMAC + r4, M[I4, MK1] = r4;
84205520:	e1 00 16 03 	rMAC = rMAC + r4, M[I4,4] = r4;

84205524 <$M.celt.interp_bits2pulses.avg_loop2>:
   avg_loop2:   
   
   r10 = M[r5 + $celt.dec.MODE_NB_EBANDS_FIELD];
84205524:	48 00 c7 d1 	r10 = M[r5 + 72];
   rMAC = r3 - rMAC;
84205528:	1f 00 15 20 	rMAC = r3 - rMAC;
   rMAC0 = rMAC1;
8420552c:	00 05 e1 8d 	rMAC0 = rMAC LSHIFT 0;
   rMAC12 = Null(ZP);
84205530:	00 04 e0 8d 	rMAC12 = Null LSHIFT 0;
   Div = rMAC/r10;
84205534:	00 00 1c d9 	Div = rMAC / r10;
   r0 = M[r5 + $celt.dec.PULSES_FIELD];
84205538:	04 01 27 d1 	r0 = M[r5 + 260];
   I2 = r0;
8420553c:	2f 00 20 50 	I2 = Null + r0;
   I3 = I2;
84205540:	0f 00 32 58 	I3 = I2 + Null;
   r0 = M[I2, M0];   
84205544:	00 28 00 02 	Null = Null + Null, r0 = M[I2,M0];
   r2 = DivResult;
84205548:	01 00 40 d9 	r2 = DivResult;
   do add_per_band_loop;
8420554c:	03 00 f0 e5 	do $M.celt.interp_bits2pulses.add_per_band_loop;
      r1 = r0 +  r2, r0 = M[I2, M0];
84205550:	4f 28 32 00 	r1 = r0 + r2, r0 = M[I2,M0];
      M[I3, M0] = r1;
84205554:	00 bc 00 02 	Null = Null + Null, M[I3,M0] = r1;

84205558 <$M.celt.interp_bits2pulses.add_per_band_loop>:
   add_per_band_loop:
   
   r10 = DivRemainder;
84205558:	02 00 c0 d9 	r10 = DivRemainder;
   r2 = 1;
8420555c:	2f 00 40 e4 	r2 = Null + 1;
   r0 = M[r5 + $celt.dec.PULSES_FIELD];
84205560:	04 01 27 d1 	r0 = M[r5 + 260];
   I2 = r0;
84205564:	2f 00 20 50 	I2 = Null + r0;
   I3 = I2, r0 = M[I2, M0];   
84205568:	0f 28 32 58 	I3 = I2 + Null, r0 = M[I2,M0];
   do add_reamin_loop;
8420556c:	03 00 f0 e5 	do $M.celt.interp_bits2pulses.add_reamin_loop;
      r1 = r0 +  r2, r0 = M[I2, M0];
84205570:	4f 28 32 00 	r1 = r0 + r2, r0 = M[I2,M0];
      M[I3, M0] = r1;
84205574:	00 bc 00 02 	Null = Null + Null, M[I3,M0] = r1;

84205578 <$M.celt.interp_bits2pulses.add_reamin_loop>:
   add_reamin_loop:  
   
   r3 = M[r5 + $celt.dec.MODE_NB_EBANDS_FIELD];
84205578:	48 00 57 d1 	r3 = M[r5 + 72];
   Words2Addr(r3);
8420557c:	02 00 55 91 	r3 = r3 ASHIFT 2;
   M3 = r3;
84205580:	5f 00 b0 50 	M3 = Null + r3;
   M1 = 0;
84205584:	00 00 90 51 	M1 = Null + 0;
   r0 = M[r5 + $celt.dec.MODE_EBANDS_ADDR_FIELD];
84205588:	60 00 27 d1 	r0 = M[r5 + 96];
   I3 = r0;
8420558c:	2f 00 30 50 	I3 = Null + r0;
   r0 = M[r5 + $celt.dec.PULSES_FIELD];
84205590:	04 01 27 d1 	r0 = M[r5 + 260];
   I2 = r0;        
84205594:	2f 00 20 50 	I2 = Null + r0;
   r0 = M[r5 + $celt.dec.FINE_QUANT_FIELD];
84205598:	08 01 27 d1 	r0 = M[r5 + 264];
   I6 = r0;     
8420559c:	2f 00 60 50 	I6 = Null + r0;
   r0 = M[r5 + $celt.dec.FINE_PRIORITY_FIELD];
842055a0:	0c 01 27 d1 	r0 = M[r5 + 268];
   I7 = r0;  //fine-pr
842055a4:	2f 00 70 50 	I7 = Null + r0;
   r0 = M[I3, MK1];   //ebands[j];
842055a8:	00 2d 00 03 	Null = Null + Null, r0 = M[I3,4];
   r1 = M[I3, 0];   
842055ac:	00 3c 00 03 	Null = Null + Null, r1 = M[I3,0];

842055b0 <$M.celt.interp_bits2pulses.loop_calc_bits>:
   //N=r1
   loop_calc_bits:
      r1 = r1 - r0; 
842055b0:	00 00 32 23 	r1 = r1 - r0;
      push r1;         //save r1
842055b4:	00 00 30 f3 	push r1;
      rMAC = 0;        //rMAC=N
842055b8:	00 00 10 01 	rMAC = Null + 0;
      rMAC0 = r1;
842055bc:	00 05 e3 8d 	rMAC0 = r1 LSHIFT 0;
      r0 = $celt.BITRES; 
842055c0:	bf 00 20 e4 	r0 = Null + 4;
      call $celt.log2_frac;       
842055c4:	4a 01 f0 e1 	call $celt.log2_frac;
      r3 = $celt.FINE_OFFSET - r0; 
842055c8:	32 00 52 65 	r3 = 50 - r0;
      //offset = r3
      pop r1;
842055cc:	00 00 34 f3 	pop r1;
      r0 = M[r5 + $celt.dec.CELT_CHANNELS_FIELD]; 
842055d0:	08 00 27 d1 	r0 = M[r5 + 8];
      r4 = r0*r1(int);                            
842055d4:	3f 00 62 98 	r4 = r0 * r1 (int);
      r4 = r4 + r1;                               
842055d8:	00 00 63 03 	r4 = r4 + r1;
      r2 = r4 + r0;                               
842055dc:	2f 00 46 00 	r2 = r4 + r0;
      r2 = r2 LSHIFT $celt.BITRES;                
842055e0:	04 00 44 8d 	r2 = r2 LSHIFT 4;
      r4 = r4 *r3(int), r1 = M[I2, 0];            
842055e4:	00 38 65 9b 	r4 = r4 * r3 (int), r1 = M[I2,0];
      r4 = r1 - r4;                               
842055e8:	6f 00 63 20 	r4 = r1 - r4;
      r1 = r0 LSHIFT $celt.BITRES;                
842055ec:	04 00 32 8d 	r1 = r0 LSHIFT 4;
      r4 = r4 - r1;                               
842055f0:	00 00 63 23 	r4 = r4 - r1;
      if NEG r4 = 0; 
842055f4:	04 00 60 00 	if NEG r4 = Null + Null;
      //r4 = offset
      r1 = r2 + r2;                               
842055f8:	4f 00 34 00 	r1 = r2 + r2;
      r6 = r4 + r4;                               
842055fc:	6f 00 86 00 	r6 = r4 + r4;
      r6 = r6 + r2;                               
84205600:	00 00 84 03 	r6 = r6 + r2;
      rMAC = 0;
84205604:	00 00 10 01 	rMAC = Null + 0;
      rMAC0 = r6;
84205608:	00 05 e8 8d 	rMAC0 = r6 LSHIFT 0;
      Div = rMAC / r1; 
8420560c:	00 00 13 d9 	Div = rMAC / r1;
      r6 = DivResult;                             
84205610:	01 00 80 d9 	r6 = DivResult;
      r3 = r6 * r2 (int);                         
84205614:	4f 00 58 98 	r3 = r6 * r2 (int);
      r1 = 1;
84205618:	2f 00 30 e4 	r1 = Null + 1;
      Null = r3 - r4;
8420561c:	6f 00 05 20 	Null = r3 - r4;
      if NEG r1 = r1 - r1, r3 = M[I2, M1];
84205620:	34 59 33 20 	if NEG r1 = r1 - r1, r3 = M[I2,M1];
      //r1 = fine-p
      r2 = r6 LSHIFT r0; //r7=eb(j)*C
84205624:	2f 00 48 8c 	r2 = r6 LSHIFT r0;
      r4 = r3 LSHIFT (-$celt.BITRES);
84205628:	fc 00 65 8d 	r4 = r3 LSHIFT -4;
      Null = r2 - r4;                     
8420562c:	6f 00 04 20 	Null = r2 - r4;
      if GT r2 = r4;
84205630:	0c 00 46 00 	if GT r2 = r4 + Null;
      r6 = -r0;
84205634:	2f 00 80 20 	r6 = Null - r0;
      r2 = r2 LSHIFT r6, M[I7, MK1] = r1; 
84205638:	bd 00 48 8f 	r2 = r2 LSHIFT r6, M[I7,4] = r1;
      r7 = r2 - 7;
8420563c:	07 00 94 21 	r7 = r2 - 7;
      if POS r2 = r2 - r7;
84205640:	95 00 44 20 	if POS r2 = r2 - r7;
      r0 = r0 + $celt.BITRES;
84205644:	bf 00 22 e4 	r0 = r0 + 4;
      r2 = r2 LSHIFT r0, M[I6, MK1] = r2;
84205648:	c9 00 42 8f 	r2 = r2 LSHIFT r0, M[I6,4] = r2;
      r3 = r3 - r2, r0 = M[I3, MK1];
8420564c:	00 2d 54 23 	r3 = r3 - r2, r0 = M[I3,4];
      if NEG r3 = r3 - r3, r1 = M[I3, M1];
84205650:	54 3d 55 20 	if NEG r3 = r3 - r3, r1 = M[I3,M1];
      M3 = M3 - M0, M[I2, MK1] = r3;
84205654:	00 d9 b8 7f 	M3 = M3 - M0, M[I2,4] = r3;
   if NZ jump   loop_calc_bits;    
84205658:	d6 ff 10 dd 	if NE jump $M.celt.interp_bits2pulses.loop_calc_bits;
   // pop rLink from stack
   jump $pop_rLink_and_rts;
8420565c:	03 00 00 fd 	jump (m) 0x3b020;
84205660:	21 b0 f0 dd 

84205664 <$celt.decode_flags>:
84205664:	01 20 00 f1 	pushm <FP(=SP), rLink>;

   // push rLink onto stack
   .CONST FLAG_BITS            (0 + 2)*ADDR_PER_WORD;
   .CONST STACK_FRAME_SIZE     1*ADDR_PER_WORD;
   pushm <FP(=SP), rLink>;
   SP = SP + STACK_FRAME_SIZE;
84205668:	04 00 03 f1 	SP = SP + 4;
#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.DECODE_FLAGS.PATCH_ID_0,r1)     // celt_patchers
#endif   
   
   // read flags
   r0 = 4;
8420566c:	bf 00 20 e4 	r0 = Null + 4;
   r1 = 0;
84205670:	00 00 30 01 	r1 = Null + 0;
   call $celt.ec_dec_uint;
84205674:	71 f2 f0 e1 	call $celt.ec_dec_uint;
   M[FP + FLAG_BITS] = r0;   
84205678:	08 00 2c f1 	M[FP + 0x8] = r0;
   Null = r0 - 2;
8420567c:	cf 00 02 e4 	Null = r0 - 2;
   if NZ jump test_for_fb3;
84205680:	07 00 10 dd 	if NE jump $M.celt.decode_flags.test_for_fb3;
      // flag bits = 2
      r0 = 4;
84205684:	bf 00 20 e4 	r0 = Null + 4;
      r1 = 0;
84205688:	00 00 30 01 	r1 = Null + 0;
      call $celt.ec_dec_uint;
8420568c:	6b f2 f0 e1 	call $celt.ec_dec_uint;
      r4 = M[FP + FLAG_BITS];
84205690:	08 00 68 f1 	r4 = M[FP + 0x8];
      r4 = r4 LSHIFT 2;
84205694:	02 00 66 8d 	r4 = r4 LSHIFT 2;
      r0 = r0 OR r4;
84205698:	00 00 26 87 	r0 = r0 OR r4;

8420569c <$M.celt.decode_flags.test_for_fb3>:
   test_for_fb3:
   Null = r0 - 3;
8420569c:	03 00 02 21 	Null = r0 - 3;
   if NZ jump flag_list_ver;
842056a0:	06 00 10 dd 	if NE jump $M.celt.decode_flags.flag_list_ver;
      // flag bits = 3
      r0 = 2;
842056a4:	af 00 20 e4 	r0 = Null + 2;
      call $celt.ec_dec_uint;
842056a8:	64 f2 f0 e1 	call $celt.ec_dec_uint;
      r4 = M[FP + FLAG_BITS];
842056ac:	08 00 68 f1 	r4 = M[FP + 0x8];
      r4 = r4 LSHIFT 1;
842056b0:	01 00 66 8d 	r4 = r4 LSHIFT 1;
      r0 = r0 OR r4;
842056b4:	00 00 26 87 	r0 = r0 OR r4;

842056b8 <$M.celt.decode_flags.flag_list_ver>:
   flag_list_ver:    
   // verify it is a valid flag
   r10 = 8;
842056b8:	08 00 c0 01 	r10 = Null + 8;
#ifdef CELT_USE_EXTERNAL_MEMORY
   r1 = M[r5 + $celt.dec.PTR_FLAGLIST_TABLE_FIELD];
842056bc:	10 02 37 d1 	r1 = M[r5 + 528];
   I2 = r1;
842056c0:	3f 00 20 50 	I2 = Null + r1;
#else // CELT_USE_EXTERNAL_MEMORY
   I2 = &$celt.flaglist;
#endif // CELT_USE_EXTERNAL_MEMORY
   r1 = M[I2, MK1];
842056c4:	00 39 00 03 	Null = Null + Null, r1 = M[I2,4];
   r2 = r1 AND 0xF;
842056c8:	0f 00 43 81 	r2 = r1 AND 0xf;
   do ver_on_list_loop;
842056cc:	04 00 f0 e5 	do $M.celt.decode_flags.ver_on_list_loop;
      r2 = r2 - r0, r1 = M[I2, MK1];
842056d0:	00 39 42 23 	r2 = r2 - r0, r1 = M[I2,4];
      if Z jump break_ver_lp;
842056d4:	05 00 00 dd 	if EQ jump $M.celt.decode_flags.break_ver_lp;
      r2 = r1 AND 0xF;
842056d8:	0f 00 43 81 	r2 = r1 AND 0xf;

842056dc <$M.celt.decode_flags.ver_on_list_loop>:
   ver_on_list_loop:
      // flag not found in the list
      // return error
      r0 = 1;
842056dc:	2f 00 20 e4 	r0 = Null + 1;
      jump $pop_rLink_and_rts;
842056e0:	03 00 00 fd 	jump (m) 0x3b020;
842056e4:	21 b0 f0 dd 

842056e8 <$M.celt.decode_flags.break_ver_lp>:
   break_ver_lp:
   
   // flags found in the list, set available features
   I2 = I2 - 2*ADDR_PER_WORD;
842056e8:	08 00 22 79 	I2 = I2 - 8;
   r1 = M[I2, 0];
842056ec:	00 38 00 03 	Null = Null + Null, r1 = M[I2,0];
   r0 = r1 AND $celt.FLAG_INTRA;
842056f0:	00 20 23 81 	r0 = r1 AND 0x2000;
   M[r5 + $celt.dec.INTRA_ENER_FIELD] = r0;
842056f4:	54 01 27 d5 	M[r5 + 340] = r0;
   r0 = r1 AND $celt.FLAG_PITCH;
842056f8:	00 10 23 81 	r0 = r1 AND 0x1000;
   M[r5 + $celt.dec.HAS_PITCH_FIELD] = r0;
842056fc:	5c 01 27 d5 	M[r5 + 348] = r0;
   r0 = r1 AND $celt.FLAG_SHORT;
84205700:	00 08 23 81 	r0 = r1 AND 0x800;
   M[r5 + $celt.dec.SHORT_BLOCKS_FIELD] = r0;
84205704:	58 01 27 d5 	M[r5 + 344] = r0;
   r0 = r1 AND $celt.FLAG_FOLD;
84205708:	00 04 23 81 	r0 = r1 AND 0x400;
   M[r5 + $celt.dec.HAS_FOLD_FIELD] = r0;
8420570c:	60 01 27 d5 	M[r5 + 352] = r0;
   
   // Extract more info for short blocks
   r0 = -1; //no transient time
84205710:	3f 00 20 e4 	r0 = Null - 1;
   M[r5 + $celt.dec.TRANSIENT_SHIFT_FIELD] = 0;
84205714:	68 01 07 d5 	M[r5 + 360] = Null;
   M[r5 + $celt.dec.MDCT_WEIGHT_SHIFT_FIELD] = 0;
84205718:	6c 01 07 d5 	M[r5 + 364] = Null;
   M[r5 + $celt.dec.MDCT_WEIGHT_POS_FIELD] = 0;
8420571c:	70 01 07 d5 	M[r5 + 368] = Null;
   Null = M[r5 + $celt.dec.SHORT_BLOCKS_FIELD];
84205720:	58 01 07 d1 	Null = M[r5 + 344];
   if Z jump set_transient_time;
84205724:	18 00 00 dd 	if EQ jump $M.celt.decode_flags.set_transient_time;
      r0 = 4;
84205728:	bf 00 20 e4 	r0 = Null + 4;
      r1 = 0;
8420572c:	00 00 30 01 	r1 = Null + 0;
      call $celt.ec_dec_uint;
84205730:	42 f2 f0 e1 	call $celt.ec_dec_uint;
      Null = r0 - 3;
84205734:	03 00 02 21 	Null = r0 - 3;
      if NZ jump check_mdct_weight;
84205738:	08 00 10 dd 	if NE jump $M.celt.decode_flags.check_mdct_weight;
         M[r5 + $celt.dec.TRANSIENT_SHIFT_FIELD] = r0;
8420573c:	68 01 27 d5 	M[r5 + 360] = r0;
         r1 = 0;
84205740:	00 00 30 01 	r1 = Null + 0;
         r0 = M[r5 + $celt.dec.MODE_OVERLAP_FIELD];
84205744:	40 00 27 d1 	r0 = M[r5 + 64];
         r2 = M[r5 + $celt.dec.MODE_MDCT_SIZE_FIELD];
84205748:	44 00 47 d1 	r2 = M[r5 + 68];
         r0 = r0 + r2;
8420574c:	00 00 24 03 	r0 = r0 + r2;
         call $celt.ec_dec_uint;
84205750:	3a f2 f0 e1 	call $celt.ec_dec_uint;
         jump set_transient_time;
84205754:	0c 00 f0 dd 	jump $M.celt.decode_flags.set_transient_time;

84205758 <$M.celt.decode_flags.check_mdct_weight>:
         check_mdct_weight:
            M[r5 + $celt.dec.TRANSIENT_SHIFT_FIELD] = 0;
84205758:	68 01 07 d5 	M[r5 + 360] = Null;
            M[r5 + $celt.dec.MDCT_WEIGHT_SHIFT_FIELD] = r0;
8420575c:	6c 01 27 d5 	M[r5 + 364] = r0;
            if Z jump pos_calc_end;
84205760:	08 00 00 dd 	if EQ jump $M.celt.decode_flags.pos_calc_end;
            r0 = M[r5 + $celt.dec.MODE_NB_SHORT_MDCTS_FIELD];
84205764:	58 00 27 d1 	r0 = M[r5 + 88];
            Null = r0 - 3;
84205768:	03 00 02 21 	Null = r0 - 3;
            if NEG jump pos_calc_end;
8420576c:	05 00 40 dd 	if NEG jump $M.celt.decode_flags.pos_calc_end;
            r0 = r0 - 1;
84205770:	3f 00 22 e4 	r0 = r0 - 1;
            r1 = 0;
84205774:	00 00 30 01 	r1 = Null + 0;
            call $celt.ec_dec_uint;
84205778:	30 f2 f0 e1 	call $celt.ec_dec_uint;
            M[r5 + $celt.dec.MDCT_WEIGHT_POS_FIELD] = r0;
8420577c:	70 01 27 d5 	M[r5 + 368] = r0;

84205780 <$M.celt.decode_flags.pos_calc_end>:
         pos_calc_end:
         r0 = 0;
84205780:	00 00 20 01 	r0 = Null + 0;

84205784 <$M.celt.decode_flags.set_transient_time>:
   set_transient_time:
   M[r5 + $celt.dec.TRANSIENT_TIME_FIELD] = r0;
84205784:	64 01 27 d5 	M[r5 + 356] = r0;

   // output
   r0 = 0;
84205788:	00 00 20 01 	r0 = Null + 0;

   // pop rLink from stack
   SP = SP - STACK_FRAME_SIZE;
8420578c:	fc ff 03 f1 	SP = SP + -4;
   popm <FP,rLink>;
84205790:	01 20 04 f1 	popm <FP, rLink>;
   rts;
84205794:	0f 00 0d dc 	rts;

84205798 <$celt.deemphasis>:
84205798:	84 01 27 d1 	r0 = M[r5 + 388];
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.DEEMPHASIS.PATCH_ID_0,r1)     // celt_patchers
#endif

#ifdef BASE_REGISTER_MODE
   r0 = M[r5 + $celt.dec.SCRATCHVAR_LEFT_OBUF_START_ADDR];
   push r0;
8420579c:	00 00 20 f3 	push r0;
   pop B5;
842057a0:	00 00 d6 f3 	pop B5;
#endif
   r0 = M[r5 + $celt.dec.SCRATCHVAR_LEFT_OBUF_ADDR];
842057a4:	7c 01 27 d1 	r0 = M[r5 + 380];
   r1 = M[r5 + $celt.dec.SCRATCHVAR_LEFT_OBUF_LEN];
842057a8:	80 01 37 d1 	r1 = M[r5 + 384];
   I5 = r0;
842057ac:	2f 00 50 50 	I5 = Null + r0;
   L5 = r1;
842057b0:	3f 00 f0 50 	L5 = Null + r1;

   r3 = 1.0;//1.0/2.0; //scale factor 
842057b4:	ff 7f 00 fd 	r3 = Null + 2147483647;
842057b8:	ff ff 50 01 
   M2 = -MK1;
842057bc:	fc ff a0 51 	M2 = Null + -4;
   M3 = MK2;
842057c0:	08 00 b0 51 	M3 = Null + 8;
   r0 = M[r5 + $celt.dec.CELT_CHANNELS_FIELD];
842057c4:	08 00 27 d1 	r0 = M[r5 + 8];
   M0 = r0 + 1;
842057c8:	01 00 82 51 	M0 = r0 + 1;
   r0 = M[r5 + $celt.dec.MODE_E_PRED_COEF_FIELD];   //r0 = alpha
842057cc:	50 00 27 d1 	r0 = M[r5 + 80];
   r6 = r5;
842057d0:	0f 00 87 00 	r6 = r5 + Null;

842057d4 <$M.celt.deemphasis.chan_loop>:
   chan_loop:
      r10 = M[r5 + $celt.dec.MODE_AUDIO_FRAME_SIZE_FIELD];
842057d4:	44 00 c7 d1 	r10 = M[r5 + 68];
      r10 = r10 - 1;
842057d8:	3f 00 cc e4 	r10 = r10 - 1;
      rMAC = M[r6 + $celt.dec.DEEMPH_HIST_SAMPLE_FIELD];                    
842057dc:	9c 00 18 d1 	rMAC = M[r6 + 156];
      rMAC = rMAC * r0, r1 = M[I5, MK1];                                                             
842057e0:	35 00 12 cf 	rMAC = rMAC * r0 (SS), r1 = M[I5,4];
      do deemphasis_loop;
842057e4:	04 00 f0 e5 	do $M.celt.deemphasis.deemphasis_loop;
         rMAC = rMAC + r1 * r3, r1 = M[I5, M2];
842057e8:	36 00 35 ae 	rMAC = rMAC + r1 * r3 (SS), r1 = M[I5,M2];
         r4 = rMAC ASHIFT 1;
842057ec:	01 00 61 91 	r4 = rMAC ASHIFT 1;
         rMAC = rMAC * r0, M[I5, M3] = r4;
842057f0:	e7 00 12 ce 	rMAC = rMAC * r0 (SS), M[I5,M3] = r4;

842057f4 <$M.celt.deemphasis.deemphasis_loop>:
      deemphasis_loop:
      rMAC = rMAC + r1 * r3, r1 = M[I5, M2];
842057f4:	36 00 35 ae 	rMAC = rMAC + r1 * r3 (SS), r1 = M[I5,M2];
      r4 = rMAC ASHIFT 1;
842057f8:	01 00 61 91 	r4 = rMAC ASHIFT 1;
      M[I5, M3] = r4;
842057fc:	e7 00 00 02 	Null = Null + Null, M[I5,M3] = r4;
      M[r6 + $celt.dec.DEEMPH_HIST_SAMPLE_FIELD] = rMAC; 
84205800:	9c 00 18 d5 	M[r6 + 156] = rMAC;

     // set up registers for second channel
#ifdef BASE_REGISTER_MODE
      r1 = M[r5 + $celt.dec.SCRATCHVAR_RIGHT_OBUF_START_ADDR];
84205804:	90 01 37 d1 	r1 = M[r5 + 400];
      push r1;
84205808:	00 00 30 f3 	push r1;
      pop B5;
8420580c:	00 00 d6 f3 	pop B5;
#endif
      r1 = M[r5 + $celt.dec.SCRATCHVAR_RIGHT_OBUF_ADDR];
84205810:	88 01 37 d1 	r1 = M[r5 + 392];
      I5 = r1;
84205814:	3f 00 50 50 	I5 = Null + r1;
      r1 = M[r5 + $celt.dec.SCRATCHVAR_RIGHT_OBUF_LEN];
84205818:	8c 01 37 d1 	r1 = M[r5 + 396];
      L5 = r1;
8420581c:	3f 00 f0 50 	L5 = Null + r1;
      r6 = r6 + ADDR_PER_WORD;
84205820:	bf 00 88 e4 	r6 = r6 + 4;

      // run for right channel if exisiting
      M0 = M0 - 1;
84205824:	01 00 88 79 	M0 = M0 - 1;
   if NZ jump chan_loop;
84205828:	eb ff 10 dd 	if NE jump $M.celt.deemphasis.chan_loop;

   L5 = 0;
8420582c:	00 00 f0 51 	L5 = Null + 0;
#ifdef BASE_REGISTER_MODE
   push Null;
84205830:	00 00 00 f3 	push Null;
   pop B5;
84205834:	00 00 d6 f3 	pop B5;
#endif

   rts;   
84205838:	0f 00 0d dc 	rts;

8420583c <$celt.get1byte>:
8420583c:	f8 01 27 d1 	r0 = M[r5 + 504];
#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.GET1BYTE.PATCH_ID_0,r1)     // celt_patchers
#endif
   
   r0 = M[r5 + $celt.dec.SCRATCHVAR_GET_BYTEPOS];           // calc amount of shift
   r0 = r0 * (-8) (int); 
84205840:	f8 ff 22 99 	r0 = r0 * -8 (int);
   r1 = M[I0, 0];                           // r1 = the current word
84205844:	00 30 00 03 	Null = Null + Null, r1 = M[I0,0];
   r1 = r1 LSHIFT r0;                       // shift current word
84205848:	00 00 32 8f 	r1 = r1 LSHIFT r0;
   r1 = r1 AND 0xFF;                        // extract only the desired bits
8420584c:	ff 00 33 81 	r1 = r1 AND 0xff;
   r0 = M[r5 + $celt.dec.SCRATCHVAR_GET_BYTEPOS];
84205850:	f8 01 27 d1 	r0 = M[r5 + 504];
#ifdef DATAFORMAT_32
   r0 = r0 - 1;
84205854:	3f 00 22 e4 	r0 = r0 - 1;
   if POS jump no_p_update;
84205858:	03 00 50 dd 	if POS jump $M.celt.get1byte.no_p_update;
      r0 = M[I0, MK1]; // increment I0 to point to the next word
8420585c:	00 21 00 03 	Null = Null + Null, r0 = M[I0,4];
      r0 = $celt.BYTE_POS_MAX_VALUE;
84205860:	03 00 20 01 	r0 = Null + 3;

84205864 <$M.celt.get1byte.no_p_update>:
   no_p_update:
   M[r5 + $celt.dec.SCRATCHVAR_GET_BYTEPOS] = r0;
84205864:	f8 01 27 d5 	M[r5 + 504] = r0;
   M[r5 + $celt.dec.SCRATCHVAR_GET_BYTEPOS] = r0;
   if Z jump no_p_update;
      r0 = M[I0, MK1]; // increment I0 to point to the next word
   no_p_update:
#endif
   r0 = M[r5 + $celt.dec.SCRATCHVAR_FRAME_BYTES_REMAINED];
84205868:	fc 01 27 d1 	r0 = M[r5 + 508];
   if LE r1 = 0;
8420586c:	0d 00 30 00 	if LE r1 = Null + Null;
   r0 = r0 - 1;
84205870:	3f 00 22 e4 	r0 = r0 - 1;
   M[r5 + $celt.dec.SCRATCHVAR_FRAME_BYTES_REMAINED] = r0;  // update number of frame bits read
84205874:	fc 01 27 d5 	M[r5 + 508] = r0;
   rts;
84205878:	0f 00 0d dc 	rts;

8420587c <$celt.get1byte_from_end>:

#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.GET1BYTE_FROM_END.PATCH_ID_0,r1)     // celt_patchers
#endif
   
   r1 = -1;
8420587c:	3f 00 30 e4 	r1 = Null - 1;
   r0 = M[r5 + $celt.dec.SCRATCHVAR_FRAME_BYTES_REMAINED_REVERSE];
84205880:	04 02 27 d1 	r0 = M[r5 + 516];
   r0 = r0 - 1;
84205884:	3f 00 22 e4 	r0 = r0 - 1;
   if NEG rts;
84205888:	04 00 0d dc 	if NEG rts;
   M[r5 + $celt.dec.SCRATCHVAR_FRAME_BYTES_REMAINED_REVERSE] = r0;  // update number of frame bits read
8420588c:	04 02 27 d5 	M[r5 + 516] = r0;
   r0 = M[r5 + $celt.dec.SCRATCHVAR_GET_BYTEPOS_REVERSE];           // calc amount of shift
84205890:	00 02 27 d1 	r0 = M[r5 + 512];
#ifdef DATAFORMAT_32
   r0 = $celt.BYTE_POS_MAX_VALUE - r0;
84205894:	03 00 22 65 	r0 = 3 - r0;
   if GT jump stay_in_this_word;
84205898:	02 00 c0 dd 	if GT jump $M.celt.get1byte_from_end.stay_in_this_word;
      r1 = M[I1, -MK1];
8420589c:	00 37 00 03 	Null = Null + Null, r1 = M[I1,-4];

842058a0 <$M.celt.get1byte_from_end.stay_in_this_word>:
   stay_in_this_word:
   r0 = r0 * (-8) (int);
842058a0:	f8 ff 22 99 	r0 = r0 * -8 (int);
   r1 = M[I1, 0];                                   // r1 = the current word
842058a4:	00 34 00 03 	Null = Null + Null, r1 = M[I1,0];
   r1 = r1 LSHIFT r0;                               // shift current word
842058a8:	00 00 32 8f 	r1 = r1 LSHIFT r0;
   r1 = r1 AND 0xFF;                                // extract only the desired bits
842058ac:	ff 00 33 81 	r1 = r1 AND 0xff;
   r0 = M[r5 + $celt.dec.SCRATCHVAR_GET_BYTEPOS_REVERSE];
842058b0:	00 02 27 d1 	r0 = M[r5 + 512];
   if NZ jump no_reset;
842058b4:	02 00 10 dd 	if NE jump $M.celt.get1byte_from_end.no_reset;
      r0 = 4;
842058b8:	bf 00 20 e4 	r0 = Null + 4;

842058bc <$M.celt.get1byte_from_end.no_reset>:
   no_reset:
   r0 = r0 - 1;
842058bc:	3f 00 22 e4 	r0 = r0 - 1;
   M[r5 + $celt.dec.SCRATCHVAR_GET_BYTEPOS_REVERSE] = r0;
842058c0:	00 02 27 d5 	M[r5 + 512] = r0;
   r0 = r0 * (-8) (int); 
   r1 = M[I1, 0];                                   // r1 = the current word
   r1 = r1 LSHIFT r0;                               // shift current word
   r1 = r1 AND 0xFF;                                // extract only the desired bits
#endif
   rts;
842058c4:	0f 00 0d dc 	rts;

842058c8 <$celt.ec_laplace_decode_start>:
842058c8:	00 00 d0 f3 	push rLink;
#endif
   
   // push rLink onto stack
   push rlink;
   
   push r3;
842058cc:	00 00 50 f3 	push r3;
   push r2;
842058d0:	00 00 40 f3 	push r2;
   call $celt.ec_decode_bin;
842058d4:	5b f1 f0 e1 	call $celt.ec_decode_bin;
   pop r2;
842058d8:	00 00 44 f3 	pop r2;
   pop r3;
842058dc:	00 00 54 f3 	pop r3;
   r4 = 0;     //fl
842058e0:	00 00 60 01 	r4 = Null + 0;
   r6 = 32768; //ft
842058e4:	00 00 00 fd 	r6 = Null + 32768;
842058e8:	00 80 80 01 
   r7 = r3;    //fh
842058ec:	0f 00 95 00 	r7 = r3 + Null;
   M0 = 0;     //val
842058f0:	00 00 80 51 	M0 = Null + 0;
   M2 = 1;
842058f4:	01 00 a0 51 	M2 = Null + 1;

842058f8 <$M.celt.ec_laplace_decode_start.loop_start_laplace>:
   loop_start_laplace:
      Null = r0 -  r7;
842058f8:	9f 00 02 20 	Null = r0 - r7;
      if NEG jump laplace_loop_end;
842058fc:	0e 00 40 dd 	if NEG jump $M.celt.ec_laplace_decode_start.laplace_loop_end;
      Null = r3;
84205900:	0f 00 05 00 	Null = r3 + Null;
      r4 = r7;
84205904:	0f 00 69 00 	r4 = r7 + Null;
      rMAC = r3*r2;
84205908:	4f 00 15 cc 	rMAC = r3 * r2 (SS);
      rMAC = rMAC LSHIFT (DAWTH-15);
8420590c:	11 00 e1 8d 	rMAC = rMAC LSHIFT 17 (MI);
      r3 = rMAC;
84205910:	0f 00 51 00 	r3 = rMAC + Null;
      NULL = r7 - (32768-1);
84205914:	ff 7f 09 21 	Null = r7 - 32767;
      if POS rMAC = 0;
84205918:	05 00 10 00 	if POS rMAC = Null + Null;
      rMAC = rMAC OR r3;
8420591c:	00 00 15 87 	rMAC = rMAC OR r3;
      if Z r3 = M2;
84205920:	a0 00 50 44 	if EQ r3 = Null + M2;
      rMAC = r3 + r3;
84205924:	5f 00 15 00 	rMAC = r3 + r3;
      r7 = r7 + rMAC;
84205928:	00 00 91 03 	r7 = r7 + rMAC;
      M0 = M0 + 1;
8420592c:	01 00 88 59 	M0 = M0 + 1;
   jump loop_start_laplace;
84205930:	f2 ff f0 dd 	jump $M.celt.ec_laplace_decode_start.loop_start_laplace;

84205934 <$M.celt.ec_laplace_decode_start.laplace_loop_end>:
            
   laplace_loop_end:    
   Null = r4 - 0;
84205934:	00 00 06 21 	Null = r4 - 0;
   if LE jump end_flh_fix;
84205938:	08 00 d0 dd 	if LE jump $M.celt.ec_laplace_decode_start.end_flh_fix;
      rMAC = r0 - r4;
8420593c:	6f 00 12 20 	rMAC = r0 - r4;
      rMAC = rMAC - r3;
84205940:	00 00 15 23 	rMAC = rMAC - r3;
      if NEG r7 = r7 - r3;
84205944:	54 00 99 20 	if NEG r7 = r7 - r3;
      Null = rMAC;
84205948:	0f 00 01 00 	Null = rMAC + Null;
      if NEG jump end_flh_fix;
8420594c:	03 00 40 dd 	if NEG jump $M.celt.ec_laplace_decode_start.end_flh_fix;
      M0 = -M0;
84205950:	8f 00 80 74 	M0 = Null - M0;
      r4 = r4 + r3;
84205954:	00 00 65 03 	r4 = r4 + r3;

84205958 <$M.celt.ec_laplace_decode_start.end_flh_fix>:
   end_flh_fix:
   Null = r4 - r7;
84205958:	9f 00 06 20 	Null = r4 - r7;
   if Z r4 = r4 - M2;
8420595c:	a0 00 66 64 	if EQ r4 = r4 - M2;
   M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FL + 0] = r4;
84205960:	d4 01 67 d5 	M[r5 + 468] = r4;
   M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FL + MK1] = 0;
84205964:	d8 01 07 d5 	M[r5 + 472] = Null;
   M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FH + 0] = r7;
84205968:	dc 01 97 d5 	M[r5 + 476] = r7;
   M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FH + MK1] = 0; 
8420596c:	e0 01 07 d5 	M[r5 + 480] = Null;
   M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FT + 0] = r6;
84205970:	cc 01 87 d5 	M[r5 + 460] = r6;
   M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FT + MK1] = 0; 
84205974:	d0 01 07 d5 	M[r5 + 464] = Null;
   push M0;
84205978:	00 00 81 f3 	push M0;
   call $celt.ec_dec_update;
8420597c:	3d f1 f0 e1 	call $celt.ec_dec_update;
   pop r1;
84205980:	00 00 34 f3 	pop r1;
   // pop rLink from stack
   jump $pop_rLink_and_rts;
84205984:	03 00 00 fd 	jump (m) 0x3b020;
84205988:	21 b0 f0 dd 

8420598c <$celt.ec_laplace_encode_start>:
#endif
   
   // push rLink onto stack
   .CONST TEMP                 (0 + 2)*ADDR_PER_WORD;
   .CONST STACK_FRAME_SIZE     1*ADDR_PER_WORD;
   pushm <FP(=SP), rLink>;
8420598c:	01 20 00 f1 	pushm <FP(=SP), rLink>;
   SP = SP + STACK_FRAME_SIZE;
84205990:	04 00 03 f1 	SP = SP + 4;
   M[FP + TEMP] = r1;              // value
84205994:	08 00 3c f1 	M[FP + 0x8] = r1;
   r10 = r1;                       // value
84205998:	0f 00 c3 00 	r10 = r1 + Null;
   if NEG                          // if(val <0):
   r10 = -r10;                     // val = -val
8420599c:	c4 00 c0 20 	if NEG r10 = Null - r10;
   r7 = 32768;                     // ft = 32768;
842059a0:	00 00 00 fd 	r7 = Null + 32768;
842059a4:	00 80 90 01 
   r6 = -r3;                       // fl = -fs
842059a8:	5f 00 80 20 	r6 = Null - r3;
   M1 = 1;
842059ac:	01 00 90 51 	M1 = Null + 1;
   M2 = 0;
842059b0:	00 00 a0 51 	M2 = Null + 0;
   do calc_fl_loop;       
842059b4:	12 00 f0 e5 	do $M.celt.ec_laplace_encode_start.calc_fl_loop;
      r4 = r3 + r3;                // fs * 2
842059b8:	5f 00 65 00 	r4 = r3 + r3;
      r6 = r6 + r4;                // fl = fl + fs * 2;
842059bc:	00 00 86 03 	r6 = r6 + r4;
      r0 = r3;                     // tmp_s = fs
842059c0:	0f 00 25 00 	r0 = r3 + Null;
      rMAC = r3*r2;                // fs * (ec_int32) decay
842059c4:	4f 00 15 cc 	rMAC = r3 * r2 (SS);
      r3 = rMAC LSHIFT (DAWTH-15); // fs = (fs * (ec_int32) decay);
842059c8:	11 00 51 8d 	r3 = rMAC LSHIFT 17;
      if NZ jump end_update;       // jump if (fs != 0)
842059cc:	0b 00 10 dd 	if NE jump $M.celt.ec_laplace_encode_start.end_update;
         r8 = r6 + 2;              // fl + 2
842059d0:	af 00 a8 e4 	r8 = r6 + 2;
         Null = r7 - r8;           // (fl + 2 - ft)
842059d4:	af 00 09 20 	Null = r7 - r8;
         if POS jump set_fs;       // if (fl + 2 <= ft) , fs = 1
842059d8:	07 00 50 dd 	if POS jump $M.celt.ec_laplace_encode_start.set_fs;
            r3 = r0;               // fs = tmp_s; 
842059dc:	0f 00 52 00 	r3 = r0 + Null;
            r6 = r6 - r4;          // fl = tmp_l
842059e0:	00 00 86 23 	r6 = r6 - r4;
            r1 = M2;               // value = i
842059e4:	af 00 30 44 	r1 = Null + M2;
            Null = M[FP + TEMP];
842059e8:	08 00 08 f1 	Null = M[FP + 0x8];
            if NEG r1 = -r1;       // if(s) , value = -i
842059ec:	34 00 30 20 	if NEG r1 = Null - r1;
            jump end_calc_loop;
842059f0:	03 00 f0 dd 	jump $M.celt.ec_laplace_encode_start.calc_fl_loop;

842059f4 <$M.celt.ec_laplace_encode_start.set_fs>:
      set_fs:
      r3 = 1;
842059f4:	2f 00 50 e4 	r3 = Null + 1;

842059f8 <$M.celt.ec_laplace_encode_start.end_update>:
      end_update:
      M2 = M2 + 1;                 // i = i + 1        
842059f8:	01 00 aa 59 	M2 = M2 + 1;

842059fc <$M.celt.ec_laplace_encode_start.calc_fl_loop>:
   calc_fl_loop:
   end_calc_loop:
   Null = r6;
842059fc:	0f 00 08 00 	Null = r6 + Null;
   if NEG r6 = 0;                  // if (fl < 0) , fl = 0;
84205a00:	04 00 80 00 	if NEG r6 = Null + Null;
   Null = M[FP + TEMP];
84205a04:	08 00 08 f1 	Null = M[FP + 0x8];
   if NEG r6 = r6 + r3;            // if (s) , fl = fl + fs;
84205a08:	54 00 88 00 	if NEG r6 = r6 + r3;
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FL + 1] = Null;
   r6 = r6 + r3;
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FH + 0] = r6;
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FH + 1] = Null;
#else
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FL] = r6;
84205a0c:	d4 01 87 d5 	M[r5 + 468] = r6;
   r6 = r6 + r3;
84205a10:	00 00 85 03 	r6 = r6 + r3;
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FH] = r6;
84205a14:	dc 01 87 d5 	M[r5 + 476] = r6;
#endif   
   M[FP + TEMP] = r1;
84205a18:	08 00 3c f1 	M[FP + 0x8] = r1;
   call $celt.ec_encode_bin;
84205a1c:	4a f2 f0 e1 	call $celt.ec_encode_bin;
   r1 = M[FP + TEMP]; 
84205a20:	08 00 38 f1 	r1 = M[FP + 0x8];
   // pop rLink from stack
   SP = SP - STACK_FRAME_SIZE;
84205a24:	fc ff 03 f1 	SP = SP + -4;
   popm <FP,rLink>;
84205a28:	01 20 04 f1 	popm <FP, rLink>;
   rts;
84205a2c:	0f 00 0d dc 	rts;

84205a30 <$celt.idiv32>:
84205a30:	00 04 e5 8d 	rMAC12 = r3 LSHIFT 0;
   LIBS_PUSH_REGS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.IDIV32.PATCH_ID_0)     // celt_patchers
#endif

   // normalise divisor  to DAWTH-1 bits
   rMAC12 = r3(ZP);
   rMAC0 = r2;
84205a34:	00 05 e4 8d 	rMAC0 = r2 LSHIFT 0;
   r10 = signdet rMAC;
84205a38:	0f 00 c1 d8 	r10 = SIGNDET rMAC;
   r4 = rMAC LSHIFT r10;
84205a3c:	cf 00 61 8c 	r4 = rMAC LSHIFT r10;

   rMAC12 = r1(ZP);
84205a40:	00 04 e3 8d 	rMAC12 = r1 LSHIFT 0;
   rMAC0 = r0;
84205a44:	00 05 e2 8d 	rMAC0 = r0 LSHIFT 0;
   r7 = signdet rMAC;
84205a48:	0f 00 91 d8 	r7 = SIGNDET rMAC;
   r7 = r7 - 2;
84205a4c:	cf 00 99 e4 	r7 = r7 - 2;
   rMAC = rMAC LSHIFT r7 (56bit);
84205a50:	00 00 19 8f 	rMAC = rMAC LSHIFT r7 (56bit);

   // divide normalised dividend/divisor
   Div = rMAC / r4;
84205a54:	00 00 16 d9 	Div = rMAC / r4;

   // divisor truncated when normalise?
   r8 = r10 - DAWTH;
84205a58:	20 00 ac 21 	r8 = r10 - 32;
   if NEG jump truncate_proc;
84205a5c:	12 00 40 dd 	if NEG jump $M.celt.idiv32.truncate_proc;
   r8 = r8 - r7;
84205a60:	00 00 a9 23 	r8 = r8 - r7;
   if POS jump div_rem;
84205a64:	05 00 50 dd 	if POS jump $M.celt.idiv32.div_rem;
      r7 = 0;
84205a68:	00 00 90 01 	r7 = Null + 0;
      r6 = DivResult;
84205a6c:	01 00 80 d9 	r6 = DivResult;
      r6 = r6 LSHIFT r8;
84205a70:	00 00 8a 8f 	r6 = r6 LSHIFT r8;
     rts;
84205a74:	0f 00 0d dc 	rts;

84205a78 <$M.celt.idiv32.div_rem>:
   div_rem:
   // result might be more than DAWTH-1 bits
   r10 = r8 - (DAWTH);
84205a78:	20 00 ca 21 	r10 = r8 - 32;
   r7 = DivResult;
84205a7c:	01 00 90 d9 	r7 = DivResult;
   r6 = r7 LSHIFT r8;
84205a80:	af 00 89 8c 	r6 = r7 LSHIFT r8;
   r7 = r7 LSHIFT r10;
84205a84:	00 00 9c 8f 	r7 = r7 LSHIFT r10;

   // divide the remainder to divisor
   rMAC = DivRemainder;
84205a88:	02 00 10 d9 	rMAC = DivRemainder;
   rMAC = rMAC LSHIFT r10 (56bit);
84205a8c:	00 00 1c 8f 	rMAC = rMAC LSHIFT r10 (56bit);
   Div = rMAC / r4;
84205a90:	00 00 16 d9 	Div = rMAC / r4;

   // add result to previous division result
   r4 = DivResult;
84205a94:	01 00 60 d9 	r4 = DivResult;
   r6 = r6 + r4;
84205a98:	00 00 86 03 	r6 = r6 + r4;
   r7 = r7 + carry;
84205a9c:	00 00 90 07 	r7 = r7 + Null + Carry;
   rts;
84205aa0:	0f 00 0d dc 	rts;

84205aa4 <$M.celt.idiv32.truncate_proc>:
   truncate_proc:
      r8 = r8 - r7;
84205aa4:	00 00 a9 23 	r8 = r8 - r7;
      r7 = DivResult;
84205aa8:	01 00 90 d9 	r7 = DivResult;
      r6 = r7 LSHIFT r8;
84205aac:	af 00 89 8c 	r6 = r7 LSHIFT r8;
      r8 = r8 - (DAWTH);
84205ab0:	20 00 aa 21 	r8 = r8 - 32;
      r7 = r7 LSHIFT r8;
84205ab4:	00 00 9a 8f 	r7 = r7 LSHIFT r8;
      rMAC = r6*r2 (UU);
84205ab8:	4f 00 18 c0 	rMAC = r6 * r2 (UU);
      r8 = rMAC LSHIFT (DAWTH-1);
84205abc:	1f 00 a1 8d 	r8 = rMAC LSHIFT 31;
      rMAC0 = rMAC1;
84205ac0:	00 05 e1 8d 	rMAC0 = rMAC LSHIFT 0;
      rMAC12 = rMAC2(ZP);
84205ac4:	e0 04 e1 8d 	rMAC12 = rMAC LSHIFT -32;
      rMAC = rMAC + r7*r2(SU);
84205ac8:	4f 00 19 a8 	rMAC = rMAC + r7 * r2 (SU);
      rMAC = rMAC + r6*r3(SU);
84205acc:	5f 00 18 a8 	rMAC = rMAC + r6 * r3 (SU);
      r4 = rMAC LSHIFT (DAWTH-1);
84205ad0:	1f 00 61 8d 	r4 = rMAC LSHIFT 31;
      Null = r0 - r8;
84205ad4:	af 00 02 20 	Null = r0 - r8;
      Null = r1 - r4 -borrow;
84205ad8:	6f 00 03 24 	Null = r1 - r4 - Borrow;
      if POS rts;
84205adc:	05 00 0d dc 	if POS rts;
         r6 = r6 - 1;
84205ae0:	3f 00 88 e4 	r6 = r6 - 1;
         r7 = r7 - borrow;
84205ae4:	00 00 90 27 	r7 = r7 - Null - Borrow;
   rts;
84205ae8:	0f 00 0d dc 	rts;

84205aec <$celt.log2_frac>:
   
#if defined(PATCH_LIBS)
   LIBS_PUSH_R0_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.LOG2_FRAC.PATCH_ID_0,r1)     // celt_patchers
#endif
   
   r1 = signdet rMAC;
84205aec:	0f 00 31 d8 	r1 = SIGNDET rMAC;
   #if defined(KAL_ARCH3) || defined(KAL_ARCH4) || defined(KAL_ARCH5)
      r1 = r1 -(DAWTH-17);
84205af0:	0f 00 33 21 	r1 = r1 - 15;
      rMAC = rMAC ASHIFT r1(56bit);
84205af4:	00 00 13 93 	rMAC = rMAC ASHIFT r1 (56bit);
      r1 = (DAWTH+16) -r1;
84205af8:	30 00 33 65 	r1 = 48 - r1;
      r1 = r1 -6;
      rMAC = rMAC ASHIFT r1;
      rMAC = rMAC * 0.5 (frac);
      r1 = 41 - r1;
   #endif
   r2 = 1 LSHIFT r0;
84205afc:	01 00 42 e9 	r2 = 0x1 LSHIFT r0;
   r1 = r1 - 1;
84205b00:	3f 00 33 e4 	r1 = r1 - 1;
   r10 = r0+1;
84205b04:	2f 00 c2 e4 	r10 = r0 + 1;
   r6 = 0.5;
84205b08:	00 40 00 fd 	r6 = Null + 1073741824;
84205b0c:	00 00 80 01 
   r0 = r1 LSHIFT r0;
84205b10:	2f 00 23 8c 	r0 = r1 LSHIFT r0;
#ifdef K32
   r7 = (0x7FFFFF);
84205b14:	7f 00 00 fd 	r7 = Null + 8388607;
84205b18:	ff ff 90 01 
#else
   r7 = (0x7FFF);
#endif
   r1 = 1;
84205b1c:	2f 00 30 e4 	r1 = Null + 1;
   do comp_loop;
84205b20:	0a 00 f0 e5 	do $M.celt.log2_frac.comp_loop;
      NULL = rMAC LSHIFT -16;
84205b24:	f0 00 01 8d 	Null = rMAC LSHIFT -16;
      if NZ r0 = r0 + r2;
84205b28:	41 00 22 00 	if NE r0 = r0 + r2;
      Null = rMAC LSHIFT -16;
84205b2c:	f0 00 01 8d 	Null = rMAC LSHIFT -16;
      if NZ rMAC = rMAC * r6 (frac);
84205b30:	81 00 11 94 	if NE rMAC = rMAC * r6 (frac);
      rMAC = rMAC * rMAC;
84205b34:	1f 00 11 cc 	rMAC = rMAC * rMAC (SS);
#ifdef K32
      // Adjust rMAC72 to make rMAC0 and rMAC1 bit-exact with ARCH3 when retrieved
      rMAC = rMAC ASHIFT 8 (56bit);
84205b38:	08 00 11 91 	rMAC = rMAC ASHIFT 8 (56bit);
#endif
      rMAC = rMAC + r1 * r7;
84205b3c:	9f 00 13 ac 	rMAC = rMAC + r1 * r7 (SS);
      rMAC = rMAC LSHIFT 8;
84205b40:	08 00 e1 8d 	rMAC = rMAC LSHIFT 8 (MI);
      r2 = r2 LSHIFT -1;
84205b44:	ff 00 44 8d 	r2 = r2 LSHIFT -1;

84205b48 <$M.celt.log2_frac.comp_loop>:
   comp_loop:
   rMAC = rMAC - 0x8000;
84205b48:	00 00 00 fd 	rMAC = rMAC - 32768;
84205b4c:	00 80 11 21 
   if GT r0 = r0 + r1;
84205b50:	3c 00 22 00 	if GT r0 = r0 + r1;
   rts;
84205b54:	0f 00 0d dc 	rts;

84205b58 <$celt.imusdiv32>:
#if defined(PATCH_LIBS)
   LIBS_PUSH_REGS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.IMUSDIV32.PATCH_ID_0)     // celt_patchers
#endif

   // calc a*b
   rMAC = r0 * r2 (UU);
84205b58:	4f 00 12 c0 	rMAC = r0 * r2 (UU);
   r6 = rMAC LSHIFT (DAWTH-1);
84205b5c:	1f 00 81 8d 	r6 = rMAC LSHIFT 31;
   rMAC0 = rMAC1;
84205b60:	00 05 e1 8d 	rMAC0 = rMAC LSHIFT 0;
   rMAC12 = rMAC2 (ZP);
84205b64:	e0 04 e1 8d 	rMAC12 = rMAC LSHIFT -32;
   rMAC = rMAC + r1 * r2 (SU);
84205b68:	4f 00 13 a8 	rMAC = rMAC + r1 * r2 (SU);
   rMAC = rMAC + r3 * r0 (SU);
84205b6c:	2f 00 15 a8 	rMAC = rMAC + r3 * r0 (SU);
   r7 = rMAC LSHIFT (DAWTH-1);
84205b70:	1f 00 91 8d 	r7 = rMAC LSHIFT 31;
   rMAC0 = rMAC1;
84205b74:	00 05 e1 8d 	rMAC0 = rMAC LSHIFT 0;
   rMAC12 = rMAC2 (SE);
84205b78:	e0 04 e1 91 	rMAC12 = rMAC ASHIFT -32;
   rMAC = rMAC + r1 * r3 (SS);
84205b7c:	5f 00 13 ac 	rMAC = rMAC + r1 * r3 (SS);
   r8 = rMAC LSHIFT (DAWTH-1);
84205b80:	1f 00 a1 8d 	r8 = rMAC LSHIFT 31;
   
   // r8:r7:r6 = a*b, calc a*b-c
   r6 = r6 - r4;
84205b84:	00 00 86 23 	r6 = r6 - r4;
   r7 = r7 - r5 - Borrow;
84205b88:	00 00 97 27 	r7 = r7 - r5 - Borrow;
   r8 = r8 - Borrow;
84205b8c:	00 00 a0 27 	r8 = r8 - Null - Borrow;

   // divide to d (result can be up to 32 bits)
   rMAC  = r8;
84205b90:	0f 00 1a 00 	rMAC = r8 + Null;
   rMAC0 = r7;
84205b94:	00 05 e9 8d 	rMAC0 = r7 LSHIFT 0;
   Div = rMAC/r10;
84205b98:	00 00 1c d9 	Div = rMAC / r10;
   r3 = DivResult;
84205b9c:	01 00 50 d9 	r3 = DivResult;
   r2 = DivRemainder;
84205ba0:	02 00 40 d9 	r2 = DivRemainder;
   r8 = r10 LSHIFT 1;
84205ba4:	01 00 ac 8d 	r8 = r10 LSHIFT 1;
   rMAC = r2;
84205ba8:	0f 00 14 00 	rMAC = r2 + Null;
   rMAC0 = r6;
84205bac:	00 05 e8 8d 	rMAC0 = r6 LSHIFT 0;
   Div = rMAC/r8;
84205bb0:	00 00 1a d9 	Div = rMAC / r8;
   r2 = DivResult;
84205bb4:	01 00 40 d9 	r2 = DivResult;
   r8 = DivRemainder;
84205bb8:	02 00 a0 d9 	r8 = DivRemainder;
   r2 = r2 + r2;
84205bbc:	00 00 44 03 	r2 = r2 + r2;
   r7 = 1;
84205bc0:	2f 00 90 e4 	r7 = Null + 1;
   Null = r8 - r10;
84205bc4:	cf 00 0a 20 	Null = r8 - r10;
   if POS r2 = r2 + r7;
84205bc8:	95 00 44 00 	if POS r2 = r2 + r7;
   rts;
84205bcc:	0f 00 0d dc 	rts;

84205bd0 <$celt.bitexact_cos>:

#if defined(PATCH_LIBS)
   LIBS_PUSH_REGS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.BITEXACT_COS.PATCH_ID_0)     // celt_patchers
#endif
   
   rMAC = r0*r0;
84205bd0:	2f 00 12 cc 	rMAC = r0 * r0 (SS);
   r3 = 1;
84205bd4:	2f 00 50 e4 	r3 = Null + 1;
   rMAC = rMAC + r3*4096;
84205bd8:	00 00 00 fd 	rMAC = rMAC + r3 * 1.9073486328125e-06 (SS);
84205bdc:	00 10 15 ad 
   r2 = rMAC ASHIFT (DAWTH-14);
84205be0:	12 00 41 91 	r2 = rMAC ASHIFT 18;
   rMAC = r2 - 32767;
84205be4:	ff 7f 14 21 	rMAC = r2 - 32767;
   if POS r2 = r2 - rMAC;
84205be8:	15 00 44 20 	if POS r2 = r2 - rMAC;

   rMAC = r2 * (-626);
84205bec:	ff ff 00 fd 	rMAC = r2 * -2.91503965854644775390625e-07 (SS);
84205bf0:	8e fd 14 cd 
   rMAC = rMAC + r3*16384;
84205bf4:	00 00 00 fd 	rMAC = rMAC + r3 * 7.62939453125e-06 (SS);
84205bf8:	00 40 15 ad 
   rMAC = rMAC ASHIFT (DAWTH-16);
84205bfc:	10 00 e1 91 	rMAC = rMAC ASHIFT 16 (MI);
   rMAC = rMAC + 8277;
84205c00:	55 20 11 01 	rMAC = rMAC + 8277;

   rMAC = r2 * rMAC;
84205c04:	1f 00 14 cc 	rMAC = r2 * rMAC (SS);
   rMAC = rMAC + r3*16384;
84205c08:	00 00 00 fd 	rMAC = rMAC + r3 * 7.62939453125e-06 (SS);
84205c0c:	00 40 15 ad 
   rMAC = rMAC ASHIFT (DAWTH-16);
84205c10:	10 00 e1 91 	rMAC = rMAC ASHIFT 16 (MI);
   rMAC = rMAC - 7651;
84205c14:	e3 1d 11 21 	rMAC = rMAC - 7651;

   rMAC = r2 * rMAC;
84205c18:	1f 00 14 cc 	rMAC = r2 * rMAC (SS);
   rMAC = rMAC + r3*16384;
84205c1c:	00 00 00 fd 	rMAC = rMAC + r3 * 7.62939453125e-06 (SS);
84205c20:	00 40 15 ad 
   rMAC = rMAC ASHIFT (DAWTH-16);
84205c24:	10 00 e1 91 	rMAC = rMAC ASHIFT 16 (MI);
   r2 = rMAC - r2;
84205c28:	4f 00 41 20 	r2 = rMAC - r2;
   if POS r2= -r3;
84205c2c:	55 00 40 20 	if POS r2 = Null - r3;
   r2 = r2 + 32768;
84205c30:	00 00 00 fd 	r2 = r2 + 32768;
84205c34:	00 80 44 01 

   rts;
84205c38:	0f 00 0d dc 	rts;

84205c3c <$celt.put1byte>:
84205c3c:	ec 01 27 d1 	r0 = M[r5 + 492];
#if defined(PATCH_LIBS)
   LIBS_PUSH_REGS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.PUT1BYTE.PATCH_ID_0)     // celt_patchers
#endif  

   r0 = M[r5 + $celt.enc.SCRATCHVAR_FRAME_BYTES_REMAINED];
   if LE rts;
84205c40:	0d 00 0d dc 	if LE rts;
   r0 = r0 - 1;
84205c44:	3f 00 22 e4 	r0 = r0 - 1;
   M[r5 + $celt.enc.SCRATCHVAR_FRAME_BYTES_REMAINED] = r0;
84205c48:	ec 01 27 d5 	M[r5 + 492] = r0;
   r0 = M[r5 + $celt.enc.SCRATCHVAR_PUT_BYTEPOS];
84205c4c:	e8 01 27 d1 	r0 = M[r5 + 488];
#ifdef DATAFORMAT_32
   if Z jump anotherword;
84205c50:	12 00 00 dd 	if EQ jump $M.celt.put1byte.anotherword;
     push r1; //push unshifted byte to write
84205c54:	00 00 30 f3 	push r1;
     r0 = r0 LSHIFT 3;
84205c58:	03 00 22 8d 	r0 = r0 LSHIFT 3;
     r1 = r1 LSHIFT r0;
84205c5c:	00 00 32 8f 	r1 = r1 LSHIFT r0;
     push r1;
84205c60:	00 00 30 f3 	push r1;
     r1 = 0xFF LSHIFT r0;
84205c64:	ff 00 32 e9 	r1 = 0xff LSHIFT r0;
     r1 = r1 XOR 0xFFFFFFFF;
84205c68:	ff ff 00 fd 	r1 = r1 XOR 0xffffffff;
84205c6c:	ff ff 33 89 
     r0 = M[I0, 0];
84205c70:	00 20 00 03 	Null = Null + Null, r0 = M[I0,0];
     r0 = r0 AND r1;
84205c74:	00 00 23 83 	r0 = r0 AND r1;
     pop r1;
84205c78:	00 00 34 f3 	pop r1;
     r0 = r0 OR r1;
84205c7c:	00 00 23 87 	r0 = r0 OR r1;
     M[I0, 0] = r0;
84205c80:	00 a0 00 03 	Null = Null + Null, M[I0,0] = r0;
     r0 = M[r5 + $celt.enc.SCRATCHVAR_PUT_BYTEPOS];
84205c84:	e8 01 27 d1 	r0 = M[r5 + 488];
     r0 = r0 - 1;
84205c88:	3f 00 22 e4 	r0 = r0 - 1;
     M[r5 + $celt.enc.SCRATCHVAR_PUT_BYTEPOS] = r0;
84205c8c:	e8 01 27 d5 	M[r5 + 488] = r0;
     pop r1;  //restore written byte
84205c90:	00 00 34 f3 	pop r1;
     rts;
84205c94:	0f 00 0d dc 	rts;

84205c98 <$M.celt.put1byte.anotherword>:
   anotherword:
   r0 = M[I0, 0];
84205c98:	00 20 00 03 	Null = Null + Null, r0 = M[I0,0];
   r0 = r0 AND 0xFFFFFF00;
84205c9c:	ff ff 00 fd 	r0 = r0 AND 0xffffff00;
84205ca0:	00 ff 22 81 
   r0 = r0 OR r1;
84205ca4:	00 00 23 87 	r0 = r0 OR r1;
   M[I0, MK1] = r0;
84205ca8:	00 a1 00 03 	Null = Null + Null, M[I0,4] = r0;
   r0 = $celt.BYTE_POS_MAX_VALUE;
84205cac:	03 00 20 01 	r0 = Null + 3;
   M[r5 + $celt.enc.SCRATCHVAR_PUT_BYTEPOS] = r0;
84205cb0:	e8 01 27 d5 	M[r5 + 488] = r0;
   rts;
84205cb4:	0f 00 0d dc 	rts;

84205cb8 <$celt.put1byte_to_end>:

#if defined(PATCH_LIBS)
   LIBS_PUSH_REGS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.PUT1BYTE_TO_END.PATCH_ID_0)     // celt_patchers
#endif
   
   r0 = M[r5 + $celt.enc.SCRATCHVAR_FRAME_BYTES_REMAINED_REVERSE];
84205cb8:	f4 01 27 d1 	r0 = M[r5 + 500];
   r0 = r0 - 1;
84205cbc:	3f 00 22 e4 	r0 = r0 - 1;
   if NEG rts;
84205cc0:	04 00 0d dc 	if NEG rts;
   M[r5 + $celt.enc.SCRATCHVAR_FRAME_BYTES_REMAINED_REVERSE] = r0;
84205cc4:	f4 01 27 d5 	M[r5 + 500] = r0;
   r0 = M[r5 + $celt.enc.SCRATCHVAR_PUT_BYTEPOS_REVERSE];
84205cc8:	f0 01 27 d1 	r0 = M[r5 + 496];
#ifdef DATAFORMAT_32
   if Z jump anotherword;
84205ccc:	11 00 00 dd 	if EQ jump $M.celt.put1byte_to_end.anotherword;
     r0 = $celt.BYTE_POS_MAX_VALUE - r0; // Max byte count counting 0,1,2,3 and subtracting previously read byte count.
84205cd0:	03 00 22 65 	r0 = 3 - r0;
     r0 = r0 LSHIFT 3;
84205cd4:	03 00 22 8d 	r0 = r0 LSHIFT 3;
     r1 = r1 LSHIFT r0;
84205cd8:	00 00 32 8f 	r1 = r1 LSHIFT r0;
     push r1;
84205cdc:	00 00 30 f3 	push r1;
     r1 = 0xFF LSHIFT r0;
84205ce0:	ff 00 32 e9 	r1 = 0xff LSHIFT r0;
     r1 = r1 XOR 0xFFFFFFFF;
84205ce4:	ff ff 00 fd 	r1 = r1 XOR 0xffffffff;
84205ce8:	ff ff 33 89 
     r0 = M[I1, 0];
84205cec:	00 24 00 03 	Null = Null + Null, r0 = M[I1,0];
     r0 = r0 AND r1;
84205cf0:	00 00 23 83 	r0 = r0 AND r1;
     pop r1;
84205cf4:	00 00 34 f3 	pop r1;
     r0 = r0 OR r1;
84205cf8:	00 00 23 87 	r0 = r0 OR r1;
     M[I1, 0] = r0;
84205cfc:	00 a4 00 03 	Null = Null + Null, M[I1,0] = r0;
     r0 = M[r5 + $celt.enc.SCRATCHVAR_PUT_BYTEPOS_REVERSE];
84205d00:	f0 01 27 d1 	r0 = M[r5 + 496];
     r0 = r0 - 1;
84205d04:	3f 00 22 e4 	r0 = r0 - 1;
     M[r5 + $celt.enc.SCRATCHVAR_PUT_BYTEPOS_REVERSE] = r0;
84205d08:	f0 01 27 d5 	M[r5 + 496] = r0;
     rts;
84205d0c:	0f 00 0d dc 	rts;

84205d10 <$M.celt.put1byte_to_end.anotherword>:
   anotherword:
   r0 = M[I1, 0];
84205d10:	00 24 00 03 	Null = Null + Null, r0 = M[I1,0];
   r0 = r0 AND 0x00FFFFFF;
84205d14:	ff 00 00 fd 	r0 = r0 AND 0xffffff;
84205d18:	ff ff 22 81 
   r1 = r1 LSHIFT 24;
84205d1c:	18 00 33 8d 	r1 = r1 LSHIFT 24;
   r0 = r0 OR r1;
84205d20:	00 00 23 87 	r0 = r0 OR r1;
   M[I1, -MK1] = r0;
84205d24:	00 a7 00 03 	Null = Null + Null, M[I1,-4] = r0;
   r0 = $celt.BYTE_POS_MAX_VALUE;
84205d28:	03 00 20 01 	r0 = Null + 3;
   M[r5 + $celt.enc.SCRATCHVAR_PUT_BYTEPOS_REVERSE] = r0;
84205d2c:	f0 01 27 d5 	M[r5 + 496] = r0;
   rts;
84205d30:	0f 00 0d dc 	rts;
Disassembly of section .text_minim:

84205d34 <$_celt_decode_create>:
 * \return Whether the response_data field has been populated with a valid
 * response
 */
bool celt_decode_create(OPERATOR_DATA *op_data, void *message_data,
                                unsigned *response_id, void **response_data)
{
84205d34:	f5 1d       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>, SP = SP + 0x10;
84205d36:	11 09       	r7 = r0 + Null;
84205d38:	18 09       	r6 = r1 + Null;
84205d3a:	27 00       	r5 = r2 + Null;
84205d3c:	2a 09       	r8 = r3 + Null;
Private Function Declarations
*/

static inline CELT_DEC_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (CELT_DEC_OP_DATA *) base_op_get_instance_data(op_data);
84205d3e:	ef fd d3 ff 	call (m) 0x4e6;
84205d42:	29 ed 
84205d44:	16 00       	r4 = r0 + Null;
#endif

    patch_fn_shared(celt_decode_wrapper);
    
    /* call base_op create, which also allocates and fills response message */
    if (!base_op_create(op_data, message_data, response_id, response_data))
84205d46:	55 08       	r3 = r8 + Null;
84205d48:	3c 00       	r2 = r5 + Null;
84205d4a:	43 08       	r1 = r6 + Null;
84205d4c:	4a 08       	r0 = r7 + Null;
84205d4e:	ef fd d3 ff 	call (m) 0x35a;
84205d52:	2d e0 
84205d54:	10 04       	Null = r0 - Null;
84205d56:	03 62       	if NE jump (m) Lc_celt_decode_create_3;

84205d58 <Lc_celt_decode_create_2>:
    {
        return FALSE;
84205d58:	02 00       	r0 = Null + Null;
84205d5a:	78 6e       	jump (m) Lc_celt_decode_create_15;

84205d5c <Lc_celt_decode_create_3>:
        return TRUE;
    }
#endif

#ifdef CELT_DECODE_OFFLOAD
    celt_data->offload_enabled = opmgr_op_thread_offload(op_data) && audio_thread_offload_is_active();
84205d5c:	4a 08       	r0 = r7 + Null;
84205d5e:	ef fd ed ff 	call (m) 0x385a;
84205d62:	3d e7 
84205d64:	10 04       	Null = r0 - Null;
84205d66:	09 60       	if EQ jump (m) Lc_celt_decode_create_5;

84205d68 <Lc_celt_decode_create_4>:
84205d68:	ff fd 70 f0 	call (m) 0x13ec2;
84205d6c:	3b ea 
84205d6e:	03 00       	r1 = Null + Null;
84205d70:	10 04       	Null = r0 - Null;
84205d72:	21 f0 43 ce 	if NE r1 = Null + 1;
84205d76:	02 6e       	jump (m) Lc_celt_decode_create_6;

84205d78 <Lc_celt_decode_create_5>:
84205d78:	03 00       	r1 = Null + Null;

84205d7a <Lc_celt_decode_create_6>:
84205d7a:	63 f0 ab 8e 	M[r4 + 684] = r1;

    L2_DBG_MSG1("CELT decode, offload_enabled = %d",  celt_data->offload_enabled);
84205d7e:	01 f0 3c 91 	rMAC = MBS[Null + 0x33c];
84205d82:	88 24       	Null = rMAC - 2;
84205d84:	07 68       	if LT jump (m) Lc_celt_decode_create_8;

84205d86 <Lc_celt_decode_create_7>:
84205d86:	55 f1 02 f0 	r0 = Null + 357564416;
84205d8a:	00 40 
84205d8c:	ef fd d7 ff 	call (m) 0xcde;
84205d90:	33 ea 

84205d92 <Lc_celt_decode_create_8>:

    if (celt_data->offload_enabled)
84205d92:	60 f0 ab 88 	Null = M[r4 + 684];
84205d96:	12 60       	if EQ jump (m) Lc_celt_decode_create_11;

84205d98 <Lc_celt_decode_create_9>:
    {
        /* Offload enabled, so use a shared allocation */
        if (!mem_table_zalloc_shared((void *)(&(celt_data->codec_data)),
                        celt_dec_offload_shared_malloc_table, CELT_OFFLOAD_MALLOC_TABLE_LENGTH,
                        &new_allocation))
84205d98:	c5 11       	r3 = FP + 28;
84205d9a:	84 20       	r2 = Null + 2;
84205d9c:	07 f0 03 f0 	r1 = Null + 7347920;
84205da0:	d0 7a 
84205da2:	62 f0 4c 20 	r0 = r4 + 76;
84205da6:	ef fd df ff 	call (m) 0x1c4e;
84205daa:	29 e5 
84205dac:	10 04       	Null = r0 - Null;
84205dae:	11 62       	if NE jump (m) Lc_celt_decode_create_12;

84205db0 <Lc_celt_decode_create_10>:
        {
            free_data_and_fail(op_data, response_data);
84205db0:	53 08       	r1 = r8 + Null;
84205db2:	4a 08       	r0 = r7 + Null;
84205db4:	02 f0 3b ef 	call (m) Lc_free_data_and_fail_1;
84205db8:	48 6e       	jump (m) Lc_celt_decode_create_14;

84205dba <Lc_celt_decode_create_11>:
    }
    else
    {
        /* No offload: can't use shared allocation */
        if (!mem_table_zalloc((void *)(&(celt_data->codec_data)),
                        celt_dec_offload_malloc_table, CELT_OFFLOAD_MALLOC_TABLE_LENGTH))
84205dba:	84 20       	r2 = Null + 2;
84205dbc:	07 f0 03 f0 	r1 = Null + 7347936;
84205dc0:	e0 7a 
84205dc2:	62 f0 4c 20 	r0 = r4 + 76;
84205dc6:	ef fd df ff 	call (m) 0x1bfe;
84205dca:	39 e1 
84205dcc:	10 04       	Null = r0 - Null;
84205dce:	f1 61       	if EQ jump (m) Lc_celt_decode_create_10;

84205dd0 <Lc_celt_decode_create_12>:
    }
#endif

    /* now allocate the non-shareable memory */
    if(!mem_table_zalloc((uintptr_t *)(&(celt_data->codec_data)), celt_dec_malloc_table,
                                                CELT_DEC_MALLOC_TABLE_LENGTH))
84205dd0:	04 21       	r2 = Null + 4;
84205dd2:	07 f0 03 f0 	r1 = Null + 7347896;
84205dd6:	b8 7a 
84205dd8:	62 f0 4c 20 	r0 = r4 + 76;
84205ddc:	ef fd df ff 	call (m) 0x1bfe;
84205de0:	23 e1 
84205de2:	10 04       	Null = r0 - Null;
84205de4:	e6 61       	if EQ jump (m) Lc_celt_decode_create_10;

84205de6 <Lc_celt_decode_create_13>:
#endif
            /* Successfully allocated everything! */
            /* Stage 2 populate the DECODER structure */

            /* Tell the codec structure where to find the celt codec data */
            celt_data->decoder_data.codec.decoder_data_object = &(celt_data->codec_data);
84205de6:	61 f0 4c 20 	rMAC = r4 + 76;
84205dea:	b1 8f       	M[r4 + 24] = rMAC;
            
            
            celt_data->codec_data.ptr_flaglist_table = celt_data->codec_common_data.celt_flaglist ;
84205dec:	61 f0 a4 88 	rMAC = M[r4 + 656];
84205df0:	61 f0 97 8e 	M[r4 + 604] = rMAC;
            celt_data->codec_data.ptr_emeans_table =celt_data->codec_common_data.celt_emeans_table ;
84205df4:	61 f0 a5 88 	rMAC = M[r4 + 660];
84205df8:	61 f0 98 8e 	M[r4 + 608] = rMAC;
            celt_data->codec_data.ptr_max_n_table =celt_data->codec_common_data.celt_max_nfield ;
84205dfc:	61 f0 a6 88 	rMAC = M[r4 + 664];
84205e00:	61 f0 99 8e 	M[r4 + 612] = rMAC;
            celt_data->codec_data.ptr_max_k_table =celt_data->codec_common_data.celt_max_k_table ;
84205e04:	61 f0 a7 88 	rMAC = M[r4 + 668];
84205e08:	61 f0 9a 8e 	M[r4 + 616] = rMAC;
            celt_data->codec_data.ptr_inv2_table =celt_data->codec_common_data.celt_inv2_table ;
84205e0c:	61 f0 a8 88 	rMAC = M[r4 + 672];
84205e10:	61 f0 9b 8e 	M[r4 + 620] = rMAC;
            
            celt_data->codec_data.frame_size = 190;
84205e14:	01 f0 be 40 	rMAC = Null + 190;
84205e18:	31 af       	M[r4 + 80] = rMAC;
            celt_data->codec_data.channels =  CELT_STEREO_MODE;
84205e1a:	41 20       	rMAC = Null + 1;
84205e1c:	71 af       	M[r4 + 84] = rMAC;
            celt_data->codec_data.mdct_function =  (void*)celt_imdct_radix2;
84205e1e:	42 f0 01 f0 	rMAC = Null + 69208492;
84205e22:	ac 51 
84205e24:	b1 af       	M[r4 + 88] = rMAC;
            celt_data->codec_data.mdct_short_function = (void*)celt_imdct_radix2;
84205e26:	f1 af       	M[r4 + 92] = rMAC;
            celt_data->codec_data.dec_mode = CELT_MODE;
84205e28:	60 f0 a2 8e 	M[r4 + 648] = Null;
            
            /* Call the celt decoder init_decode and init_tables functions. */
            celt_decode_lib_init(&(celt_data->decoder_data.codec));
84205e2c:	32 00       	r0 = r4 + Null;
84205e2e:	d1 ff 26 e2 	call $_celt_decode_lib_init;
84205e32:	61 f0 ab 88 	rMAC = M[r4 + 684];
84205e36:	f1 ff f9 ff 	if NE call $_celt_setup_thread_offload;
84205e3a:	3e e9 

            CELT_SETUP_OFFLOAD_IF_ENABLED();

            populate_celt_asm_funcs(&(celt_data->decoder_data.decode_frame),
                                    &(celt_data->decoder_data.silence));
84205e3c:	63 f0 44 20 	r1 = r4 + 68;
84205e40:	62 f0 40 20 	r0 = r4 + 64;
84205e44:	06 f0 3b eb 	call (m) $_populate_celt_asm_funcs;

84205e48 <Lc_celt_decode_create_14>:
        if (!mem_table_zalloc_shared((void *)(&(celt_data->codec_data)),
                        celt_dec_offload_shared_malloc_table, CELT_OFFLOAD_MALLOC_TABLE_LENGTH,
                        &new_allocation))
        {
            free_data_and_fail(op_data, response_data);
            return TRUE;
84205e48:	42 20       	r0 = Null + 1;

84205e4a <Lc_celt_decode_create_15>:
    }
    /* Clear up all the allocated memory. */
    free_data_and_fail(op_data, response_data);
    return TRUE;
#endif
}
84205e4a:	f5 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, r8, rLink>;
84205e4c:	d8 4c       	rts;

84205e4e <$_celt_decode_destroy>:
 * \return Whether the response_data field has been populated with a valid
 * response
 */
bool celt_decode_destroy(OPERATOR_DATA *op_data, void *message_data,
                                    unsigned *response_id, void **response_data)
{
84205e4e:	f4 1c       	pushm <FP(=SP), r4, r5, r6, r7, rLink>;
84205e50:	16 00       	r4 = r0 + Null;
84205e52:	19 09       	r7 = r1 + Null;
84205e54:	27 00       	r5 = r2 + Null;
84205e56:	28 09       	r6 = r3 + Null;
    patch_fn_shared(celt_decode_wrapper);
    /* check that we are not trying to destroy a running operator */
    if (opmgr_op_is_running(op_data))
84205e58:	ef fd fc ff 	call (m) 0x5700;
84205e5c:	29 e5 
84205e5e:	10 04       	Null = r0 - Null;
84205e60:	09 60       	if EQ jump (m) Lc_celt_decode_destroy_3;

84205e62 <Lc_celt_decode_destroy_2>:
    {
        /* We can't destroy a running operator. */
        return base_op_build_std_response_ex(op_data, STATUS_CMD_FAILED, response_data);
84205e62:	03 f0 00 60 	r1 = Null + 4096;
84205e66:	44 08       	r2 = r6 + Null;
84205e68:	32 00       	r0 = r4 + Null;
84205e6a:	ef fd d3 ff 	call (m) 0x4bc;
84205e6e:	33 e2 
84205e70:	10 6e       	jump (m) Lc_celt_decode_destroy_6;

84205e72 <Lc_celt_decode_destroy_3>:
    }
    else if(base_op_destroy(op_data, message_data, response_id, response_data))
84205e72:	45 08       	r3 = r6 + Null;
84205e74:	3c 00       	r2 = r5 + Null;
84205e76:	4b 08       	r1 = r7 + Null;
84205e78:	32 00       	r0 = r4 + Null;
84205e7a:	ef fd d2 ff 	call (m) 0x370;
84205e7e:	37 e7 
84205e80:	10 04       	Null = r0 - Null;
84205e82:	06 60       	if EQ jump (m) Lc_celt_decode_destroy_5;

84205e84 <Lc_celt_decode_destroy_4>:
        /* Free all the scratch memory we reserved */
        scratch_deregister();
#endif
        /* Clear up the celt_decode specific work and then let base_op do
         * the grunt work. */
        free_data(op_data);
84205e84:	32 00       	r0 = r4 + Null;
84205e86:	02 f0 39 e6 	call (m) Lc_free_data_1;
        return TRUE;
84205e8a:	42 20       	r0 = Null + 1;
84205e8c:	02 6e       	jump (m) Lc_celt_decode_destroy_6;

84205e8e <Lc_celt_decode_destroy_5>:
    }

    return FALSE;
84205e8e:	02 00       	r0 = Null + Null;

84205e90 <Lc_celt_decode_destroy_6>:
}
84205e90:	f4 48       	popm <FP, r4, r5, r6, r7, rLink>;
84205e92:	d8 4c       	rts;

84205e94 <$_celt_decode_process_data>:
 * \param op_data Pointer to the operator instance data.
 * \param touched Structure to return the terminals which this operator wants kicked
 */

void celt_decode_process_data(OPERATOR_DATA *op_data, TOUCHED_TERMINALS *touched)
{
84205e94:	f6 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>;
84205e96:	4d 4c       	SP = SP + 52;
84205e98:	12 09       	r8 = r0 + Null;
84205e9a:	1b 09       	r9 = r1 + Null;
Private Function Declarations
*/

static inline CELT_DEC_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (CELT_DEC_OP_DATA *) base_op_get_instance_data(op_data);
84205e9c:	ef fd d3 ff 	call (m) 0x4e6;
84205ea0:	2b e2 
84205ea2:	16 00       	r4 = r0 + Null;
    CELT_DEC_OP_DATA *celt_data = get_instance_data(op_data);
    unsigned output_samples;
#ifdef CELT_DECODE_OFFLOAD
    A2DP_DECODER_PARAMS *decoder_data = &celt_data->decoder_data;
    unsigned op_offset_pre_dec, op_offset_post_dec;
    INT_OP_ID opid = base_op_get_int_op_id(op_data);
84205ea4:	52 08       	r0 = r8 + Null;
84205ea6:	ef fd d3 ff 	call (m) 0x4f0;
84205eaa:	2b e2 
84205eac:	17 00       	r5 = r0 + Null;
84205eae:	b1 f1 17 7b 	rMAC = Null + 229143;
84205eb2:	5f de       	M[FP + 44] = r5;
84205eb4:	61 de       	M[FP + 48] = rMAC;
84205eb6:	6e de       	M[FP + 52] = r4;
84205eb8:	31 a8       	rMAC = M[r4 + 64];
84205eba:	71 de       	M[FP + 56] = rMAC;
84205ebc:	78 de       	M[FP + 60] = Null;
84205ebe:	71 98       	rMAC = M[r4 + 36];
84205ec0:	81 de       	M[FP + 64] = rMAC;
84205ec2:	42 f0 31 f0 	rMAC = Null + 69231553;
84205ec6:	c1 43 
84205ec8:	89 de       	M[FP + 68] = rMAC;
84205eca:	ea f0 12 8e 	M[FP + 72] = r8;
        (uintptr_t)CODEC_NORMAL_DECODE,
        (uintptr_t)celt_data->decoder_data.a2dp_header,
        celt_dec_offload_callback, op_data
    };
#endif /* CELT_DECODE_OFFLOAD */
    bool input_full = FALSE;
84205ece:	40 de       	M[FP + 32] = Null;
    stereo_ptrs write_ptrs = {NULL, NULL};
84205ed0:	07 f0 01 f0 	rMAC = Null + 7347948;
84205ed4:	ec 7a 
84205ed6:	c2 14       	r0 = FP + 76;
84205ed8:	0b e8       	r1 = M[rMAC + Null];
84205eda:	4c 88       	r2 = M[rMAC + 4];
84205edc:	13 ee       	M[r0 + Null] = r1;
84205ede:	54 8e       	M[r0 + 4] = r2;

    if (!cbuffer_calc_amount_space_in_words(celt_data->decoder_data.codec.in_buffer))
84205ee0:	32 e8       	r0 = M[r4 + Null];
84205ee2:	ff fd 9f f1 	call (m) 0x39d88;
84205ee6:	27 e5 
84205ee8:	10 04       	Null = r0 - Null;
84205eea:	03 62       	if NE jump (m) Lc_celt_decode_process_data_3;

84205eec <Lc_celt_decode_process_data_2>:
    {
        input_full = TRUE;
84205eec:	41 20       	rMAC = Null + 1;
84205eee:	41 de       	M[FP + 32] = rMAC;

84205ef0 <Lc_celt_decode_process_data_3>:
    }

#ifdef CELT_DECODE_OFFLOAD

    if (audio_thread_rpc_is_queued(opid))
84205ef0:	3a 00       	r0 = r5 + Null;
84205ef2:	ff fd 70 f0 	call (m) 0x13f5e;
84205ef6:	2d e3 
84205ef8:	10 04       	Null = r0 - Null;
84205efa:	05 60       	if EQ jump (m) Lc_celt_decode_process_data_5;

84205efc <Lc_celt_decode_process_data_4>:
    {
        celt_data->kicks_pending = TRUE;
84205efc:	41 20       	rMAC = Null + 1;
84205efe:	61 f0 aa 8e 	M[r4 + 680] = rMAC;
        return;
84205f02:	c4 6e       	jump (m) Lc_celt_decode_process_data_45;

84205f04 <Lc_celt_decode_process_data_5>:
    }

    op_offset_pre_dec = cbuffer_get_write_offset(decoder_data->op_out_left);
84205f04:	f2 89       	r0 = M[r4 + 28];
84205f06:	ff fd 72 f0 	call (m) 0x14420;
84205f0a:	3b e8 
84205f0c:	10 09       	r6 = r0 + Null;

    celt_data->clone_input->read_ptr = decoder_data->codec.in_buffer->read_ptr;
84205f0e:	31 e8       	rMAC = M[r4 + Null];
84205f10:	62 f0 a9 88 	r0 = M[r4 + 676];
84205f14:	49 88       	rMAC = M[rMAC + 4];
84205f16:	51 8e       	M[r0 + 4] = rMAC;

    decoder_data->op_out_left->write_ptr = decoder_data->codec.out_left_buffer->write_ptr;
84205f18:	71 88       	rMAC = M[r4 + 4];
84205f1a:	f2 89       	r0 = M[r4 + 28];
84205f1c:	89 88       	rMAC = M[rMAC + 8];
84205f1e:	91 8e       	M[r0 + 8] = rMAC;
    if (decoder_data->op_out_right != NULL)
84205f20:	31 98       	rMAC = M[r4 + 32];
84205f22:	04 60       	if EQ jump (m) Lc_celt_decode_process_data_7;

84205f24 <Lc_celt_decode_process_data_6>:
    {
        decoder_data->op_out_right->write_ptr = decoder_data->codec.out_right_buffer->write_ptr;
84205f24:	b2 88       	r0 = M[r4 + 8];
84205f26:	92 88       	r0 = M[r0 + 8];
84205f28:	8a 8e       	M[rMAC + 8] = r0;

84205f2a <Lc_celt_decode_process_data_7>:
    }

    decoder_data->codec.in_buffer->write_ptr = celt_data->clone_input->write_ptr;
84205f2a:	61 f0 a9 88 	rMAC = M[r4 + 676];
84205f2e:	32 e8       	r0 = M[r4 + Null];
84205f30:	89 88       	rMAC = M[rMAC + 8];
84205f32:	91 8e       	M[r0 + 8] = rMAC;

    if ((BUF_DESC_IN_PLACE(decoder_data->op_out_left->descriptor) != 0) && (decoder_data->op_out_left->aux_ptr != NULL))
84205f34:	f2 89       	r0 = M[r4 + 28];
84205f36:	51 89       	rMAC = M[r0 + 20];
84205f38:	c9 c6       	rMAC = rMAC AND 0x10000;
84205f3a:	07 60       	if EQ jump (m) Lc_celt_decode_process_data_10;

84205f3c <Lc_celt_decode_process_data_8>:
84205f3c:	11 89       	rMAC = M[r0 + 16];
84205f3e:	05 60       	if EQ jump (m) Lc_celt_decode_process_data_10;

84205f40 <Lc_celt_decode_process_data_9>:
    {
        tCbuffer *tail = (tCbuffer *)decoder_data->op_out_left->aux_ptr;
        decoder_data->codec.out_left_buffer->read_ptr = tail->read_ptr;
84205f40:	49 88       	rMAC = M[rMAC + 4];
84205f42:	72 88       	r0 = M[r4 + 4];
84205f44:	51 8e       	M[r0 + 4] = rMAC;
84205f46:	04 6e       	jump (m) Lc_celt_decode_process_data_11;

84205f48 <Lc_celt_decode_process_data_10>:
    }
    else
    {
        decoder_data->codec.out_left_buffer->read_ptr = decoder_data->op_out_left->read_ptr;
84205f48:	51 88       	rMAC = M[r0 + 4];
84205f4a:	72 88       	r0 = M[r4 + 4];
84205f4c:	51 8e       	M[r0 + 4] = rMAC;

84205f4e <Lc_celt_decode_process_data_11>:
    }

    if (decoder_data->op_out_right != NULL)
84205f4e:	32 98       	r0 = M[r4 + 32];
84205f50:	0d 60       	if EQ jump (m) Lc_celt_decode_process_data_16;

84205f52 <Lc_celt_decode_process_data_12>:
    {
        if ((BUF_DESC_IN_PLACE(decoder_data->op_out_right->descriptor) != 0) && (decoder_data->op_out_right->aux_ptr != NULL))
84205f52:	51 89       	rMAC = M[r0 + 20];
84205f54:	c9 c6       	rMAC = rMAC AND 0x10000;
84205f56:	07 60       	if EQ jump (m) Lc_celt_decode_process_data_15;

84205f58 <Lc_celt_decode_process_data_13>:
84205f58:	11 89       	rMAC = M[r0 + 16];
84205f5a:	05 60       	if EQ jump (m) Lc_celt_decode_process_data_15;

84205f5c <Lc_celt_decode_process_data_14>:
        {
            tCbuffer *tail = (tCbuffer *)decoder_data->op_out_right->aux_ptr;
            decoder_data->codec.out_right_buffer->read_ptr = tail->read_ptr;
84205f5c:	49 88       	rMAC = M[rMAC + 4];
84205f5e:	b2 88       	r0 = M[r4 + 8];
84205f60:	51 8e       	M[r0 + 4] = rMAC;
84205f62:	04 6e       	jump (m) Lc_celt_decode_process_data_16;

84205f64 <Lc_celt_decode_process_data_15>:
        }
        else
        {
            decoder_data->codec.out_right_buffer->read_ptr = decoder_data->op_out_right->read_ptr;
84205f64:	51 88       	rMAC = M[r0 + 4];
84205f66:	b2 88       	r0 = M[r4 + 8];
84205f68:	51 8e       	M[r0 + 4] = rMAC;

84205f6a <Lc_celt_decode_process_data_16>:
        }
    }

    op_offset_post_dec = cbuffer_get_write_offset(decoder_data->op_out_left);
84205f6a:	f2 89       	r0 = M[r4 + 28];
84205f6c:	ff fd 72 f0 	call (m) 0x14420;
84205f70:	35 e5 
84205f72:	17 00       	r5 = r0 + Null;
#endif

    /* Checks for enough data and enough output space are done at the top of
     * this function so it's not done in this C code as well. */

    a2dp_decode_buffer_get_write_ptrs(&(celt_data->decoder_data), &write_ptrs);
84205f74:	c3 14       	r1 = FP + 76;
84205f76:	32 00       	r0 = r4 + Null;
84205f78:	ef fd d1 ff 	call (m) 0x24a;
84205f7c:	33 e6 
    /* Checks for enough data and enough output space are done at the top of
     * this function so it's not done in this C code as well. */


#ifdef CELT_DECODE_OFFLOAD
    if (celt_data->offload_enabled)
84205f7e:	60 f0 ab 88 	Null = M[r4 + 684];
84205f82:	06 60       	if EQ jump (m) Lc_celt_decode_process_data_18;

84205f84 <Lc_celt_decode_process_data_17>:
    {
        thread_offload_queue_rpc(&rpc_data);
84205f84:	c2 12       	r0 = FP + 44;
84205f86:	ff fd 70 f0 	call (m) 0x13fa6;
84205f8a:	21 e1 
84205f8c:	08 6e       	jump (m) Lc_celt_decode_process_data_19;

84205f8e <Lc_celt_decode_process_data_18>:
    else
    {
        a2dp_decoder_decode(&(celt_data->decoder_data.codec),
                             celt_data->decoder_data.decode_frame,
                             CODEC_NORMAL_DECODE,
                             celt_data->decoder_data.a2dp_header);
84205f8e:	75 98       	r3 = M[r4 + 36];
84205f90:	33 a8       	r1 = M[r4 + 64];
84205f92:	04 00       	r2 = Null + Null;
84205f94:	32 00       	r0 = r4 + Null;
84205f96:	ff fd 8f f1 	call (m) 0x37f16;
84205f9a:	21 ec 

84205f9c <Lc_celt_decode_process_data_19>:
    }

    /* total data processed on the input */
    if (op_offset_post_dec >= op_offset_pre_dec)
84205f9c:	8f f7 00 c2 	Null = r5 - r6;
84205fa0:	04 64       	if NC jump (m) Lc_celt_decode_process_data_21;

84205fa2 <Lc_celt_decode_process_data_20>:
    {
        output_samples = op_offset_post_dec - op_offset_pre_dec;
84205fa2:	00 f8 37 c2 	r5 = r5 - r6;
84205fa6:	08 6e       	jump (m) Lc_celt_decode_process_data_22;

84205fa8 <Lc_celt_decode_process_data_21>:
    }
    else
    {
        unsigned buffsize = cbuffer_get_size_in_words(decoder_data->op_out_left);
84205fa8:	f2 89       	r0 = M[r4 + 28];
84205faa:	ff fd 72 f0 	call (m) 0x14450;
84205fae:	27 e5 
        output_samples = buffsize + op_offset_post_dec - op_offset_pre_dec;
84205fb0:	d1 01       	rMAC = r0 + r5;
84205fb2:	8f f1 07 c2 	r5 = rMAC - r6;

84205fb6 <Lc_celt_decode_process_data_22>:
                            CODEC_NORMAL_DECODE,
                            celt_data->decoder_data.a2dp_header);
    output_samples = celt_data->decoder_data.codec.num_output_samples;
#endif /* CELT_DECODE_OFFLOAD */

    if (output_samples > 0)
84205fb6:	38 04       	Null = r5 - Null;
84205fb8:	4f 60       	if EQ jump (m) Lc_celt_decode_process_data_40;

84205fba <Lc_celt_decode_process_data_23>:
    {
        /* Source 0 is always touched */
        unsigned touched_sources = TOUCHED_SOURCE_0;
84205fba:	09 71       	r7 = Null + 1;
        unsigned b4idx, afteridx;
        metadata_tag *mtag;
        tCbuffer *src, *dst;

#ifdef CELT_DECODE_OFFLOAD
        src = celt_data->clone_input;
84205fbc:	62 f0 a9 88 	r0 = M[r4 + 676];
#else
        src = celt_data->decoder_data.codec.in_buffer;
#endif

        dst = celt_data->decoder_data.metadata_op_buffer;
84205fc0:	68 f0 12 88 	r6 = M[r4 + 72];
        processed = celt_data->codec_data.frame_size;
84205fc4:	33 a9       	r1 = M[r4 + 80];

        mtag = buff_metadata_remove(src, processed, &b4idx, &afteridx);
84205fc6:	85 12       	r3 = FP + 40;
84205fc8:	44 12       	r2 = FP + 36;
84205fca:	ff fd 75 f0 	call (m) 0x149ca;
84205fce:	21 e0 
 *
 * \return TRUE if the buffer supports metadata. FALSE if it doesn't.
 */
static inline bool buff_has_metadata(tCbuffer *buff)
{
    if (buff->metadata != NULL)
84205fd0:	81 f0 06 88 	rMAC = M[r6 + 24];
84205fd4:	56 60       	if EQ jump (m) Lc_celt_decode_process_data_44;

84205fd6 <Lc_celt_decode_process_data_24>:
            unsigned output_octets;
            /* TODO In the current implementation of timestamp insertion (RTP decode) each packet
             * will have a tag (with timestamp) so it makes sense to check if this condition
             * is not true. In the future the decoder should support timestamp insertion
             * in case if not all packet has tags.*/
            if (mtag != NULL)
84205fd6:	10 04       	Null = r0 - Null;
84205fd8:	1b 60       	if EQ jump (m) Lc_celt_decode_process_data_31;

84205fda <Lc_celt_decode_process_data_25>:
            {
                if ( IS_TIMESTAMPED_TAG(mtag))
84205fda:	51 88       	rMAC = M[r0 + 4];
84205fdc:	13 f0 30 00 	r1 = rMAC AND 0x30;
84205fe0:	1a 60       	if EQ jump (m) Lc_celt_decode_process_data_32;

84205fe2 <Lc_celt_decode_process_data_26>:
84205fe2:	c9 c2       	rMAC = rMAC AND 0x40;
84205fe4:	18 62       	if NE jump (m) Lc_celt_decode_process_data_32;

84205fe6 <Lc_celt_decode_process_data_27>:
                {
                    PL_ASSERT(b4idx == 0);
84205fe6:	48 d8       	Null = M[FP + 36];
84205fe8:	09 60       	if EQ jump (m) Lc_celt_decode_process_data_29;

84205fea <Lc_celt_decode_process_data_28>:
84205fea:	03 f0 5a 43 	r1 = Null + 858;
84205fee:	02 f0 13 60 	r0 = Null + 4115;
84205ff2:	ff fd 87 f0 	call (m) 0x16ff0;
84205ff6:	3f ef 
84205ff8:	49 6e       	jump (m) Lc_celt_decode_process_data_45;

84205ffa <Lc_celt_decode_process_data_29>:
                    PL_ASSERT(mtag->next == NULL);
84205ffa:	11 e8       	rMAC = M[r0 + Null];
84205ffc:	0c 60       	if EQ jump (m) Lc_celt_decode_process_data_32;

84205ffe <Lc_celt_decode_process_data_30>:
84205ffe:	03 f0 5b 43 	r1 = Null + 859;
84206002:	02 f0 13 60 	r0 = Null + 4115;
84206006:	ff fd 87 f0 	call (m) 0x16ff0;
8420600a:	2b ef 
8420600c:	3f 6e       	jump (m) Lc_celt_decode_process_data_45;

8420600e <Lc_celt_decode_process_data_31>:
            else
            {
                /* produce one tag per frame
                   NB. this is an invented tag, no timestamps, nor other private data,
                   it only serves the purpose of removing at audio EP TODO TTP */
                mtag = buff_metadata_new_tag();
8420600e:	ff fd 72 f0 	call (m) 0x1454e;
84206012:	21 ea 

84206014 <Lc_celt_decode_process_data_32>:
            }
            /* decoded output will have different frame lengths */
            output_octets = output_samples * OCTETS_PER_SAMPLE;
84206014:	7d 54       	r3 = r5 LSHIFT 2;
            if (mtag != NULL)
84206016:	10 04       	Null = r0 - Null;
84206018:	06 60       	if EQ jump (m) Lc_celt_decode_process_data_34;

8420601a <Lc_celt_decode_process_data_33>:
            {
                mtag->length = output_octets;
8420601a:	d5 8e       	M[r0 + 12] = r3;
                METADATA_PACKET_START_SET(mtag);
8420601c:	51 88       	rMAC = M[r0 + 4];
8420601e:	c9 c8       	rMAC = rMAC OR 0x4;
                METADATA_PACKET_END_SET(mtag);
84206020:	49 c9       	rMAC = rMAC OR 0x8;
84206022:	51 8e       	M[r0 + 4] = rMAC;

84206024 <Lc_celt_decode_process_data_34>:
            }
            buff_metadata_append(dst, mtag, 0, output_octets);
84206024:	04 00       	r2 = Null + Null;
84206026:	13 00       	r1 = r0 + Null;
84206028:	42 08       	r0 = r6 + Null;
8420602a:	ff fd 73 f0 	call (m) 0x147b8;
8420602e:	2f ec 

84206030 <Lc_celt_decode_process_data_35>:
            buff_metadata_delete_tag(mtag, TRUE);
        }
#endif      /* INSTALL_METADATA */

        /* Handle mono/stereo fade-out */
        if (a2dp_decode_check_and_perform_fadeout(&(celt_data->decoder_data), output_samples, &write_ptrs))
84206030:	c4 14       	r2 = FP + 76;
84206032:	3b 00       	r1 = r5 + Null;
84206034:	32 00       	r0 = r4 + Null;
84206036:	ef fd d1 ff 	call (m) 0x27a;
8420603a:	25 e2 
8420603c:	10 04       	Null = r0 - Null;
8420603e:	07 60       	if EQ jump (m) Lc_celt_decode_process_data_37;

84206040 <Lc_celt_decode_process_data_36>:
        {
                common_send_simple_unsolicited_message(op_data, OPMSG_REPLY_ID_FADEOUT_DONE);
84206040:	13 f0 00 40 	r1 = Null + 8192;
84206044:	52 08       	r0 = r8 + Null;
84206046:	ef fd d2 ff 	call (m) 0x586;
8420604a:	21 ea 

8420604c <Lc_celt_decode_process_data_37>:
            }

       /* If stereo outputs are connected then source 1 was touched as well */
       if (celt_data->decoder_data.codec.out_right_buffer != NULL)
8420604c:	b1 88       	rMAC = M[r4 + 8];
8420604e:	02 60       	if EQ jump (m) Lc_celt_decode_process_data_39;

84206050 <Lc_celt_decode_process_data_38>:
       {
           touched_sources |= TOUCHED_SOURCE_1;
84206050:	19 71       	r7 = Null + 3;

84206052 <Lc_celt_decode_process_data_39>:
       }

       /* Source(s) touched */
       touched->sources = touched_sources;
84206052:	b9 f0 00 ee 	M[r9 + Null] = r7;

84206056 <Lc_celt_decode_process_data_40>:
         * after having consumed from a full buffer. In cases where the endpoint should kick an
         * upstream entity this is useful so the upstream entity can be notified of more space.
         * In other cases it helps to get data into the decoder as quickly as possible.
         */
    if ((cbuffer_calc_amount_data_in_words(celt_data->decoder_data.codec.in_buffer) < MAX_CELT_FRAME_SIZE_IN_WORDS) ||
        (input_full && cbuffer_calc_amount_space_in_words(celt_data->decoder_data.codec.in_buffer)))
84206056:	32 e8       	r0 = M[r4 + Null];
84206058:	ff fd 9e f1 	call (m) 0x39dd4;
8420605c:	3d eb 
8420605e:	20 f0 00 2c 	Null = r0 - 1024;
84206062:	09 64       	if NC jump (m) Lc_celt_decode_process_data_43;

84206064 <Lc_celt_decode_process_data_41>:
84206064:	41 d8       	rMAC = M[FP + 32];
84206066:	12 60       	if EQ jump (m) Lc_celt_decode_process_data_45;

84206068 <Lc_celt_decode_process_data_42>:
84206068:	32 e8       	r0 = M[r4 + Null];
8420606a:	ff fd 9e f1 	call (m) 0x39d88;
8420606e:	3f e8 
84206070:	10 04       	Null = r0 - Null;
84206072:	0c 60       	if EQ jump (m) Lc_celt_decode_process_data_45;

84206074 <Lc_celt_decode_process_data_43>:
    {
        touched->sinks |= TOUCHED_SINK_0;
84206074:	b1 f0 01 88 	rMAC = M[r9 + 4];
84206078:	09 c8       	rMAC = rMAC OR 0x1;
8420607a:	b1 f0 01 8e 	M[r9 + 4] = rMAC;
8420607e:	06 6e       	jump (m) Lc_celt_decode_process_data_45;

84206080 <Lc_celt_decode_process_data_44>:
            }
            buff_metadata_append(dst, mtag, 0, output_octets);
        }
        else
        {
            buff_metadata_delete_tag(mtag, TRUE);
84206080:	4b 08       	r1 = r7 + Null;
84206082:	ff fd 72 f0 	call (m) 0x1459c;
84206086:	3b e8 
84206088:	d4 6f       	jump (m) Lc_celt_decode_process_data_35;

8420608a <Lc_celt_decode_process_data_45>:

#ifdef INSTALL_CELT_DATA_TEST
    /* Kick the input to get it going */
    touched->sinks |= TOUCHED_SINK_0;
#endif
}
8420608a:	73 4c       	SP = SP + -52;
8420608c:	f6 48       	popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
8420608e:	d8 4c       	rts;

84206090 <$_celt_decode_buffer_details>:
 * response
 */

bool celt_decode_buffer_details(OPERATOR_DATA *op_data, void *message_data,
                                    unsigned *response_id, void **response_data)
{
84206090:	c8 1c       	pushm <FP(=SP), rLink>;
    patch_fn_shared(celt_decode_wrapper);

    return a2dp_decode_buffer_details_core(op_data, message_data,response_id, response_data,CELT_DECODE_INPUT_BUFFER_SIZE,CELT_DECODE_OUTPUT_BUFFER_SIZE,0);
84206092:	00 f0 30 cf 	push Null;
84206096:	04 f0 50 e0 	push Null + 1024;
8420609a:	04 f0 50 e0 	push Null + 1024;
8420609e:	ef fd d0 ff 	call (m) 0x186;
842060a2:	29 e7 
842060a4:	7d 4c       	SP = SP + -12;

842060a6 <Lc_celt_decode_buffer_details_2>:
}
842060a6:	c8 48       	popm <FP, rLink>;
842060a8:	d8 4c       	rts;

842060aa <$_celt_decode_connect>:
    return TRUE;
}

bool celt_decode_connect(OPERATOR_DATA *op_data, void *message_data,
                                unsigned *response_id, void **response_data)
{
842060aa:	f4 1c       	pushm <FP(=SP), r4, r5, r6, r7, rLink>;
842060ac:	17 00       	r5 = r0 + Null;
842060ae:	18 09       	r6 = r1 + Null;
842060b0:	29 09       	r7 = r3 + Null;
Private Function Declarations
*/

static inline CELT_DEC_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (CELT_DEC_OP_DATA *) base_op_get_instance_data(op_data);
842060b2:	ef fd d2 ff 	call (m) 0x4e6;
842060b6:	35 e1 
842060b8:	16 00       	r4 = r0 + Null;
    CELT_DEC_OP_DATA *celt_data = get_instance_data(op_data);
    A2DP_DECODER_PARAMS *decoder_data = &celt_data->decoder_data;
    unsigned terminal_id;

    /* Check that the capability is not running */
    if (opmgr_op_is_running(op_data))
842060ba:	3a 00       	r0 = r5 + Null;
842060bc:	ef fd fb ff 	call (m) 0x5700;
842060c0:	25 e2 
842060c2:	10 04       	Null = r0 - Null;
842060c4:	09 60       	if EQ jump (m) Lc_celt_decode_connect_3;

842060c6 <Lc_celt_decode_connect_2>:
    {
        return base_op_build_std_response_ex(op_data, STATUS_CMD_FAILED, response_data);
842060c6:	03 f0 00 60 	r1 = Null + 4096;
842060ca:	4c 08       	r2 = r7 + Null;
842060cc:	3a 00       	r0 = r5 + Null;
842060ce:	ef fd d1 ff 	call (m) 0x4bc;
842060d2:	2f ef 
842060d4:	2c 6e       	jump (m) Lc_celt_decode_connect_16;

842060d6 <Lc_celt_decode_connect_3>:
    }

    if (!base_op_build_std_response_ex(op_data, STATUS_OK, response_data))
842060d6:	03 00       	r1 = Null + Null;
842060d8:	4c 08       	r2 = r7 + Null;
842060da:	3a 00       	r0 = r5 + Null;
842060dc:	ef fd d1 ff 	call (m) 0x4bc;
842060e0:	21 ef 
842060e2:	10 04       	Null = r0 - Null;
842060e4:	03 62       	if NE jump (m) Lc_celt_decode_connect_5;

842060e6 <Lc_celt_decode_connect_4>:
    {
        return FALSE;
842060e6:	02 00       	r0 = Null + Null;
842060e8:	22 6e       	jump (m) Lc_celt_decode_connect_16;

842060ea <Lc_celt_decode_connect_5>:
    }

    terminal_id = ((unsigned *)message_data)[0];

    switch (terminal_id)
842060ea:	81 f0 00 e8 	rMAC = M[r6 + Null];
842060ee:	0d 60       	if EQ jump (m) Lc_celt_decode_connect_10;

842060f0 <Lc_celt_decode_connect_6>:
842060f0:	48 24       	Null = rMAC - 1;
842060f2:	14 60       	if EQ jump (m) Lc_celt_decode_connect_13;

842060f4 <Lc_celt_decode_connect_7>:
842060f4:	00 f2 10 f0 	Null = rMAC - 8388608;
842060f8:	00 24 
842060fa:	05 62       	if NE jump (m) Lc_celt_decode_connect_9;

842060fc <Lc_celt_decode_connect_8>:
    {
        case INPUT_TERMINAL_ID:
            celt_data->clone_input = (tCbuffer*)(((uintptr_t *)message_data)[1]);
842060fc:	81 f0 01 88 	rMAC = M[r6 + 4];
84206100:	61 f0 a9 8e 	M[r4 + 676] = rMAC;

84206104 <Lc_celt_decode_connect_9>:
#endif /* INSTALL_METADATA */

            break;
        /* NB No default as can't happen */
    }
    return TRUE;
84206104:	42 20       	r0 = Null + 1;
84206106:	13 6e       	jump (m) Lc_celt_decode_connect_16;

84206108 <Lc_celt_decode_connect_10>:
    {
        case INPUT_TERMINAL_ID:
            celt_data->clone_input = (tCbuffer*)(((uintptr_t *)message_data)[1]);
            break;
        case LEFT_OUT_TERMINAL_ID:
            decoder_data->op_out_left = (tCbuffer*)(((uintptr_t *)message_data)[1]);
84206108:	81 f0 01 88 	rMAC = M[r6 + 4];
8420610c:	f1 8f       	M[r4 + 28] = rMAC;
#ifdef INSTALL_METADATA
            if (decoder_data->metadata_op_buffer == NULL)
8420610e:	b2 a8       	r0 = M[r4 + 72];
84206110:	fa 63       	if NE jump (m) Lc_celt_decode_connect_9;

84206112 <Lc_celt_decode_connect_11>:
84206112:	8a 89       	r0 = M[rMAC + 24];
84206114:	f8 61       	if EQ jump (m) Lc_celt_decode_connect_9;

84206116 <Lc_celt_decode_connect_12>:
            {
                if (buff_has_metadata(decoder_data->op_out_left))
                {
                    decoder_data->metadata_op_buffer = decoder_data->op_out_left;
84206116:	b1 ae       	M[r4 + 72] = rMAC;
84206118:	f6 6f       	jump (m) Lc_celt_decode_connect_9;

8420611a <Lc_celt_decode_connect_13>:
            }
#endif /* INSTALL_METADATA */

            break;
        case RIGHT_OUT_TERMINAL_ID:
            decoder_data->op_out_right = (tCbuffer*)(((uintptr_t *)message_data)[1]);
8420611a:	81 f0 01 88 	rMAC = M[r6 + 4];
8420611e:	31 9e       	M[r4 + 32] = rMAC;
#ifdef INSTALL_METADATA
            if (decoder_data->metadata_op_buffer == NULL)
84206120:	b2 a8       	r0 = M[r4 + 72];
84206122:	f1 63       	if NE jump (m) Lc_celt_decode_connect_9;

84206124 <Lc_celt_decode_connect_14>:
84206124:	8a 89       	r0 = M[rMAC + 24];
84206126:	ef 61       	if EQ jump (m) Lc_celt_decode_connect_9;

84206128 <Lc_celt_decode_connect_15>:
            {
                if (buff_has_metadata(decoder_data->op_out_right))
                {
                    decoder_data->metadata_op_buffer = decoder_data->op_out_right;
84206128:	b1 ae       	M[r4 + 72] = rMAC;
8420612a:	ed 6f       	jump (m) Lc_celt_decode_connect_9;

8420612c <Lc_celt_decode_connect_16>:

            break;
        /* NB No default as can't happen */
    }
    return TRUE;
}
8420612c:	f4 48       	popm <FP, r4, r5, r6, r7, rLink>;
8420612e:	d8 4c       	rts;

84206130 <$_celt_decode_disconnect>:

bool celt_decode_disconnect(OPERATOR_DATA *op_data, void *message_data,
                                    unsigned *response_id, void **response_data)
{
84206130:	f4 1c       	pushm <FP(=SP), r4, r5, r6, r7, rLink>;
84206132:	10 09       	r6 = r0 + Null;
84206134:	1f 00       	r5 = r1 + Null;
84206136:	29 09       	r7 = r3 + Null;
Private Function Declarations
*/

static inline CELT_DEC_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (CELT_DEC_OP_DATA *) base_op_get_instance_data(op_data);
84206138:	ef fd d1 ff 	call (m) 0x4e6;
8420613c:	2f ed 
8420613e:	16 00       	r4 = r0 + Null;
bool celt_decode_disconnect(OPERATOR_DATA *op_data, void *message_data,
                                    unsigned *response_id, void **response_data)
{
    CELT_DEC_OP_DATA *celt_data = get_instance_data(op_data);
    A2DP_DECODER_PARAMS *decoder_data = &celt_data->decoder_data;
    unsigned terminal_id = ((unsigned *)message_data)[0];
84206140:	3f e8       	r5 = M[r5 + Null];

    /* Check that the capability is not running, Only the sink can be
     * disconnected whilst running!*/
    if (opmgr_op_is_running(op_data))
84206142:	42 08       	r0 = r6 + Null;
84206144:	ef fd fa ff 	call (m) 0x5700;
84206148:	3d ed 
8420614a:	10 04       	Null = r0 - Null;
8420614c:	0d 60       	if EQ jump (m) Lc_celt_decode_disconnect_4;

8420614e <Lc_celt_decode_disconnect_2>:
    {
        if (terminal_id != INPUT_TERMINAL_ID )
8420614e:	00 f2 70 f0 	Null = r5 - 8388608;
84206152:	00 24 
84206154:	09 60       	if EQ jump (m) Lc_celt_decode_disconnect_4;

84206156 <Lc_celt_decode_disconnect_3>:
        {
            return base_op_build_std_response_ex(op_data, STATUS_CMD_FAILED, response_data);
84206156:	03 f0 00 60 	r1 = Null + 4096;
8420615a:	4c 08       	r2 = r7 + Null;
8420615c:	42 08       	r0 = r6 + Null;
8420615e:	ef fd d1 ff 	call (m) 0x4bc;
84206162:	3f ea 
84206164:	24 6e       	jump (m) Lc_celt_decode_disconnect_17;

84206166 <Lc_celt_decode_disconnect_4>:
        }
    }

    if (!base_op_build_std_response_ex(op_data, STATUS_OK, response_data))
84206166:	03 00       	r1 = Null + Null;
84206168:	4c 08       	r2 = r7 + Null;
8420616a:	42 08       	r0 = r6 + Null;
8420616c:	ef fd d1 ff 	call (m) 0x4bc;
84206170:	31 ea 
84206172:	10 04       	Null = r0 - Null;
84206174:	03 62       	if NE jump (m) Lc_celt_decode_disconnect_6;

84206176 <Lc_celt_decode_disconnect_5>:
    {
        return FALSE;
84206176:	02 00       	r0 = Null + Null;
84206178:	1a 6e       	jump (m) Lc_celt_decode_disconnect_17;

8420617a <Lc_celt_decode_disconnect_6>:
    }

    switch (terminal_id)
8420617a:	38 04       	Null = r5 - Null;
8420617c:	0a 60       	if EQ jump (m) Lc_celt_decode_disconnect_10;

8420617e <Lc_celt_decode_disconnect_7>:
8420617e:	78 24       	Null = r5 - 1;
84206180:	0f 60       	if EQ jump (m) Lc_celt_decode_disconnect_13;

84206182 <Lc_celt_decode_disconnect_8>:
84206182:	00 f2 70 f0 	Null = r5 - 8388608;
84206186:	00 24 
84206188:	11 62       	if NE jump (m) Lc_celt_decode_disconnect_16;

8420618a <Lc_celt_decode_disconnect_9>:
    {
        case INPUT_TERMINAL_ID:
            celt_data->clone_input = NULL;
8420618a:	60 f0 a9 8e 	M[r4 + 676] = Null;
            break;
8420618e:	0e 6e       	jump (m) Lc_celt_decode_disconnect_16;

84206190 <Lc_celt_decode_disconnect_10>:
        case LEFT_OUT_TERMINAL_ID:
#ifdef INSTALL_METADATA
            if (decoder_data->metadata_op_buffer == decoder_data->op_out_left)
84206190:	b1 a8       	rMAC = M[r4 + 72];
84206192:	f2 89       	r0 = M[r4 + 28];
84206194:	88 04       	Null = rMAC - r0;
84206196:	02 62       	if NE jump (m) Lc_celt_decode_disconnect_12;

84206198 <Lc_celt_decode_disconnect_11>:
            {
                decoder_data->metadata_op_buffer = NULL;
84206198:	b0 ae       	M[r4 + 72] = Null;

8420619a <Lc_celt_decode_disconnect_12>:
            }
#endif /* INSTALL_METADATA */

            decoder_data->op_out_left = NULL;
8420619a:	f0 8f       	M[r4 + 28] = Null;
            break;
8420619c:	07 6e       	jump (m) Lc_celt_decode_disconnect_16;

8420619e <Lc_celt_decode_disconnect_13>:
        case RIGHT_OUT_TERMINAL_ID:
#ifdef INSTALL_METADATA
            if (decoder_data->metadata_op_buffer == decoder_data->op_out_right)
8420619e:	b1 a8       	rMAC = M[r4 + 72];
842061a0:	32 98       	r0 = M[r4 + 32];
842061a2:	88 04       	Null = rMAC - r0;
842061a4:	02 62       	if NE jump (m) Lc_celt_decode_disconnect_15;

842061a6 <Lc_celt_decode_disconnect_14>:
            {
                decoder_data->metadata_op_buffer = NULL;
842061a6:	b0 ae       	M[r4 + 72] = Null;

842061a8 <Lc_celt_decode_disconnect_15>:
            }
#endif /* INSTALL_METADATA */


            decoder_data->op_out_right = NULL;
842061a8:	30 9e       	M[r4 + 32] = Null;

842061aa <Lc_celt_decode_disconnect_16>:
            break;
        /* NB No default as can't happen */
    }
    return TRUE;
842061aa:	42 20       	r0 = Null + 1;

842061ac <Lc_celt_decode_disconnect_17>:
}
842061ac:	f4 48       	popm <FP, r4, r5, r6, r7, rLink>;
842061ae:	d8 4c       	rts;

842061b0 <$_celt_decode_start>:
}

#ifdef CELT_DECODE_OFFLOAD

bool celt_decode_start(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
842061b0:	f4 1c       	pushm <FP(=SP), r4, r5, r6, r7, rLink>;
842061b2:	17 00       	r5 = r0 + Null;
842061b4:	20 09       	r6 = r2 + Null;
842061b6:	29 09       	r7 = r3 + Null;
Private Function Declarations
*/

static inline CELT_DEC_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (CELT_DEC_OP_DATA *) base_op_get_instance_data(op_data);
842061b8:	ef fd d1 ff 	call (m) 0x4e6;
842061bc:	2f e9 
842061be:	16 00       	r4 = r0 + Null;
{
    CELT_DEC_OP_DATA *celt_data = get_instance_data(op_data);
    A2DP_DECODER_PARAMS *decoder_data = &celt_data->decoder_data;
    unsigned buffer_flags;

    *response_id = OPCMD_START;
842061c0:	81 20       	rMAC = Null + 2;
842061c2:	81 f0 00 ee 	M[r6 + Null] = rMAC;

    /* Create the response. If there aren't sufficient resources for this fail
     * early. */
    if (!base_op_build_std_response_ex(op_data, STATUS_OK, response_data))
842061c6:	03 00       	r1 = Null + Null;
842061c8:	4c 08       	r2 = r7 + Null;
842061ca:	3a 00       	r0 = r5 + Null;
842061cc:	ef fd d1 ff 	call (m) 0x4bc;
842061d0:	31 e7 
842061d2:	10 04       	Null = r0 - Null;
842061d4:	03 62       	if NE jump (m) Lc_celt_decode_start_3;

842061d6 <Lc_celt_decode_start_2>:
    {
        return FALSE;
842061d6:	02 00       	r0 = Null + Null;
842061d8:	60 6e       	jump (m) Lc_celt_decode_start_12;

842061da <Lc_celt_decode_start_3>:
    }

    if (opmgr_op_is_running(op_data))
842061da:	3a 00       	r0 = r5 + Null;
842061dc:	ef fd fa ff 	call (m) 0x5700;
842061e0:	25 e9 
842061e2:	10 04       	Null = r0 - Null;
842061e4:	0b 62       	if NE jump (m) Lc_celt_decode_start_7;

842061e6 <Lc_celt_decode_start_4>:
        return TRUE;
    }

    /* At least the sink and the 1st source need to be connected. TODO in
     * stereo mode 2 sources should be connected. */
    if (!(celt_data->clone_input != NULL && decoder_data->op_out_left != NULL))
842061e6:	62 f0 a9 88 	r0 = M[r4 + 676];
842061ea:	03 60       	if EQ jump (m) Lc_celt_decode_start_6;

842061ec <Lc_celt_decode_start_5>:
842061ec:	f1 89       	rMAC = M[r4 + 28];
842061ee:	08 62       	if NE jump (m) Lc_celt_decode_start_8;

842061f0 <Lc_celt_decode_start_6>:
 * \param  response_data Pointer to the pointer to message that is allocated in the function.
 * \param  new_status  A status ID that is to be sent in the message.
 */
inline static void base_op_change_response_status(void **response_data, STATUS_KYMERA new_status)
{
    (((OP_STD_RSP *)(*response_data))->status = new_status);
842061f0:	01 f0 00 60 	rMAC = Null + 4096;
842061f4:	92 f0 00 e8 	r0 = M[r7 + Null];
842061f8:	51 8e       	M[r0 + 4] = rMAC;

842061fa <Lc_celt_decode_start_7>:
    }

    if (opmgr_op_is_running(op_data))
    {
        /* Operator already started nothing to do. */
        return TRUE;
842061fa:	42 20       	r0 = Null + 1;
842061fc:	4e 6e       	jump (m) Lc_celt_decode_start_12;

842061fe <Lc_celt_decode_start_8>:
842061fe:	91 89       	rMAC = M[r0 + 24];
84206200:	46 62       	if NE jump (m) Lc_celt_decode_start_11;

84206202 <Lc_celt_decode_start_9>:
#endif /* INSTALL_METADATA */

    /* Make copies of the connection buffers to give to the codec library
     * This runs asynchronously, so can't use the buffers visible externally 
     */
    buffer_flags = celt_data->clone_input->descriptor;
84206202:	62 f0 a9 88 	r0 = M[r4 + 676];
84206206:	57 89       	r5 = M[r0 + 20];
    decoder_data->codec.in_buffer = cbuffer_create( celt_data->clone_input->base_addr,
                    cbuffer_get_size_in_words(celt_data->clone_input), buffer_flags);
84206208:	ff fd 71 f0 	call (m) 0x14450;
8420620c:	29 e2 
8420620e:	13 00       	r1 = r0 + Null;
84206210:	61 f0 a9 88 	rMAC = M[r4 + 676];
84206214:	ca 88       	r0 = M[rMAC + 12];
84206216:	3c 00       	r2 = r5 + Null;
84206218:	ff fd 70 f0 	call (m) 0x1429c;
8420621c:	25 e4 
8420621e:	32 ee       	M[r4 + Null] = r0;

    decoder_data->codec.in_buffer->read_ptr = celt_data->clone_input->read_ptr;
84206220:	61 f0 a9 88 	rMAC = M[r4 + 676];
84206224:	32 e8       	r0 = M[r4 + Null];
84206226:	49 88       	rMAC = M[rMAC + 4];
84206228:	51 8e       	M[r0 + 4] = rMAC;
    decoder_data->codec.in_buffer->write_ptr = celt_data->clone_input->write_ptr;
8420622a:	61 f0 a9 88 	rMAC = M[r4 + 676];
8420622e:	32 e8       	r0 = M[r4 + Null];
84206230:	89 88       	rMAC = M[rMAC + 8];
84206232:	91 8e       	M[r0 + 8] = rMAC;

    buffer_flags = decoder_data->op_out_left->descriptor;
84206234:	f2 89       	r0 = M[r4 + 28];
84206236:	57 89       	r5 = M[r0 + 20];
    decoder_data->codec.out_left_buffer = cbuffer_create( decoder_data->op_out_left->base_addr,
                    cbuffer_get_size_in_words(decoder_data->op_out_left), buffer_flags);
84206238:	ff fd 71 f0 	call (m) 0x14450;
8420623c:	39 e0 
8420623e:	13 00       	r1 = r0 + Null;
84206240:	f1 89       	rMAC = M[r4 + 28];
84206242:	ca 88       	r0 = M[rMAC + 12];
84206244:	3c 00       	r2 = r5 + Null;
84206246:	ff fd 70 f0 	call (m) 0x1429c;
8420624a:	37 e2 
8420624c:	72 8e       	M[r4 + 4] = r0;

    decoder_data->codec.out_left_buffer->read_ptr =  decoder_data->op_out_left->read_ptr;
8420624e:	f1 89       	rMAC = M[r4 + 28];
84206250:	72 88       	r0 = M[r4 + 4];
84206252:	49 88       	rMAC = M[rMAC + 4];
84206254:	51 8e       	M[r0 + 4] = rMAC;
    decoder_data->codec.out_left_buffer->write_ptr =  decoder_data->op_out_left->write_ptr;
84206256:	f1 89       	rMAC = M[r4 + 28];
84206258:	72 88       	r0 = M[r4 + 4];
8420625a:	89 88       	rMAC = M[rMAC + 8];
8420625c:	91 8e       	M[r0 + 8] = rMAC;

    /* Right output doesn't need to be connected */
    if (decoder_data->op_out_right != NULL)
8420625e:	32 98       	r0 = M[r4 + 32];
84206260:	cd 61       	if EQ jump (m) Lc_celt_decode_start_7;

84206262 <Lc_celt_decode_start_10>:
    {
        buffer_flags = decoder_data->op_out_right->descriptor;
84206262:	57 89       	r5 = M[r0 + 20];
        decoder_data->codec.out_right_buffer = cbuffer_create( decoder_data->op_out_right->base_addr,
                        cbuffer_get_size_in_words(decoder_data->op_out_right), buffer_flags);
84206264:	ff fd 70 f0 	call (m) 0x14450;
84206268:	2d ef 
8420626a:	13 00       	r1 = r0 + Null;
8420626c:	31 98       	rMAC = M[r4 + 32];
8420626e:	ca 88       	r0 = M[rMAC + 12];
84206270:	3c 00       	r2 = r5 + Null;
84206272:	ff fd 70 f0 	call (m) 0x1429c;
84206276:	2b e1 
84206278:	b2 8e       	M[r4 + 8] = r0;

        decoder_data->codec.out_right_buffer->read_ptr =  decoder_data->op_out_right->read_ptr;
8420627a:	31 98       	rMAC = M[r4 + 32];
8420627c:	b2 88       	r0 = M[r4 + 8];
8420627e:	49 88       	rMAC = M[rMAC + 4];
84206280:	51 8e       	M[r0 + 4] = rMAC;
        decoder_data->codec.out_right_buffer->write_ptr =  decoder_data->op_out_right->write_ptr;
84206282:	31 98       	rMAC = M[r4 + 32];
84206284:	b2 88       	r0 = M[r4 + 8];
84206286:	89 88       	rMAC = M[rMAC + 8];
84206288:	91 8e       	M[r0 + 8] = rMAC;
8420628a:	b8 6f       	jump (m) Lc_celt_decode_start_7;

8420628c <Lc_celt_decode_start_11>:
#ifdef INSTALL_METADATA
    /* Any input metadata should have been configured as 2 octets per sample by
     * the source. Refuse to start if metadata is present and this is not the case. */
    if (buff_has_metadata(celt_data->clone_input))
    {
        if(ENCODED_DATA_OCTETS_IN_WORD != cbuffer_get_usable_octets(celt_data->clone_input))
8420628c:	ff fd 70 f0 	call (m) 0x14384;
84206290:	39 e7 
84206292:	10 25       	Null = r0 - 4;
84206294:	ae 63       	if NE jump (m) Lc_celt_decode_start_6;

84206296 <Lc__ite_3>:
84206296:	b6 6f       	jump (m) Lc_celt_decode_start_9;

84206298 <Lc_celt_decode_start_12>:
        decoder_data->codec.out_right_buffer->read_ptr =  decoder_data->op_out_right->read_ptr;
        decoder_data->codec.out_right_buffer->write_ptr =  decoder_data->op_out_right->write_ptr;
    }

    return TRUE;
}
84206298:	f4 48       	popm <FP, r4, r5, r6, r7, rLink>;
8420629a:	d8 4c       	rts;

8420629c <$_celt_decode_stop_reset>:

bool celt_decode_stop_reset(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
8420629c:	f4 1c       	pushm <FP(=SP), r4, r5, r6, r7, rLink>;
8420629e:	17 00       	r5 = r0 + Null;
842062a0:	29 09       	r7 = r3 + Null;
Private Function Declarations
*/

static inline CELT_DEC_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (CELT_DEC_OP_DATA *) base_op_get_instance_data(op_data);
842062a2:	ef fd d1 ff 	call (m) 0x4e6;
842062a6:	25 e2 
842062a8:	10 09       	r6 = r0 + Null;

bool celt_decode_stop_reset(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
    CELT_DEC_OP_DATA *celt_data = get_instance_data(op_data);
    A2DP_DECODER_PARAMS *decoder_data = &celt_data->decoder_data;
    INT_OP_ID opid = base_op_get_int_op_id(op_data);
842062aa:	3a 00       	r0 = r5 + Null;
842062ac:	ef fd d1 ff 	call (m) 0x4f0;
842062b0:	25 e2 
842062b2:	16 00       	r4 = r0 + Null;

    /* Create the response. If there aren't sufficient resources for this fail
     * early. */
    if (!base_op_build_std_response_ex(op_data, STATUS_OK, response_data))
842062b4:	03 00       	r1 = Null + Null;
842062b6:	4c 08       	r2 = r7 + Null;
842062b8:	3a 00       	r0 = r5 + Null;
842062ba:	ef fd d1 ff 	call (m) 0x4bc;
842062be:	23 e0 
842062c0:	10 04       	Null = r0 - Null;
842062c2:	03 62       	if NE jump (m) Lc_celt_decode_stop_reset_3;

842062c4 <Lc_celt_decode_stop_reset_2>:
    {
        return FALSE;
842062c4:	02 00       	r0 = Null + Null;
842062c6:	21 6e       	jump (m) Lc_celt_decode_stop_reset_6;

842062c8 <Lc_celt_decode_stop_reset_3>:
    }

    /* Mark the operator as stopped. */
    base_op_stop_operator(op_data);
842062c8:	3a 00       	r0 = r5 + Null;
842062ca:	ef fd d1 ff 	call (m) 0x54a;
842062ce:	21 e4 

842062d0 <Lc_celt_decode_stop_reset_4>:

    /* Wait for any processing to finish */
    while (audio_thread_rpc_is_queued(opid));
842062d0:	32 00       	r0 = r4 + Null;
842062d2:	ff fd 6e f0 	call (m) 0x13f5e;
842062d6:	2d e4 
842062d8:	10 04       	Null = r0 - Null;
842062da:	fb 63       	if NE jump (m) Lc_celt_decode_stop_reset_4;

842062dc <Lc_celt_decode_stop_reset_5>:

    /* Free the buffers that were allocated in the start handler */
    cbuffer_destroy_struct(decoder_data->codec.in_buffer);
842062dc:	82 f0 00 e8 	r0 = M[r6 + Null];
842062e0:	ff fd 70 f0 	call (m) 0x143cc;
842062e4:	2d e7 
    decoder_data->codec.in_buffer = NULL;
842062e6:	80 f0 00 ee 	M[r6 + Null] = Null;

    cbuffer_destroy_struct(decoder_data->codec.out_left_buffer);
842062ea:	82 f0 01 88 	r0 = M[r6 + 4];
842062ee:	ff fd 70 f0 	call (m) 0x143cc;
842062f2:	3f e6 
    decoder_data->codec.out_left_buffer = NULL;
842062f4:	80 f0 01 8e 	M[r6 + 4] = Null;

    cbuffer_destroy_struct(decoder_data->codec.out_right_buffer);
842062f8:	82 f0 02 88 	r0 = M[r6 + 8];
842062fc:	ff fd 70 f0 	call (m) 0x143cc;
84206300:	31 e6 
    decoder_data->codec.out_right_buffer = NULL;
84206302:	80 f0 02 8e 	M[r6 + 8] = Null;
    
    return TRUE;
84206306:	42 20       	r0 = Null + 1;

84206308 <Lc_celt_decode_stop_reset_6>:
}
84206308:	f4 48       	popm <FP, r4, r5, r6, r7, rLink>;
8420630a:	d8 4c       	rts;

8420630c <$_celt_dec_opmsg_set_encoding_params>:
    /* Kick the input to get it going */
    touched->sinks |= TOUCHED_SINK_0;
#endif
}
bool celt_dec_opmsg_set_encoding_params(OPERATOR_DATA *op_data, void *message_data, unsigned int *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
8420630c:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
8420630e:	17 00       	r5 = r0 + Null;
84206310:	1e 00       	r4 = r1 + Null;
Private Function Declarations
*/

static inline CELT_DEC_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (CELT_DEC_OP_DATA *) base_op_get_instance_data(op_data);
84206312:	ef fd d0 ff 	call (m) 0x4e6;
84206316:	35 ee 
84206318:	10 09       	r6 = r0 + Null;
{
 
   CELT_DEC_OP_DATA *celt_data = get_instance_data(op_data);
   patch_fn_shared(celt_decode_wrapper);
   
    if (opmgr_op_is_running(op_data))
8420631a:	3a 00       	r0 = r5 + Null;
8420631c:	ef fd f9 ff 	call (m) 0x5700;
84206320:	25 ef 
84206322:	10 04       	Null = r0 - Null;
84206324:	03 60       	if EQ jump (m) Lc_celt_dec_opmsg_set_encoding_params_3;

84206326 <Lc_celt_dec_opmsg_set_encoding_params_2>:
    {
     /* Can't change params while running */
       return (FALSE);
84206326:	02 00       	r0 = Null + Null;
84206328:	19 6e       	jump (m) Lc_celt_dec_opmsg_set_encoding_params_5;

8420632a <Lc_celt_dec_opmsg_set_encoding_params_3>:
    }

    /* Check that the message recieved is the correct length. No checking for
     * stupid configurations though this might be nice to have. */
    if (OPMGR_GET_OPMSG_LENGTH((OP_MSG_REQ *)message_data) != OPMSG_CELT_ENC_SET_ENCODING_PARAMS_WORD_SIZE)
8420632a:	71 88       	rMAC = M[r4 + 4];
8420632c:	08 25       	Null = rMAC - 4;
8420632e:	fc 63       	if NE jump (m) Lc_celt_dec_opmsg_set_encoding_params_2;

84206330 <Lc_celt_dec_opmsg_set_encoding_params_4>:
    {
        return FALSE;
    }

    /* Populate the CELT DEC  structure with the new fields */
    celt_data->codec_data.dec_mode = OPMSG_FIELD_GET(message_data, OPMSG_CELT_ENC_SET_ENCODING_PARAMS, MODE);
84206330:	f1 88       	rMAC = M[r4 + 12];
84206332:	89 c6       	rMAC = rMAC AND 0xffff;
84206334:	81 f0 a2 8e 	M[r6 + 648] = rMAC;
    celt_data->codec_data.frame_size = OPMSG_FIELD_GET(message_data, OPMSG_CELT_ENC_SET_ENCODING_PARAMS, FRAME_SIZE);
84206338:	31 89       	rMAC = M[r4 + 16];
8420633a:	89 c6       	rMAC = rMAC AND 0xffff;
8420633c:	81 f0 14 8e 	M[r6 + 80] = rMAC;
    celt_data->codec_data.channels = OPMSG_FIELD_GET(message_data, OPMSG_CELT_ENC_SET_ENCODING_PARAMS, CHANNELS);
84206340:	71 89       	rMAC = M[r4 + 20];
84206342:	89 c6       	rMAC = rMAC AND 0xffff;
84206344:	81 f0 15 8e 	M[r6 + 84] = rMAC;
    celt_decode_lib_init(&(celt_data->decoder_data.codec));
84206348:	42 08       	r0 = r6 + Null;
8420634a:	ce ff 2a e9 	call $_celt_decode_lib_init;
8420634e:	81 f0 ab 88 	rMAC = M[r6 + 684];
84206352:	f1 ff f7 ff 	if NE call $_celt_setup_thread_offload;
84206356:	22 e1 
    CELT_SETUP_OFFLOAD_IF_ENABLED();
   
    return TRUE;
84206358:	42 20       	r0 = Null + 1;

8420635a <Lc_celt_dec_opmsg_set_encoding_params_5>:
}
8420635a:	f3 48       	popm <FP, r4, r5, r6, rLink>;
8420635c:	d8 4c       	rts;

8420635e <Lc_free_data_1>:
 * CELT_decode capability.
 *
 * \param op_data Pointer to the operator instance data.
 */
static void free_data(OPERATOR_DATA *op_data)
{
8420635e:	f1 1c       	pushm <FP(=SP), r4, rLink>;
Private Function Declarations
*/

static inline CELT_DEC_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (CELT_DEC_OP_DATA *) base_op_get_instance_data(op_data);
84206360:	ef fd d0 ff 	call (m) 0x4e6;
84206364:	27 ec 
84206366:	16 00       	r4 = r0 + Null;
    mem_table_free_shared((void *)(&(celt_data->codec_data)),
                    celt_dec_shared_malloc_table, CELT_DEC_SHARED_TABLE_LENGTH);
#endif

#ifdef CELT_DECODE_OFFLOAD
    if (celt_data->offload_enabled)
84206368:	60 f0 ab 88 	Null = M[r4 + 684];
8420636c:	0b 60       	if EQ jump (m) Lc_free_data_3;

8420636e <Lc_free_data_2>:
    {
        mem_table_free_shared((void *)(&(celt_data->codec_data)),
                                celt_dec_offload_shared_malloc_table, CELT_OFFLOAD_MALLOC_TABLE_LENGTH);
8420636e:	84 20       	r2 = Null + 2;
84206370:	07 f0 03 f0 	r1 = Null + 7347920;
84206374:	d0 7a 
84206376:	62 f0 4c 20 	r0 = r4 + 76;
8420637a:	ef fd dc ff 	call (m) 0x1c5e;
8420637e:	25 e7 
84206380:	0a 6e       	jump (m) Lc_free_data_4;

84206382 <Lc_free_data_3>:
    }
    else
    {
        mem_table_free((void *)(&(celt_data->codec_data)),
                                celt_dec_offload_malloc_table, CELT_OFFLOAD_MALLOC_TABLE_LENGTH);
84206382:	84 20       	r2 = Null + 2;
84206384:	07 f0 03 f0 	r1 = Null + 7347936;
84206388:	e0 7a 
8420638a:	62 f0 4c 20 	r0 = r4 + 76;
8420638e:	ef fd dc ff 	call (m) 0x1c0c;
84206392:	3f e3 

84206394 <Lc_free_data_4>:
    }
#endif

    /* free non-shared memory */
    mem_table_free((void *)(&(celt_data->codec_data)), celt_dec_malloc_table,
                                                CELT_DEC_MALLOC_TABLE_LENGTH);
84206394:	04 21       	r2 = Null + 4;
84206396:	07 f0 03 f0 	r1 = Null + 7347896;
8420639a:	b8 7a 
8420639c:	62 f0 4c 20 	r0 = r4 + 76;
842063a0:	ef fd dc ff 	call (m) 0x1c0c;
842063a4:	2d e3 
    
    celt_free_decoder_twiddle();
842063a6:	d0 ff 26 ea 	call $_celt_free_decoder_twiddle;

842063aa <Lc_free_data_5>:

}
842063aa:	f1 48       	popm <FP, r4, rLink>;
842063ac:	d8 4c       	rts;

842063ae <Lc_free_data_and_fail_1>:
 *
 * \param op_data Pointer to the operator instance data.
 * \param response Pointer to the response message to give a failed status
 */
static void free_data_and_fail(OPERATOR_DATA *op_data, void **response)
{
842063ae:	f1 1c       	pushm <FP(=SP), r4, rLink>;
842063b0:	1e 00       	r4 = r1 + Null;
    patch_fn_shared(celt_decode_wrapper);

    /* Free the data and then override the response message status to fail */
    free_data(op_data);
842063b2:	d6 4f       	call (m) Lc_free_data_1;
842063b4:	01 f0 00 60 	rMAC = Null + 4096;
842063b8:	32 e8       	r0 = M[r4 + Null];
842063ba:	51 8e       	M[r0 + 4] = rMAC;

842063bc <Lc_free_data_and_fail_2>:
    base_op_change_response_status(response, STATUS_CMD_FAILED);
}
842063bc:	f1 48       	popm <FP, r4, rLink>;
842063be:	d8 4c       	rts;

842063c0 <Lc_celt_dec_offload_callback_1>:
 * to the data processing function. That then propagates metadata from the 
 * previous iteration and schedules a new one.
 */

static void celt_dec_offload_callback(void *context)
{
842063c0:	f1 1c       	pushm <FP(=SP), r4, rLink>;
842063c2:	16 00       	r4 = r0 + Null;
Private Function Declarations
*/

static inline CELT_DEC_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (CELT_DEC_OP_DATA *) base_op_get_instance_data(op_data);
842063c4:	ef fd d0 ff 	call (m) 0x4e6;
842063c8:	23 e9 
static void celt_dec_offload_callback(void *context)
{
    OPERATOR_DATA *op_data = (OPERATOR_DATA*) context;
    CELT_DEC_OP_DATA *celt_data = get_instance_data(op_data);

    if ((celt_data->kicks_pending) || (celt_data->decoder_data.codec.num_output_samples > 0))
842063ca:	20 f0 aa 88 	Null = M[r0 + 680];
842063ce:	03 62       	if NE jump (m) Lc_celt_dec_offload_callback_3;

842063d0 <Lc_celt_dec_offload_callback_2>:
842063d0:	10 89       	Null = M[r0 + 16];
842063d2:	07 60       	if EQ jump (m) Lc_celt_dec_offload_callback_4;

842063d4 <Lc_celt_dec_offload_callback_3>:
    {
        celt_data->kicks_pending = FALSE;
842063d4:	20 f0 aa 8e 	M[r0 + 680] = Null;
        opmgr_kick_operator(op_data);
842063d8:	32 00       	r0 = r4 + Null;
842063da:	ef fd e9 ff 	call (m) 0x374a;
842063de:	31 eb 

842063e0 <Lc_celt_dec_offload_callback_4>:
    }
}
842063e0:	f1 48       	popm <FP, r4, rLink>;
842063e2:	d8 4c       	rts;

842063e4 <$_celt_encode_create>:
 * \return Whether the response_data field has been populated with a valid
 * response
 */
bool celt_encode_create(OPERATOR_DATA *op_data, void *message_data,
                                unsigned *response_id, void **response_data)
{
842063e4:	f5 1d       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>, SP = SP + 0x10;
842063e6:	11 09       	r7 = r0 + Null;
842063e8:	18 09       	r6 = r1 + Null;
842063ea:	27 00       	r5 = r2 + Null;
842063ec:	2a 09       	r8 = r3 + Null;
    return (ENCODER_PARAMS *) base_op_get_class_ext(op_data);
}

static inline CELT_ENC_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (CELT_ENC_OP_DATA *) base_op_get_instance_data(op_data);
842063ee:	ef fd d0 ff 	call (m) 0x4e6;
842063f2:	39 e7 
842063f4:	16 00       	r4 = r0 + Null;
#endif

    patch_fn_shared(celt_encode_wrapper);

    /* call base_op create, which also allocates and fills response message */
    if (!base_op_create(op_data, message_data, response_id, response_data))
842063f6:	55 08       	r3 = r8 + Null;
842063f8:	3c 00       	r2 = r5 + Null;
842063fa:	43 08       	r1 = r6 + Null;
842063fc:	4a 08       	r0 = r7 + Null;
842063fe:	ef fd cf ff 	call (m) 0x35a;
84206402:	3d ea 
84206404:	10 04       	Null = r0 - Null;
84206406:	03 62       	if NE jump (m) Lc_celt_encode_create_3;

84206408 <Lc_celt_encode_create_2>:
    {
        return FALSE;
84206408:	02 00       	r0 = Null + Null;
8420640a:	82 6e       	jump (m) Lc_celt_encode_create_17;

8420640c <Lc_celt_encode_create_3>:
    }

    /* Create the link to the base class object */
    if (!encoder_base_class_init(op_data, &celt_data->encoder_data, &(celt_data->codec_data), &celt_enc_vt))
8420640c:	07 f0 05 f0 	r3 = Null + 7348112;
84206410:	90 7b 
84206412:	34 39       	r2 = r4 + 52;
84206414:	33 00       	r1 = r4 + Null;
84206416:	4a 08       	r0 = r7 + Null;
84206418:	ff fd 83 f1 	call (m) 0x36b80;
8420641c:	29 eb 
8420641e:	10 04       	Null = r0 - Null;
84206420:	29 60       	if EQ jump (m) Lc_celt_encode_create_9;

84206422 <Lc_celt_encode_create_4>:
        return TRUE;
    }
#endif

#ifdef CELT_ENCODE_OFFLOAD
    celt_data->offload_enabled = opmgr_op_thread_offload(op_data) && audio_thread_offload_is_active();
84206422:	4a 08       	r0 = r7 + Null;
84206424:	ef fd ea ff 	call (m) 0x385a;
84206428:	37 e1 
8420642a:	10 04       	Null = r0 - Null;
8420642c:	28 60       	if EQ jump (m) Lc_celt_encode_create_10;

8420642e <Lc_celt_encode_create_5>:
8420642e:	ff fd 6d f0 	call (m) 0x13ec2;
84206432:	35 e4 
84206434:	03 00       	r1 = Null + Null;
84206436:	10 04       	Null = r0 - Null;
84206438:	21 f0 43 ce 	if NE r1 = Null + 1;
8420643c:	21 6e       	jump (m) Lc_celt_encode_create_11;

8420643e <Lc_celt_encode_create_6>:
    }
    else
    {
        /* No offload: can't use shared allocation */
        if (!mem_table_zalloc((void *)(&(celt_data->codec_data)),
                        celt_enc_offload_malloc_table, CELT_OFFLOAD_MALLOC_TABLE_LENGTH))
8420643e:	84 20       	r2 = Null + 2;
84206440:	07 f0 03 f0 	r1 = Null + 7348100;
84206444:	84 7b 
84206446:	32 39       	r0 = r4 + 52;
84206448:	ef fd db ff 	call (m) 0x1bfe;
8420644c:	37 ed 
8420644e:	10 04       	Null = r0 - Null;
84206450:	11 60       	if EQ jump (m) Lc_celt_encode_create_9;

84206452 <Lc_celt_encode_create_7>:
    }
#endif

    /* now allocate the non-shareable memory */
    if (!mem_table_zalloc((uintptr_t *)(&(celt_data->codec_data)), celt_enc_malloc_table,
                                                CELT_ENC_MALLOC_TABLE_LENGTH))
84206452:	04 21       	r2 = Null + 4;
84206454:	07 f0 03 f0 	r1 = Null + 7348060;
84206458:	5c 7b 
8420645a:	32 39       	r0 = r4 + 52;
8420645c:	ef fd db ff 	call (m) 0x1bfe;
84206460:	23 ed 
84206462:	10 04       	Null = r0 - Null;
84206464:	28 62       	if NE jump (m) Lc_celt_encode_create_15;

84206466 <Lc_celt_encode_create_8>:
    {
        encoder_base_class_deinit(&celt_enc_vt);
84206466:	07 f0 02 f0 	r0 = Null + 7348112;
8420646a:	90 7b 
8420646c:	ff fd 83 f1 	call (m) 0x36bc0;
84206470:	35 ea 

84206472 <Lc_celt_encode_create_9>:
    }

    /* Create the link to the base class object */
    if (!encoder_base_class_init(op_data, &celt_data->encoder_data, &(celt_data->codec_data), &celt_enc_vt))
    {
        free_data_and_fail(op_data, response_data);
84206472:	53 08       	r1 = r8 + Null;
84206474:	4a 08       	r0 = r7 + Null;
84206476:	03 f0 27 e8 	call (m) Lc_free_data_and_fail_1;
8420647a:	49 6e       	jump (m) Lc_celt_encode_create_16;

8420647c <Lc_celt_encode_create_10>:
        return TRUE;
    }
#endif

#ifdef CELT_ENCODE_OFFLOAD
    celt_data->offload_enabled = opmgr_op_thread_offload(op_data) && audio_thread_offload_is_active();
8420647c:	03 00       	r1 = Null + Null;

8420647e <Lc_celt_encode_create_11>:
8420647e:	63 f0 a8 8e 	M[r4 + 672] = r1;
    L2_DBG_MSG1("CELT encode, offload_enabled = %d",  celt_data->offload_enabled);
84206482:	01 f0 3c 91 	rMAC = MBS[Null + 0x33c];
84206486:	88 24       	Null = rMAC - 2;
84206488:	07 68       	if LT jump (m) Lc_celt_encode_create_13;

8420648a <Lc_celt_encode_create_12>:
8420648a:	55 f1 02 f0 	r0 = Null + 357564450;
8420648e:	22 40 
84206490:	ef fd d4 ff 	call (m) 0xcde;
84206494:	2f e2 

84206496 <Lc_celt_encode_create_13>:
    if (celt_data->offload_enabled)
84206496:	60 f0 a8 88 	Null = M[r4 + 672];
8420649a:	d2 61       	if EQ jump (m) Lc_celt_encode_create_6;

8420649c <Lc_celt_encode_create_14>:
    {
        /* Offload enabled, so use a shared allocation */
        if (!mem_table_zalloc_shared((void *)(&(celt_data->codec_data)),
                        celt_enc_offload_shared_malloc_table, CELT_OFFLOAD_MALLOC_TABLE_LENGTH,
                        &new_allocation))
8420649c:	c5 11       	r3 = FP + 28;
8420649e:	84 20       	r2 = Null + 2;
842064a0:	07 f0 03 f0 	r1 = Null + 7348084;
842064a4:	74 7b 
842064a6:	32 39       	r0 = r4 + 52;
842064a8:	ef fd db ff 	call (m) 0x1c4e;
842064ac:	27 ed 
842064ae:	10 04       	Null = r0 - Null;
842064b0:	d1 63       	if NE jump (m) Lc_celt_encode_create_7;

842064b2 <Lc__ite_4>:
842064b2:	e0 6f       	jump (m) Lc_celt_encode_create_9;

842064b4 <Lc_celt_encode_create_15>:



    /* Init default encoding values */
 
    celt_data->codec_data.ptr_flaglist_table = celt_data->codec_common_data.celt_flaglist ;
842064b4:	61 f0 9e 88 	rMAC = M[r4 + 632];
842064b8:	61 f0 91 8e 	M[r4 + 580] = rMAC;
    celt_data->codec_data.ptr_emeans_table =celt_data->codec_common_data.celt_emeans_table ;
842064bc:	61 f0 9f 88 	rMAC = M[r4 + 636];
842064c0:	61 f0 92 8e 	M[r4 + 584] = rMAC;
    celt_data->codec_data.ptr_max_n_table =celt_data->codec_common_data.celt_max_nfield ;
842064c4:	61 f0 a0 88 	rMAC = M[r4 + 640];
842064c8:	61 f0 93 8e 	M[r4 + 588] = rMAC;
    celt_data->codec_data.ptr_max_k_table =celt_data->codec_common_data.celt_max_k_table ;
842064cc:	61 f0 a1 88 	rMAC = M[r4 + 644];
842064d0:	61 f0 94 8e 	M[r4 + 592] = rMAC;
    celt_data->codec_data.ptr_inv2_table =celt_data->codec_common_data.celt_inv2_table ;
842064d4:	61 f0 a2 88 	rMAC = M[r4 + 648];
842064d8:	61 f0 95 8e 	M[r4 + 596] = rMAC;
    
    celt_data->codec_data.celt_codec_frame_size_field = 190;
842064dc:	01 f0 be 40 	rMAC = Null + 190;
842064e0:	b1 9f       	M[r4 + 56] = rMAC;
    celt_data->codec_data.celt_channels_field =  CELT_STEREO_MODE;
842064e2:	41 20       	rMAC = Null + 1;
842064e4:	f1 9f       	M[r4 + 60] = rMAC;
    celt_data->codec_data.celt_enc_mdct_function_field =  (void*)celt_mdct_radix2;
842064e6:	42 f0 01 f0 	rMAC = Null + 69210816;
842064ea:	c0 62 
842064ec:	31 ae       	M[r4 + 64] = rMAC;
    celt_data->codec_data.celt_enc_mdct_short_function_field = (void*)celt_mdct_radix2;
842064ee:	71 ae       	M[r4 + 68] = rMAC;
    celt_data->codec_data.celt_enc_mode_field = CELT_MODE;
842064f0:	60 f0 9c 8e 	M[r4 + 624] = Null;

    /* Call the celt encoder init and init_tables functions. */

    celt_encode_lib_init(&(celt_data->encoder_data.codec));
842064f4:	32 00       	r0 = r4 + Null;
842064f6:	cf ff 3a e7 	call $_celt_encode_lib_init;
842064fa:	61 f0 a8 88 	rMAC = M[r4 + 672];
842064fe:	f1 ff f6 ff 	if NE call $_celt_setup_thread_offload;
84206502:	36 e3 
    CELT_SETUP_OFFLOAD_IF_ENABLED();

#ifdef INSTALL_METADATA
    /* Get the sample rate and delay from the CELT internal data into the common decoder struct */
    celt_data->encoder_data.sample_rate = celt_data->codec_data.celt_enc_mode_fs_field;
84206504:	31 b9       	rMAC = M[r4 + 112];
84206506:	f1 8f       	M[r4 + 28] = rMAC;
    celt_data->encoder_data.delay_samples = celt_data->codec_data.celt_enc_mode_overlap_field;
84206508:	71 b9       	rMAC = M[r4 + 116];
8420650a:	31 9f       	M[r4 + 48] = rMAC;

8420650c <Lc_celt_encode_create_16>:

    /* Create the link to the base class object */
    if (!encoder_base_class_init(op_data, &celt_data->encoder_data, &(celt_data->codec_data), &celt_enc_vt))
    {
        free_data_and_fail(op_data, response_data);
        return TRUE;
8420650c:	42 20       	r0 = Null + 1;

8420650e <Lc_celt_encode_create_17>:
    celt_data->encoder_data.sample_rate = celt_data->codec_data.celt_enc_mode_fs_field;
    celt_data->encoder_data.delay_samples = celt_data->codec_data.celt_enc_mode_overlap_field;
#endif

    return TRUE;
}
8420650e:	f5 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, r8, rLink>;
84206510:	d8 4c       	rts;

84206512 <$_celt_enc_opmsg_set_encoding_params>:
    patch_fn_shared(celt_encode_wrapper);
    return encoder_buffer_details_core(op_data, message_data,response_id, response_data,CELT_ENCODE_OUTPUT_BUFFER_SIZE,CELT_ENCODE_OUTPUT_BUFFER_SIZE);
}

bool celt_enc_opmsg_set_encoding_params(OPERATOR_DATA *op_data, void *message_data, unsigned int *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84206512:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
84206514:	17 00       	r5 = r0 + Null;
84206516:	1e 00       	r4 = r1 + Null;
    return (ENCODER_PARAMS *) base_op_get_class_ext(op_data);
}

static inline CELT_ENC_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (CELT_ENC_OP_DATA *) base_op_get_instance_data(op_data);
84206518:	ef fd cf ff 	call (m) 0x4e6;
8420651c:	2f ee 
8420651e:	10 09       	r6 = r0 + Null;
bool celt_enc_opmsg_set_encoding_params(OPERATOR_DATA *op_data, void *message_data, unsigned int *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    CELT_ENC_OP_DATA *celt_data = get_instance_data(op_data);
    patch_fn_shared(celt_encode_wrapper);
   
    if (opmgr_op_is_running(op_data))
84206520:	3a 00       	r0 = r5 + Null;
84206522:	ef fd f8 ff 	call (m) 0x5700;
84206526:	3f ee 
84206528:	10 04       	Null = r0 - Null;
8420652a:	03 60       	if EQ jump (m) Lc_celt_enc_opmsg_set_encoding_params_3;

8420652c <Lc_celt_enc_opmsg_set_encoding_params_2>:
    {
     /* Can't change params while running */
       return (FALSE);
8420652c:	02 00       	r0 = Null + Null;
8420652e:	21 6e       	jump (m) Lc_celt_enc_opmsg_set_encoding_params_5;

84206530 <Lc_celt_enc_opmsg_set_encoding_params_3>:
    }

    /* Check that the message recieved is the correct length. No checking for
     * stupid configurations though this might be nice to have. */
    if (OPMGR_GET_OPMSG_LENGTH((OP_MSG_REQ *)message_data) != OPMSG_CELT_ENC_SET_ENCODING_PARAMS_WORD_SIZE)
84206530:	71 88       	rMAC = M[r4 + 4];
84206532:	08 25       	Null = rMAC - 4;
84206534:	fc 63       	if NE jump (m) Lc_celt_enc_opmsg_set_encoding_params_2;

84206536 <Lc_celt_enc_opmsg_set_encoding_params_4>:
    {
        return FALSE;
    }

    /* Populate the CELT ENC  structure with the new fields */
    celt_data->codec_data.celt_enc_mode_field = OPMSG_FIELD_GET(message_data, OPMSG_CELT_ENC_SET_ENCODING_PARAMS, MODE);
84206536:	f1 88       	rMAC = M[r4 + 12];
84206538:	89 c6       	rMAC = rMAC AND 0xffff;
8420653a:	81 f0 9c 8e 	M[r6 + 624] = rMAC;
    celt_data->codec_data.celt_codec_frame_size_field = OPMSG_FIELD_GET(message_data, OPMSG_CELT_ENC_SET_ENCODING_PARAMS, FRAME_SIZE);
8420653e:	31 89       	rMAC = M[r4 + 16];
84206540:	89 c6       	rMAC = rMAC AND 0xffff;
84206542:	81 f0 0e 8e 	M[r6 + 56] = rMAC;
    celt_data->codec_data.celt_channels_field = OPMSG_FIELD_GET(message_data, OPMSG_CELT_ENC_SET_ENCODING_PARAMS, CHANNELS);
84206546:	71 89       	rMAC = M[r4 + 20];
84206548:	89 c6       	rMAC = rMAC AND 0xffff;
8420654a:	81 f0 0f 8e 	M[r6 + 60] = rMAC;
    celt_encode_lib_init(&(celt_data->encoder_data.codec));
8420654e:	42 08       	r0 = r6 + Null;
84206550:	cf ff 20 e5 	call $_celt_encode_lib_init;
84206554:	81 f0 a8 88 	rMAC = M[r6 + 672];
84206558:	f1 ff f6 ff 	if NE call $_celt_setup_thread_offload;
8420655c:	3c e0 
    CELT_SETUP_OFFLOAD_IF_ENABLED();
#ifdef INSTALL_METADATA
    /* Get the sample rate and delay from the CELT internal data into the common decoder struct */
    celt_data->encoder_data.sample_rate = celt_data->codec_data.celt_enc_mode_fs_field;
8420655e:	81 f0 1c 88 	rMAC = M[r6 + 112];
84206562:	81 f0 07 8e 	M[r6 + 28] = rMAC;
    celt_data->encoder_data.delay_samples = celt_data->codec_data.celt_enc_mode_overlap_field;
84206566:	81 f0 1d 88 	rMAC = M[r6 + 116];
8420656a:	81 f0 0c 8e 	M[r6 + 48] = rMAC;
#endif
    return TRUE;
8420656e:	42 20       	r0 = Null + 1;

84206570 <Lc_celt_enc_opmsg_set_encoding_params_5>:
}
84206570:	f3 48       	popm <FP, r4, r5, r6, rLink>;
84206572:	d8 4c       	rts;

84206574 <$_celt_encode_free_data>:
 * celt_encode capability.
 *
 * \param op_data Pointer to the operator instance data.
 */
void celt_encode_free_data(OPERATOR_DATA *op_data)
{
84206574:	f1 1c       	pushm <FP(=SP), r4, rLink>;
    return (ENCODER_PARAMS *) base_op_get_class_ext(op_data);
}

static inline CELT_ENC_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (CELT_ENC_OP_DATA *) base_op_get_instance_data(op_data);
84206576:	ef fd cf ff 	call (m) 0x4e6;
8420657a:	31 eb 
8420657c:	16 00       	r4 = r0 + Null;
    mem_table_free_shared((void *)(&(celt_data->codec_data)),
                    celt_enc_shared_malloc_table, CELT_ENC_SHARED_TABLE_LENGTH);
#endif

#ifdef CELT_ENCODE_OFFLOAD
    if (celt_data->offload_enabled)
8420657e:	60 f0 a8 88 	Null = M[r4 + 672];
84206582:	0a 60       	if EQ jump (m) Lc_celt_encode_free_data_3;

84206584 <Lc_celt_encode_free_data_2>:
    {
        mem_table_free_shared((void *)(&(celt_data->codec_data)),
                                celt_enc_offload_shared_malloc_table, CELT_OFFLOAD_MALLOC_TABLE_LENGTH);
84206584:	84 20       	r2 = Null + 2;
84206586:	07 f0 03 f0 	r1 = Null + 7348084;
8420658a:	74 7b 
8420658c:	32 39       	r0 = r4 + 52;
8420658e:	ef fd db ff 	call (m) 0x1c5e;
84206592:	31 e6 
84206594:	09 6e       	jump (m) Lc_celt_encode_free_data_4;

84206596 <Lc_celt_encode_free_data_3>:
    }
    else
    {
        mem_table_free((void *)(&(celt_data->codec_data)),
                                celt_enc_offload_malloc_table, CELT_OFFLOAD_MALLOC_TABLE_LENGTH);
84206596:	84 20       	r2 = Null + 2;
84206598:	07 f0 03 f0 	r1 = Null + 7348100;
8420659c:	84 7b 
8420659e:	32 39       	r0 = r4 + 52;
842065a0:	ef fd db ff 	call (m) 0x1c0c;
842065a4:	2d e3 

842065a6 <Lc_celt_encode_free_data_4>:
    }
#endif

    /* free non-shared memory */
    mem_table_free((void *)(&(celt_data->codec_data)), celt_enc_malloc_table,
                                                CELT_ENC_MALLOC_TABLE_LENGTH);
842065a6:	04 21       	r2 = Null + 4;
842065a8:	07 f0 03 f0 	r1 = Null + 7348060;
842065ac:	5c 7b 
842065ae:	32 39       	r0 = r4 + 52;
842065b0:	ef fd db ff 	call (m) 0x1c0c;
842065b4:	3d e2 
    
    celt_free_decoder_twiddle();
842065b6:	cf ff 36 e9 	call $_celt_free_decoder_twiddle;

842065ba <Lc_celt_encode_free_data_5>:


}
842065ba:	f1 48       	popm <FP, r4, rLink>;
842065bc:	d8 4c       	rts;

842065be <$_celt_encode_buffer_details>:
 * response
 */

bool celt_encode_buffer_details(OPERATOR_DATA *op_data, void *message_data,
                                    unsigned *response_id, void **response_data)
{
842065be:	c8 1c       	pushm <FP(=SP), rLink>;
    patch_fn_shared(celt_encode_wrapper);
    return encoder_buffer_details_core(op_data, message_data,response_id, response_data,CELT_ENCODE_OUTPUT_BUFFER_SIZE,CELT_ENCODE_OUTPUT_BUFFER_SIZE);
842065c0:	04 f0 50 e0 	push Null + 1024;
842065c4:	04 f0 50 e0 	push Null + 1024;
842065c8:	ff fd 83 f1 	call (m) 0x36da6;
842065cc:	3f ee 
842065ce:	7e 4c       	SP = SP + -8;

842065d0 <Lc_celt_encode_buffer_details_2>:
}
842065d0:	c8 48       	popm <FP, rLink>;
842065d2:	d8 4c       	rts;

842065d4 <$_celt_encode_frame_sizes>:
 * \param out_size_octets number of octets produced per frame
 * 
 * \return TRUE to say these are actual frames
 */
bool celt_encode_frame_sizes(OPERATOR_DATA *op_data, unsigned *in_size_samples, unsigned *out_size_octets)
{
842065d4:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
842065d6:	1e 00       	r4 = r1 + Null;
842065d8:	27 00       	r5 = r2 + Null;
    return (ENCODER_PARAMS *) base_op_get_class_ext(op_data);
}

static inline CELT_ENC_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (CELT_ENC_OP_DATA *) base_op_get_instance_data(op_data);
842065da:	ef fd cf ff 	call (m) 0x4e6;
842065de:	2d e8 
 * \return TRUE to say these are actual frames
 */
bool celt_encode_frame_sizes(OPERATOR_DATA *op_data, unsigned *in_size_samples, unsigned *out_size_octets)
{
    CELT_ENC_OP_DATA *celt_data = get_instance_data(op_data);
    *in_size_samples = celt_data->codec_data.celt_enc_mode_mdct_size_field;
842065e0:	91 b9       	rMAC = M[r0 + 120];
842065e2:	31 ee       	M[r4 + Null] = rMAC;
    *out_size_octets = celt_data->codec_data.celt_codec_frame_size_field;
842065e4:	91 99       	rMAC = M[r0 + 56];
842065e6:	39 ee       	M[r5 + Null] = rMAC;

    return TRUE;
842065e8:	42 20       	r0 = Null + 1;

842065ea <Lc_celt_encode_frame_sizes_2>:
}
842065ea:	f2 48       	popm <FP, r4, r5, rLink>;
842065ec:	d8 4c       	rts;

842065ee <$_celt_encode_connect>:
    return TRUE;
}

bool celt_encode_connect(OPERATOR_DATA *op_data, void *message_data,
                     unsigned *response_id, void **response_data)
{
842065ee:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
842065f0:	16 00       	r4 = r0 + Null;
842065f2:	19 09       	r7 = r1 + Null;
842065f4:	2a 09       	r8 = r3 + Null;
Private Function Declarations
*/

static inline ENCODER_PARAMS *get_class_data(OPERATOR_DATA *op_data)
{
    return (ENCODER_PARAMS *) base_op_get_class_ext(op_data);
842065f6:	ef fd cf ff 	call (m) 0x558;
842065fa:	23 eb 
842065fc:	10 09       	r6 = r0 + Null;
}

static inline CELT_ENC_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (CELT_ENC_OP_DATA *) base_op_get_instance_data(op_data);
842065fe:	32 00       	r0 = r4 + Null;
84206600:	ef fd cf ff 	call (m) 0x4e6;
84206604:	27 e7 
84206606:	17 00       	r5 = r0 + Null;
{
    ENCODER_PARAMS *encoder_data = get_class_data(op_data);
    CELT_ENC_OP_DATA *opx_data = get_instance_data(op_data);
    unsigned terminal_id;

    if (!base_op_build_std_response_ex(op_data, STATUS_OK, response_data))
84206608:	03 00       	r1 = Null + Null;
8420660a:	54 08       	r2 = r8 + Null;
8420660c:	32 00       	r0 = r4 + Null;
8420660e:	ef fd cf ff 	call (m) 0x4bc;
84206612:	2f e5 
84206614:	10 04       	Null = r0 - Null;
84206616:	03 62       	if NE jump (m) Lc_celt_encode_connect_3;

84206618 <Lc_celt_encode_connect_2>:
    {
        return FALSE;
84206618:	02 00       	r0 = Null + Null;
8420661a:	3c 6e       	jump (m) Lc_celt_encode_connect_17;

8420661c <Lc_celt_encode_connect_3>:
    }
    
    /* We don't allow any connections or disconnections with the operator running */
    if (opmgr_op_is_running(op_data))
8420661c:	32 00       	r0 = r4 + Null;
8420661e:	ef fd f8 ff 	call (m) 0x5700;
84206622:	23 e7 
84206624:	10 04       	Null = r0 - Null;
84206626:	08 60       	if EQ jump (m) Lc_celt_encode_connect_6;

84206628 <Lc_celt_encode_connect_4>:
84206628:	01 f0 00 60 	rMAC = Null + 4096;
8420662c:	a2 f0 00 e8 	r0 = M[r8 + Null];
84206630:	51 8e       	M[r0 + 4] = rMAC;

84206632 <Lc_celt_encode_connect_5>:
    {
        base_op_change_response_status(response_data, STATUS_CMD_FAILED);
        return TRUE;
84206632:	42 20       	r0 = Null + 1;
84206634:	2f 6e       	jump (m) Lc_celt_encode_connect_17;

84206636 <Lc_celt_encode_connect_6>:
    }

    terminal_id = ((unsigned *)message_data)[0];

    switch (terminal_id)
84206636:	91 f0 00 e8 	rMAC = M[r7 + Null];
8420663a:	15 60       	if EQ jump (m) Lc_celt_encode_connect_12;

8420663c <Lc_celt_encode_connect_7>:
8420663c:	00 f2 10 f0 	Null = rMAC - 8388608;
84206640:	00 24 
84206642:	1c 60       	if EQ jump (m) Lc_celt_encode_connect_14;

84206644 <Lc_celt_encode_connect_8>:
84206644:	00 f2 10 f0 	Null = rMAC - 8388609;
84206648:	01 24 
8420664a:	f4 63       	if NE jump (m) Lc_celt_encode_connect_5;

8420664c <Lc_celt_encode_connect_9>:
                }
            }
#endif /* INSTALL_METADATA */
            break;
        case RIGHT_IN_TERMINAL_ID:
            opx_data->clone_right_input =  (tCbuffer*)(((uintptr_t *)message_data)[1]);
8420664c:	91 f0 01 88 	rMAC = M[r7 + 4];
84206650:	71 f0 a5 8e 	M[r5 + 660] = rMAC;
#ifdef INSTALL_METADATA
            if (encoder_data->metadata_ip_buffer == NULL)
84206654:	82 f0 06 88 	r0 = M[r6 + 24];
84206658:	ed 63       	if NE jump (m) Lc_celt_encode_connect_5;

8420665a <Lc_celt_encode_connect_10>:
8420665a:	8a 89       	r0 = M[rMAC + 24];
8420665c:	eb 61       	if EQ jump (m) Lc_celt_encode_connect_5;

8420665e <Lc_celt_encode_connect_11>:
            {
                if (buff_has_metadata(opx_data->clone_right_input))
                {
                    encoder_data->metadata_ip_buffer = opx_data->clone_right_input;
8420665e:	81 f0 06 8e 	M[r6 + 24] = rMAC;
84206662:	e8 6f       	jump (m) Lc_celt_encode_connect_5;

84206664 <Lc_celt_encode_connect_12>:
    terminal_id = ((unsigned *)message_data)[0];

    switch (terminal_id)
    {
        case OUTPUT_TERMINAL_ID:
            opx_data->clone_output = (tCbuffer*)(((uintptr_t *)message_data)[1]);
84206664:	92 f0 01 88 	r0 = M[r7 + 4];
84206668:	72 f0 a6 8e 	M[r5 + 664] = r0;
8420666c:	91 89       	rMAC = M[r0 + 24];
8420666e:	e2 61       	if EQ jump (m) Lc_celt_encode_connect_5;

84206670 <Lc_celt_encode_connect_13>:
#ifdef INSTALL_METADATA
            if (buff_has_metadata(opx_data->clone_output))
            {
                cbuffer_set_usable_octets(opx_data->clone_output, ENCODED_DATA_OCTETS_IN_WORD);
84206670:	03 21       	r1 = Null + 4;
84206672:	ff fd 6e f0 	call (m) 0x1432e;
84206676:	3d e5 
84206678:	dd 6f       	jump (m) Lc_celt_encode_connect_5;

8420667a <Lc_celt_encode_connect_14>:
            }
#endif
            break;
        case LEFT_IN_TERMINAL_ID:
            opx_data->clone_left_input =  (tCbuffer*)(((uintptr_t *)message_data)[1]);
8420667a:	91 f0 01 88 	rMAC = M[r7 + 4];
8420667e:	71 f0 a4 8e 	M[r5 + 656] = rMAC;
#ifdef INSTALL_METADATA
            if (encoder_data->metadata_ip_buffer == NULL)
84206682:	82 f0 06 88 	r0 = M[r6 + 24];
84206686:	d6 63       	if NE jump (m) Lc_celt_encode_connect_5;

84206688 <Lc_celt_encode_connect_15>:
84206688:	8a 89       	r0 = M[rMAC + 24];
8420668a:	d4 61       	if EQ jump (m) Lc_celt_encode_connect_5;

8420668c <Lc_celt_encode_connect_16>:
            {
                if (buff_has_metadata(opx_data->clone_left_input))
                {
                    encoder_data->metadata_ip_buffer = opx_data->clone_left_input;
8420668c:	81 f0 06 8e 	M[r6 + 24] = rMAC;
84206690:	d1 6f       	jump (m) Lc_celt_encode_connect_5;

84206692 <Lc_celt_encode_connect_17>:
#endif /* INSTALL_METADATA */
            break;
        /* NB No default as can't happen */
    }
    return TRUE;
}
84206692:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
84206694:	d8 4c       	rts;

84206696 <$_celt_encode_disconnect>:

bool celt_encode_disconnect(OPERATOR_DATA *op_data, void *message_data,
                        unsigned *response_id, void **response_data)
{
84206696:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
84206698:	10 09       	r6 = r0 + Null;
8420669a:	19 09       	r7 = r1 + Null;
8420669c:	2a 09       	r8 = r3 + Null;
Private Function Declarations
*/

static inline ENCODER_PARAMS *get_class_data(OPERATOR_DATA *op_data)
{
    return (ENCODER_PARAMS *) base_op_get_class_ext(op_data);
8420669e:	ef fd cf ff 	call (m) 0x558;
842066a2:	3b e5 
842066a4:	17 00       	r5 = r0 + Null;
}

static inline CELT_ENC_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (CELT_ENC_OP_DATA *) base_op_get_instance_data(op_data);
842066a6:	42 08       	r0 = r6 + Null;
842066a8:	ef fd cf ff 	call (m) 0x4e6;
842066ac:	3f e1 
842066ae:	16 00       	r4 = r0 + Null;
bool celt_encode_disconnect(OPERATOR_DATA *op_data, void *message_data,
                        unsigned *response_id, void **response_data)
{
    ENCODER_PARAMS *encoder_data = get_class_data(op_data);
    CELT_ENC_OP_DATA *opx_data = get_instance_data(op_data);
    unsigned terminal_id = ((unsigned*)message_data)[0];
842066b0:	99 f0 00 e8 	r7 = M[r7 + Null];

    /* Check that the operator is not running !*/
    if (opmgr_op_is_running(op_data))
842066b4:	42 08       	r0 = r6 + Null;
842066b6:	ef fd f8 ff 	call (m) 0x5700;
842066ba:	2b e2 
842066bc:	10 04       	Null = r0 - Null;
842066be:	09 60       	if EQ jump (m) Lc_celt_encode_disconnect_3;

842066c0 <Lc_celt_encode_disconnect_2>:
    {
        return base_op_build_std_response_ex(op_data, STATUS_CMD_FAILED, response_data);
842066c0:	03 f0 00 60 	r1 = Null + 4096;
842066c4:	54 08       	r2 = r8 + Null;
842066c6:	42 08       	r0 = r6 + Null;
842066c8:	ef fd ce ff 	call (m) 0x4bc;
842066cc:	35 ef 
842066ce:	30 6e       	jump (m) Lc_celt_encode_disconnect_16;

842066d0 <Lc_celt_encode_disconnect_3>:
    }

    if (!base_op_build_std_response_ex(op_data, STATUS_OK, response_data))
842066d0:	03 00       	r1 = Null + Null;
842066d2:	54 08       	r2 = r8 + Null;
842066d4:	42 08       	r0 = r6 + Null;
842066d6:	ef fd ce ff 	call (m) 0x4bc;
842066da:	27 ef 
842066dc:	10 04       	Null = r0 - Null;
842066de:	03 62       	if NE jump (m) Lc_celt_encode_disconnect_5;

842066e0 <Lc_celt_encode_disconnect_4>:
    {
        return FALSE;
842066e0:	02 00       	r0 = Null + Null;
842066e2:	26 6e       	jump (m) Lc_celt_encode_disconnect_16;

842066e4 <Lc_celt_encode_disconnect_5>:
    }

    switch (terminal_id)
842066e4:	0f f9 00 c2 	Null = r7 - Null;
842066e8:	15 60       	if EQ jump (m) Lc_celt_encode_disconnect_12;

842066ea <Lc_celt_encode_disconnect_6>:
842066ea:	00 f2 90 f0 	Null = r7 - 8388608;
842066ee:	00 24 
842066f0:	14 60       	if EQ jump (m) Lc_celt_encode_disconnect_13;

842066f2 <Lc_celt_encode_disconnect_7>:
842066f2:	00 f2 90 f0 	Null = r7 - 8388609;
842066f6:	01 24 
842066f8:	0b 62       	if NE jump (m) Lc_celt_encode_disconnect_11;

842066fa <Lc_celt_encode_disconnect_8>:
#endif /* INSTALL_METADATA */
            opx_data->clone_left_input = NULL;
            break;
        case RIGHT_IN_TERMINAL_ID:
#ifdef INSTALL_METADATA
            if (encoder_data->metadata_ip_buffer == opx_data->clone_right_input)
842066fa:	b9 89       	rMAC = M[r5 + 24];
842066fc:	62 f0 a5 88 	r0 = M[r4 + 660];
84206700:	88 04       	Null = rMAC - r0;
84206702:	04 62       	if NE jump (m) Lc_celt_encode_disconnect_10;

84206704 <Lc_celt_encode_disconnect_9>:
            {
                /* If the left input is still connected, get metadata from there.
                 * If it's not, this will be NULL anyway.
                 */
                encoder_data->metadata_ip_buffer = opx_data->clone_left_input;
84206704:	61 f0 a4 88 	rMAC = M[r4 + 656];
84206708:	b9 8f       	M[r5 + 24] = rMAC;

8420670a <Lc_celt_encode_disconnect_10>:
            }
#endif /* INSTALL_METADATA */
            opx_data->clone_right_input = NULL;
8420670a:	60 f0 a5 8e 	M[r4 + 660] = Null;

8420670e <Lc_celt_encode_disconnect_11>:
            break;
        /* NB No default as can't happen */
    }
    return TRUE;
8420670e:	42 20       	r0 = Null + 1;
84206710:	0f 6e       	jump (m) Lc_celt_encode_disconnect_16;

84206712 <Lc_celt_encode_disconnect_12>:
    }

    switch (terminal_id)
    {
        case OUTPUT_TERMINAL_ID:
            opx_data->clone_output = NULL;
84206712:	60 f0 a6 8e 	M[r4 + 664] = Null;
            break;
84206716:	fc 6f       	jump (m) Lc_celt_encode_disconnect_11;

84206718 <Lc_celt_encode_disconnect_13>:
        case LEFT_IN_TERMINAL_ID:
#ifdef INSTALL_METADATA
            if (encoder_data->metadata_ip_buffer == opx_data->clone_left_input)
84206718:	b9 89       	rMAC = M[r5 + 24];
8420671a:	62 f0 a4 88 	r0 = M[r4 + 656];
8420671e:	88 04       	Null = rMAC - r0;
84206720:	04 62       	if NE jump (m) Lc_celt_encode_disconnect_15;

84206722 <Lc_celt_encode_disconnect_14>:
            {
                /* If the right input is still connected, get metadata from there.
                 * If it's not, this will be NULL anyway.
                 */
                encoder_data->metadata_ip_buffer = opx_data->clone_right_input;
84206722:	61 f0 a5 88 	rMAC = M[r4 + 660];
84206726:	b9 8f       	M[r5 + 24] = rMAC;

84206728 <Lc_celt_encode_disconnect_15>:
            }
#endif /* INSTALL_METADATA */
            opx_data->clone_left_input = NULL;
84206728:	60 f0 a4 8e 	M[r4 + 656] = Null;
            break;
8420672c:	f1 6f       	jump (m) Lc_celt_encode_disconnect_11;

8420672e <Lc_celt_encode_disconnect_16>:
            opx_data->clone_right_input = NULL;
            break;
        /* NB No default as can't happen */
    }
    return TRUE;
}
8420672e:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
84206730:	d8 4c       	rts;

84206732 <$_celt_encoder_start>:

#ifdef CELT_ENCODE_OFFLOAD

bool celt_encoder_start(OPERATOR_DATA *op_data, void *message_data,
                                unsigned *response_id, void **response_data)
{
84206732:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
84206734:	16 00       	r4 = r0 + Null;
84206736:	22 09       	r8 = r2 + Null;
84206738:	29 09       	r7 = r3 + Null;
Private Function Declarations
*/

static inline ENCODER_PARAMS *get_class_data(OPERATOR_DATA *op_data)
{
    return (ENCODER_PARAMS *) base_op_get_class_ext(op_data);
8420673a:	ef fd cf ff 	call (m) 0x558;
8420673e:	3f e0 
84206740:	10 09       	r6 = r0 + Null;
}

static inline CELT_ENC_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (CELT_ENC_OP_DATA *) base_op_get_instance_data(op_data);
84206742:	32 00       	r0 = r4 + Null;
84206744:	ef fd ce ff 	call (m) 0x4e6;
84206748:	23 ed 
8420674a:	17 00       	r5 = r0 + Null;
{
    ENCODER_PARAMS *encoder_data = get_class_data(op_data);
    CELT_ENC_OP_DATA *opx_data = get_instance_data(op_data);
    unsigned buffer_flags;

    *response_id = OPCMD_START;
8420674c:	81 20       	rMAC = Null + 2;
8420674e:	a1 f0 00 ee 	M[r8 + Null] = rMAC;

    /* Create the response. If there aren't sufficient resources for this fail
     * early. */
    if (!base_op_build_std_response_ex(op_data, STATUS_OK, response_data))
84206752:	03 00       	r1 = Null + Null;
84206754:	4c 08       	r2 = r7 + Null;
84206756:	32 00       	r0 = r4 + Null;
84206758:	ef fd ce ff 	call (m) 0x4bc;
8420675c:	25 eb 
8420675e:	10 04       	Null = r0 - Null;
84206760:	03 62       	if NE jump (m) Lc_celt_encoder_start_3;

84206762 <Lc_celt_encoder_start_2>:
    {
        return FALSE;
84206762:	02 00       	r0 = Null + Null;
84206764:	6f 6e       	jump (m) Lc_celt_encoder_start_10;

84206766 <Lc_celt_encoder_start_3>:
    }

    if (opmgr_op_is_running(op_data))
84206766:	32 00       	r0 = r4 + Null;
84206768:	ef fd f7 ff 	call (m) 0x5700;
8420676c:	39 ec 
8420676e:	10 04       	Null = r0 - Null;
84206770:	0c 62       	if NE jump (m) Lc_celt_encoder_start_7;

84206772 <Lc_celt_encoder_start_4>:
        /* Operator already started nothing to do. */
        return TRUE;
    }

    /* 1st (left) source and output need to be connected. */
    if ((opx_data->clone_left_input == NULL)||(opx_data->clone_output == NULL))
84206772:	71 f0 a4 88 	rMAC = M[r5 + 656];
84206776:	04 60       	if EQ jump (m) Lc_celt_encoder_start_6;

84206778 <Lc_celt_encoder_start_5>:
84206778:	71 f0 a6 88 	rMAC = M[r5 + 664];
8420677c:	08 62       	if NE jump (m) Lc_celt_encoder_start_8;

8420677e <Lc_celt_encoder_start_6>:
8420677e:	01 f0 00 60 	rMAC = Null + 4096;
84206782:	92 f0 00 e8 	r0 = M[r7 + Null];
84206786:	51 8e       	M[r0 + 4] = rMAC;

84206788 <Lc_celt_encoder_start_7>:
    }

    if (opmgr_op_is_running(op_data))
    {
        /* Operator already started nothing to do. */
        return TRUE;
84206788:	42 20       	r0 = Null + 1;
8420678a:	5c 6e       	jump (m) Lc_celt_encoder_start_10;

8420678c <Lc_celt_encoder_start_8>:
        base_op_change_response_status(response_data, STATUS_CMD_FAILED);
        return TRUE;
    }

#ifdef INSTALL_METADATA
    encoder_data->last_tag_samples = LAST_TAG_SAMPLES_INVALID;
8420678c:	41 24       	rMAC = Null - 1;
8420678e:	81 f0 0a 8e 	M[r6 + 40] = rMAC;
    encoder_data->last_tag_err_offset_id = INFO_ID_INVALID;
84206792:	80 f0 0b 8e 	M[r6 + 44] = Null;
#endif /* INSTALL_METADATA */

    /* Make copies of the connection buffers to give to the codec library
     * This runs asynchronously, so can't use the buffers visible externally 
     */
    buffer_flags = opx_data->clone_output->descriptor;
84206796:	72 f0 a6 88 	r0 = M[r5 + 664];
8420679a:	56 89       	r4 = M[r0 + 20];
    encoder_data->codec.out_buffer = cbuffer_create( opx_data->clone_output->base_addr,
                    cbuffer_get_size_in_words(opx_data->clone_output), buffer_flags);
8420679c:	ff fd 6e f0 	call (m) 0x14450;
842067a0:	35 e5 
842067a2:	13 00       	r1 = r0 + Null;
842067a4:	71 f0 a6 88 	rMAC = M[r5 + 664];
842067a8:	ca 88       	r0 = M[rMAC + 12];
842067aa:	34 00       	r2 = r4 + Null;
842067ac:	ff fd 6d f0 	call (m) 0x1429c;
842067b0:	31 e7 
842067b2:	82 f0 00 ee 	M[r6 + Null] = r0;

    encoder_data->codec.out_buffer->read_ptr = opx_data->clone_output->read_ptr;
842067b6:	71 f0 a6 88 	rMAC = M[r5 + 664];
842067ba:	82 f0 00 e8 	r0 = M[r6 + Null];
842067be:	49 88       	rMAC = M[rMAC + 4];
842067c0:	51 8e       	M[r0 + 4] = rMAC;
    encoder_data->codec.out_buffer->write_ptr = opx_data->clone_output->write_ptr;
842067c2:	71 f0 a6 88 	rMAC = M[r5 + 664];
842067c6:	82 f0 00 e8 	r0 = M[r6 + Null];
842067ca:	89 88       	rMAC = M[rMAC + 8];
842067cc:	91 8e       	M[r0 + 8] = rMAC;

    buffer_flags = opx_data->clone_left_input->descriptor;
842067ce:	72 f0 a4 88 	r0 = M[r5 + 656];
842067d2:	56 89       	r4 = M[r0 + 20];
    encoder_data->codec.in_left_buffer = cbuffer_create( opx_data->clone_left_input->base_addr,
                    cbuffer_get_size_in_words(opx_data->clone_left_input), buffer_flags);
842067d4:	ff fd 6e f0 	call (m) 0x14450;
842067d8:	3d e3 
842067da:	13 00       	r1 = r0 + Null;
842067dc:	71 f0 a4 88 	rMAC = M[r5 + 656];
842067e0:	ca 88       	r0 = M[rMAC + 12];
842067e2:	34 00       	r2 = r4 + Null;
842067e4:	ff fd 6d f0 	call (m) 0x1429c;
842067e8:	39 e5 
842067ea:	82 f0 01 8e 	M[r6 + 4] = r0;

    encoder_data->codec.in_left_buffer->read_ptr = opx_data->clone_left_input->read_ptr;
842067ee:	71 f0 a4 88 	rMAC = M[r5 + 656];
842067f2:	82 f0 01 88 	r0 = M[r6 + 4];
842067f6:	49 88       	rMAC = M[rMAC + 4];
842067f8:	51 8e       	M[r0 + 4] = rMAC;
    encoder_data->codec.in_left_buffer->write_ptr = opx_data->clone_left_input->write_ptr;
842067fa:	71 f0 a4 88 	rMAC = M[r5 + 656];
842067fe:	82 f0 01 88 	r0 = M[r6 + 4];
84206802:	89 88       	rMAC = M[rMAC + 8];
84206804:	91 8e       	M[r0 + 8] = rMAC;

    /* Right input does't need to be connected */
    if (opx_data->clone_right_input)
84206806:	72 f0 a5 88 	r0 = M[r5 + 660];
8420680a:	bf 61       	if EQ jump (m) Lc_celt_encoder_start_7;

8420680c <Lc_celt_encoder_start_9>:
    {
        buffer_flags = opx_data->clone_right_input->descriptor;
8420680c:	56 89       	r4 = M[r0 + 20];
        encoder_data->codec.in_right_buffer = cbuffer_create( opx_data->clone_right_input->base_addr,
                        cbuffer_get_size_in_words(opx_data->clone_right_input), buffer_flags);
8420680e:	ff fd 6e f0 	call (m) 0x14450;
84206812:	23 e2 
84206814:	13 00       	r1 = r0 + Null;
84206816:	71 f0 a5 88 	rMAC = M[r5 + 660];
8420681a:	ca 88       	r0 = M[rMAC + 12];
8420681c:	34 00       	r2 = r4 + Null;
8420681e:	ff fd 6d f0 	call (m) 0x1429c;
84206822:	3f e3 
84206824:	82 f0 02 8e 	M[r6 + 8] = r0;

        encoder_data->codec.in_right_buffer->read_ptr = opx_data->clone_right_input->read_ptr;
84206828:	71 f0 a5 88 	rMAC = M[r5 + 660];
8420682c:	82 f0 02 88 	r0 = M[r6 + 8];
84206830:	49 88       	rMAC = M[rMAC + 4];
84206832:	51 8e       	M[r0 + 4] = rMAC;
        encoder_data->codec.in_right_buffer->write_ptr = opx_data->clone_right_input->write_ptr;
84206834:	71 f0 a5 88 	rMAC = M[r5 + 660];
84206838:	82 f0 02 88 	r0 = M[r6 + 8];
8420683c:	89 88       	rMAC = M[rMAC + 8];
8420683e:	91 8e       	M[r0 + 8] = rMAC;
84206840:	a4 6f       	jump (m) Lc_celt_encoder_start_7;

84206842 <Lc_celt_encoder_start_10>:
    }
    return TRUE;
}
84206842:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
84206844:	d8 4c       	rts;

84206846 <$_celt_encoder_stop_reset>:

bool celt_encoder_stop_reset(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
84206846:	f4 1c       	pushm <FP(=SP), r4, r5, r6, r7, rLink>;
84206848:	17 00       	r5 = r0 + Null;
8420684a:	29 09       	r7 = r3 + Null;
Private Function Declarations
*/

static inline ENCODER_PARAMS *get_class_data(OPERATOR_DATA *op_data)
{
    return (ENCODER_PARAMS *) base_op_get_class_ext(op_data);
8420684c:	ef fd ce ff 	call (m) 0x558;
84206850:	2d e8 
84206852:	10 09       	r6 = r0 + Null;
}

bool celt_encoder_stop_reset(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
    ENCODER_PARAMS *encoder_data = get_class_data(op_data);
    INT_OP_ID opid = base_op_get_int_op_id(op_data);
84206854:	3a 00       	r0 = r5 + Null;
84206856:	ef fd ce ff 	call (m) 0x4f0;
8420685a:	3b e4 
8420685c:	16 00       	r4 = r0 + Null;

    /* Create the response. If there aren't sufficient resources for this fail
     * early. */
    if (!base_op_build_std_response_ex(op_data, STATUS_OK, response_data))
8420685e:	03 00       	r1 = Null + Null;
84206860:	4c 08       	r2 = r7 + Null;
84206862:	3a 00       	r0 = r5 + Null;
84206864:	ef fd ce ff 	call (m) 0x4bc;
84206868:	39 e2 
8420686a:	10 04       	Null = r0 - Null;
8420686c:	03 62       	if NE jump (m) Lc_celt_encoder_stop_reset_3;

8420686e <Lc_celt_encoder_stop_reset_2>:
    {
        return FALSE;
8420686e:	02 00       	r0 = Null + Null;
84206870:	21 6e       	jump (m) Lc_celt_encoder_stop_reset_6;

84206872 <Lc_celt_encoder_stop_reset_3>:
    }

    /* Mark the operator as stopped. */
    base_op_stop_operator(op_data);
84206872:	3a 00       	r0 = r5 + Null;
84206874:	ef fd ce ff 	call (m) 0x54a;
84206878:	37 e6 

8420687a <Lc_celt_encoder_stop_reset_4>:

    /* Wait for any processing to finish */
    while (audio_thread_rpc_is_queued(opid));
8420687a:	32 00       	r0 = r4 + Null;
8420687c:	ff fd 6b f0 	call (m) 0x13f5e;
84206880:	23 e7 
84206882:	10 04       	Null = r0 - Null;
84206884:	fb 63       	if NE jump (m) Lc_celt_encoder_stop_reset_4;

84206886 <Lc_celt_encoder_stop_reset_5>:

    /* Free the buffers that were allocated in the start handler */
    cbuffer_destroy_struct(encoder_data->codec.out_buffer);
84206886:	82 f0 00 e8 	r0 = M[r6 + Null];
8420688a:	ff fd 6d f0 	call (m) 0x143cc;
8420688e:	23 ea 
    encoder_data->codec.out_buffer = NULL;
84206890:	80 f0 00 ee 	M[r6 + Null] = Null;

    cbuffer_destroy_struct(encoder_data->codec.in_left_buffer);
84206894:	82 f0 01 88 	r0 = M[r6 + 4];
84206898:	ff fd 6d f0 	call (m) 0x143cc;
8420689c:	35 e9 
    encoder_data->codec.in_left_buffer = NULL;
8420689e:	80 f0 01 8e 	M[r6 + 4] = Null;

    cbuffer_destroy_struct(encoder_data->codec.in_right_buffer);
842068a2:	82 f0 02 88 	r0 = M[r6 + 8];
842068a6:	ff fd 6d f0 	call (m) 0x143cc;
842068aa:	27 e9 
    encoder_data->codec.in_right_buffer = NULL;
842068ac:	80 f0 02 8e 	M[r6 + 8] = Null;

    return TRUE;
842068b0:	42 20       	r0 = Null + 1;

842068b2 <Lc_celt_encoder_stop_reset_6>:
}
842068b2:	f4 48       	popm <FP, r4, r5, r6, r7, rLink>;
842068b4:	d8 4c       	rts;

842068b6 <$_celt_encode_process_data>:
        opmgr_kick_operator(op_data);
    }
}

void celt_encode_process_data(OPERATOR_DATA *op_data, TOUCHED_TERMINALS *touched)
{
842068b6:	f6 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>;
842068b8:	57 4c       	SP = SP + 92;
842068ba:	12 09       	r8 = r0 + Null;
842068bc:	43 de       	M[FP + 32] = r1;
Private Function Declarations
*/

static inline ENCODER_PARAMS *get_class_data(OPERATOR_DATA *op_data)
{
    return (ENCODER_PARAMS *) base_op_get_class_ext(op_data);
842068be:	ef fd ce ff 	call (m) 0x558;
842068c2:	3b e4 
842068c4:	11 09       	r7 = r0 + Null;
}

static inline CELT_ENC_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (CELT_ENC_OP_DATA *) base_op_get_instance_data(op_data);
842068c6:	52 08       	r0 = r8 + Null;
842068c8:	ef fd ce ff 	call (m) 0x4e6;
842068cc:	3f e0 
842068ce:	17 00       	r5 = r0 + Null;

void celt_encode_process_data(OPERATOR_DATA *op_data, TOUCHED_TERMINALS *touched)
{
    ENCODER_PARAMS *enc_base = get_class_data(op_data);
    CELT_ENC_OP_DATA *opx_data = get_instance_data(op_data);
    INT_OP_ID opid = base_op_get_int_op_id(op_data);
842068d0:	52 08       	r0 = r8 + Null;
842068d2:	ef fd ce ff 	call (m) 0x4f0;
842068d6:	3f e0 
    const ENCODER_CAP_VIRTUAL_TABLE *vt = enc_base->vt;
842068d8:	9b f0 05 88 	r9 = M[r7 + 20];
842068dc:	c1 f1 1d 40 	rMAC = Null + 229405;
842068e0:	9a de       	M[FP + 76] = r0;
842068e2:	a1 de       	M[FP + 80] = rMAC;
842068e4:	e9 f0 15 8e 	M[FP + 84] = r7;
842068e8:	b1 f0 00 e8 	rMAC = M[r9 + Null];
842068ec:	b1 de       	M[FP + 88] = rMAC;
842068ee:	b8 de       	M[FP + 92] = Null;
842068f0:	42 f0 31 f0 	rMAC = Null + 69233553;
842068f4:	91 53 
842068f6:	c0 de       	M[FP + 96] = Null;
842068f8:	c9 de       	M[FP + 100] = rMAC;
842068fa:	ea f0 1a 8e 	M[FP + 104] = r8;
    };

    patch_fn(encoder_process_data);


    if (audio_thread_rpc_is_queued(opid))
842068fe:	ff fd 6b f0 	call (m) 0x13f5e;
84206902:	21 e3 
84206904:	10 04       	Null = r0 - Null;
84206906:	06 60       	if EQ jump (m) Lc_celt_encode_process_data_3;

84206908 <Lc_celt_encode_process_data_2>:
    {
        /* RPC is busy, try again later */
        opx_data->kicks_pending = TRUE;
84206908:	41 20       	rMAC = Null + 1;
8420690a:	71 f0 a7 8e 	M[r5 + 668] = rMAC;
        return;
8420690e:	0f f0 e9 e4 	jump (m) Lc_celt_encode_process_data_44;

84206912 <Lc_celt_encode_process_data_3>:
    }

    ip_offset_pre_enc = cbuffer_get_read_offset(opx_data->clone_left_input);
84206912:	72 f0 a4 88 	r0 = M[r5 + 656];
84206916:	ff fd 6d f0 	call (m) 0x143f0;
8420691a:	3b e6 
8420691c:	10 09       	r6 = r0 + Null;

    opx_data->clone_left_input->read_ptr = enc_base->codec.in_left_buffer->read_ptr;
8420691e:	91 f0 01 88 	rMAC = M[r7 + 4];
84206922:	72 f0 a4 88 	r0 = M[r5 + 656];
84206926:	49 88       	rMAC = M[rMAC + 4];
84206928:	51 8e       	M[r0 + 4] = rMAC;
    opx_data->clone_right_input->read_ptr = enc_base->codec.in_right_buffer->read_ptr;
8420692a:	91 f0 02 88 	rMAC = M[r7 + 8];
8420692e:	72 f0 a5 88 	r0 = M[r5 + 660];
84206932:	49 88       	rMAC = M[rMAC + 4];
84206934:	51 8e       	M[r0 + 4] = rMAC;
    opx_data->clone_output->write_ptr = enc_base->codec.out_buffer->write_ptr;
84206936:	91 f0 00 e8 	rMAC = M[r7 + Null];
8420693a:	72 f0 a6 88 	r0 = M[r5 + 664];
8420693e:	89 88       	rMAC = M[rMAC + 8];
84206940:	91 8e       	M[r0 + 8] = rMAC;

    enc_base->codec.in_left_buffer->write_ptr = opx_data->clone_left_input->write_ptr;
84206942:	71 f0 a4 88 	rMAC = M[r5 + 656];
84206946:	92 f0 01 88 	r0 = M[r7 + 4];
8420694a:	89 88       	rMAC = M[rMAC + 8];
8420694c:	91 8e       	M[r0 + 8] = rMAC;
    enc_base->codec.in_right_buffer->write_ptr = opx_data->clone_right_input->write_ptr;
8420694e:	71 f0 a5 88 	rMAC = M[r5 + 660];
84206952:	92 f0 02 88 	r0 = M[r7 + 8];
84206956:	89 88       	rMAC = M[rMAC + 8];
84206958:	91 8e       	M[r0 + 8] = rMAC;

    if ((BUF_DESC_IN_PLACE(opx_data->clone_output->descriptor) != 0) && (opx_data->clone_output->aux_ptr != NULL))
8420695a:	72 f0 a6 88 	r0 = M[r5 + 664];
8420695e:	51 89       	rMAC = M[r0 + 20];
84206960:	c9 c6       	rMAC = rMAC AND 0x10000;
84206962:	08 60       	if EQ jump (m) Lc_celt_encode_process_data_6;

84206964 <Lc_celt_encode_process_data_4>:
84206964:	11 89       	rMAC = M[r0 + 16];
84206966:	06 60       	if EQ jump (m) Lc_celt_encode_process_data_6;

84206968 <Lc_celt_encode_process_data_5>:
    {
        tCbuffer *tail = (tCbuffer *)opx_data->clone_output->aux_ptr;
        enc_base->codec.out_buffer->read_ptr = tail->read_ptr;
84206968:	49 88       	rMAC = M[rMAC + 4];
8420696a:	92 f0 00 e8 	r0 = M[r7 + Null];
8420696e:	51 8e       	M[r0 + 4] = rMAC;
84206970:	05 6e       	jump (m) Lc_celt_encode_process_data_7;

84206972 <Lc_celt_encode_process_data_6>:
    }
    else
    {
        enc_base->codec.out_buffer->read_ptr = opx_data->clone_output->read_ptr;
84206972:	51 88       	rMAC = M[r0 + 4];
84206974:	92 f0 00 e8 	r0 = M[r7 + Null];
84206978:	51 8e       	M[r0 + 4] = rMAC;

8420697a <Lc_celt_encode_process_data_7>:
    }

    ip_offset_post_enc = cbuffer_get_read_offset(enc_base->codec.in_left_buffer);
8420697a:	92 f0 01 88 	r0 = M[r7 + 4];
8420697e:	ff fd 6d f0 	call (m) 0x143f0;
84206982:	33 e3 
84206984:	16 00       	r4 = r0 + Null;

    if (opx_data->offload_enabled)
84206986:	70 f0 a8 88 	Null = M[r5 + 672];
8420698a:	06 60       	if EQ jump (m) Lc_celt_encode_process_data_9;

8420698c <Lc_celt_encode_process_data_8>:
    {
        thread_offload_queue_rpc(&rpc_data);
8420698c:	c2 14       	r0 = FP + 76;
8420698e:	ff fd 6b f0 	call (m) 0x13fa6;
84206992:	39 e0 
84206994:	07 6e       	jump (m) Lc_celt_encode_process_data_10;

84206996 <Lc_celt_encode_process_data_9>:
    }
    else
    {
        encoder_encode(&(enc_base->codec), vt->encode_fn);
84206996:	b3 f0 00 e8 	r1 = M[r9 + Null];
8420699a:	4a 08       	r0 = r7 + Null;
8420699c:	ff fd 8b f1 	call (m) 0x3801c;
842069a0:	21 e4 

842069a2 <Lc_celt_encode_process_data_10>:
    }

    /* total data processed on the input */
    if (ip_offset_post_enc >= ip_offset_pre_enc)
842069a2:	8f f6 00 c2 	Null = r4 - r6;
842069a6:	04 64       	if NC jump (m) Lc_celt_encode_process_data_12;

842069a8 <Lc_celt_encode_process_data_11>:
    {
        ip_proc_data = ip_offset_post_enc - ip_offset_pre_enc;
842069a8:	00 f8 36 c2 	r4 = r4 - r6;
842069ac:	09 6e       	jump (m) Lc_celt_encode_process_data_13;

842069ae <Lc_celt_encode_process_data_12>:
    }
    else
    {
        unsigned buffsize = cbuffer_get_size_in_words(enc_base->codec.in_left_buffer);
842069ae:	92 f0 01 88 	r0 = M[r7 + 4];
842069b2:	ff fd 6d f0 	call (m) 0x14450;
842069b6:	3f e4 
        ip_proc_data = buffsize + ip_offset_post_enc - ip_offset_pre_enc;
842069b8:	91 01       	rMAC = r0 + r4;
842069ba:	8f f1 06 c2 	r4 = rMAC - r6;

842069be <Lc_celt_encode_process_data_13>:
    }

    if (ip_proc_data > 0)
842069be:	30 04       	Null = r4 - Null;
842069c0:	db 60       	if EQ jump (m) Lc_celt_encode_process_data_44;

842069c2 <Lc_celt_encode_process_data_14>:
        unsigned b4idx, afteridx;
        metadata_tag *mtag_ip, *mtag_ip_list;
        metadata_tag *mtag;
        tCbuffer *src, *dst;
        unsigned frame, frame_count, frame_len_enc_octets, frame_len_samples;
        unsigned new_ttp, base_ttp = 0, sample_offset = 0;
842069c2:	48 de       	M[FP + 36] = Null;
842069c4:	50 de       	M[FP + 40] = Null;
        bool framed_data;
        ttp_status status;

        src = enc_base->metadata_ip_buffer;
842069c6:	98 f0 06 88 	r6 = M[r7 + 24];
        dst = opx_data->clone_output;
842069ca:	71 f0 a6 88 	rMAC = M[r5 + 664];
842069ce:	59 de       	M[FP + 44] = rMAC;
        ip_proc_data_octets = ip_proc_data * OCTETS_PER_SAMPLE;
842069d0:	77 54       	r5 = r4 LSHIFT 2;

        framed_data = vt->frame_size_fn(op_data, &frame_len_samples, &frame_len_enc_octets);
842069d2:	b1 f0 03 88 	rMAC = M[r9 + 12];
842069d6:	c4 13       	r2 = FP + 60;
842069d8:	03 14       	r1 = FP + 64;
842069da:	52 08       	r0 = r8 + Null;
842069dc:	d1 4c       	call rMAC;

        if (framed_data)
842069de:	10 04       	Null = r0 - Null;
842069e0:	08 60       	if EQ jump (m) Lc_celt_encode_process_data_16;

842069e2 <Lc_celt_encode_process_data_15>:
        {
            /* Data is framed, so handle multiple output frames if necessary */
            frame_count = ip_proc_data / frame_len_samples;
842069e2:	83 d8       	r1 = M[FP + 64];
842069e4:	32 00       	r0 = r4 + Null;
842069e6:	ff fd 9c f0 	call (m) 0x1a290;
842069ea:	2b e5 
842069ec:	13 09       	r9 = r0 + Null;
842069ee:	0b 6e       	jump (m) Lc_celt_encode_process_data_17;

842069f0 <Lc_celt_encode_process_data_16>:
        }
        else
        {
            /* Treat whatever was produced as a single "frame" */
            frame_count = 1;
842069f0:	0b 71       	r9 = Null + 1;
            frame_len_enc_octets = frame_len_enc_octets * (ip_proc_data / frame_len_samples);
842069f2:	83 d8       	r1 = M[FP + 64];
842069f4:	32 00       	r0 = r4 + Null;
842069f6:	ff fd 9c f0 	call (m) 0x1a290;
842069fa:	3b e4 
842069fc:	79 d8       	rMAC = M[FP + 60];
842069fe:	89 1a       	rMAC = rMAC * r0 (int);
84206a00:	79 de       	M[FP + 60] = rMAC;
            frame_len_samples = ip_proc_data;
84206a02:	86 de       	M[FP + 64] = r4;

84206a04 <Lc_celt_encode_process_data_17>:
        }

        /* Extract metadata tag from input */
        mtag_ip_list = buff_metadata_remove(src, ip_proc_data_octets, &b4idx, &afteridx);
84206a04:	85 13       	r3 = FP + 56;
84206a06:	44 13       	r2 = FP + 52;
84206a08:	3b 00       	r1 = r5 + Null;
84206a0a:	42 08       	r0 = r6 + Null;
84206a0c:	ff fd 6f f0 	call (m) 0x149ca;
84206a10:	3f ed 
84206a12:	62 de       	M[FP + 48] = r0;
84206a14:	17 00       	r5 = r0 + Null;

84206a16 <Lc_celt_encode_process_data_18>:

        /* Find the first timestamped tag */
        mtag_ip = mtag_ip_list;
        while ((mtag_ip != NULL) && (!IS_TIMESTAMPED_TAG(mtag_ip)))
84206a16:	38 04       	Null = r5 - Null;
84206a18:	2b 60       	if EQ jump (m) Lc_celt_encode_process_data_26;

84206a1a <Lc_celt_encode_process_data_19>:
84206a1a:	79 88       	rMAC = M[r5 + 4];
84206a1c:	12 f0 30 00 	r0 = rMAC AND 0x30;
84206a20:	03 60       	if EQ jump (m) Lc_celt_encode_process_data_21;

84206a22 <Lc_celt_encode_process_data_20>:
84206a22:	c9 c2       	rMAC = rMAC AND 0x40;
84206a24:	07 60       	if EQ jump (m) Lc_celt_encode_process_data_22;

84206a26 <Lc_celt_encode_process_data_21>:
        {
            b4idx += mtag_ip->length;
84206a26:	f9 88       	rMAC = M[r5 + 12];
84206a28:	6a d8       	r0 = M[FP + 52];
84206a2a:	51 00       	rMAC = r0 + rMAC;
84206a2c:	69 de       	M[FP + 52] = rMAC;
            mtag_ip = mtag_ip->next;
84206a2e:	3f e8       	r5 = M[r5 + Null];
84206a30:	f3 6f       	jump (m) Lc_celt_encode_process_data_18;

84206a32 <Lc_celt_encode_process_data_22>:
        }

        if ((b4idx == 0) && (mtag_ip != NULL))
84206a32:	68 d8       	Null = M[FP + 52];
84206a34:	1d 62       	if NE jump (m) Lc_celt_encode_process_data_26;

84206a36 <Lc_celt_encode_process_data_23>:
        {
            /* If the old tag is already at the start of the encoded frame,
             * Just use its timestamp directly
             */
            base_ttp = mtag_ip->timestamp;
84206a36:	39 89       	rMAC = M[r5 + 16];
84206a38:	49 de       	M[FP + 36] = rMAC;
            sample_offset = 0;
84206a3a:	50 de       	M[FP + 40] = Null;

84206a3c <Lc_celt_encode_process_data_24>:
        if (mtag_ip != NULL)
        {
            unsigned *err_offset_id;
            unsigned length;
            /* Save the timestamp info from the incoming metadata */
            enc_base->last_tag_timestamp = mtag_ip->timestamp;
84206a3c:	39 89       	rMAC = M[r5 + 16];
84206a3e:	91 f0 08 8e 	M[r7 + 32] = rMAC;
            enc_base->last_tag_spa = mtag_ip->sp_adjust;
84206a42:	79 89       	rMAC = M[r5 + 20];
84206a44:	91 f0 09 8e 	M[r7 + 36] = rMAC;
            enc_base->last_tag_samples = ip_proc_data - (b4idx / OCTETS_PER_SAMPLE);
84206a48:	6a d8       	r0 = M[FP + 52];
84206a4a:	52 50       	r0 = r0 LSHIFT -2;
84206a4c:	b1 04       	rMAC = r4 - r0;
84206a4e:	91 f0 0a 8e 	M[r7 + 40] = rMAC;
            if (buff_metadata_find_private_data(mtag_ip, META_PRIV_KEY_TTP_OFFSET, &length, (void **)&err_offset_id))
84206a52:	45 14       	r3 = FP + 68;
84206a54:	84 14       	r2 = FP + 72;
84206a56:	43 20       	r1 = Null + 1;
84206a58:	3a 00       	r0 = r5 + Null;
84206a5a:	ff fd 6e f0 	call (m) 0x14762;
84206a5e:	29 e8 
84206a60:	10 04       	Null = r0 - Null;
84206a62:	20 60       	if EQ jump (m) Lc_celt_encode_process_data_32;

84206a64 <Lc_celt_encode_process_data_25>:
            {
                enc_base->last_tag_err_offset_id = (*err_offset_id);
84206a64:	89 d8       	rMAC = M[FP + 68];
84206a66:	09 e8       	rMAC = M[rMAC + Null];
84206a68:	91 f0 0b 8e 	M[r7 + 44] = rMAC;
84206a6c:	10 6e       	jump (m) Lc_celt_encode_process_data_31;

84206a6e <Lc_celt_encode_process_data_26>:
        }
        else
        {
            /* Otherwise, use the previously-stashed timestamp.
             * There had better be one ! */
            if (enc_base->last_tag_samples != LAST_TAG_SAMPLES_INVALID)
84206a6e:	91 f0 0a 88 	rMAC = M[r7 + 40];
84206a72:	48 20       	Null = rMAC + 1;
84206a74:	05 60       	if EQ jump (m) Lc_celt_encode_process_data_28;

84206a76 <Lc_celt_encode_process_data_27>:
            {
                base_ttp = enc_base->last_tag_timestamp;
84206a76:	92 f0 08 88 	r0 = M[r7 + 32];
84206a7a:	4a de       	M[FP + 36] = r0;
                sample_offset = enc_base->last_tag_samples;
84206a7c:	51 de       	M[FP + 40] = rMAC;

84206a7e <Lc_celt_encode_process_data_28>:
            }
        }

        if (mtag_ip != NULL)
84206a7e:	38 04       	Null = r5 - Null;
84206a80:	de 63       	if NE jump (m) Lc_celt_encode_process_data_24;

84206a82 <Lc_celt_encode_process_data_29>:
                enc_base->last_tag_err_offset_id = INFO_ID_INVALID;
            }
        }
        else
        {
            if (enc_base->last_tag_samples != LAST_TAG_SAMPLES_INVALID)
84206a82:	48 20       	Null = rMAC + 1;
84206a84:	04 60       	if EQ jump (m) Lc_celt_encode_process_data_31;

84206a86 <Lc_celt_encode_process_data_30>:
            {
                enc_base->last_tag_samples += ip_proc_data;
84206a86:	71 00       	rMAC = r4 + rMAC;
84206a88:	91 f0 0a 8e 	M[r7 + 40] = rMAC;

84206a8c <Lc_celt_encode_process_data_31>:
            }
        }

        status.sp_adjustment = enc_base->last_tag_spa;
84206a8c:	91 f0 09 88 	rMAC = M[r7 + 36];
84206a90:	e1 de       	M[FP + 112] = rMAC;
        status.err_offset_id = enc_base->last_tag_err_offset_id;
84206a92:	91 f0 0b 88 	rMAC = M[r7 + 44];
84206a96:	e9 de       	M[FP + 116] = rMAC;
        status.stream_restart = (METADATA_STREAM_START(mtag_ip) != 0);
84206a98:	79 88       	rMAC = M[r5 + 4];
84206a9a:	09 c0       	rMAC = rMAC AND 0x1;
84206a9c:	f1 de       	M[FP + 120] = rMAC;

        /* Create new tags for each output frame */
        for (frame = 0; frame < frame_count; frame++)
84206a9e:	07 00       	r5 = Null + Null;
84206aa0:	1b 6e       	jump (m) Lc_celt_encode_process_data_36;

84206aa2 <Lc_celt_encode_process_data_32>:
            {
                enc_base->last_tag_err_offset_id = (*err_offset_id);
            }
            else
            {
                enc_base->last_tag_err_offset_id = INFO_ID_INVALID;
84206aa2:	90 f0 0b 8e 	M[r7 + 44] = Null;
84206aa6:	f3 6f       	jump (m) Lc_celt_encode_process_data_31;

84206aa8 <Lc_celt_encode_process_data_33>:
                    L2_DBG_MSG1("Encoder op 0x%04x last tag samples invalid", base_op_get_ext_op_id(op_data));
                }
            }
            else
            {
                L2_DBG_MSG1("Encoder op 0x%04x failed to allocate tag", base_op_get_ext_op_id(op_data));
84206aa8:	01 f0 3c 91 	rMAC = MBS[Null + 0x33c];
84206aac:	88 24       	Null = rMAC - 2;
84206aae:	0c 68       	if LT jump (m) Lc_celt_encode_process_data_35;

84206ab0 <Lc_celt_encode_process_data_34>:
84206ab0:	52 08       	r0 = r8 + Null;
84206ab2:	ef fd cd ff 	call (m) 0x4f4;
84206ab6:	23 e2 
84206ab8:	13 00       	r1 = r0 + Null;
84206aba:	55 f1 02 f0 	r0 = Null + 357564527;
84206abe:	6f 40 
84206ac0:	ef fd d1 ff 	call (m) 0xcde;
84206ac4:	3f e0 

84206ac6 <Lc_celt_encode_process_data_35>:
            }

            buff_metadata_append(dst, mtag, 0, frame_len_enc_octets);
84206ac6:	7d d8       	r3 = M[FP + 60];
84206ac8:	04 00       	r2 = Null + Null;
84206aca:	33 00       	r1 = r4 + Null;
84206acc:	5a d8       	r0 = M[FP + 44];
84206ace:	ff fd 6e f0 	call (m) 0x147b8;
84206ad2:	2b e7 
        status.sp_adjustment = enc_base->last_tag_spa;
        status.err_offset_id = enc_base->last_tag_err_offset_id;
        status.stream_restart = (METADATA_STREAM_START(mtag_ip) != 0);

        /* Create new tags for each output frame */
        for (frame = 0; frame < frame_count; frame++)
84206ad4:	7f 20       	r5 = r5 + 1;

84206ad6 <Lc_celt_encode_process_data_36>:
84206ad6:	bf f7 00 c2 	Null = r5 - r9;
84206ada:	02 f0 81 e1 	if C jump (m) Lc_celt_encode_process_data_42;

84206ade <Lc_celt_encode_process_data_37>:
        {
            mtag = buff_metadata_new_tag();
84206ade:	ff fd 6d f0 	call (m) 0x1454e;
84206ae2:	31 e3 
84206ae4:	16 00       	r4 = r0 + Null;

            if (mtag != NULL)
84206ae6:	e1 61       	if EQ jump (m) Lc_celt_encode_process_data_33;

84206ae8 <Lc_celt_encode_process_data_38>:
            {
                mtag->length = frame_len_enc_octets;
84206ae8:	79 d8       	rMAC = M[FP + 60];
84206aea:	f1 8e       	M[r4 + 12] = rMAC;
                METADATA_PACKET_START_SET(mtag);
84206aec:	71 88       	rMAC = M[r4 + 4];
84206aee:	c9 c8       	rMAC = rMAC OR 0x4;
                METADATA_PACKET_END_SET(mtag);
84206af0:	49 c9       	rMAC = rMAC OR 0x8;
84206af2:	71 8e       	M[r4 + 4] = rMAC;

                if (enc_base->last_tag_samples != LAST_TAG_SAMPLES_INVALID)
84206af4:	91 f0 0a 88 	rMAC = M[r7 + 40];
84206af8:	48 20       	Null = rMAC + 1;
84206afa:	20 60       	if EQ jump (m) Lc_celt_encode_process_data_40;

84206afc <Lc_celt_encode_process_data_39>:
                {
                    /* Calculate new TTP from incoming data and sample offset */
                    new_ttp = ttp_get_next_timestamp(base_ttp, sample_offset + frame * frame_len_samples,
                        enc_base->sample_rate, enc_base->last_tag_spa);
84206afc:	95 f0 09 88 	r3 = M[r7 + 36];
84206b00:	94 f0 07 88 	r2 = M[r7 + 28];
84206b04:	81 d8       	rMAC = M[FP + 64];
84206b06:	52 d8       	r0 = M[FP + 40];
84206b08:	c9 1b       	rMAC = rMAC * r5 (int);
84206b0a:	8b 00       	r1 = rMAC + r0;
84206b0c:	4a d8       	r0 = M[FP + 36];
84206b0e:	ff fd 97 f0 	call (m) 0x19b02;
84206b12:	35 ef 
84206b14:	10 09       	r6 = r0 + Null;
                    new_ttp = time_sub(new_ttp, convert_samples_to_time(enc_base->delay_samples, enc_base->sample_rate));
84206b16:	93 f0 07 88 	r1 = M[r7 + 28];
84206b1a:	92 f0 0c 88 	r0 = M[r7 + 48];
84206b1e:	ff fd 8c f0 	call (m) 0x183fe;
84206b22:	21 e7 
84206b24:	00 f2 38 c2 	r6 = r6 - r0;
                    status.ttp = new_ttp;
84206b28:	e8 f0 1b 8e 	M[FP + 108] = r6;
                    ttp_utils_populate_tag(mtag, &status);
84206b2c:	c3 16       	r1 = FP + 108;
84206b2e:	32 00       	r0 = r4 + Null;
84206b30:	ef fd d0 ff 	call (m) 0xbe6;
84206b34:	37 e5 
                    status.stream_restart = FALSE;
84206b36:	f0 de       	M[FP + 120] = Null;
84206b38:	c7 6f       	jump (m) Lc_celt_encode_process_data_35;

84206b3a <Lc_celt_encode_process_data_40>:
                }
                else
                {
                    L2_DBG_MSG1("Encoder op 0x%04x last tag samples invalid", base_op_get_ext_op_id(op_data));
84206b3a:	01 f0 3c 91 	rMAC = MBS[Null + 0x33c];
84206b3e:	88 24       	Null = rMAC - 2;
84206b40:	c3 69       	if LT jump (m) Lc_celt_encode_process_data_35;

84206b42 <Lc_celt_encode_process_data_41>:
84206b42:	52 08       	r0 = r8 + Null;
84206b44:	ef fd cc ff 	call (m) 0x4f4;
84206b48:	31 ed 
84206b4a:	13 00       	r1 = r0 + Null;
84206b4c:	55 f1 02 f0 	r0 = Null + 357564484;
84206b50:	44 40 
84206b52:	ef fd d0 ff 	call (m) 0xcde;
84206b56:	2d ec 
84206b58:	b7 6f       	jump (m) Lc_celt_encode_process_data_35;

84206b5a <Lc_celt_encode_process_data_42>:
            buff_metadata_add_private_data(mtag, META_PRIV_KEY_USER_DATA, sizeof(unsigned), &frame_len_samples);
#endif
        }

        /* Free all the incoming tags */
        buff_metadata_tag_list_delete(mtag_ip_list);
84206b5a:	62 d8       	r0 = M[FP + 48];
84206b5c:	ff fd 6d f0 	call (m) 0x145ee;
84206b60:	33 e4 
#else
        NOT_USED(ip_proc_data);
#endif      /* INSTALL_METADATA */

        /* It ran and produced output so kick forwards */
        touched->sources = TOUCHED_SOURCE_0;
84206b62:	41 20       	rMAC = Null + 1;
84206b64:	42 d8       	r0 = M[FP + 32];
84206b66:	11 ee       	M[r0 + Null] = rMAC;

        /* If input data was stopped us running again then kick back to get some more */
        if (enc_base->codec.mode == CODEC_NOT_ENOUGH_INPUT_DATA)
84206b68:	91 f0 03 88 	rMAC = M[r7 + 12];
84206b6c:	48 24       	Null = rMAC - 1;
84206b6e:	04 62       	if NE jump (m) Lc_celt_encode_process_data_44;

84206b70 <Lc_celt_encode_process_data_43>:
        {
            touched->sinks = TOUCHED_SOURCE_0 | TOUCHED_SOURCE_1;
84206b70:	c1 20       	rMAC = Null + 3;
84206b72:	42 d8       	r0 = M[FP + 32];
84206b74:	51 8e       	M[r0 + 4] = rMAC;

84206b76 <Lc_celt_encode_process_data_44>:
        }
    }
}
84206b76:	69 4c       	SP = SP + -92;
84206b78:	f6 48       	popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84206b7a:	d8 4c       	rts;

84206b7c <Lc_free_data_and_fail_1>:
 *
 * \param op_data Pointer to the operator instance data.
 * \param response Pointer to the response message to give a failed status
 */
static void free_data_and_fail(OPERATOR_DATA *op_data, void **response)
{
84206b7c:	f1 1c       	pushm <FP(=SP), r4, rLink>;
84206b7e:	1e 00       	r4 = r1 + Null;
    patch_fn_shared(celt_encode_wrapper);
    /* Free the data and then override the response message status to fail */
    celt_encode_free_data(op_data);
84206b80:	fc ff 35 ef 	call (m) $_celt_encode_free_data;
84206b84:	01 f0 00 60 	rMAC = Null + 4096;
84206b88:	32 e8       	r0 = M[r4 + Null];
84206b8a:	51 8e       	M[r0 + 4] = rMAC;

84206b8c <Lc_free_data_and_fail_2>:
    base_op_change_response_status(response, STATUS_CMD_FAILED);
}
84206b8c:	f1 48       	popm <FP, r4, rLink>;
84206b8e:	d8 4c       	rts;

84206b90 <Lc_celt_enc_offload_callback_1>:
 * to the data processing function. That then propagates metadata from the 
 * previous iteration and schedules a new one.
 */

static void celt_enc_offload_callback(void *context)
{
84206b90:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
84206b92:	16 00       	r4 = r0 + Null;
    return (ENCODER_PARAMS *) base_op_get_class_ext(op_data);
}

static inline CELT_ENC_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (CELT_ENC_OP_DATA *) base_op_get_instance_data(op_data);
84206b94:	ef fd cc ff 	call (m) 0x4e6;
84206b98:	33 ea 
84206b9a:	17 00       	r5 = r0 + Null;
Private Function Declarations
*/

static inline ENCODER_PARAMS *get_class_data(OPERATOR_DATA *op_data)
{
    return (ENCODER_PARAMS *) base_op_get_class_ext(op_data);
84206b9c:	32 00       	r0 = r4 + Null;
84206b9e:	ef fd cc ff 	call (m) 0x558;
84206ba2:	3b ed 
{
    OPERATOR_DATA *op_data = (OPERATOR_DATA*) context;
    CELT_ENC_OP_DATA *opx_data = get_instance_data(op_data);
    ENCODER_PARAMS *enc_base = get_class_data(op_data);

    if ((opx_data->kicks_pending) || (enc_base->codec.mode == CODEC_SUCCESS))
84206ba4:	70 f0 a7 88 	Null = M[r5 + 668];
84206ba8:	03 62       	if NE jump (m) Lc_celt_enc_offload_callback_3;

84206baa <Lc_celt_enc_offload_callback_2>:
84206baa:	d0 88       	Null = M[r0 + 12];
84206bac:	07 62       	if NE jump (m) Lc_celt_enc_offload_callback_4;

84206bae <Lc_celt_enc_offload_callback_3>:
    {
        opx_data->kicks_pending = FALSE;
84206bae:	70 f0 a7 8e 	M[r5 + 668] = Null;
        opmgr_kick_operator(op_data);
84206bb2:	32 00       	r0 = r4 + Null;
84206bb4:	ef fd e5 ff 	call (m) 0x374a;
84206bb8:	37 ec 

84206bba <Lc_celt_enc_offload_callback_4>:
    }
}
84206bba:	f2 48       	popm <FP, r4, r5, rLink>;
84206bbc:	d8 4c       	rts;

84206bbe <$_populate_celt_asm_funcs>:

$_populate_celt_asm_funcs:

   LIBS_PUSH_REGS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.POPULATE_CELT_ASM_FUNCS.PATCH_ID_0)     // celt_patchers

   r2 = $celt.frame_decode;
84206bbe:	42 f0 04 f0 	r2 = Null + 69207308;
84206bc2:	0c 49 
   M[r0] = r2;
84206bc4:	84 ee       	M[Null + r0] = r2;
   r3 = NULL;
84206bc6:	05 00       	r3 = Null + Null;
   M[r1] = r2;
84206bc8:	c4 ee       	M[Null + r1] = r2;
   rts;
84206bca:	d8 4c       	rts;

84206bcc <$kdc_start>:
.MODULE $M.kdc_start;
.CODESEGMENT PM;
.DATASEGMENT DM;

$kdc_start:
r0 = $_celt_decode_cap_data;
84206bcc:	07 f0 02 f0 	r0 = Null + 7347792;
84206bd0:	50 7a 
r0 = $_celt_encode_cap_data;
84206bd2:	07 f0 02 f0 	r0 = Null + 7347956;
84206bd6:	f4 7a 
    /* Force this symbol to be exported in ELF */
    Null = $___kymera_debug_map_addr;
84206bd8:	20 f0 f8 42 	Null = Null + 17144;

84206bdc <$_thread_offload_update_p1_dm_location>:
.CODESEGMENT PM;
.MINIM;

$_thread_offload_update_p1_dm_location:
#ifdef ENTRY_POINT_THREAD_OFFLOAD_UPDATE_P1_MEM_LOCATION
    rMAC = M[$_patched_fw_version];
84206bdc:	01 f1 00 88 	rMAC = M[Null + 0x2000];
    Null = rMAC - PATCH_BUILD_ID;
84206be0:	00 f0 10 f2 	Null = rMAC - 10276;
84206be4:	24 34 
    if EQ jump ENTRY_POINT_THREAD_OFFLOAD_UPDATE_P1_MEM_LOCATION;
84206be6:	fb ff 60 ff 	if EQ jump (m) 0x400215e;
84206bea:	f9 ea 

84206bec <$M.download_support_lib.thread_offload_update_p1_dm_location.L_pb_mismatch>:
#endif
L_pb_mismatch:
    /* Stub: return (uintptr_t 0); */
    r0 = 0;
84206bec:	02 00       	r0 = Null + Null;
    rts;
84206bee:	d8 4c       	rts;
