
/home/svc-audio-dspsw/kymera_builds/builds/2020/kymera_2005191628/kalimba/kymera/tools/KCSMaker/out/7120/streplus_rom_release/download/debugbin/download_celt_decode.elf:     file format elf32-littlekalimba

Disassembly of section .text_maxim:

84200000 <$celt.decoder_init>:
#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.DECODER_INIT.PATCH_ID_0,r1)     // celt_patchers
#endif   

   // -- get data object
   push r5;
84200000:	00 00 70 f3 	push r5;
   r9 = r5;
84200004:	0f 00 b7 00 	r9 = r5 + Null;
   r5 = M[r5 + $codec.DECODER_DATA_OBJECT_FIELD];
84200008:	18 00 77 d1 	r5 = M[r5 + 24];

   // -- disable re-init flag
   M[r5 + $celt.dec.REINIT_DECODER_FIELD] = 0;
8420000c:	24 00 07 d5 	M[r5 + 36] = Null;
      
   // reset byte pos
   r0 = $celt.BYTE_POS_MAX_VALUE;
84200010:	03 00 20 01 	r0 = Null + 3;
   M[r5 + $celt.dec.GET_BYTE_POS_FIELD] = r0;
84200014:	a4 00 27 d5 	M[r5 + 164] = r0;
   
   // -- read mode variables
   r10 = $celt.mode.STRUC_SIZE ;
84200018:	14 00 c0 01 	r10 = Null + 20;
   r8 = M[r5 + $celt.dec.CELT_MODE_OBJECT_FIELD];
8420001c:	00 00 a7 d1 	r8 = M[r5 + 0];
   I3 = r8;
84200020:	af 00 30 50 	I3 = Null + r8;
   I6 = r5 + $celt.dec.MODE_FIELDS_OFFSET_FIELD;
84200024:	3c 00 67 51 	I6 = r5 + 60;
   do read_single_vars_loop;
84200028:	03 00 f0 e5 	do $M.celt.decoder_init.read_single_vars_loop;
      r0 = M[I3, MK1];
8420002c:	00 2d 00 03 	Null = Null + Null, r0 = M[I3,4];
      M[I6, MK1] = r0;
84200030:	a9 00 00 03 	Null = Null + Null, M[I6,4] = r0;

84200034 <$M.celt.decoder_init.read_single_vars_loop>:
   read_single_vars_loop:
      
   r1 = M[r5 + $celt.dec.CELT_CHANNELS_FIELD];
84200034:	08 00 37 d1 	r1 = M[r5 + 8];
   r0 = M[r9 + $codec.DECODER_OUT_RIGHT_BUFFER_FIELD];
84200038:	08 00 2b d1 	r0 = M[r9 + 8];
   r1 = r1 XOR 1;
8420003c:	01 00 33 89 	r1 = r1 XOR 0x1;
   r0 = r0 * r1 (int);
84200040:	00 00 23 9b 	r0 = r0 * r1 (int);
   M[r5 + $celt.dec.SCRATCHVAR_MONO_TO_STEREO] = r0;
84200044:	78 01 27 d5 	M[r5 + 376] = r0;
 
   r0 = &$celt.ec_dec_tell;
84200048:	20 04 00 fd 	r0 = Null + 69210920;
8420004c:	28 13 20 01 
   M[r5 + $celt.dec.TELL_FUNC_FIELD] = r0;
84200050:	30 00 27 d5 	M[r5 + 48] = r0;
   r0 = &$celt.alg_unquant;
84200054:	20 04 00 fd 	r0 = Null + 69214040;
84200058:	58 1f 20 01 
   M[r5 + $celt.dec.ALG_QUANT_FUNC_FIELD] = r0;
8420005c:	34 00 27 d5 	M[r5 + 52] = r0;
   r0 = &$celt.ec_dec_uint;
84200060:	20 04 00 fd 	r0 = Null + 69210612;
84200064:	f4 11 20 01 
   M[r5 + $celt.dec.EC_UINT_FUNC_FIELD] = r0;
84200068:	38 00 27 d5 	M[r5 + 56] = r0;
   
   pop r5;
8420006c:	00 00 74 f3 	pop r5;
   rts;
84200070:	0f 00 0d dc 	rts;

84200074 <$_celt_decode_lib_init>:

#if defined(PATCH_LIBS)
   LIBS_PUSH_R0_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.DECODE_LIB_INIT.PATCH_ID_0,r1)     // celt_patchers
#endif   
   // Save the registers C expects us to preserve that get trashed
   PUSH_ALL_C
84200074:	c0 af 00 f1 	pushm <r4, r5, r6, r7, r8, r9, rLink, rMACB>;
84200078:	77 00 01 f1 	pushm <I0, I1, I2, I4, I5, I6>;
8420007c:	00 f7 01 f1 	pushm <M0, M1, M2, L0, L1, L4, L5>;
   r9 = r0;
84200080:	0f 00 b2 00 	r9 = r0 + Null;
   r5 = r0;
84200084:	0f 00 72 00 	r5 = r0 + Null;
   push r0;
84200088:	00 00 20 f3 	push r0;

   r5 = M[r5 + $codec.DECODER_DATA_OBJECT_FIELD];
8420008c:	18 00 77 d1 	r5 = M[r5 + 24];
   r6 = 0 ;                                  // decoder 
84200090:	00 00 80 01 	r6 = Null + 0;
   r0 = M[r5 + $celt.dec.MODE_FIELD];        // mode 
84200094:	3c 02 27 d1 	r0 = M[r5 + 572];
   call $celt.codec.init_tables;
84200098:	db 02 f0 e1 	call $celt.codec.init_tables;
   
   pop r0;
8420009c:	00 00 24 f3 	pop r0;
   r9 = r0;
842000a0:	0f 00 b2 00 	r9 = r0 + Null;
   r5 = r0;
842000a4:	0f 00 72 00 	r5 = r0 + Null;
   call $celt.decoder_init;
842000a8:	d6 ff f0 e1 	call $celt.decoder_init;
   
   r5 = M[r5 + $codec.DECODER_DATA_OBJECT_FIELD];
842000ac:	18 00 77 d1 	r5 = M[r5 + 24];
   
   r8 = M[r5 + $celt.dec.PTR_celt_dec_state_pool];
842000b0:	38 02 a7 d1 	r8 = M[r5 + 568];
   r7 = 306;                                 //length($celt_enc_state_pool);
842000b4:	32 01 90 01 	r7 = Null + 306;
   call $celt.alloc_state_mem;
842000b8:	0c 00 f0 e1 	call $celt.alloc_state_mem;
#ifdef KYMERA 
   NULL = M[r5 + $celt.dec.FFT_TABLE_INIT_DONE_FIELD];
842000bc:	40 02 07 d1 	Null = M[r5 + 576];
   if NZ jump dont_init_fft_tables;
842000c0:	06 00 10 dd 	if NE jump $M.celt.decoder_init.dont_init_fft_tables;
   r0 = $celt.dec.FFT_TWIDDLE_SIZE;
842000c4:	00 02 20 01 	r0 = Null + 512;
   call $math.fft_twiddle.alloc;
842000c8:	07 00 00 fd 	call 0x74f20;
842000cc:	20 4f f0 e1 
   r0 = 1;
842000d0:	2f 00 20 e4 	r0 = Null + 1;
   M[r5 + $celt.dec.FFT_TABLE_INIT_DONE_FIELD] = r0;
842000d4:	40 02 27 d5 	M[r5 + 576] = r0;

842000d8 <$M.celt.decoder_init.dont_init_fft_tables>:
dont_init_fft_tables:
#endif 

   // restore preserved registers
   POP_ALL_C
842000d8:	00 f7 05 f1 	popm <M0, M1, M2, L0, L1, L4, L5>;
842000dc:	77 00 05 f1 	popm <I0, I1, I2, I4, I5, I6>;
842000e0:	c0 af 04 f1 	popm <r4, r5, r6, r7, r8, r9, rLink, rMACB>;
   rts;
842000e4:	0f 00 0d dc 	rts;

842000e8 <$celt.alloc_state_mem>:
#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.ALLOC_STATE_MEM.PATCH_ID_0,r1)     // celt_patchers
#endif   

   // -- get data object
   r0 = $celt.MAX_BANDS;
842000e8:	19 00 20 01 	r0 = Null + 25;
   r1 = M[r5 + $celt.dec.MODE_OVERLAP_FIELD];   
842000ec:	40 00 37 d1 	r1 = M[r5 + 64];
   r2 = M[r5 + $celt.dec.CELT_CHANNELS_FIELD];
842000f0:	08 00 47 d1 	r2 = M[r5 + 8];
   r2 = r2 + 1;
842000f4:	2f 00 44 e4 	r2 = r2 + 1;
   r3 = r0 + r1;
842000f8:	3f 00 52 00 	r3 = r0 + r1;
   r3 = r3 * r2 (int);
842000fc:	00 00 54 9b 	r3 = r3 * r2 (int);
   Null = r7 - r3;
84200100:	5f 00 09 20 	Null = r7 - r3;
   if NEG call $error;
84200104:	03 00 00 fd 	if NEG call (m) 0x3ac3e;
84200108:	3f ac 40 e1 
   M[r5 + $celt.dec.OLD_EBAND_LEFT_FIELD] = r8;
8420010c:	8c 00 a7 d5 	M[r5 + 140] = r8;
   Words2Addr(r0);
84200110:	02 00 22 91 	r0 = r0 ASHIFT 2;
   r8 = r8 + r0;
84200114:	00 00 a2 03 	r8 = r8 + r0;
   if NZ r8 = r8 + r0;
84200118:	21 00 aa 00 	if NE r8 = r8 + r0;
   M[r5 + $celt.dec.HIST_OLA_LEFT_FIELD] = r8;
8420011c:	94 00 a7 d5 	M[r5 + 148] = r8;
   Words2Addr(r1);
84200120:	02 00 33 91 	r1 = r1 ASHIFT 2;
   r8 = r8 + r1;   
84200124:	00 00 a3 03 	r8 = r8 + r1;
   M[r5 + $celt.dec.HIST_OLA_RIGHT_FIELD] = r8;   
84200128:	98 00 a7 d5 	M[r5 + 152] = r8;

   rts;
8420012c:	0f 00 0d dc 	rts;

84200130 <$celt.alloc_scratch_mem>:
  
#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.ALLOC_SCRATCH_MEM.PATCH_ID_0,r6)     // celt_patchers
#endif
  
   I0 = r5 + $celt.dec.DM1_SCRATCH_FIELDS_OFFSET ;
84200130:	bc 00 07 51 	I0 = r5 + 188;
   r10 = $celt.dec.DM1_SCRATCH_FIELDS_LENGTH;
84200134:	0e 00 c0 01 	r10 = Null + 14;
   I4 = r1;
84200138:	3f 00 40 50 	I4 = Null + r1;
   do copy_dm1_loop;
8420013c:	05 00 f0 e5 	do $M.celt.alloc_scratch_mem.copy_dm1_loop;
      r0 = M[I4, MK1];
84200140:	21 00 00 03 	Null = Null + Null, r0 = M[I4,4];
      Words2Addr(r0);
84200144:	02 00 22 91 	r0 = r0 ASHIFT 2;
      r0 = r0 + r2;
84200148:	00 00 24 03 	r0 = r0 + r2;
      M[I0, MK1] = r0;
8420014c:	00 a1 00 03 	Null = Null + Null, M[I0,4] = r0;

84200150 <$M.celt.alloc_scratch_mem.copy_dm1_loop>:
   copy_dm1_loop:
   
   I0 = r5 + $celt.dec.DM2_SCRATCH_FIELDS_OFFSET ;
84200150:	04 01 07 51 	I0 = r5 + 260;
   r10 = $celt.dec.DM2_SCRATCH_FIELDS_LENGTH;
84200154:	0d 00 c0 01 	r10 = Null + 13;
   I4 = r3;
84200158:	5f 00 40 50 	I4 = Null + r3;
   do copy_dm2_loop;
8420015c:	05 00 f0 e5 	do $M.celt.alloc_scratch_mem.copy_dm2_loop;
      r0 = M[I4, MK1];
84200160:	21 00 00 03 	Null = Null + Null, r0 = M[I4,4];
      Words2Addr(r0);
84200164:	02 00 22 91 	r0 = r0 ASHIFT 2;
      r0 = r0 + r4;
84200168:	00 00 26 03 	r0 = r0 + r4;
      M[I0, MK1] = r0;
8420016c:	00 a1 00 03 	Null = Null + Null, M[I0,4] = r0;

84200170 <$M.celt.alloc_scratch_mem.copy_dm2_loop>:
   copy_dm2_loop:
   rts;
84200170:	0f 00 0d dc 	rts;

84200174 <$celt.decoder_frame_init>:
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.DECODER_FRAME_INIT.PATCH_ID_0,r1)     // celt_patchers
#endif
   
   // push rLink onto stack
   //$push_rLink_macro;
   push rlink;
84200174:	00 00 d0 f3 	push rLink;

   // set byte-pos values
   r0 = M[r5 + $celt.dec.GET_BYTE_POS_FIELD];
84200178:	a4 00 27 d1 	r0 = M[r5 + 164];
   M[r5 + $celt.dec.SCRATCHVAR_GET_BYTEPOS] = r0;
8420017c:	f8 01 27 d5 	M[r5 + 504] = r0;
   r0 = M[r9 + $codec.DECODER_IN_BUFFER_FIELD];
84200180:	00 00 2b d1 	r0 = M[r9 + 0];
#ifdef BASE_REGISTER_MODE
   call $cbuffer.get_read_address_and_size_and_start_address;
84200184:	03 00 00 fd 	call (m) 0x3a27a;
84200188:	7b a2 f0 e1 
   push r2;
8420018c:	00 00 40 f3 	push r2;
   pop  B0;
84200190:	00 00 a6 f3 	pop B0;
#else
   call $cbuffer.get_read_address_and_size;
#endif
   I0 = r0;
84200194:	2f 00 00 50 	I0 = Null + r0;
   L0 = r1;
84200198:	3f 00 c0 50 	L0 = Null + r1;
   
   // get the frame length in bytes
   r8 = M[r9 + $celt.dec.CELT_MODE_OBJECT_FIELD];
8420019c:	00 00 ab d1 	r8 = M[r9 + 0];
   r0 = M[r5 + $celt.dec.CELT_CODEC_FRAME_SIZE_FIELD];
842001a0:	04 00 27 d1 	r0 = M[r5 + 4];
   M[r5 + $celt.dec.SCRATCHVAR_FRAME_BYTES_REMAINED] = r0;
842001a4:	fc 01 27 d5 	M[r5 + 508] = r0;
   M[r5 + $celt.dec.SCRATCHVAR_FRAME_BYTES_REMAINED_REVERSE] = r0;
842001a8:	04 02 27 d5 	M[r5 + 516] = r0;
   r1 = M[r5 + $celt.dec.SCRATCHVAR_GET_BYTEPOS];
842001ac:	f8 01 37 d1 	r1 = M[r5 + 504];
   r1 = r0 + r1;
842001b0:	3f 00 32 00 	r1 = r0 + r1;
   r1 = r1 AND $celt.BYTE_POS_MAX_VALUE;
842001b4:	03 00 33 81 	r1 = r1 AND 0x3;
   M[r5 + $celt.dec.SCRATCHVAR_GET_BYTEPOS_REVERSE] = r1;
842001b8:	00 02 37 d5 	M[r5 + 512] = r1;
   
   //I1/L1 -> must point to end of buffer
   I1 = I0;
842001bc:	0f 00 10 58 	I1 = I0 + Null;
   L1 = L0;
842001c0:	0f 00 dc 58 	L1 = L0 + Null;
#ifdef BASE_REGISTER_MODE
   push B0;
842001c4:	00 00 a2 f3 	push B0;
   pop B1;
842001c8:	00 00 b6 f3 	pop B1;
#endif
   r10 = M[r5 + $celt.dec.SCRATCHVAR_GET_BYTEPOS_REVERSE];
842001cc:	00 02 c7 d1 	r10 = M[r5 + 512];
   r0 = r0 + r10;
842001d0:	00 00 2c 03 	r0 = r0 + r10;
   r10 = M[r5 + $celt.dec.SCRATCHVAR_GET_BYTEPOS];
842001d4:	f8 01 c7 d1 	r10 = M[r5 + 504];
   r0 = r0 - r10;
842001d8:	00 00 2c 23 	r0 = r0 - r10;
   r0 = r0 LSHIFT $celt.FRM_DATA_MID_DIV_CONST;
842001dc:	fe 00 22 8d 	r0 = r0 LSHIFT -2;
   Words2Addr(r0);
842001e0:	02 00 22 91 	r0 = r0 ASHIFT 2;
   M0 = r0;
842001e4:	2f 00 80 50 	M0 = Null + r0;
   r0 = M[I1, M0];
842001e8:	00 24 00 02 	Null = Null + Null, r0 = M[I1,M0];
   
   // initialise entropy decoder
   call $celt.ec_dec_init;
842001ec:	3d 03 f0 e1 	call $celt.ec_dec_init;

   // pop rLink from stack
   jump $pop_rLink_and_rts;
842001f0:	03 00 00 fd 	jump (m) 0x3b020;
842001f4:	21 b0 f0 dd 

842001f8 <$celt.end_reading_frame>:

#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.END_READING_FRAME.PATCH_ID_0,r1)     // celt_patchers
#endif

   push rlink;
842001f8:	00 00 d0 f3 	push rLink;
   
   r0 = M[r5 + $celt.dec.GET_BYTE_POS_FIELD];
842001fc:	a4 00 27 d1 	r0 = M[r5 + 164];
   r4 = M[r5 + $celt.dec.CELT_CODEC_FRAME_SIZE_FIELD];
84200200:	04 00 67 d1 	r4 = M[r5 + 4];
   //Get byte position for next frame
   r1 = r4 AND $celt.BYTE_POS_MAX_VALUE;
84200204:	03 00 36 81 	r1 = r4 AND 0x3;
   r2 = r0 XOR r1;
84200208:	3f 00 42 88 	r2 = r0 XOR r1;
   M[r5 + $celt.dec.GET_BYTE_POS_FIELD] = r2;
8420020c:	a4 00 47 d5 	M[r5 + 164] = r2;
   r4 = r4 + r2;
84200210:	00 00 64 03 	r4 = r4 + r2;
   r4 = r4 LSHIFT $celt.FRM_DATA_MID_DIV_CONST;
84200214:	fe 00 66 8d 	r4 = r4 LSHIFT -2;
   Words2Addr(r4);
84200218:	02 00 66 91 	r4 = r4 ASHIFT 2;
   M0 = r4;   
8420021c:	6f 00 80 50 	M0 = Null + r4;
   r0 = M[r9 + $codec.DECODER_IN_BUFFER_FIELD];
84200220:	00 00 2b d1 	r0 = M[r9 + 0];
#ifdef BASE_REGISTER_MODE
   call $cbuffer.get_read_address_and_size_and_start_address;
84200224:	03 00 00 fd 	call (m) 0x3a27a;
84200228:	7b a2 f0 e1 
   push r2;
8420022c:	00 00 40 f3 	push r2;
   pop  B0;
84200230:	00 00 a6 f3 	pop B0;
#else
   call $cbuffer.get_read_address_and_size;
#endif
   I0 = r0;
84200234:	2f 00 00 50 	I0 = Null + r0;
   L0 = r1;
84200238:	3f 00 c0 50 	L0 = Null + r1;
   r0 = M[I0, M0];
8420023c:	00 20 00 02 	Null = Null + Null, r0 = M[I0,M0];
   L0 = 0;
84200240:	00 00 c0 51 	L0 = Null + 0;
   r0 = M[r9 + $codec.DECODER_IN_BUFFER_FIELD];
84200244:	00 00 2b d1 	r0 = M[r9 + 0];
   r1 = I0;
84200248:	0f 00 30 44 	r1 = Null + I0;
   call $cbuffer.set_read_address;
8420024c:	03 00 00 fd 	call (m) 0x3a2e6;
84200250:	e7 a2 f0 e1 
   L0 = 0;
84200254:	00 00 c0 51 	L0 = Null + 0;
   L1 = 0;
84200258:	00 00 d0 51 	L1 = Null + 0;
#ifdef BASE_REGISTER_MODE
   push Null;
8420025c:	00 00 00 f3 	push Null;
   pop  B0;
84200260:	00 00 a6 f3 	pop B0;
   push Null;
84200264:	00 00 00 f3 	push Null;
   pop  B1; 
84200268:	00 00 b6 f3 	pop B1;
#endif
   
   // pop rLink from stack
   jump $pop_rLink_and_rts;
8420026c:	03 00 00 fd 	jump (m) 0x3b020;
84200270:	21 b0 f0 dd 

84200274 <$_celt_free_decoder_twiddle>:
84200274:	80 28 00 f1 	pushm <r5, r9, rLink>;
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.FREE_DECODER_TWIDDLE.PATCH_ID_0,r1)     // celt_patchers
#endif
   
   // Save the registers C expects us to preserve that get trashed
   pushm <r5, r9, rLink>;
   push I0;
84200278:	00 00 01 f3 	push I0;
   r0 = $celt.FFT_TWIDDLE_SIZE;
8420027c:	00 02 20 01 	r0 = Null + 512;
   call $math.fft_twiddle.release;
84200280:	07 00 00 fd 	call 0x74ff8;
84200284:	f8 4f f0 e1 

   // restore preserved registers
   pop I0;
84200288:	00 00 05 f3 	pop I0;
   popm <r5, r9, rLink>;
8420028c:	80 28 04 f1 	popm <r5, r9, rLink>;

   rts;
84200290:	0f 00 0d dc 	rts;

84200294 <$celt.frame_decode>:
84200294:	00 00 d0 f3 	push rLink;

   // push rLink onto stack
      push rlink;

   //-- Is re-init required?
   Null = M[r5 + $celt.dec.REINIT_DECODER_FIELD];
84200298:	24 00 07 d1 	Null = M[r5 + 36];
   if NZ call $celt.decoder_init;
8420029c:	59 ff 10 e1 	if NE call $celt.decoder_init;
   
   push r5;
842002a0:	00 00 70 f3 	push r5;
   r9 = r5;
842002a4:	0f 00 b7 00 	r9 = r5 + Null;
   r5 = M[r5 + $codec.DECODER_DATA_OBJECT_FIELD];
842002a8:	18 00 77 d1 	r5 = M[r5 + 24];
 #ifdef KYMERA 
   r1 = M[r5 + $celt.dec.PTR_MODE_DM1SCRATCH_ALLOC];//&$celt.enc.celt_512_48000_mode.dm1scratch_alloc;
842002ac:	28 02 37 d1 	r1 = M[r5 + 552];
   r2 = M[r5 + $celt.dec.PTR_celt_dm1_scratch];//&$celt_dm1_scratch;
842002b0:	30 02 47 d1 	r2 = M[r5 + 560];
   r3 = M[r5 + $celt.dec.PTR_MODE_DM2SCRATCH_ALLOC];//&$celt.enc.celt_512_48000_mode.dm2scratch_alloc; 
842002b4:	2c 02 57 d1 	r3 = M[r5 + 556];
   r4 = M[r5 + $celt.dec.PTR_celt_dm2_scratch];//&$celt_dm2_scratch;
842002b8:	34 02 67 d1 	r4 = M[r5 + 564];
   call $celt.alloc_scratch_mem;
842002bc:	9d ff f0 e1 	call $celt.alloc_scratch_mem;
 #endif

   // -- Save codec struct pointer --
   M[r5 + $celt.dec.SCRATCHVAR_CODEC_STRUC] = r5;
842002c0:	74 01 77 d5 	M[r5 + 372] = r5;

   // -- No output samples yet
   M[r9 + $codec.DECODER_NUM_OUTPUT_SAMPLES_FIELD] = 0;
842002c4:	10 00 0b d5 	M[r9 + 16] = Null;
   
   // -- See if there is enough output space
   r4 = M[r5 + $celt.dec.MODE_AUDIO_FRAME_SIZE_FIELD];
842002c8:	44 00 67 d1 	r4 = M[r5 + 68];
   r0 = M[r9 + $codec.DECODER_OUT_LEFT_BUFFER_FIELD];
842002cc:	04 00 2b d1 	r0 = M[r9 + 4];
#ifdef KYMERA
        call $cbuffer.calc_amount_space_in_words;
842002d0:	03 00 00 fd 	call (m) 0x39d88;
842002d4:	89 9d f0 e1 
#else
        call $cbuffer.calc_amount_space;
#endif
   Null = r0 - r4;
842002d8:	6f 00 02 20 	Null = r0 - r4;
   if NEG jump exit_not_enough_output_space;
842002dc:	75 00 40 dd 	if NEG jump $M.celt.frame_decode.exit_not_enough_output_space;
   r0 = M[r9 + $codec.DECODER_OUT_RIGHT_BUFFER_FIELD];
842002e0:	08 00 2b d1 	r0 = M[r9 + 8];
   if Z jump end_space_check;
842002e4:	05 00 00 dd 	if EQ jump $M.celt.frame_decode.end_space_check;
#ifdef KYMERA
        call $cbuffer.calc_amount_space_in_words;
842002e8:	03 00 00 fd 	call (m) 0x39d88;
842002ec:	89 9d f0 e1 
#else
        call $cbuffer.calc_amount_space;
#endif
      Null = r0 - r4;
842002f0:	6f 00 02 20 	Null = r0 - r4;
      if NEG jump exit_not_enough_output_space;
842002f4:	6f 00 40 dd 	if NEG jump $M.celt.frame_decode.exit_not_enough_output_space;

842002f8 <$M.celt.frame_decode.end_space_check>:
   end_space_check:
   
   // save output buffer addresses
   r0 = M[r9 + $codec.DECODER_OUT_LEFT_BUFFER_FIELD];
842002f8:	04 00 2b d1 	r0 = M[r9 + 4];
#ifdef BASE_REGISTER_MODE
   call $cbuffer.get_write_address_and_size_and_start_address;
842002fc:	03 00 00 fd 	call (m) 0x3a2b0;
84200300:	b1 a2 f0 e1 
   M[r5 + $celt.dec.SCRATCHVAR_LEFT_OBUF_START_ADDR] = r2;
84200304:	84 01 47 d5 	M[r5 + 388] = r2;
#else   
   call $cbuffer.get_write_address_and_size;
#endif
   M[r5 + $celt.dec.SCRATCHVAR_LEFT_OBUF_ADDR] = r0;
84200308:	7c 01 27 d5 	M[r5 + 380] = r0;
   M[r5 + $celt.dec.SCRATCHVAR_LEFT_OBUF_LEN] = r1;
8420030c:	80 01 37 d5 	M[r5 + 384] = r1;
   r0 = M[r9 + $codec.DECODER_OUT_RIGHT_BUFFER_FIELD];
84200310:	08 00 2b d1 	r0 = M[r9 + 8];
   if Z jump end_ch_addr_save;
84200314:	06 00 00 dd 	if EQ jump $M.celt.frame_decode.end_ch_addr_save;
#ifdef BASE_REGISTER_MODE
   call $cbuffer.get_write_address_and_size_and_start_address;
84200318:	03 00 00 fd 	call (m) 0x3a2b0;
8420031c:	b1 a2 f0 e1 
   M[r5 + $celt.dec.SCRATCHVAR_RIGHT_OBUF_START_ADDR] = r2;
84200320:	90 01 47 d5 	M[r5 + 400] = r2;
#else  
   call $cbuffer.get_write_address_and_size;
#endif
      M[r5 + $celt.dec.SCRATCHVAR_RIGHT_OBUF_ADDR] = r0;
84200324:	88 01 27 d5 	M[r5 + 392] = r0;
      M[r5 + $celt.dec.SCRATCHVAR_RIGHT_OBUF_LEN] = r1;
84200328:	8c 01 37 d5 	M[r5 + 396] = r1;

8420032c <$M.celt.frame_decode.end_ch_addr_save>:
      no_plc_run:
      M[r5 + $celt.dec.PLC_COUNTER_FIELD] = Null;
   #endif
*/   
   //-- See if there is at least one frame 
   r0 = M[r9 + $codec.DECODER_IN_BUFFER_FIELD];
8420032c:	00 00 2b d1 	r0 = M[r9 + 0];
#ifdef KYMERA
   call $cbuffer.calc_amount_data_in_words;
84200330:	03 00 00 fd 	call (m) 0x39dd4;
84200334:	d5 9d f0 e1 
#else
   call $cbuffer.calc_amount_data;
#endif
   r0 = r0 + r0;
84200338:	00 00 22 03 	r0 = r0 + r0;
   r1 = M[r5 + $celt.dec.GET_BYTE_POS_FIELD];
8420033c:	a4 00 37 d1 	r1 = M[r5 + 164];
   r2 = r0 + r1;
84200340:	3f 00 42 00 	r2 = r0 + r1;
   r2 = r2 - 1;
84200344:	3f 00 44 e4 	r2 = r2 - 1;
   r1 = M[r5 + $celt.dec.CELT_CODEC_FRAME_SIZE_FIELD];
84200348:	04 00 37 d1 	r1 = M[r5 + 4];
   r0 = $codec.NOT_ENOUGH_INPUT_DATA;
8420034c:	2f 00 20 e4 	r0 = Null + 1;
   Null = r2 - r1;
84200350:	3f 00 04 20 	Null = r2 - r1;
   if NEG jump exit;
84200354:	58 00 40 dd 	if NEG jump $M.celt.frame_decode.exit;
 
   // -- Initialise frame decoder
   call $celt.decoder_frame_init;
84200358:	87 ff f0 e1 	call $celt.decoder_frame_init;
   
   // -- Extract flags
   call $celt.decode_flags;
8420035c:	3e 0e f0 e1 	call $celt.decode_flags;
   M[r5 + $celt.dec.SCRATCHVAR_FRAME_CORRUPT] = r0;
84200360:	94 01 27 d5 	M[r5 + 404] = r0;
   if NZ jump frame_corrupt;
84200364:	50 00 10 dd 	if NE jump $M.celt.frame_decode.frame_corrupt;
   
   // -- Unquantise Coarse Energies
   call $celt.unquant_coarse_energy;
84200368:	dc 08 f0 e1 	call $celt.unquant_coarse_energy;
   
   // -- Compute bit allocations
   call $celt.compute_allocation;
8420036c:	80 0d f0 e1 	call $celt.compute_allocation;
   
   // -- Decode fine energy bits
   call $celt.unquant_fine_energy;
84200370:	2f 09 f0 e1 	call $celt.unquant_fine_energy;
   
   // -- Dequantise residual bits 
   r0 = M[r5 + $celt.dec.CELT_CHANNELS_FIELD];
84200374:	08 00 27 d1 	r0 = M[r5 + 8];
   if Z call $celt.unquant_bands;
84200378:	55 09 00 e1 	if EQ call $celt.quant_bands;
   r0 = M[r5 + $celt.dec.CELT_CHANNELS_FIELD];
8420037c:	08 00 27 d1 	r0 = M[r5 + 8];
   if NZ call $celt.unquant_bands_stereo;
84200380:	cc 09 10 e1 	if NE call $celt.unquant_bands_stereo;
   
   // -- Decode remaining bits
   call $celt.unquant_energy_finalise;
84200384:	e6 0b f0 e1 	call $celt.unquant_energy_finalise;
   
   // -- MDCT shape for some short encoded frames
   r8 = $celt.CELT_DECODER;
84200388:	00 00 a0 01 	r8 = Null + 0;
   Null = M[r5 + $celt.dec.MDCT_WEIGHT_SHIFT_FIELD];
8420038c:	6c 01 07 d1 	Null = M[r5 + 364];
   if NZ call  $celt.mdct_shape;
84200390:	a6 08 10 e1 	if NE call $celt.mdct_shape;
 
   // -- Denormalising bands
   call $celt.denormalise_bands;
84200394:	3e 0c f0 e1 	call $celt.denormalise_bands;
 
   // -- Input frame processed, terminate reading
   call $celt.end_reading_frame;
84200398:	98 ff f0 e1 	call $celt.end_reading_frame;
   
   //-- TODO: Do optional stereo to mono processing here
   push r9;   
8420039c:	00 00 b0 f3 	push r9;
   // -- Apply windowing and overlap add
   call $celt.imdct_window_overlap_add;
842003a0:	2e 01 f0 e1 	call $celt.imdct_window_overlap_add;
   pop r9;
842003a4:	00 00 b4 f3 	pop r9;

842003a8 <$M.celt.frame_decode.post_proc>:
      if NZ call $celt.fill_plc_buffers; 
   #endif
*/   
   
   // -- Apply final de-emphasis filter  
   call $celt.deemphasis;
842003a8:	78 0e f0 e1 	call $celt.deemphasis;
   
   //-- Mono to stereo convert
   Null = M[r5 + $celt.dec.SCRATCHVAR_MONO_TO_STEREO];
842003ac:	78 01 07 d1 	Null = M[r5 + 376];
   if Z jump end_mono_to_stereo_convert;
842003b0:	19 00 00 dd 	if EQ jump $M.celt.frame_decode.end_mono_to_stereo_convert;
   r10 = M[r5 + $celt.dec.MODE_AUDIO_FRAME_SIZE_FIELD];
842003b4:	44 00 c7 d1 	r10 = M[r5 + 68];
   r0 = M[r5 + $celt.dec.SCRATCHVAR_LEFT_OBUF_ADDR];
842003b8:	7c 01 27 d1 	r0 = M[r5 + 380];
   r1 = M[r5 + $celt.dec.SCRATCHVAR_LEFT_OBUF_LEN];
842003bc:	80 01 37 d1 	r1 = M[r5 + 384];
   I5 = r0;
842003c0:	2f 00 50 50 	I5 = Null + r0;
   L5 = r1;
842003c4:	3f 00 f0 50 	L5 = Null + r1;
   r0 = M[r5 + $celt.dec.SCRATCHVAR_RIGHT_OBUF_ADDR];
842003c8:	88 01 27 d1 	r0 = M[r5 + 392];
   r1 = M[r5 + $celt.dec.SCRATCHVAR_RIGHT_OBUF_LEN];
842003cc:	8c 01 37 d1 	r1 = M[r5 + 396];
   I4 = r0;
842003d0:	2f 00 40 50 	I4 = Null + r0;
   L4 = r1;
842003d4:	3f 00 e0 50 	L4 = Null + r1;
#ifdef BASE_REGISTER_MODE
   r0 = M[r5 + $celt.dec.SCRATCHVAR_LEFT_OBUF_START_ADDR];
842003d8:	84 01 27 d1 	r0 = M[r5 + 388];
   push r0;
842003dc:	00 00 20 f3 	push r0;
   pop B5;
842003e0:	00 00 d6 f3 	pop B5;
   r0 = M[r5 + $celt.dec.SCRATCHVAR_RIGHT_OBUF_START_ADDR];
842003e4:	90 01 27 d1 	r0 = M[r5 + 400];
   push r0;
842003e8:	00 00 20 f3 	push r0;
   pop B4;
842003ec:	00 00 c6 f3 	pop B4;
#endif 
   do copy_left_to_right_loop;
842003f0:	03 00 f0 e5 	do $M.celt.frame_decode.copy_left_to_right_loop;
      r0 = M[I5, MK1];
842003f4:	25 00 00 03 	Null = Null + Null, r0 = M[I5,4];
      M[I4, MK1] = r0;
842003f8:	a1 00 00 03 	Null = Null + Null, M[I4,4] = r0;

842003fc <$M.celt.frame_decode.copy_left_to_right_loop>:
   copy_left_to_right_loop:
   L4 = 0;
842003fc:	00 00 e0 51 	L4 = Null + 0;
   L5 = 0;   
84200400:	00 00 f0 51 	L5 = Null + 0;
#ifdef BASE_REGISTER_MODE
   push Null;
84200404:	00 00 00 f3 	push Null;
   pop B4;
84200408:	00 00 c6 f3 	pop B4;
   push Null; 
8420040c:	00 00 00 f3 	push Null;
   pop B5; 
84200410:	00 00 d6 f3 	pop B5;

84200414 <$M.celt.frame_decode.end_mono_to_stereo_convert>:
   end_mono_to_stereo_convert:
   
   // -- Stereo to mono convert
   // Celt library doesnt do this at the moment   
   //-- Set write address for left channel
   r0 = M[r9 + $codec.DECODER_OUT_LEFT_BUFFER_FIELD];
84200414:	04 00 2b d1 	r0 = M[r9 + 4];
#ifdef BASE_REGISTER_MODE
   call $cbuffer.get_write_address_and_size_and_start_address;
84200418:	03 00 00 fd 	call (m) 0x3a2b0;
8420041c:	b1 a2 f0 e1 
   push r2;
84200420:	00 00 40 f3 	push r2;
   pop  B5;
84200424:	00 00 d6 f3 	pop B5;
#else  
   call $cbuffer.get_write_address_and_size;
#endif
   I5 = r0;
84200428:	2f 00 50 50 	I5 = Null + r0;
   L5 = r1;
8420042c:	3f 00 f0 50 	L5 = Null + r1;
   r0 = M[r5 + $celt.dec.MODE_AUDIO_FRAME_SIZE_FIELD];
84200430:	44 00 27 d1 	r0 = M[r5 + 68];
   Words2Addr(r0);
84200434:	02 00 22 91 	r0 = r0 ASHIFT 2;
   M0 = r0;
84200438:	2f 00 80 50 	M0 = Null + r0;
   r0 = M[I5, M0];
8420043c:	24 00 00 02 	Null = Null + Null, r0 = M[I5,M0];
   r0 = M[r9 + $codec.DECODER_OUT_LEFT_BUFFER_FIELD];
84200440:	04 00 2b d1 	r0 = M[r9 + 4];
   r1 = I5;
84200444:	5f 00 30 44 	r1 = Null + I5;
   call $cbuffer.set_write_address;
84200448:	03 00 00 fd 	call (m) 0x3a320;
8420044c:	21 a3 f0 e1 
   
   //-- Set write address for right channel
   r0 = M[r9 + $codec.DECODER_OUT_RIGHT_BUFFER_FIELD];
84200450:	08 00 2b d1 	r0 = M[r9 + 8];
   if Z jump end_buffer_set_write_address;
84200454:	0c 00 00 dd 	if EQ jump $M.celt.frame_decode.end_buffer_set_write_address;
#ifdef BASE_REGISTER_MODE
   call $cbuffer.get_write_address_and_size_and_start_address;
84200458:	03 00 00 fd 	call (m) 0x3a2b0;
8420045c:	b1 a2 f0 e1 
   push r2;
84200460:	00 00 40 f3 	push r2;
   pop  B5;
84200464:	00 00 d6 f3 	pop B5;
#else     
   call $cbuffer.get_write_address_and_size;
#endif
   I5 = r0;
84200468:	2f 00 50 50 	I5 = Null + r0;
   L5 = r1;
8420046c:	3f 00 f0 50 	L5 = Null + r1;
   r0 = M[I5, M0];
84200470:	24 00 00 02 	Null = Null + Null, r0 = M[I5,M0];
   r0 = M[r9 + $codec.DECODER_OUT_RIGHT_BUFFER_FIELD];
84200474:	08 00 2b d1 	r0 = M[r9 + 8];
   r1 = I5;
84200478:	5f 00 30 44 	r1 = Null + I5;
   call $cbuffer.set_write_address;
8420047c:	03 00 00 fd 	call (m) 0x3a320;
84200480:	21 a3 f0 e1 

84200484 <$M.celt.frame_decode.end_buffer_set_write_address>:
   end_buffer_set_write_address:
   L5 = 0;
84200484:	00 00 f0 51 	L5 = Null + 0;
#ifdef BASE_REGISTER_MODE
   push Null;
84200488:	00 00 00 f3 	push Null;
   pop  B5;
8420048c:	00 00 d6 f3 	pop B5;
#endif
   
   // -- Decoding Successful
   r0 = M0;
84200490:	8f 00 20 44 	r0 = Null + M0;
   Addr2Words(r0);
84200494:	fe 00 22 91 	r0 = r0 ASHIFT -2;
   M[r9 + $codec.DECODER_NUM_OUTPUT_SAMPLES_FIELD] = r0;
84200498:	10 00 2b d5 	M[r9 + 16] = r0;
   r0 = $codec.SUCCESS;
8420049c:	00 00 20 01 	r0 = Null + 0;
   jump exit;
842004a0:	05 00 f0 dd 	jump $M.celt.frame_decode.exit;

842004a4 <$M.celt.frame_decode.frame_corrupt>:
   
   // check if any errors occured
   frame_corrupt:
      call $celt.end_reading_frame;
842004a4:	55 ff f0 e1 	call $celt.end_reading_frame;
      r0 = $codec.FRAME_CORRUPT;
842004a8:	05 00 20 01 	r0 = Null + 5;
      jump exit;
842004ac:	02 00 f0 dd 	jump $M.celt.frame_decode.exit;

842004b0 <$M.celt.frame_decode.exit_not_enough_output_space>:
 
   exit_not_enough_output_space:
   // set NOT_ENOUGH_OUTPUT_SPACE flag and exit
   r0 = $codec.NOT_ENOUGH_OUTPUT_SPACE;
842004b0:	af 00 20 e4 	r0 = Null + 2;

842004b4 <$M.celt.frame_decode.exit>:
   
   exit:
   M[r9 + $codec.DECODER_MODE_FIELD] = r0;
842004b4:	0c 00 2b d5 	M[r9 + 12] = r0;

   pop r5;
842004b8:	00 00 74 f3 	pop r5;

   // pop rLink from stack
   jump $pop_rLink_and_rts;
842004bc:	03 00 00 fd 	jump (m) 0x3b020;
842004c0:	21 b0 f0 dd 

842004c4 <$_celt_imdct_radix2>:
842004c4:	01 20 00 f1 	pushm <FP(=SP), rLink>;
   // push rLink onto stack
   .CONST TEMP                 (0 + 2)*ADDR_PER_WORD;
   .CONST TMP_VAR              (7 + 2)*ADDR_PER_WORD;
   .CONST STACK_FRAME_SIZE     8*ADDR_PER_WORD;
   pushm <FP(=SP), rLink>;
   SP = SP + STACK_FRAME_SIZE;
842004c8:	20 00 03 f1 	SP = SP + 32;
   
   M[FP + TEMP + 0*MK1] = r5; 
842004cc:	08 00 7c f1 	M[FP + 0x8] = r5;
   M[FP + TEMP + 1*MK1] = r8; 
842004d0:	0c 00 ac f1 	M[FP + 0xc] = r8;
   M[FP + TEMP + 2*MK1] = r6; 
842004d4:	10 00 8c f1 	M[FP + 0x10] = r6;
   r0 = I0;
842004d8:	0f 00 20 44 	r0 = Null + I0;
#ifdef BASE_REGISTER_MODE
   push r0;
842004dc:	00 00 20 f3 	push r0;
   pop B0;
842004e0:	00 00 a6 f3 	pop B0;
   push Null;
842004e4:	00 00 00 f3 	push Null;
   pop B5;
842004e8:	00 00 d6 f3 	pop B5;
   L4 = 0;
842004ec:	00 00 e0 51 	L4 = Null + 0;
   L5 = 0;
842004f0:	00 00 f0 51 	L5 = Null + 0;
#endif 
   M[FP + TEMP + 3*MK1] = r0;
842004f4:	14 00 2c f1 	M[FP + 0x14] = r0;
   r0 = I5;
842004f8:	5f 00 20 44 	r0 = Null + I5;
   M[FP + TEMP + 4*MK1] = r0;
842004fc:	18 00 2c f1 	M[FP + 0x18] = r0;
   M[FP + TEMP + 5*MK1] = r4;
84200500:	1c 00 6c f1 	M[FP + 0x1c] = r4;
   
   // get the trig from mode object
   I7 = r5 + $celt.dec.SCRATCHVAR_FFT_STRUCT;
84200504:	98 01 77 51 	I7 = r5 + 408;
   r2 = r8 LSHIFT -1;
84200508:	ff 00 4a 8d 	r2 = r8 LSHIFT -1;
   M[r5 + $celt.dec.SCRATCHVAR_FFT_STRUCT + $fft.NUM_POINTS_FIELD] = r2;
8420050c:	98 01 47 d5 	M[r5 + 408] = r2;
   r0 = I0;
84200510:	0f 00 20 44 	r0 = Null + I0;
   M[r5 + $celt.dec.SCRATCHVAR_FFT_STRUCT + $fft.REAL_ADDR_FIELD] = r0;
84200514:	9c 01 27 d5 	M[r5 + 412] = r0;
   r0 = I5;
84200518:	5f 00 20 44 	r0 = Null + I5;
   M[r5 + $celt.dec.SCRATCHVAR_FFT_STRUCT + $fft.IMAG_ADDR_FIELD] = r0;
8420051c:	a0 01 27 d5 	M[r5 + 416] = r0;


   // get scale factor from mode object
   r0 = M[r5 + $celt.dec.MODE_TRIG_OFFSET_FIELD];
84200520:	78 00 27 d1 	r0 = M[r5 + 120];
   r1 = &$celt.mode.TRIG_VECTOR_SIZE;
84200524:	0c 00 30 01 	r1 = Null + 12;
   NULL = M[r5 + $celt.dec.SHORT_BLOCKS_FIELD];
84200528:	58 01 07 d1 	Null = M[r5 + 344];
   if Z r1 = 0;
8420052c:	00 00 30 00 	if EQ r1 = Null + Null;
   Words2Addr(r1);
84200530:	02 00 33 91 	r1 = r1 ASHIFT 2;
   I2 = r0 + r1;
84200534:	3f 00 22 50 	I2 = r0 + r1;
   r0 = M[I2, MK1];
84200538:	00 29 00 03 	Null = Null + Null, r0 = M[I2,4];
   M[FP + TEMP + 6*MK1] = r0;
8420053c:	20 00 2c f1 	M[FP + 0x20] = r0;
   r0 = M[I2, MK1];
84200540:	00 29 00 03 	Null = Null + Null, r0 = M[I2,4];

   // set up the modify registers
   M0 = MK1;
84200544:	04 00 80 51 	M0 = Null + 4;
   M1 = MK2;
84200548:	08 00 90 51 	M1 = Null + 8;
   M2 = -MK2;
8420054c:	f8 ff a0 51 	M2 = Null + -8;

   // need to copy the odd values into the output buffer
   r10 = r8 LSHIFT -1;
84200550:	ff 00 ca 8d 	r10 = r8 LSHIFT -1;
   r10 = r10 - 1;
84200554:	3f 00 cc e4 	r10 = r10 - 1;

   // set a pointer to the start of the copy, and the target
   // and two buffers as output pointers for below
   I4 = I0;                         // input
84200558:	0f 00 40 58 	I4 = I0 + Null;
   Words2Addr(r8);
8420055c:	02 00 aa 91 	r8 = r8 ASHIFT 2;
#ifdef BASE_REGISTER_MODE
   push B0;
84200560:	00 00 a2 f3 	push B0;
   pop B4;
84200564:	00 00 c6 f3 	pop B4;
#endif 
   I0 = I0 + r8, r2 = M[I2,M0];                  // cfreq
84200568:	00 48 0a 5a 	I0 = I0 + r8, r2 = M[I2,M0];
   I0 = I0 - M0, r3 = M[I2,M0];                  // sfreq
8420056c:	00 58 08 7e 	I0 = I0 - M0, r3 = M[I2,M0];
   r0 = M[r5 + $celt.dec.IMDCT_OUTPUT_FIELD];
84200570:	d4 00 27 d1 	r0 = M[r5 + 212];
   I6 = r0;
84200574:	2f 00 60 50 	I6 = Null + r0;
   r4 = M[r5 + $celt.dec.TEMP_FFT_FIELD];
84200578:	dc 00 67 d1 	r4 = M[r5 + 220];
   I5 = r4, r0 = M[I0,M2];
8420057c:	6f 22 50 50 	I5 = Null + r4, r0 = M[I0,M2];
   do pre_copy_loop;
84200580:	02 00 f0 e5 	do $M.celt.imdct_radix2.pre_copy_loop;
      r0 = M[I0,M2],
       M[I5,M0] = r0;
84200584:	a4 22 00 02 	Null = Null + Null, r0 = M[I0,M2], M[I5,M0] = r0;

84200588 <$M.celt.imdct_radix2.pre_copy_loop>:
   pre_copy_loop:
   M[I5,M0] = r0;
84200588:	a4 00 00 02 	Null = Null + Null, M[I5,M0] = r0;

   // set up two registers to work through the input in opposite directions
   I0 = I4;                         // input
8420058c:	0f 00 04 58 	I0 = I4 + Null;
   I5 = r4, r4 = M[I2,M0];                  // c
84200590:	6f 68 50 50 	I5 = Null + r4, r4 = M[I2,M0];

   // to make the additions easier below set c= -c & s= -s
   r4 = -r4, r1 = M[I2,M0];   // r4 = -c
84200594:	6f 38 60 20 	r4 = Null - r4, r1 = M[I2,M0];
   r7 = -r1, r0 = M[I0, M1];  // r7 = -s
84200598:	3f 21 90 20 	r7 = Null - r1, r0 = M[I0,M1];
 
   // use M3 as a loop counter
   M3 = 3*MK1;
8420059c:	0c 00 b0 51 	M3 = Null + 12;
   M2 = 0;
842005a0:	00 00 a0 51 	M2 = Null + 0;

   // tmp used to store c
   r1 = FP + TMP_VAR;
842005a4:	24 00 37 f1 	r1 = FP + 36;
   I1 = r1;
842005a8:	3f 00 10 50 	I1 = Null + r1;
   Addr2Words(r8);
842005ac:	fe 00 aa 91 	r8 = r8 ASHIFT -2;

842005b0 <$M.celt.imdct_radix2.outer_pre_process_loop>:
   outer_pre_process_loop:
      r10 = r8 LSHIFT -3;              // r10 = N/8
842005b0:	fd 00 ca 8d 	r10 = r8 LSHIFT -3;
      //I2 = I2 + 2;
      do pre_process_loop;
842005b4:	0a 00 f0 e5 	do $M.celt.imdct_radix2.pre_process_loop;
      
         // process the data
         rMAC = r0 * r4, r1 = M[I5, M0];        // rMAC = (-tempr) * (-c)
842005b8:	34 00 26 ce 	rMAC = r0 * r4 (SS), r1 = M[I5,M0];
         rMAC = rMAC + r1 * r7;                 // rMAC = temp*c + tempi*(-s)
842005bc:	9f 00 13 ac 	rMAC = rMAC + r1 * r7 (SS);
         rMAC = r0 * r7, M[I4, M0] = rMAC;      // rMAC = (-tempr)*(-s)
842005c0:	90 00 29 ce 	rMAC = r0 * r7 (SS), M[I4,M0] = rMAC;
         rMAC = rMAC - r1 * r4;                 // rMAC = tempr*s - tempi*(-c)
842005c4:	6f 00 13 bc 	rMAC = rMAC - r1 * r4 (SS);
         
         // update the multipliers: "c" and "s"
         rMAC = r4 * r2, M[I6, M0] = rMAC;      // (-c) * cfreq
842005c8:	98 00 64 ce 	rMAC = r4 * r2 (SS), M[I6,M0] = rMAC;
         rMAC = rMAC - r7 * r3, r0 = M[I0, M1]; // (-c)'= (-c) * cfreq - (-s) * sfreq
842005cc:	5f 21 19 bc 	rMAC = rMAC - r7 * r3 (SS), r0 = M[I0,M1];
         rMAC = r4 * r3, M[I1,M2] = rMAC;       // (-c_old) * sfreq
842005d0:	5f 96 16 cc 	rMAC = r4 * r3 (SS), M[I1,M2] = rMAC;
         rMAC = rMAC + r7 * r2;                 // (-s)' = (-c_old)*sfreq + (-s)*cfreq
842005d4:	4f 00 19 ac 	rMAC = rMAC + r7 * r2 (SS);
         r7 = rMAC, r4 = M[I1,M2];              // r7 = (-s)'
842005d8:	0f 66 91 00 	r7 = rMAC + Null, r4 = M[I1,M2];

842005dc <$M.celt.imdct_radix2.pre_process_loop>:
      pre_process_loop:

      // load the constant points mid way to improve accuracy
      r4 = M[I2,M0];
842005dc:	00 68 00 02 	Null = Null + Null, r4 = M[I2,M0];
      r4 = -r4, r1 = M[I2,M0];
842005e0:	6f 38 60 20 	r4 = Null - r4, r1 = M[I2,M0];
      r7 = -r1;
842005e4:	3f 00 90 20 	r7 = Null - r1;
      M3 = M3 - M0;
842005e8:	00 00 b8 7f 	M3 = M3 - M0;
   if POS jump outer_pre_process_loop;
842005ec:	f1 ff 50 dd 	if POS jump $M.celt.imdct_radix2.outer_pre_process_loop;
   
#ifdef BASE_REGISTER_MODE
   push NULL;
842005f0:	00 00 00 f3 	push Null;
   pop B5;
842005f4:	00 00 d6 f3 	pop B5;
   push NULL;
842005f8:	00 00 00 f3 	push Null;
   pop B4;
842005fc:	00 00 c6 f3 	pop B4;
#endif 
   // set up data in fft_structure
   I7 = r5 + $celt.dec.SCRATCHVAR_FFT_STRUCT;
84200600:	98 01 77 51 	I7 = r5 + 408;

   // -- call the ifft --
   r8 = M[FP + TEMP + 6*MK1];
84200604:	20 00 a8 f1 	r8 = M[FP + 0x20];
   call $math.scaleable_ifft;
84200608:	07 00 00 fd 	call 0x74bf0;
8420060c:	f0 4b f0 e1 
   
   r5 = M[FP + TEMP + 0*MK1]; //pointer to objcet
84200610:	08 00 78 f1 	r5 = M[FP + 0x8];
   r8 = M[FP + TEMP + 1*MK1]; //N
84200614:	0c 00 a8 f1 	r8 = M[FP + 0xc];
   r6 = M[FP + TEMP + 2*MK1]; //c
84200618:	10 00 88 f1 	r6 = M[FP + 0x10];
   
   // get the trig from mode object
   r0 = M[r5 + $celt.dec.MODE_TRIG_OFFSET_FIELD];
8420061c:	78 00 27 d1 	r0 = M[r5 + 120];
   r1 = $celt.mode.TRIG_VECTOR_SIZE;
84200620:	0c 00 30 01 	r1 = Null + 12;
   NULL = M[r5 + $celt.dec.SHORT_BLOCKS_FIELD];
84200624:	58 01 07 d1 	Null = M[r5 + 344];
   if Z r1 = 0;
84200628:	00 00 30 00 	if EQ r1 = Null + Null;
   Words2Addr(r1);
8420062c:	02 00 33 91 	r1 = r1 ASHIFT 2;
   I2 = r0 + r1;
84200630:	3f 00 22 50 	I2 = r0 + r1;
   I2 = I2 + 2*ADDR_PER_WORD;
84200634:	08 00 22 59 	I2 = I2 + 8;

   // re-set up the number of points
   r1 = I7;
84200638:	7f 00 30 44 	r1 = Null + I7;
   r10 = r8 LSHIFT -1;
8420063c:	ff 00 ca 8d 	r10 = r8 LSHIFT -1;
 
   // set up the shift registers
   M0 = MK1;
84200640:	04 00 80 51 	M0 = Null + 4;
   M1 = MK2;
84200644:	08 00 90 51 	M1 = Null + 8;
   M2 = -MK2;
84200648:	f8 ff a0 51 	M2 = Null + -8;

   // copy the data out of the temporary store after the IFFT
   r2 = M[FP + TEMP + 3*MK1];
8420064c:	14 00 48 f1 	r2 = M[FP + 0x14];
   I0 = r2;
84200650:	4f 00 00 50 	I0 = Null + r2;
   Words2Addr(r10);
84200654:	02 00 cc 91 	r10 = r10 ASHIFT 2;
   I0 = I0 + r10;                      // I0 points to the second half
84200658:	00 00 0c 5b 	I0 = I0 + r10;
   Addr2Words(r10);
8420065c:	fe 00 cc 91 	r10 = r10 ASHIFT -2;

   r2 = M[FP + TEMP + 4*MK1];
84200660:	18 00 48 f1 	r2 = M[FP + 0x18];
   I4 = r2;
84200664:	4f 00 40 50 	I4 = Null + r2;
   I7 = r2;
84200668:	4f 00 70 50 	I7 = Null + r2;

   r10 = r10 - 1;                    // r10 = N/2 - 1
8420066c:	3f 00 cc e4 	r10 = r10 - 1;
   r0 = M[I4, M0];                   // do one read and write outside the loop
84200670:	20 00 00 02 	Null = Null + Null, r0 = M[I4,M0];
                  
   do copy_loop;
84200674:	02 00 f0 e5 	do $M.celt.imdct_radix2.copy_loop;
      r0 = M[I4, M0], M[I0, M0] = r0;
84200678:	20 a0 00 02 	Null = Null + Null, M[I0,M0] = r0, r0 = M[I4,M0];

8420067c <$M.celt.imdct_radix2.copy_loop>:




   // calculate some bit reverse constants
   r6 = SIGNDET r8, M[I0, M0] = r0; // perform the last memory write
8420067c:	0f a0 8a d8 	r6 = SIGNDET r8, M[I0,M0] = r0;
   r6 = r6 + 2 - LOG2_ADDR_PER_WORD;                     
84200680:	00 00 88 01 	r6 = r6 + 0;
   r7 = 1;                          // r7 used as loop counter, set for below
84200684:	2f 00 90 e4 	r7 = Null + 1;
   r6 = r7 LSHIFT r6;
84200688:	8f 00 89 8c 	r6 = r7 LSHIFT r6;
   M3 = r6;                         // bit reverse shift register
8420068c:	8f 00 b0 50 	M3 = Null + r6;
   r6 = r6 LSHIFT -1;               // shift operator for I1 initialisation
84200690:	ff 00 88 8d 	r6 = r6 LSHIFT -1;

   r0 = M[FP + TEMP + 3*MK1];
84200694:	14 00 28 f1 	r0 = M[FP + 0x14];

#ifdef BASE_REGISTER_MODE
   push r0;
84200698:	00 00 20 f3 	push r0;
   pop B0;
8420069c:	00 00 a6 f3 	pop B0;
#endif 

   call $math.address_bitreverse;
842006a0:	07 00 00 fd 	call 0x748ec;
842006a4:	ec 48 f0 e1 
   I0 = r1;
842006a8:	3f 00 00 50 	I0 = Null + r1;
  
#ifdef BASE_REGISTER_MODE   
    r0 = M[FP + TEMP + 3*MK1]; 
842006ac:	14 00 28 f1 	r0 = M[FP + 0x14];
    r2 = r8 LSHIFT -1;
842006b0:	ff 00 4a 8d 	r2 = r8 LSHIFT -1;
    Words2Addr(r2);
842006b4:	02 00 44 91 	r2 = r2 ASHIFT 2;
    r0 = r0 + r2;
842006b8:	00 00 24 03 	r0 = r0 + r2;
    push r0 ;
842006bc:	00 00 20 f3 	push r0;
    pop B1;
842006c0:	00 00 b6 f3 	pop B1;
    call $math.address_bitreverse;
842006c4:	07 00 00 fd 	call 0x748ec;
842006c8:	ec 48 f0 e1 
    I1 = r1;
842006cc:	3f 00 10 50 	I1 = Null + r1;
#else 
    I1 = I0 + r6;
#endif 
   r2 = M[I2, M0];                     // imaginary ifft component
842006d0:	00 48 00 02 	Null = Null + Null, r2 = M[I2,M0];
   I2 = r1, r2 = M[I2, M0];*/
  
                                                   // cfreq
   //r10 = r8 LSHIFT -1;                               // r10 = N/2
   // set up pointers to output buffers
   r3 = M[I2, M0];                                   // sfreq
842006d4:	00 58 00 02 	Null = Null + Null, r3 = M[I2,M0];
   I6 = I7 - M0, r4 = M[I2, M0];                     // c
842006d8:	8f 68 67 7c 	I6 = I7 - M0, r4 = M[I2,M0];
   Words2Addr(r8);
842006dc:	02 00 aa 91 	r8 = r8 ASHIFT 2;
   I6 = I6 + r8, r5 = M[I2, M0];  
842006e0:	00 78 6a 5a 	I6 = I6 + r8, r5 = M[I2,M0];
   Addr2Words(r8);                   // s
842006e4:	fe 00 aa 91 	r8 = r8 ASHIFT -2;

   // store the constant locations in r6
   r6 = I2;
842006e8:	2f 00 80 44 	r6 = Null + I2;

   // data is returned bit reversed, so enable bit reverse addressing on AG1
   rFlags = rFlags OR $BR_FLAG;
842006ec:	40 00 ee 85 	rFlags = rFlags OR 0x40;

   // load bit reversed tmp c location
   r0 = FP + TMP_VAR;
842006f0:	24 00 27 f1 	r0 = FP + 36;
   call $math.address_bitreverse;
842006f4:	07 00 00 fd 	call 0x748ec;
842006f8:	ec 48 f0 e1 
   I2 = r1;
842006fc:	3f 00 20 50 	I2 = Null + r1;
   //call save_I0;
   M0 = 0, r0 = M[I0, M3];                 // tempr
84200700:	0f 23 80 50 	M0 = Null + Null, r0 = M[I0,M3];

84200704 <$M.celt.imdct_radix2.post_process_loop1>:

   // use r7 as outer loop counter, set above
   post_process_loop1:

      r10 = r8 LSHIFT -3;             // r10 = N/8
84200704:	fd 00 ca 8d 	r10 = r8 LSHIFT -3;
      do inner_post_process_loop1;
84200708:	0a 00 f0 e5 	do $M.celt.imdct_radix2.inner_post_process_loop1;
         //call save_I1;
         rMAC = r0 * r4, r1 = M[I1, M3];                 // rMAC = tempr * c
8420070c:	6f 37 12 cc 	rMAC = r0 * r4 (SS), r1 = M[I1,M3];
                                                         // tempi
         rMAC = rMAC - r1 * r5;                          // rMAC = tempr*c - tempi*s
84200710:	7f 00 13 bc 	rMAC = rMAC - r1 * r5 (SS);
         rMAC = r1 * r4, M[I6, M2] = rMAC;               // rMAC = tempi * c
84200714:	9a 00 36 ce 	rMAC = r1 * r4 (SS), M[I6,M2] = rMAC;
                                                         // I6 = tr
         rMAC = rMAC + r0 * r5;                          // rMAC = tempi*c + tempr*s
84200718:	7f 00 12 ac 	rMAC = rMAC + r0 * r5 (SS);
         
         // update the multipliers: "c" and "s"
         rMAC = r4 * r2, M[I7, M1] = rMAC;               // c * cfreq
8420071c:	9d 00 64 ce 	rMAC = r4 * r2 (SS), M[I7,M1] = rMAC;
        // call save_I0;
         rMAC = rMAC - r5 * r3, r0 = M[I0, M3];          // c' = c * cfreq - s * sfreq
84200720:	5f 23 17 bc 	rMAC = rMAC - r5 * r3 (SS), r0 = M[I0,M3];
         rMAC = r4 * r3, M[I2,M0] = rMAC;                // c_old * sfreq
84200724:	5f 98 16 cc 	rMAC = r4 * r3 (SS), M[I2,M0] = rMAC;
         rMAC = rMAC + r5 * r2;                          // s' = c_old*sfreq + s*cfreq
84200728:	4f 00 17 ac 	rMAC = rMAC + r5 * r2 (SS);
         r5 = rMAC, r4 = M[I2,M0];                       // r5 = s'
8420072c:	0f 68 71 00 	r5 = rMAC + Null, r4 = M[I2,M0];

84200730 <$M.celt.imdct_radix2.inner_post_process_loop1>:
      inner_post_process_loop1:

      // load more accurate data for c and s
      r4 = M[r6];
84200730:	0f 00 68 d0 	r4 = M[r6 + Null];
      r5 = M[r6 + MK1];
84200734:	04 00 78 d1 	r5 = M[r6 + 4];
      r6 = r6 + 2*ADDR_PER_WORD;
84200738:	08 00 88 01 	r6 = r6 + 8;
      r7 = r7 - 1;
8420073c:	3f 00 99 e4 	r7 = r7 - 1;
   if POS jump post_process_loop1;
84200740:	f1 ff 50 dd 	if POS jump $M.celt.imdct_radix2.post_process_loop1;
   // second loop i.e. inner_post_process_loop2_2 address bitreversal 
   // causes a memory access problem in the last iteration. This is a read
   // operation that is not going to be used therefore the loop counter on 
   // the second loop has been reduced by one to avoid this issue and last 
   // iteration is run separattely without the read operation.
   r10 = r8 LSHIFT -3;              // r10 = N/8
84200744:	fd 00 ca 8d 	r10 = r8 LSHIFT -3;
   do inner_post_process_loop2_1;
84200748:	0a 00 f0 e5 	do $M.celt.imdct_radix2.inner_post_process_loop2_1;
     // call save_I1;
      rMAC = r0 * r5, r1 = M[I1, M3];                  // rMAC = tempr*s
8420074c:	7f 37 12 cc 	rMAC = r0 * r5 (SS), r1 = M[I1,M3];
                                                       // tempi
      rMAC = rMAC + r1 * r4;                           // rMAC = tempr*s + tempi * c
84200750:	6f 00 13 ac 	rMAC = rMAC + r1 * r4 (SS);
      rMAC = r0 * r4,M[I7, M1] = rMAC;                 // rMAC = tempr * c
84200754:	9d 00 26 ce 	rMAC = r0 * r4 (SS), M[I7,M1] = rMAC;
      rMAC = rMAC - r1 * r5;                           // rMAC = tempr*c - tempi*s
84200758:	7f 00 13 bc 	rMAC = rMAC - r1 * r5 (SS);
      
      // Update the multipliers: "c" and "s"
      rMAC = r4 * r2, M[I6, M2] = rMAC;                // c * cfreq
8420075c:	9a 00 64 ce 	rMAC = r4 * r2 (SS), M[I6,M2] = rMAC;
      //call save_I0;
      rMAC = rMAC - r5 * r3, r0 = M[I0, M3];           // c' = c * cfreq - s * sfreq
84200760:	5f 23 17 bc 	rMAC = rMAC - r5 * r3 (SS), r0 = M[I0,M3];
            
      rMAC = r4 * r3, M[I2,M0] = rMAC;                 // c_old * sfreq
84200764:	5f 98 16 cc 	rMAC = r4 * r3 (SS), M[I2,M0] = rMAC;
      rMAC = rMAC + r5 * r2;                           // s' = c_old*sfreq + s*cfreq
84200768:	4f 00 17 ac 	rMAC = rMAC + r5 * r2 (SS);
      r5 = rMAC, r4 = M[I2,M0];                        // r5 = s'          
8420076c:	0f 68 71 00 	r5 = rMAC + Null, r4 = M[I2,M0];

84200770 <$M.celt.imdct_radix2.inner_post_process_loop2_1>:
   inner_post_process_loop2_1:
   // load more accurate data for c and s
   r4 = M[r6];
84200770:	0f 00 68 d0 	r4 = M[r6 + Null];
   r5 = M[r6 + MK1];
84200774:	04 00 78 d1 	r5 = M[r6 + 4];
   r6 = r6 + 2*ADDR_PER_WORD;    //4;
84200778:	08 00 88 01 	r6 = r6 + 8;
   
   // Initialise the second loop
   r10 = r8 LSHIFT -3;           // r10 = N/8 
8420077c:	fd 00 ca 8d 	r10 = r8 LSHIFT -3;
   r10 = r10 -1;  // Explanation on top of inner_post_process_loop2_1 loop above
84200780:	3f 00 cc e4 	r10 = r10 - 1;
   do inner_post_process_loop2_2;
84200784:	0a 00 f0 e5 	do $M.celt.imdct_radix2.inner_post_process_loop2_2;
     // call save_I1;
      rMAC = r0 * r5, r1 = M[I1, M3];                  // rMAC = tempr*s
84200788:	7f 37 12 cc 	rMAC = r0 * r5 (SS), r1 = M[I1,M3];
                                                       // tempi
      rMAC = rMAC + r1 * r4;                           // rMAC = tempr*s + tempi * c
8420078c:	6f 00 13 ac 	rMAC = rMAC + r1 * r4 (SS);
      rMAC = r0 * r4,M[I7, M1] = rMAC;                 // rMAC = tempr * c
84200790:	9d 00 26 ce 	rMAC = r0 * r4 (SS), M[I7,M1] = rMAC;
      rMAC = rMAC - r1 * r5;                           // rMAC = tempr*c - tempi*s
84200794:	7f 00 13 bc 	rMAC = rMAC - r1 * r5 (SS);
      
      // Update the multipliers: "c" and "s"
      rMAC = r4 * r2, M[I6, M2] = rMAC;                // c * cfreq
84200798:	9a 00 64 ce 	rMAC = r4 * r2 (SS), M[I6,M2] = rMAC;
      //call save_I0;
      rMAC = rMAC - r5 * r3, r0 = M[I0, M3];           // c' = c * cfreq - s * sfreq
8420079c:	5f 23 17 bc 	rMAC = rMAC - r5 * r3 (SS), r0 = M[I0,M3];
            
      rMAC = r4 * r3, M[I2,M0] = rMAC;                 // c_old * sfreq
842007a0:	5f 98 16 cc 	rMAC = r4 * r3 (SS), M[I2,M0] = rMAC;
      rMAC = rMAC + r5 * r2;                           // s' = c_old*sfreq + s*cfreq
842007a4:	4f 00 17 ac 	rMAC = rMAC + r5 * r2 (SS);
      r5 = rMAC, r4 = M[I2,M0];                        // r5 = s'          
842007a8:	0f 68 71 00 	r5 = rMAC + Null, r4 = M[I2,M0];

842007ac <$M.celt.imdct_radix2.inner_post_process_loop2_2>:
   inner_post_process_loop2_2:

   // Run the additional itteration without bit reverse access.
   // Also the last two statements of loop are redundant so are omitted.
      rMAC = r0 * r5, r1 = M[I1, M3];                  // rMAC = tempr*s
842007ac:	7f 37 12 cc 	rMAC = r0 * r5 (SS), r1 = M[I1,M3];
                                                       // tempi
      rMAC = rMAC + r1 * r4;                           // rMAC = tempr*s + tempi * c
842007b0:	6f 00 13 ac 	rMAC = rMAC + r1 * r4 (SS);
      rMAC = r0 * r4,M[I7, M1] = rMAC;                 // rMAC = tempr * c
842007b4:	9d 00 26 ce 	rMAC = r0 * r4 (SS), M[I7,M1] = rMAC;
      rMAC = rMAC - r1 * r5;                           // rMAC = tempr*c - tempi*s
842007b8:	7f 00 13 bc 	rMAC = rMAC - r1 * r5 (SS);
      
      // Update the multipliers: "c" and "s"
      rMAC = r4 * r2, M[I6, M2] = rMAC;                // c * cfreq
842007bc:	9a 00 64 ce 	rMAC = r4 * r2 (SS), M[I6,M2] = rMAC;
      //call save_I0;
      rMAC = rMAC - r5 * r3;                           // c' = c * cfreq - s * sfreq
842007c0:	5f 00 17 bc 	rMAC = rMAC - r5 * r3 (SS);
            
      rMAC = r4 * r3, M[I2,M0] = rMAC;                 // c_old * sfreq
842007c4:	5f 98 16 cc 	rMAC = r4 * r3 (SS), M[I2,M0] = rMAC;



   // disable bit reversed addressing on AG1
   rFlags = rFlags AND $NOT_BR_FLAG;
842007c8:	bf ff ee 81 	rFlags = rFlags AND 0xffbf;

   L4 = 0;
842007cc:	00 00 e0 51 	L4 = Null + 0;
   L5 = 0;
842007d0:	00 00 f0 51 	L5 = Null + 0;
#ifdef BASE_REGISTER_MODE
   push Null;
842007d4:	00 00 00 f3 	push Null;
   pop B0;
842007d8:	00 00 a6 f3 	pop B0;
   push Null;
842007dc:	00 00 00 f3 	push Null;
   pop B1;
842007e0:	00 00 b6 f3 	pop B1;
   push Null;
842007e4:	00 00 00 f3 	push Null;
   pop B4;
842007e8:	00 00 c6 f3 	pop B4;
   push Null;
842007ec:	00 00 00 f3 	push Null;
   pop B5;
842007f0:	00 00 d6 f3 	pop B5;
#endif
   // -- see if shift is required
   r4 = M[FP + TEMP + 5*MK1];
842007f4:	1c 00 68 f1 	r4 = M[FP + 0x1c];
   if Z jump end;
842007f8:	14 00 00 dd 	if EQ jump $M.celt.imdct_radix2.end;

   r7 = 0.5;
842007fc:	00 40 00 fd 	r7 = Null + 1073741824;
84200800:	00 00 90 01 

   r8 = (2-DAWTH) - r4;
84200804:	e2 ff a6 65 	r8 = -30 - r4;
   r8 = r7 LSHIFT r8;
84200808:	af 00 a9 8c 	r8 = r7 LSHIFT r8;
   
   // -- get output address
   r0 = M[FP + TEMP + 4*MK1];
8420080c:	18 00 28 f1 	r0 = M[FP + 0x18];
   I2 = r0;
84200810:	2f 00 20 50 	I2 = Null + r0;
   
   // -- get output length
   r10 = M[FP + TEMP + MK1];   
84200814:	0c 00 c8 f1 	r10 = M[FP + 0xc];
   M0 = -MK1;   
84200818:	fc ff 80 51 	M0 = Null + -4;
   M1 = MK2;
8420081c:	08 00 90 51 	M1 = Null + 8;
   r10 = r10 - 1;
84200820:	3f 00 cc e4 	r10 = r10 - 1;
   r0 = 1.0;
84200824:	ff 7f 00 fd 	r0 = Null + 2147483647;
84200828:	ff ff 20 01 
   
   // -- shift and round
   rMAC = M[I2, MK1];          
8420082c:	00 19 00 03 	Null = Null + Null, rMAC = M[I2,4];
   rMAC = rMAC + r8 * r7;
84200830:	9f 00 1a ac 	rMAC = rMAC + r8 * r7 (SS);
   do shift_round_loop;
84200834:	03 00 f0 e5 	do $M.celt.imdct_radix2.shift_round_loop;
      r1 = rMAC ASHIFT r4, rMAC = M[I2, M0];   
84200838:	6f 18 31 90 	r1 = rMAC ASHIFT r4, rMAC = M[I2,M0];
      rMAC = rMAC + r8 * r7, M[I2, M1] = r1;    
8420083c:	9f b9 1a ac 	rMAC = rMAC + r8 * r7 (SS), M[I2,M1] = r1;

84200840 <$M.celt.imdct_radix2.shift_round_loop>:
   shift_round_loop:
   r1 = rMAC ASHIFT r4, rMAC = M[I2, M0];
84200840:	6f 18 31 90 	r1 = rMAC ASHIFT r4, rMAC = M[I2,M0];
   M[I2, M1] = r1;
84200844:	00 b9 00 02 	Null = Null + Null, M[I2,M1] = r1;

84200848 <$M.celt.imdct_radix2.end>:
   end:
   
   r5 = M[FP + TEMP + 0*MK1]; //pointer to objcet
84200848:	08 00 78 f1 	r5 = M[FP + 0x8];
  
   // pop rLink from stack
   SP = SP - STACK_FRAME_SIZE;
8420084c:	e0 ff 03 f1 	SP = SP + -32;
   popm <FP,rLink>;
84200850:	01 20 04 f1 	popm <FP, rLink>;
   rts;
84200854:	0f 00 0d dc 	rts;

84200858 <$celt.imdct_window_overlap_add>:
84200858:	01 20 00 f1 	pushm <FP(=SP), rLink>;
   .CONST OBUF_LEN             (3 + 2)*ADDR_PER_WORD;
   .CONST OBUF_START           (4 + 2)*ADDR_PER_WORD;
   .CONST OLA_ADDR             (5 + 2)*ADDR_PER_WORD;
   .CONST STACK_FRAME_SIZE     6*ADDR_PER_WORD;
   pushm <FP(=SP), rLink>;
   SP = SP + STACK_FRAME_SIZE;
8420085c:	18 00 03 f1 	SP = SP + 24;


   // different processing for short blocks
   Null = M[r5 + $celt.dec.SHORT_BLOCKS_FIELD];
84200860:	58 01 07 d1 	Null = M[r5 + 344];
   if NZ jump short_block_proc;
84200864:	31 00 10 dd 	if NE jump $M.celt.imdct_window_overlap_add.short_block_proc;

84200868 <$M.celt.imdct_window_overlap_add.long_block_proc>:
   long_block_proc:
   
      // IMDCT transform
      r0 = M[r5 + $celt.dec.FREQ_FIELD];
84200868:	14 01 27 d1 	r0 = M[r5 + 276];
      I0 = r0;                                       // frequency spectrum
8420086c:	2f 00 00 50 	I0 = Null + r0;
      r0 = M[r5 + $celt.dec.IMDCT_OUTPUT_FIELD];
84200870:	d4 00 27 d1 	r0 = M[r5 + 212];
      I5 = r0;                                       // imdct output
84200874:	2f 00 50 50 	I5 = Null + r0;
      r8 = M[r5 + $celt.dec.MODE_MDCT_SIZE_FIELD];       
84200878:	44 00 a7 d1 	r8 = M[r5 + 68];
      r6 = 0;                                        // left channel
8420087c:	00 00 80 01 	r6 = Null + 0;
      r0 = M[r5 + $celt.dec.IMDCT_FUNCTION_FIELD];   // obtain imdct function
84200880:	0c 00 27 d1 	r0 = M[r5 + 12];
      r4 = M[r5 + $celt.dec.SCRATCHVAR_MAX_SBAND + 0];
84200884:	f0 01 67 d1 	r4 = M[r5 + 496];
      call r0;
84200888:	0f 00 02 e0 	call r0;
  
      // -- Apply window+overlap-add
      r0 = M[r5 + $celt.dec.IMDCT_OUTPUT_FIELD];
8420088c:	d4 00 27 d1 	r0 = M[r5 + 212];
      I0 = r0;                                // input
84200890:	2f 00 00 50 	I0 = Null + r0;
      r0 = M[r5 + $celt.dec.HIST_OLA_LEFT_FIELD];
84200894:	94 00 27 d1 	r0 = M[r5 + 148];
      M3 = r0;              // history
84200898:	2f 00 b0 50 	M3 = Null + r0;
#ifdef BASE_REGISTER_MODE
      r0 = M[r5 + $celt.dec.SCRATCHVAR_LEFT_OBUF_START_ADDR];
8420089c:	84 01 27 d1 	r0 = M[r5 + 388];
      push r0; 
842008a0:	00 00 20 f3 	push r0;
      pop B5; 
842008a4:	00 00 d6 f3 	pop B5;
#endif
      r0 = M[r5 + $celt.dec.SCRATCHVAR_LEFT_OBUF_ADDR];
842008a8:	7c 01 27 d1 	r0 = M[r5 + 380];
      r1 = M[r5 + $celt.dec.SCRATCHVAR_LEFT_OBUF_LEN];
842008ac:	80 01 37 d1 	r1 = M[r5 + 384];
      I5 = r0;                                                    // output buffer
842008b0:	2f 00 50 50 	I5 = Null + r0;
      L5 = r1;
842008b4:	3f 00 f0 50 	L5 = Null + r1;

      r8 = M[r5 + $celt.dec.CELT_MODE_OBJECT_FIELD];
842008b8:	00 00 a7 d1 	r8 = M[r5 + 0];
      r3 = M[r5 + $celt.dec.MODE_MDCT_SIZE_FIELD];                // audio frame size
842008bc:	44 00 57 d1 	r3 = M[r5 + 68];
      call $celt.windowing_overlapadd;
842008c0:	88 00 f0 e1 	call $celt.windowing_overlapadd;

      // right channel is available?
      Null = M[r5 + $celt.dec.CELT_CHANNELS_FIELD];
842008c4:	08 00 07 d1 	Null = M[r5 + 8];
      if Z jump end_long_proc;
842008c8:	17 00 00 dd 	if EQ jump $M.celt.imdct_window_overlap_add.end_long_proc;
         // IMDCT transform
         r0 = M[r5 + $celt.dec.FREQ2_FIELD];
842008cc:	18 01 27 d1 	r0 = M[r5 + 280];
         I0 = r0;
842008d0:	2f 00 00 50 	I0 = Null + r0;
         // frequency spectrum
         r0 = M[r5 + $celt.dec.IMDCT_OUTPUT_FIELD];
842008d4:	d4 00 27 d1 	r0 = M[r5 + 212];
         I5 = r0;                          // imdct output
842008d8:	2f 00 50 50 	I5 = Null + r0;
         r8 = M[r5 + $celt.dec.MODE_MDCT_SIZE_FIELD];          // audio frame size
842008dc:	44 00 a7 d1 	r8 = M[r5 + 68];
         r6 = 1;                                               // right channel
842008e0:	2f 00 80 e4 	r6 = Null + 1;
         r0 = M[r5 + $celt.dec.IMDCT_FUNCTION_FIELD];          // obtain imdct function
842008e4:	0c 00 27 d1 	r0 = M[r5 + 12];
         r4 = M[r5 + $celt.dec.SCRATCHVAR_MAX_SBAND + 1*MK1];
842008e8:	f4 01 67 d1 	r4 = M[r5 + 500];
         call r0;
842008ec:	0f 00 02 e0 	call r0;
         
         // -- Apply window+overlap-add
         r0 = M[r5 + $celt.dec.IMDCT_OUTPUT_FIELD];
842008f0:	d4 00 27 d1 	r0 = M[r5 + 212];
         I0 = r0;                               // input
842008f4:	2f 00 00 50 	I0 = Null + r0;
         r0 = M[r5 + $celt.dec.HIST_OLA_RIGHT_FIELD];
842008f8:	98 00 27 d1 	r0 = M[r5 + 152];
         M3 = r0;                // history
842008fc:	2f 00 b0 50 	M3 = Null + r0;
#ifdef BASE_REGISTER_MODE
         r0 = M[r5 + $celt.dec.SCRATCHVAR_RIGHT_OBUF_START_ADDR];
84200900:	90 01 27 d1 	r0 = M[r5 + 400];
         push r0; 
84200904:	00 00 20 f3 	push r0;
         pop B5; 
84200908:	00 00 d6 f3 	pop B5;
#endif
         r0 = M[r5 + $celt.dec.SCRATCHVAR_RIGHT_OBUF_ADDR];
8420090c:	88 01 27 d1 	r0 = M[r5 + 392];
         r1 = M[r5 + $celt.dec.SCRATCHVAR_RIGHT_OBUF_LEN];
84200910:	8c 01 37 d1 	r1 = M[r5 + 396];
         I5 = r0;                                                  // output buffer
84200914:	2f 00 50 50 	I5 = Null + r0;
         L5 = r1;
84200918:	3f 00 f0 50 	L5 = Null + r1;
         r3 = M[r5 + $celt.dec.MODE_MDCT_SIZE_FIELD];              // audio frame size
8420091c:	44 00 57 d1 	r3 = M[r5 + 68];
         call $celt.windowing_overlapadd;
84200920:	70 00 f0 e1 	call $celt.windowing_overlapadd;

84200924 <$M.celt.imdct_window_overlap_add.end_long_proc>:
      end_long_proc:
      jump end;
84200924:	6c 00 f0 dd 	jump $M.celt.imdct_window_overlap_add.end;

84200928 <$M.celt.imdct_window_overlap_add.short_block_proc>:
   short_block_proc:
      // -- Short Blocks processing
      M[FP + CH_NO] = Null;
84200928:	0c 00 0c f1 	M[FP + 0xc] = Null;
      
#ifdef BASE_REGISTER_MODE
      r0 = M[r5 + $celt.dec.SCRATCHVAR_LEFT_OBUF_START_ADDR];
8420092c:	84 01 27 d1 	r0 = M[r5 + 388];
      M[FP + OBUF_START] = r0; 
84200930:	18 00 2c f1 	M[FP + 0x18] = r0;
#endif
      r0 = M[r5 + $celt.dec.SCRATCHVAR_LEFT_OBUF_ADDR];
84200934:	7c 01 27 d1 	r0 = M[r5 + 380];
      r1 = M[r5 + $celt.dec.SCRATCHVAR_LEFT_OBUF_LEN];
84200938:	80 01 37 d1 	r1 = M[r5 + 384];
      M[FP + OBUF_ADDR] = r0;
8420093c:	10 00 2c f1 	M[FP + 0x10] = r0;
      M[FP + OBUF_LEN] = r1;
84200940:	14 00 3c f1 	M[FP + 0x14] = r1;
      r0 = M[r5 + $celt.dec.HIST_OLA_LEFT_FIELD];
84200944:	94 00 27 d1 	r0 = M[r5 + 148];
      M[FP + OLA_ADDR] = r0;
84200948:	1c 00 2c f1 	M[FP + 0x1c] = r0;

8420094c <$M.celt.imdct_window_overlap_add.chan_loop>:
      chan_loop:
         // silence hist, first block overlap add is performed after windowing
         r0 =  0;
8420094c:	00 00 20 01 	r0 = Null + 0;
         r1 = M[r5 + $celt.dec.SHORT_HIST_FIELD];
84200950:	d8 00 37 d1 	r1 = M[r5 + 216];
         I0 = r1;//&$celt.dec.short_hist;
84200954:	3f 00 00 50 	I0 = Null + r1;
         r8 = M[r5 + $celt.dec.CELT_MODE_OBJECT_FIELD];
84200958:	00 00 a7 d1 	r8 = M[r5 + 0];
         r10 = M[r5 +$celt.dec.MODE_OVERLAP_FIELD];
8420095c:	40 00 c7 d1 	r10 = M[r5 + 64];
         do silent_hist_loop;
84200960:	02 00 f0 e5 	do $M.celt.imdct_window_overlap_add.silent_hist_loop;
            M[I0, MK1] = r0;
84200964:	00 a1 00 03 	Null = Null + Null, M[I0,4] = r0;

84200968 <$M.celt.imdct_window_overlap_add.silent_hist_loop>:
         silent_hist_loop:
         M[FP + TEMP_LP] = r0; //block counter
84200968:	08 00 2c f1 	M[FP + 0x8] = r0;

8420096c <$M.celt.imdct_window_overlap_add.short_mdct_loop>:
         short_mdct_loop:
            //get short freq inputs
            r1 = M[r5 + $celt.dec.SHORT_FREQ_FIELD];
8420096c:	1c 01 37 d1 	r1 = M[r5 + 284];
            I0 = r1;
84200970:	3f 00 00 50 	I0 = Null + r1;
            r4 = M[r5 +$celt.dec.MODE_NB_SHORT_MDCTS_FIELD];
84200974:	58 00 67 d1 	r4 = M[r5 + 88];
            Words2Addr(r4);
84200978:	02 00 66 91 	r4 = r4 ASHIFT 2;
            M0 = r4;
8420097c:	6f 00 80 50 	M0 = Null + r4;
            M1 = MK1;
84200980:	04 00 90 51 	M1 = Null + 4;
            r1 = M[r5 + $celt.dec.FREQ_FIELD];
84200984:	14 01 37 d1 	r1 = M[r5 + 276];
            r8 = M[r5 + $celt.dec.FREQ2_FIELD];
84200988:	18 01 a7 d1 	r8 = M[r5 + 280];
            Null = M[FP + CH_NO];
8420098c:	0c 00 08 f1 	Null = M[FP + 0xc];
            if NZ r1 = r8;
84200990:	01 00 3a 00 	if NE r1 = r8 + Null;
            Words2Addr(r0);
84200994:	02 00 22 91 	r0 = r0 ASHIFT 2;
            I4 = r1 + r0;
84200998:	2f 00 43 50 	I4 = r1 + r0;
            r4 = M[r5 + $celt.dec.MODE_SHORT_MDCT_SIZE_FIELD];
8420099c:	5c 00 67 d1 	r4 = M[r5 + 92];
            r10 = r4 - 1;
842009a0:	3f 00 c6 e4 	r10 = r4 - 1;
            r1 = M[I4, M0];
842009a4:	30 00 00 02 	Null = Null + Null, r1 = M[I4,M0];
            do copy_short_freq;
842009a8:	02 00 f0 e5 	do $M.celt.imdct_window_overlap_add.copy_short_freq;
               M[I0, M1] = r1, r1 = M[I4, M0];
842009ac:	30 b1 00 02 	Null = Null + Null, M[I0,M1] = r1, r1 = M[I4,M0];

842009b0 <$M.celt.imdct_window_overlap_add.copy_short_freq>:
            copy_short_freq:
            M[I0, MK1] = r1;
842009b0:	00 b1 00 03 	Null = Null + Null, M[I0,4] = r1;
            
            // -- IMDCT transform
            r1 = M[r5 + $celt.dec.SHORT_FREQ_FIELD];
842009b4:	1c 01 37 d1 	r1 = M[r5 + 284];
            I0 = r1;                                           //input
842009b8:	3f 00 00 50 	I0 = Null + r1;
            r1 = M[r5 + $celt.dec.IMDCT_OUTPUT_FIELD];
842009bc:	d4 00 37 d1 	r1 = M[r5 + 212];
            I5 = r1;                                           //output
842009c0:	3f 00 50 50 	I5 = Null + r1;
            r8 = r4;                                           //short block size
842009c4:	0f 00 a6 00 	r8 = r4 + Null;
            r6 = 0;                                            //left channel
842009c8:	00 00 80 01 	r6 = Null + 0;
            r1 = M[FP + CH_NO];
842009cc:	0c 00 38 f1 	r1 = M[FP + 0xc];
            r0 = M[r5 + $celt.dec.IMDCT_SHORT_FUNCTION_FIELD]; //IMDCT function
842009d0:	10 00 27 d1 	r0 = M[r5 + 16];
            Words2Addr(r1);
842009d4:	02 00 33 91 	r1 = r1 ASHIFT 2;
            r4 = r5 + r1;
842009d8:	3f 00 67 00 	r4 = r5 + r1;
            r4 = M[r4 + $celt.dec.SCRATCHVAR_MAX_SBAND];
842009dc:	f0 01 66 d1 	r4 = M[r4 + 496];
            call r0;
842009e0:	0f 00 02 e0 	call r0;
           
            // window + overlap-add
#ifdef BASE_REGISTER_MODE
            r0 = M[FP + OBUF_START]; 
842009e4:	18 00 28 f1 	r0 = M[FP + 0x18];
            push r0;
842009e8:	00 00 20 f3 	push r0;
            pop B5;
842009ec:	00 00 d6 f3 	pop B5;
#endif
            r0 = M[FP + OBUF_ADDR];
842009f0:	10 00 28 f1 	r0 = M[FP + 0x10];
            r1 = M[FP + OBUF_LEN];
842009f4:	14 00 38 f1 	r1 = M[FP + 0x14];
            I5 = r0;
842009f8:	2f 00 50 50 	I5 = Null + r0;
            L5 = r1;
842009fc:	3f 00 f0 50 	L5 = Null + r1;

            r3 = M[r5 + $celt.dec.MODE_SHORT_MDCT_SIZE_FIELD];
84200a00:	5c 00 57 d1 	r3 = M[r5 + 92];
            r0 =  M[FP + TEMP_LP];
84200a04:	08 00 28 f1 	r0 = M[FP + 0x8];
            r0 = r0 * r3(int);
84200a08:	00 00 25 9b 	r0 = r0 * r3 (int);
            Words2Addr(r0);
84200a0c:	02 00 22 91 	r0 = r0 ASHIFT 2;
            M0 = r0;
84200a10:	2f 00 80 50 	M0 = Null + r0;
            r0 = M[I5, M0];
84200a14:	24 00 00 02 	Null = Null + Null, r0 = M[I5,M0];
            r0 = M[r5 + $celt.dec.IMDCT_OUTPUT_FIELD];
84200a18:	d4 00 27 d1 	r0 = M[r5 + 212];
            I0 = r0;
84200a1c:	2f 00 00 50 	I0 = Null + r0;
            r0 = M[r5 + $celt.dec.SHORT_HIST_FIELD];
84200a20:	d8 00 27 d1 	r0 = M[r5 + 216];
            M3 = r0;
84200a24:	2f 00 b0 50 	M3 = Null + r0;
            call $celt.windowing_overlapadd;
84200a28:	2e 00 f0 e1 	call $celt.windowing_overlapadd;

            // prepare for next block
            r0 = M[FP + TEMP_LP];
84200a2c:	08 00 28 f1 	r0 = M[FP + 0x8];
            r0 = r0 + 1;
84200a30:	2f 00 22 e4 	r0 = r0 + 1;
            M[FP + TEMP_LP] = r0;
84200a34:	08 00 2c f1 	M[FP + 0x8] = r0;
            r1 = M[r5 + $celt.dec.MODE_NB_SHORT_MDCTS_FIELD];
84200a38:	58 00 37 d1 	r1 = M[r5 + 88];
            Null = r1 - r0;
84200a3c:	2f 00 03 20 	Null = r1 - r0;
         if NZ jump short_mdct_loop;
84200a40:	cb ff 10 dd 	if NE jump $M.celt.imdct_window_overlap_add.short_mdct_loop;

         // transient processing if enabled
         r0 = M[FP + OBUF_ADDR];
84200a44:	10 00 28 f1 	r0 = M[FP + 0x10];
         I5 = r0;
84200a48:	2f 00 50 50 	I5 = Null + r0;
         r0 = M[r5 + $celt.dec.SHORT_HIST_FIELD];
84200a4c:	d8 00 27 d1 	r0 = M[r5 + 216];
         I0 = r0;
84200a50:	2f 00 00 50 	I0 = Null + r0;
         r0 = M[r5 + $celt.dec.TRANSIENT_SHIFT_FIELD];
84200a54:	68 01 27 d1 	r0 = M[r5 + 360];
         if NZ call $celt.transient_synthesis;
84200a58:	bd 06 10 e1 	if NE call $celt.transient_synthesis;

         // overlap add for first block
         r10 = M[r5 +$celt.dec.MODE_OVERLAP_FIELD];
84200a5c:	40 00 c7 d1 	r10 = M[r5 + 64];
         r0 = M[FP + OBUF_ADDR];
84200a60:	10 00 28 f1 	r0 = M[FP + 0x10];
         I5 = r0;
84200a64:	2f 00 50 50 	I5 = Null + r0;
         r0 = M[r5 + $celt.dec.SHORT_HIST_FIELD];
84200a68:	d8 00 27 d1 	r0 = M[r5 + 216];
         I0 = r0;
84200a6c:	2f 00 00 50 	I0 = Null + r0;
         r0 = M[FP + OLA_ADDR];
84200a70:	1c 00 28 f1 	r0 = M[FP + 0x1c];
         I1 = r0;
84200a74:	2f 00 10 50 	I1 = Null + r0;
         r7 = 1.0;
84200a78:	ff 7f 00 fd 	r7 = Null + 2147483647;
84200a7c:	ff ff 90 01 
         do short_wola_loop;
84200a80:	04 00 f0 e5 	do $M.celt.imdct_window_overlap_add.short_wola_loop;
            rMAC = M[I1, 0], r0 = M[I5, 0]; 
84200a84:	24 14 00 03 	Null = Null + Null, rMAC = M[I1,0], r0 = M[I5,0];
            rMAC = rMAC + r0*r7, r1 = M[I0, MK1];
84200a88:	00 31 29 af 	rMAC = rMAC + r0 * r7 (SS), r1 = M[I0,4];
            M[I5, MK1] = rMAC, M[I1, MK1] = r1;
84200a8c:	95 b5 00 03 	Null = Null + Null, M[I1,4] = r1, M[I5,4] = rMAC;

84200a90 <$M.celt.imdct_window_overlap_add.short_wola_loop>:
         short_wola_loop:
         L5 = 0;
84200a90:	00 00 f0 51 	L5 = Null + 0;

#ifdef BASE_REGISTER_MODE
         push Null; 
84200a94:	00 00 00 f3 	push Null;
         pop B5; 
84200a98:	00 00 d6 f3 	pop B5;

         r0 = M[r5 + $celt.dec.SCRATCHVAR_RIGHT_OBUF_START_ADDR];
84200a9c:	90 01 27 d1 	r0 = M[r5 + 400];
         M[FP + OBUF_START] = r0; 
84200aa0:	18 00 2c f1 	M[FP + 0x18] = r0;
#endif       
         r0 = M[r5 + $celt.dec.SCRATCHVAR_RIGHT_OBUF_ADDR];
84200aa4:	88 01 27 d1 	r0 = M[r5 + 392];
         r1 = M[r5 + $celt.dec.SCRATCHVAR_RIGHT_OBUF_LEN];
84200aa8:	8c 01 37 d1 	r1 = M[r5 + 396];
         M[FP + OBUF_ADDR] = r0;
84200aac:	10 00 2c f1 	M[FP + 0x10] = r0;
         M[FP + OBUF_LEN] = r1;
84200ab0:	14 00 3c f1 	M[FP + 0x14] = r1;
         r0 = M[r5 + $celt.dec.HIST_OLA_RIGHT_FIELD];
84200ab4:	98 00 27 d1 	r0 = M[r5 + 152];
         M[FP + OLA_ADDR] = r0;      
84200ab8:	1c 00 2c f1 	M[FP + 0x1c] = r0;
         r0 = M[FP + CH_NO];
84200abc:	0c 00 28 f1 	r0 = M[FP + 0xc];
         r0 = r0 + 1;
84200ac0:	2f 00 22 e4 	r0 = r0 + 1;
         M[FP + CH_NO] = r0;
84200ac4:	0c 00 2c f1 	M[FP + 0xc] = r0;
         r1 = M[r5 + $celt.dec.CELT_CHANNELS_FIELD];
84200ac8:	08 00 37 d1 	r1 = M[r5 + 8];
         Null = r1 - r0;
84200acc:	2f 00 03 20 	Null = r1 - r0;
         if POS jump chan_loop;
84200ad0:	9f ff 50 dd 	if POS jump $M.celt.imdct_window_overlap_add.chan_loop;

84200ad4 <$M.celt.imdct_window_overlap_add.end>:
   end:
   SP = SP - STACK_FRAME_SIZE;
84200ad4:	e8 ff 03 f1 	SP = SP + -24;
   popm <FP,rLink>;
84200ad8:	01 20 04 f1 	popm <FP, rLink>;
   rts;
84200adc:	0f 00 0d dc 	rts;

84200ae0 <$celt.windowing_overlapadd>:
#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.WINDOWING_OVERLAPADD.PATCH_ID_0,r8)     // celt_patchers
#endif

   // obtain window data
   r0 = M[r5 + $celt.dec.MODE_WINDOW_ADDR_FIELD];
84200ae0:	68 00 27 d1 	r0 = M[r5 + 104];
   I3 = r0;
84200ae4:	2f 00 30 50 	I3 = Null + r0;
   
   // r8 = overlap_size
   // r6 = overlap size)
   // r4 = frame_size/2
   r8 = M[r5 + $celt.dec.MODE_OVERLAP_FIELD];
84200ae8:	40 00 a7 d1 	r8 = M[r5 + 64];
   r6 = r8 LSHIFT -1;
84200aec:	ff 00 8a 8d 	r6 = r8 LSHIFT -1;
   r4 = r3 LSHIFT -1;
84200af0:	ff 00 65 8d 	r4 = r3 LSHIFT -1;
    
   // set a few Modify registers
   M0 = MK1;
84200af4:	04 00 80 51 	M0 = Null + 4;
   M1 = -MK1;
84200af8:	fc ff 90 51 	M1 = Null + -4;
    
   // copy from middle of the window (reverse)
   r10 = r4 - r6;
84200afc:	8f 00 c6 20 	r10 = r4 - r6;
   Words2Addr(r4);
84200b00:	02 00 66 91 	r4 = r4 ASHIFT 2;
   Words2Addr(r6);
84200b04:	02 00 88 91 	r6 = r6 ASHIFT 2;
   I1 = I0 + r4;
84200b08:	6f 00 10 58 	I1 = I0 + r4;
   I1 = I1 - M0;
84200b0c:	00 00 18 7f 	I1 = I1 - M0;
   L4 = L5;
84200b10:	0f 00 ef 58 	L4 = L5 + Null;
   I4 = I5;
84200b14:	0f 00 45 58 	I4 = I5 + Null;
#ifdef BASE_REGISTER_MODE
   push B5;
84200b18:	00 00 d2 f3 	push B5;
   pop B4;
84200b1c:	00 00 c6 f3 	pop B4;
#endif 
   M2 = r6 + r4;
84200b20:	6f 00 a8 50 	M2 = r6 + r4;
   Addr2Words(r6);
84200b24:	fe 00 88 91 	r6 = r6 ASHIFT -2;
   M2 = M2 - M0;
84200b28:	00 00 a8 7f 	M2 = M2 - M0;
   r0 = M[I4, M2];
84200b2c:	22 00 00 02 	Null = Null + Null, r0 = M[I4,M2];
   r10 = r10 - 1;
84200b30:	3f 00 cc e4 	r10 = r10 - 1;
   if LE jump end_copy_q1_loop;
84200b34:	05 00 d0 dd 	if LE jump $M.celt.windowing_overlapadd.end_copy_q1_loop;
   r0 = M[I1, M1];
84200b38:	00 25 00 02 	Null = Null + Null, r0 = M[I1,M1];
   do copy_q1_loop;        
84200b3c:	02 00 f0 e5 	do $M.celt.windowing_overlapadd.copy_q1_loop;
      M[I4, M1] = r0, r0 = M[I1, M1]; 
84200b40:	a1 25 00 02 	Null = Null + Null, r0 = M[I1,M1], M[I4,M1] = r0;

84200b44 <$M.celt.windowing_overlapadd.copy_q1_loop>:
   copy_q1_loop:
   M[I4, M1] = r0;
84200b44:	a1 00 00 02 	Null = Null + Null, M[I4,M1] = r0;

84200b48 <$M.celt.windowing_overlapadd.end_copy_q1_loop>:
   // window and add hist one overlap size
   //I2 = hist(0)
   //I0 = hist(ov - 1)
   //I3 = w1(0)
   //I7 = w2(ov-1)
   Words2Addr(r8);
84200b48:	02 00 aa 91 	r8 = r8 ASHIFT 2;
   I2 = M3;
84200b4c:	0f 00 2b 58 	I2 = M3 + Null;
   I0 = M3 + r8;
84200b50:	af 00 0b 58 	I0 = M3 + r8;
   I0 = I0 - M0;
84200b54:	00 00 08 7f 	I0 = I0 - M0;
   r7 = 1.0;
84200b58:	ff 7f 00 fd 	r7 = Null + 2147483647;
84200b5c:	ff ff 90 01 
   r10 = r6 - 1, r0 = M[I1, M1];                // r0 = x1
84200b60:	3f 25 c8 e4 	r10 = r6 - 1, r0 = M[I1,M1];
   I7 = I3 + r8, rMAC = M[I2, M0];               // rMAC = h1
84200b64:	af 18 73 58 	I7 = I3 + r8, rMAC = M[I2,M0];
   I7 = I7 - M0, r2 = M[I3, M0];                 // r2 = w1
84200b68:	00 4c 78 7e 	I7 = I7 - M0, r2 = M[I3,M0];
   do left_wola_loop;
84200b6c:	05 00 f0 e5 	do $M.celt.windowing_overlapadd.left_wola_loop;
      rMAC = rMAC - r0*r2, r2 = M[I7, M1], r1 = M[I0, M1];      //rMAC = h1 -x1*w1, r2 = w2, r1 = h2
84200b70:	4d 31 24 be 	rMAC = rMAC - r0 * r2 (SS), r1 = M[I0,M1], r2 = M[I7,M1];
      rMAC = r0*r2, M[I5, M0] = rMAC, r0 = M[I1, M1];           //yp1 = h1 -x1*w1, rMAC = w2*x1, r0 = x1
84200b74:	94 25 24 ce 	rMAC = r0 * r2 (SS), r0 = M[I1,M1], M[I5,M0] = rMAC;
      rMAC = rMAC + r7*r1, r2 = M[I3, M0];                      //rMAC = h2 + w2*x1, r2 = w1
84200b78:	3f 4c 19 ac 	rMAC = rMAC + r7 * r1 (SS), r2 = M[I3,M0];
      M[I4, M1] = rMAC, rMAC = M[I2, M0];                       //out1 = h2 + w2*x2, rMAC = h2                  
84200b7c:	91 18 00 02 	Null = Null + Null, rMAC = M[I2,M0], M[I4,M1] = rMAC;

84200b80 <$M.celt.windowing_overlapadd.left_wola_loop>:
   left_wola_loop:
   rMAC = rMAC - r0*r2, r2 = M[I7, M1], r1 = M[I0, M1];           //rMAC = h1 -x1*w1, r2 = w2, r1 = h2
84200b80:	4d 31 24 be 	rMAC = rMAC - r0 * r2 (SS), r1 = M[I0,M1], r2 = M[I7,M1];
   rMAC = r0*r2, M[I5, M0] = rMAC;                                //yp1 = h1 -x1*w1, rMAC = w2*x1
84200b84:	94 00 24 ce 	rMAC = r0 * r2 (SS), M[I5,M0] = rMAC;
   rMAC = rMAC + r7*r1;                                           //rMAC = h2 + w2*x1
84200b88:	3f 00 19 ac 	rMAC = rMAC + r7 * r1 (SS);
   M[I4, M1] = rMAC;                                              //out2 = h2 + w2*x2
84200b8c:	91 00 00 02 	Null = Null + Null, M[I4,M1] = rMAC;
   L4 = 0;
84200b90:	00 00 e0 51 	L4 = Null + 0;
#ifdef BASE_REGISTER_MODE
   push Null; 
84200b94:	00 00 00 f3 	push Null;
   pop B4;
84200b98:	00 00 c6 f3 	pop B4;
#endif   

   // copy from middle of window (forward)
   // I1 = wp(0)
   // I7 = wp(ov - 1)
   I1 = I1 + r4;
84200b9c:	00 00 16 5b 	I1 = I1 + r4;
   M2 = r4, r0 = M[I1, M0];
84200ba0:	6f 24 a0 50 	M2 = Null + r4, r0 = M[I1,M0];
   Addr2Words(r4);
84200ba4:	fe 00 66 91 	r4 = r4 ASHIFT -2;
   r0 = M[I5, M2];
84200ba8:	26 00 00 02 	Null = Null + Null, r0 = M[I5,M2];
   r10 = r4 - r6;
84200bac:	8f 00 c6 20 	r10 = r4 - r6;
   r10 = r10 - 1;
84200bb0:	3f 00 cc e4 	r10 = r10 - 1;
   if LE jump end_copy_bloop; 
84200bb4:	05 00 d0 dd 	if LE jump $M.celt.windowing_overlapadd.end_copy_bloop;
   r0 = M[I1, M0];
84200bb8:	00 24 00 02 	Null = Null + Null, r0 = M[I1,M0];
   do copy_bloop;
84200bbc:	02 00 f0 e5 	do $M.celt.windowing_overlapadd.copy_bloop;
      M[I5, M0] = r0, r0 = M[I1, M0];      
84200bc0:	a4 24 00 02 	Null = Null + Null, r0 = M[I1,M0], M[I5,M0] = r0;

84200bc4 <$M.celt.windowing_overlapadd.copy_bloop>:
   copy_bloop:
   M[I5, M0] = r0;
84200bc4:	a4 00 00 02 	Null = Null + Null, M[I5,M0] = r0;

84200bc8 <$M.celt.windowing_overlapadd.end_copy_bloop>:
   // window the last ov size and store to hist only
   // I1 = wp(0)
   // I7 = wp(ov-1)
   // I2 = hist(0)
   // I3 = hist(ov-1)
   r10 = r6 - 1;
84200bc8:	3f 00 c8 e4 	r10 = r6 - 1;
   Words2Addr(r6);
84200bcc:	02 00 88 91 	r6 = r6 ASHIFT 2;
   I4 = I3 - r6;
84200bd0:	8f 00 43 78 	I4 = I3 - r6;
   I7 = I7 + r6;
84200bd4:	00 00 78 5b 	I7 = I7 + r6;
   I2 = M3;
84200bd8:	0f 00 2b 58 	I2 = M3 + Null;
   I3 = M3 + r8, r0 = M[I1, M0];
84200bdc:	af 24 3b 58 	I3 = M3 + r8, r0 = M[I1,M0];
   I3 = I3 - M0, r2 = M[I4, M0];                         
84200be0:	40 00 38 7e 	I3 = I3 - M0, r2 = M[I4,M0];
   rMAC = r2*r0, r2 = M[I7, M1];
84200be4:	4d 00 42 ce 	rMAC = r2 * r0 (SS), r2 = M[I7,M1];
   do left_whist_loop;
84200be8:	04 00 f0 e5 	do $M.celt.windowing_overlapadd.left_whist_loop;
      rMAC = r0*r2, M[I3, M1] = rMAC, r2 = M[I4, M0];
84200bec:	40 9d 24 ce 	rMAC = r0 * r2 (SS), M[I3,M1] = rMAC, r2 = M[I4,M0];
      r0 = M[I1, M0];  
84200bf0:	00 24 00 02 	Null = Null + Null, r0 = M[I1,M0];
      rMAC = r0*r2, r2 = M[I7, M1], M[I2, M0] = rMAC;
84200bf4:	4d 98 24 ce 	rMAC = r0 * r2 (SS), M[I2,M0] = rMAC, r2 = M[I7,M1];

84200bf8 <$M.celt.windowing_overlapadd.left_whist_loop>:
   left_whist_loop:
   rMAC = r0*r2, M[I3, M1] = rMAC;
84200bf8:	4f 9d 12 cc 	rMAC = r0 * r2 (SS), M[I3,M1] = rMAC;
   M[I2, M0] = rMAC;
84200bfc:	00 98 00 02 	Null = Null + Null, M[I2,M0] = rMAC;
   rts;
84200c00:	0f 00 0d dc 	rts;

84200c04 <$celt.codec.init_tables>:
84200c04:	00 00 d0 f3 	push rLink;

   $celt.codec.init_tables:

   // push rLink onto stack
   push rLink;
   push r4;
84200c08:	00 00 60 f3 	push r4;
   r1 = r0;                 // mode
84200c0c:	0f 00 32 00 	r1 = r0 + Null;
   r3 = $all_modes;
84200c10:	70 00 00 fd 	r3 = Null + 7347316;
84200c14:	74 1c 50 01 
   Words2Addr(r0);
84200c18:	02 00 22 91 	r0 = r0 ASHIFT 2;
   r3 = M[r3 + r0];         // index into the appropriate mode
84200c1c:	00 00 52 d3 	r3 = M[r3 + r0];
   r4 = $all_modes_size;
84200c20:	70 00 00 fd 	r4 = Null + 7347328;
84200c24:	80 1c 60 01 
   r4 = M[r4 + r0];         // index into the appropriate mode size
84200c28:	00 00 62 d3 	r4 = M[r4 + r0];

   r8 = M[r5 + $celt.enc.CELT_MODE_OBJECT_FIELD];
84200c2c:	00 00 a7 d1 	r8 = M[r5 + 0];
   r7 = r8;
84200c30:	0f 00 9a 00 	r7 = r8 + Null;
   r0 = r8;
84200c34:	0f 00 2a 00 	r0 = r8 + Null;
   r10 = M[r4 + 0*MK1];
84200c38:	00 00 c6 d1 	r10 = M[r4 + 0];
   Words2Addr(r10);
84200c3c:	02 00 cc 91 	r10 = r10 ASHIFT 2;
   r8 = r8 + r10;
84200c40:	00 00 ac 03 	r8 = r8 + r10;
   Addr2Words(r10);
84200c44:	fe 00 cc 91 	r10 = r10 ASHIFT -2;
   r2 =  M[r3 + 0*MK1];
84200c48:	00 00 45 d1 	r2 = M[r3 + 0];
   call copytoramTables;
84200c4c:	62 00 f0 e1 	call $M.celt.codec.init_tables.copytoramTables;

   r10 = M[r4 + 1*MK1];
84200c50:	04 00 c6 d1 	r10 = M[r4 + 4];
   r2 =  M[r3 + 1*MK1];
84200c54:	04 00 45 d1 	r2 = M[r3 + 4];
   r0 = r8;
84200c58:	0f 00 2a 00 	r0 = r8 + Null;
   M[r7 + $celt.EBAND_OFFSET] = r0;
84200c5c:	24 00 29 d5 	M[r7 + 36] = r0;
   Words2Addr(r10);
84200c60:	02 00 cc 91 	r10 = r10 ASHIFT 2;
   r8 = r8 + r10;
84200c64:	00 00 ac 03 	r8 = r8 + r10;
   Addr2Words(r10);
84200c68:	fe 00 cc 91 	r10 = r10 ASHIFT -2;
#ifdef PACKED_TABLES_ARCH4
   call copytoramTables_upack3;
84200c6c:	79 00 f0 e1 	call $M.celt.codec.init_tables.copytoramTables_upack3;
#else
   call copytoramTables;
#endif

   r10 = M[r4 + 2*MK1];
84200c70:	08 00 c6 d1 	r10 = M[r4 + 8];
   r2 =  M[r3 + 2*MK1];
84200c74:	08 00 45 d1 	r2 = M[r3 + 8];
   r0 = r8;
84200c78:	0f 00 2a 00 	r0 = r8 + Null;
   M[r7 + $celt.ALLOCVECTORS_OFFSET] = r0;
84200c7c:	28 00 29 d5 	M[r7 + 40] = r0;
   Words2Addr(r10);
84200c80:	02 00 cc 91 	r10 = r10 ASHIFT 2;
   r8 = r8 + r10;
84200c84:	00 00 ac 03 	r8 = r8 + r10;
   Addr2Words(r10);
84200c88:	fe 00 cc 91 	r10 = r10 ASHIFT -2;
#ifdef PACKED_TABLES_ARCH4
   call copytoramTables_upack4;
84200c8c:	84 00 f0 e1 	call $M.celt.codec.init_tables.copytoramTables_upack4;
#else
   call copytoramTables;
#endif

   r2 =  M[r3 + 3*MK1];
84200c90:	0c 00 45 d1 	r2 = M[r3 + 12];
#ifdef CELT_TABLE_NO_FLASH_COPY
   M[r7 + $celt.WINDOW_OFFSET] = r2;
84200c94:	2c 00 49 d5 	M[r7 + 44] = r2;
   r8 = r8 + r10;
   Addr2Words(r10);
   call copytoramTables;
#endif

   r10 = M[r4 + 4*MK1];
84200c98:	10 00 c6 d1 	r10 = M[r4 + 16];
   r2 =  M[r3 + 4*MK1];
84200c9c:	10 00 45 d1 	r2 = M[r3 + 16];
   r0 = r8;
84200ca0:	0f 00 2a 00 	r0 = r8 + Null;
   M[r7 + $celt.PROB_OFFSET] = r0;
84200ca4:	30 00 29 d5 	M[r7 + 48] = r0;
   Words2Addr(r10);
84200ca8:	02 00 cc 91 	r10 = r10 ASHIFT 2;
   r8 = r8 + r10;
84200cac:	00 00 ac 03 	r8 = r8 + r10;
   Addr2Words(r10);
84200cb0:	fe 00 cc 91 	r10 = r10 ASHIFT -2;
#ifdef PACKED_TABLES_ARCH4
   call copytoramTables_upack2;
84200cb4:	4e 00 f0 e1 	call $M.celt.codec.init_tables.copytoramTables_upack2;
#else
   call copytoramTables;
#endif
   r10 = M[r4 + 5*MK1];
84200cb8:	14 00 c6 d1 	r10 = M[r4 + 20];
   r2 =  M[r3 + 5*MK1];
84200cbc:	14 00 45 d1 	r2 = M[r3 + 20];
   r0 = r8;
84200cc0:	0f 00 2a 00 	r0 = r8 + Null;
   M[r7 + $celt.BITS_OFFSET] = r0;
84200cc4:	34 00 29 d5 	M[r7 + 52] = r0;
   Words2Addr(r10);
84200cc8:	02 00 cc 91 	r10 = r10 ASHIFT 2;
   r8 = r8 + r10;
84200ccc:	00 00 ac 03 	r8 = r8 + r10;
   Addr2Words(r10);
84200cd0:	fe 00 cc 91 	r10 = r10 ASHIFT -2;
#ifdef PACKED_TABLES_ARCH4
   call copytoramTables_upack2;
84200cd4:	46 00 f0 e1 	call $M.celt.codec.init_tables.copytoramTables_upack2;
#else
   call copytoramTables;
#endif

   r2 =  M[r3 + 6*MK1];
84200cd8:	18 00 45 d1 	r2 = M[r3 + 24];
#ifdef CELT_TABLE_NO_FLASH_COPY
   M[r7 + $celt.EBANDS_DIF_SQRT_OFFSET] = r2;
84200cdc:	38 00 49 d5 	M[r7 + 56] = r2;
   r8 = r8 + r10;
   Addr2Words(r10);
   call copytoramTables;
#endif

   r2 =  M[r3 + 7*MK1];
84200ce0:	1c 00 45 d1 	r2 = M[r3 + 28];
#ifdef CELT_TABLE_NO_FLASH_COPY
   M[r7 + $celt.TRIG_OFFSET] = r2;
84200ce4:	3c 00 49 d5 	M[r7 + 60] = r2;
   call copytoramTables;
#endif

#ifdef CELT_TABLE_NO_FLASH_COPY

   r0 = &$celt.flaglist;
84200ce8:	70 00 00 fd 	r0 = Null + 7347468;
84200cec:	0c 1d 20 01 
   M[r5 + $celt.dec.PTR_FLAGLIST_TABLE_FIELD] = r0;
84200cf0:	10 02 27 d5 	M[r5 + 528] = r0;

   r0 = &$celt.eMeans;
84200cf4:	70 00 00 fd 	r0 = Null + 7347500;
84200cf8:	2c 1d 20 01 
   M[r5 + $celt.dec.PTR_EMEANS_TABLE_FIELD] = r0;
84200cfc:	14 02 27 d5 	M[r5 + 532] = r0;

   r0 = &$celt.maxN;
84200d00:	70 00 00 fd 	r0 = Null + 7347600;
84200d04:	90 1d 20 01 
   M[r5 + $celt.dec.PTR_MAX_N_TABLE_FIELD]= r0;
84200d08:	18 02 27 d5 	M[r5 + 536] = r0;

   r0 = &$celt.maxK;
84200d0c:	70 00 00 fd 	r0 = Null + 7347660;
84200d10:	cc 1d 20 01 
   M[r5 + $celt.dec.PTR_MAX_K_TABLE_FIELD] = r0;
84200d14:	1c 02 27 d5 	M[r5 + 540] = r0;

   r0 = &$celt.inv2;
84200d18:	70 00 00 fd 	r0 = Null + 7347720;
84200d1c:	08 1e 20 01 
   M[r5 + $celt.dec.PTR_INV2_TABLE_FIELD]= r0;
84200d20:	20 02 27 d5 	M[r5 + 544] = r0;

   NULL = r6 ;
84200d24:	0f 00 08 00 	Null = r6 + Null;
   if NZ jump encoder_table;
84200d28:	15 00 10 dd 	if NE jump $M.celt.codec.init_tables.encoder_table;
   r0 = &$celt.transientWindow;
84200d2c:	70 00 00 fd 	r0 = Null + 7347340;
84200d30:	8c 1c 20 01 
   M[r5 + $celt.dec.PTR_TRANSIENT_WINDOW_TABLE_FIELD] = r0;
84200d34:	0c 02 27 d5 	M[r5 + 524] = r0;

   r0 = &$celt.decode_jump_table;
84200d38:	70 00 00 fd 	r0 = Null + 7347752;
84200d3c:	28 1e 20 01 
   M[r5 + $celt.dec.DEC_JUMP_TABLE_FIELD] = r0;
84200d40:	24 02 27 d5 	M[r5 + 548] = r0;
   r0 = M[r5 + $celt.dec.DEC_JUMP_TABLE_FIELD];
   r2 = &$celt.decode_jump_table;
   r10 = 5;
   call copytoramTables;
#endif
   r0 = M[r5 + $celt.dec.PTR_MODE_DM1SCRATCH_ALLOC];
84200d44:	28 02 27 d1 	r0 = M[r5 + 552];
   r2 = $dec_mode_dm1scratch_alloc;
84200d48:	70 00 00 fd 	r2 = Null + 7347076;
84200d4c:	84 1b 40 01 
   Words2Addr(r1);
84200d50:	02 00 33 91 	r1 = r1 ASHIFT 2;
   r2 = M[r2 + r1];
84200d54:	00 00 43 d3 	r2 = M[r2 + r1];
   r10 = 14;
84200d58:	0e 00 c0 01 	r10 = Null + 14;
#ifdef PACKED_TABLES_ARCH4
   //r10 = $celt.dec.DM1_SCRATCH_FIELDS_LENGTH_ARCH4_PACKED;
   call copytoramTables_upack2;
84200d5c:	24 00 f0 e1 	call $M.celt.codec.init_tables.copytoramTables_upack2;
#else
  // r10 = $celt.dec.DM1_SCRATCH_FIELDS_LENGTH;
   call copytoramTables;
#endif

   r0 = M[r5 + $celt.dec.PTR_MODE_DM2SCRATCH_ALLOC];
84200d60:	2c 02 27 d1 	r0 = M[r5 + 556];
   r2 = $dec_mode_dm2scratch_alloc;
84200d64:	70 00 00 fd 	r2 = Null + 7347088;
84200d68:	90 1b 40 01 
   r2 = M[r2 + r1];
84200d6c:	00 00 43 d3 	r2 = M[r2 + r1];
   r10 = 13;
84200d70:	0d 00 c0 01 	r10 = Null + 13;
#ifdef PACKED_TABLES_ARCH4
   //r10 = $celt.dec.DM2_SCRATCH_FIELDS_LENGTH_ARCH4_PACKED;
   call copytoramTables_upack2_odd;
84200d74:	29 00 f0 e1 	call $M.celt.codec.init_tables.copytoramTables_upack2_odd;
#else
   //r10 = $celt.dec.DM2_SCRATCH_FIELDS_LENGTH;
   call copytoramTables;
#endif

   jump tables_set;
84200d78:	14 00 f0 dd 	jump $M.celt.codec.init_tables.tables_set;

84200d7c <$M.celt.codec.init_tables.encoder_table>:

encoder_table:
#ifdef CELT_TABLE_NO_FLASH_COPY
   r0 = &$celt.inv_transientWindow;
84200d7c:	70 00 00 fd 	r0 = Null + 7347404;
84200d80:	cc 1c 20 01 
   M[r5 + $celt.enc.PTR_INV_TRANSIENT_WINDOW_TABLE_FIELD] = r0;
84200d84:	0c 02 27 d5 	M[r5 + 524] = r0;

   r0 = &$celt.encode_jump_table;
84200d88:	70 00 00 fd 	r0 = Null + 7347772;
84200d8c:	3c 1e 20 01 
   M[r5 + $celt.enc.ENC_JUMP_TABLE_FIELD] = r0;
84200d90:	24 02 27 d5 	M[r5 + 548] = r0;
   r0 = M[r5 + $celt.enc.ENC_JUMP_TABLE_FIELD];
   r2 = &$celt.encode_jump_table;
   r10 = 5;
   call copytoramTables;
#endif
   r0 = M[r5 + $celt.enc.PTR_MODE_DM1SCRATCH_ALLOC];
84200d94:	28 02 27 d1 	r0 = M[r5 + 552];
   r2 = $enc_mode_dm1scratch_alloc;
84200d98:	70 00 00 fd 	r2 = Null + 7347100;
84200d9c:	9c 1b 40 01 
   Words2Addr(r1);
84200da0:	02 00 33 91 	r1 = r1 ASHIFT 2;
   r2 = M[r2 + r1];
84200da4:	00 00 43 d3 	r2 = M[r2 + r1];
   r10 = 14;
84200da8:	0e 00 c0 01 	r10 = Null + 14;
#ifdef PACKED_TABLES_ARCH4
  // r10 = $celt.dec.DM1_SCRATCH_FIELDS_LENGTH_ARCH4_PACKED;
   call copytoramTables_upack2;
84200dac:	10 00 f0 e1 	call $M.celt.codec.init_tables.copytoramTables_upack2;
#else
   r10 = $celt.dec.DM1_SCRATCH_FIELDS_LENGTH;
   call copytoramTables;
#endif

   r0 = M[r5 + $celt.enc.PTR_MODE_DM2SCRATCH_ALLOC];
84200db0:	2c 02 27 d1 	r0 = M[r5 + 556];
   r2 = $enc_mode_dm2scratch_alloc;
84200db4:	70 00 00 fd 	r2 = Null + 7347112;
84200db8:	a8 1b 40 01 
   r2 = M[r2 + r1];
84200dbc:	00 00 43 d3 	r2 = M[r2 + r1];
   r10 = 13;
84200dc0:	0d 00 c0 01 	r10 = Null + 13;
#ifdef PACKED_TABLES_ARCH4
  // r10 = $celt.dec.DM2_SCRATCH_FIELDS_LENGTH_ARCH4_PACKED;
   call copytoramTables_upack2_odd;
84200dc4:	15 00 f0 e1 	call $M.celt.codec.init_tables.copytoramTables_upack2_odd;

84200dc8 <$M.celt.codec.init_tables.tables_set>:
   r10 = $celt.dec.DM2_SCRATCH_FIELDS_LENGTH;
   call copytoramTables;
#endif

tables_set:
   pop r4;
84200dc8:	00 00 64 f3 	pop r4;
   jump $pop_rLink_and_rts;
84200dcc:	03 00 00 fd 	jump (m) 0x3b020;
84200dd0:	21 b0 f0 dd 

84200dd4 <$M.celt.codec.init_tables.copytoramTables>:
  // r0  = RAM ADDRESS
  // r2  = DMCONST ADDRESS
  // r10 = number of coefficients to copy
  // *************************************************************************
copytoramTables:
   I4 = r0;
84200dd4:	2f 00 40 50 	I4 = Null + r0;
   I1 = r2;
84200dd8:	4f 00 10 50 	I1 = Null + r2;
   r0 = M[I1,MK1];
84200ddc:	00 25 00 03 	Null = Null + Null, r0 = M[I1,4];
   do copy_celt_table_to_ram;
84200de0:	02 00 f0 e5 	do $M.celt.codec.init_tables.copy_celt_table_to_ram;
      r0 = M[I1,MK1] , M[I4,MK1] = r0;
84200de4:	a1 25 00 03 	Null = Null + Null, r0 = M[I1,4], M[I4,4] = r0;

84200de8 <$M.celt.codec.init_tables.copy_celt_table_to_ram>:
   copy_celt_table_to_ram:

   rts;
84200de8:	0f 00 0d dc 	rts;

84200dec <$M.celt.codec.init_tables.copytoramTables_upack2>:
  // r0  = RAM ADDRESS
  // r2  = DMCONST ADDRESS
  // r10 = number of coefficients to copy
  // *************************************************************************
copytoramTables_upack2:
   I4 = r0;
84200dec:	2f 00 40 50 	I4 = Null + r0;
   I1 = r2;
84200df0:	4f 00 10 50 	I1 = Null + r2;
   r0 = M[I1,MK1];
84200df4:	00 25 00 03 	Null = Null + Null, r0 = M[I1,4];
   r10 = r10 LSHIFT -1;
84200df8:	ff 00 cc 8d 	r10 = r10 LSHIFT -1;
   do copy_celt_table_to_ram_upack2;
84200dfc:	06 00 f0 e5 	do $M.celt.codec.init_tables.copy_celt_table_to_ram_upack2;
      r2 = r0 AND 0x0000FFFF;
84200e00:	ff ff 42 81 	r2 = r0 AND 0xffff;
      M[I4,MK1] = r2;
84200e04:	c1 00 00 03 	Null = Null + Null, M[I4,4] = r2;
      r2 = r0 ASHIFT -16 ;
84200e08:	f0 00 42 91 	r2 = r0 ASHIFT -16;
      r2 = r2 AND 0x0000FFFF;
84200e0c:	ff ff 44 81 	r2 = r2 AND 0xffff;
      r0 = M[I1,MK1] , M[I4,MK1] = r2;
84200e10:	c1 25 00 03 	Null = Null + Null, r0 = M[I1,4], M[I4,4] = r2;

84200e14 <$M.celt.codec.init_tables.copy_celt_table_to_ram_upack2>:
   copy_celt_table_to_ram_upack2:


   rts;
84200e14:	0f 00 0d dc 	rts;

84200e18 <$M.celt.codec.init_tables.copytoramTables_upack2_odd>:
  // r0  = RAM ADDRESS
  // r2  = DMCONST ADDRESS
  // r10 = number of coefficients to copy
  // *************************************************************************
copytoramTables_upack2_odd:
   I4 = r0;
84200e18:	2f 00 40 50 	I4 = Null + r0;
   I1 = r2;
84200e1c:	4f 00 10 50 	I1 = Null + r2;
   r10 = r10 - 1;
84200e20:	3f 00 cc e4 	r10 = r10 - 1;
   r10 = r10 LSHIFT -1;
84200e24:	ff 00 cc 8d 	r10 = r10 LSHIFT -1;
   r0 = M[I1,MK1];
84200e28:	00 25 00 03 	Null = Null + Null, r0 = M[I1,4];
   do copy_celt_table_to_ram_upack2_odd;
84200e2c:	06 00 f0 e5 	do $M.celt.codec.init_tables.copy_celt_table_to_ram_upack2_odd;
      r2 = r0 AND 0x0000FFFF;
84200e30:	ff ff 42 81 	r2 = r0 AND 0xffff;
      M[I4,MK1] = r2;
84200e34:	c1 00 00 03 	Null = Null + Null, M[I4,4] = r2;
      r2 = r0 ASHIFT -16 ;
84200e38:	f0 00 42 91 	r2 = r0 ASHIFT -16;
      r2 = r2 AND 0x0000FFFF;
84200e3c:	ff ff 44 81 	r2 = r2 AND 0xffff;
      r0 = M[I1,MK1] , M[I4,MK1] = r2;
84200e40:	c1 25 00 03 	Null = Null + Null, r0 = M[I1,4], M[I4,4] = r2;

84200e44 <$M.celt.codec.init_tables.copy_celt_table_to_ram_upack2_odd>:
   copy_celt_table_to_ram_upack2_odd:
    r2 = r0 AND 0x0000FFFF;
84200e44:	ff ff 42 81 	r2 = r0 AND 0xffff;
    M[I4,MK1] = r2;
84200e48:	c1 00 00 03 	Null = Null + Null, M[I4,4] = r2;

   rts;
84200e4c:	0f 00 0d dc 	rts;

84200e50 <$M.celt.codec.init_tables.copytoramTables_upack3>:
  // r0  = RAM ADDRESS
  // r2  = DMCONST ADDRESS
  // r10 = number of coefficients to copy
  // *************************************************************************
copytoramTables_upack3:
   I4 = r0;
84200e50:	2f 00 40 50 	I4 = Null + r0;
   I1 = r2;
84200e54:	4f 00 10 50 	I1 = Null + r2;
   r10 = 8 ;
84200e58:	08 00 c0 01 	r10 = Null + 8;
   //r10 = r10 - 1 ;
   r0 = M[I1,MK1];
84200e5c:	00 25 00 03 	Null = Null + Null, r0 = M[I1,4];
   do copy_celt_table_to_ram_upack3;
84200e60:	09 00 f0 e5 	do $M.celt.codec.init_tables.copy_celt_table_to_ram_upack3;
      r2 = r0 AND 0x000003FF;
84200e64:	ff 03 42 81 	r2 = r0 AND 0x3ff;
      M[I4,MK1] = r2;
84200e68:	c1 00 00 03 	Null = Null + Null, M[I4,4] = r2;
      r2 = r0 LSHIFT -10 ;
84200e6c:	f6 00 42 8d 	r2 = r0 LSHIFT -10;
      r2 = r2 AND 0x000003FF;
84200e70:	ff 03 44 81 	r2 = r2 AND 0x3ff;
      M[I4,MK1] = r2;
84200e74:	c1 00 00 03 	Null = Null + Null, M[I4,4] = r2;
      r2 = r0 LSHIFT -20 ;
84200e78:	ec 00 42 8d 	r2 = r0 LSHIFT -20;
      r2 = r2 AND 0x000003FF;
84200e7c:	ff 03 44 81 	r2 = r2 AND 0x3ff;
      r0 = M[I1,MK1] , M[I4,MK1] = r2;
84200e80:	c1 25 00 03 	Null = Null + Null, r0 = M[I1,4], M[I4,4] = r2;

84200e84 <$M.celt.codec.init_tables.copy_celt_table_to_ram_upack3>:
   copy_celt_table_to_ram_upack3:
      r2 = r0 AND 0x000003FF;
84200e84:	ff 03 42 81 	r2 = r0 AND 0x3ff;
      M[I4,MK1] = r2;
84200e88:	c1 00 00 03 	Null = Null + Null, M[I4,4] = r2;
      r2 = r0 LSHIFT -10 ;
84200e8c:	f6 00 42 8d 	r2 = r0 LSHIFT -10;
      r2 = r2 AND 0x000003FF;
84200e90:	ff 03 44 81 	r2 = r2 AND 0x3ff;
      M[I4,MK1] = r2;
84200e94:	c1 00 00 03 	Null = Null + Null, M[I4,4] = r2;
   rts;
84200e98:	0f 00 0d dc 	rts;

84200e9c <$M.celt.codec.init_tables.copytoramTables_upack4>:
  // r0  = RAM ADDRESS
  // r2  = DMCONST ADDRESS
  // r10 = number of coefficients to copy
  // *************************************************************************
copytoramTables_upack4:
   I4 = r0;
84200e9c:	2f 00 40 50 	I4 = Null + r0;
   I1 = r2;
84200ea0:	4f 00 10 50 	I1 = Null + r2;
   r10 = r10 LSHIFT -2;
84200ea4:	fe 00 cc 8d 	r10 = r10 LSHIFT -2;
   r0 = M[I1,MK1];
84200ea8:	00 25 00 03 	Null = Null + Null, r0 = M[I1,4];
   do copy_celt_table_to_ram_upack4;
84200eac:	0c 00 f0 e5 	do $M.celt.codec.init_tables.copy_celt_table_to_ram_upack4;
      r2 = r0 AND 0x000000FF;
84200eb0:	ff 00 42 81 	r2 = r0 AND 0xff;
      M[I4,MK1] = r2;
84200eb4:	c1 00 00 03 	Null = Null + Null, M[I4,4] = r2;
      r2 = r0 LSHIFT -8 ;
84200eb8:	f8 00 42 8d 	r2 = r0 LSHIFT -8;
      r2 = r2 AND 0x000000FF;
84200ebc:	ff 00 44 81 	r2 = r2 AND 0xff;
      M[I4,MK1] = r2;
84200ec0:	c1 00 00 03 	Null = Null + Null, M[I4,4] = r2;
      r2 = r0 LSHIFT -16 ;
84200ec4:	f0 00 42 8d 	r2 = r0 LSHIFT -16;
      r2 = r2 AND 0x000000FF;
84200ec8:	ff 00 44 81 	r2 = r2 AND 0xff;
      M[I4,MK1] = r2;
84200ecc:	c1 00 00 03 	Null = Null + Null, M[I4,4] = r2;
      r2 = r0 LSHIFT -24 ;
84200ed0:	e8 00 42 8d 	r2 = r0 LSHIFT -24;
      r2 = r2 AND 0x000000FF;
84200ed4:	ff 00 44 81 	r2 = r2 AND 0xff;
      r0 = M[I1,MK1] , M[I4,MK1] = r2;
84200ed8:	c1 25 00 03 	Null = Null + Null, r0 = M[I1,4], M[I4,4] = r2;

84200edc <$M.celt.codec.init_tables.copy_celt_table_to_ram_upack4>:
   copy_celt_table_to_ram_upack4:

   rts;
84200edc:	0f 00 0d dc 	rts;

84200ee0 <$celt.ec_dec_init>:
84200ee0:	00 00 d0 f3 	push rLink;

   // push rLink onto stack
   push rlink;

   // get rem
   call $celt.get1byte;
84200ee4:	d2 0b f0 e1 	call $celt.get1byte;
   M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_REM] = r1;
84200ee8:	a4 01 37 d5 	M[r5 + 420] = r1;
   
   // init rng
   r2 = 1<<$celt.EC_CODE_EXTRA;
84200eec:	80 00 40 01 	r2 = Null + 128;
   M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_RNG + 0] = r2;
84200ef0:	a8 01 47 d5 	M[r5 + 424] = r2;
   M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_RNG + MK1] = 0;
84200ef4:	ac 01 07 d5 	M[r5 + 428] = Null;

   // init diff
   r1 = r1 LSHIFT (-$celt.EC_SYM_BITS+$celt.EC_CODE_EXTRA);
84200ef8:	ff 00 33 8d 	r1 = r1 LSHIFT -1;
   r1 = r2 - r1; // 0x80 - (r1>>1), (borrow impossible)
84200efc:	3f 00 34 20 	r1 = r2 - r1;
   r2 = Null - Null -borrow;
84200f00:	0f 00 40 24 	r2 = Null - Null - Borrow;
#ifdef K32
   $celt.NATIVE_WORD32_CONVERT(r2,r1)
84200f04:	18 00 44 8d 	r2 = r2 LSHIFT 24;
84200f08:	00 00 34 87 	r1 = r1 OR r2;
84200f0c:	00 00 40 01 	r2 = Null + 0;
#endif
   M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_DIF + 0] = r1;
84200f10:	b0 01 37 d5 	M[r5 + 432] = r1;
   M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_DIF + MK1] = r2;
84200f14:	b4 01 47 d5 	M[r5 + 436] = r2;

   // Normalise the interval
   call $celt.ec_dec_normalise;
84200f18:	05 00 f0 e1 	call $celt.ec_dec_normalise;

   // reset bits reading from end of buffer
   M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_END_BITS_LEFT] = Null;
84200f1c:	c4 01 07 d5 	M[r5 + 452] = Null;
   M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_NB_END_BITS] = Null;
84200f20:	c8 01 07 d5 	M[r5 + 456] = Null;



   // pop rLink from stack
   jump $pop_rLink_and_rts;
84200f24:	03 00 00 fd 	jump (m) 0x3b020;
84200f28:	21 b0 f0 dd 

84200f2c <$celt.ec_dec_normalise>:
#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.EC_DEC_NORMALISE.PATCH_ID_0,r4)     // celt_patchers
#endif
   
   // push rLink onto stack
    push rlink;
84200f2c:	00 00 d0 f3 	push rLink;
   M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_DIF + MK1] = r8;

#else // K32

   // rng=r4
   r4 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_RNG];
84200f30:	a8 01 67 d1 	r4 = M[r5 + 424];
   // rem = rMAC
   rMAC = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_REM];
84200f34:	a4 01 17 d1 	rMAC = M[r5 + 420];
   // dif = r7
   r7 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_DIF];
84200f38:	b0 01 97 d1 	r7 = M[r5 + 432];

84200f3c <$M.celt.ec_dec_normalise.retry>:
   retry:
      // see if range is still small
      r0 = r4 - ($celt.EC_CODE_BOT+1);
84200f3c:	80 00 00 fd 	r0 = r4 - 8388609;
84200f40:	01 00 26 21 
      if C jump end;
84200f44:	0d 00 20 dd 	if C jump $M.celt.ec_dec_normalise.end;
         // update range
         r4 = r4 LSHIFT 8;
84200f48:	08 00 66 8d 	r4 = r4 LSHIFT 8;
         // read next byte from input buffer
         call $celt.get1byte;
84200f4c:	b8 0b f0 e1 	call $celt.get1byte;
         // use the ramining bits
         rMAC = rMAC LSHIFT $celt.EC_CODE_EXTRA;
84200f50:	07 00 e1 8d 	rMAC = rMAC LSHIFT 7 (MI);
         rMAC = rMAC AND $celt.EC_SYM_MAX;
84200f54:	ff 00 11 81 	rMAC = rMAC AND 0xff;
         r0 = r1 LSHIFT ($celt.EC_CODE_EXTRA-$celt.EC_SYM_BITS);
84200f58:	ff 00 23 8d 	r0 = r1 LSHIFT -1;
         rMAC = rMAC OR r0;
84200f5c:	00 00 12 87 	rMAC = rMAC OR r0;
         r7 = r7 LSHIFT 8;
84200f60:	08 00 99 8d 	r7 = r7 LSHIFT 8;
         r7 = r7 - rMAC;
84200f64:	00 00 91 23 	r7 = r7 - rMAC;
         r7 = r7 AND 0x7FFFFFFF;
84200f68:	ff 7f 00 fd 	r7 = r7 AND 0x7fffffff;
84200f6c:	ff ff 99 81 
         rMAC = r1;
84200f70:	0f 00 13 00 	rMAC = r1 + Null;
   jump retry;
84200f74:	f2 ff f0 dd 	jump $M.celt.ec_dec_normalise.retry;

84200f78 <$M.celt.ec_dec_normalise.end>:
   end:
   // rng = r4
   M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_RNG] = r4;
84200f78:	a8 01 67 d5 	M[r5 + 424] = r4;
   // rem = rMAC
   M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_REM] = rMAC;
84200f7c:	a4 01 17 d5 	M[r5 + 420] = rMAC;
   // dif = r7
   M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_DIF] = r7;
84200f80:	b0 01 97 d5 	M[r5 + 432] = r7;

#endif // K32

    // pop rLink from stack
   jump $pop_rLink_and_rts;
84200f84:	03 00 00 fd 	jump (m) 0x3b020;
84200f88:	21 b0 f0 dd 

84200f8c <$celt.ec_decode>:
#if defined(PATCH_LIBS)
   LIBS_PUSH_REGS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.EC_DECODE.PATCH_ID_0)     // celt_patchers
#endif
   
   // push rLink onto stack
   push rlink;
84200f8c:	00 00 d0 f3 	push rLink;
   //ft = r0:r0
   M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FT + 0] = r0;
84200f90:	cc 01 27 d5 	M[r5 + 460] = r0;
   M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FT + MK1] = r1;
84200f94:	d0 01 37 d5 	M[r5 + 464] = r1;
   r2 = r0;
84200f98:	0f 00 42 00 	r2 = r0 + Null;
   r3 = r1;
84200f9c:	0f 00 53 00 	r3 = r1 + Null;
   r0 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_RNG + 0];
84200fa0:	a8 01 27 d1 	r0 = M[r5 + 424];
   r1 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_RNG + MK1];
84200fa4:	ac 01 37 d1 	r1 = M[r5 + 428];
#ifdef DEBUG_ON
#ifdef K32
if NZ call $error; // K32: highword should be zero
#endif
#endif
   call $celt.idiv32;
84200fa8:	f5 0b f0 e1 	call $celt.idiv32;

84200fac <$celt.ec_decode.bin_jump>:
   // label for jumping from $celt.ec_decode_bin
   $celt.ec_decode.bin_jump:
   // save norm = rng/inp
   M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_NRM + 0] = r6;
84200fac:	b8 01 87 d5 	M[r5 + 440] = r6;
   M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_NRM + MK1] = r7;
84200fb0:	bc 01 97 d5 	M[r5 + 444] = r7;
   r2 = r6;
84200fb4:	0f 00 48 00 	r2 = r6 + Null;
   r3 = r7;
84200fb8:	0f 00 59 00 	r3 = r7 + Null;
   r0 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_DIF + 0];
84200fbc:	b0 01 27 d1 	r0 = M[r5 + 432];
   r1 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_DIF + MK1];
84200fc0:	b4 01 37 d1 	r1 = M[r5 + 436];
   r0 = r0 - 1;
84200fc4:	3f 00 22 e4 	r0 = r0 - 1;
   r1 = r1 - borrow;
84200fc8:	00 00 30 27 	r1 = r1 - Null - Borrow;
#ifdef DEBUG_ON
#ifdef K32
if NZ call $error; // K32: highword should be zero
#endif
#endif
   call $celt.idiv32;
84200fcc:	ec 0b f0 e1 	call $celt.idiv32;
   r2 = r6 + 1;
84200fd0:	2f 00 48 e4 	r2 = r6 + 1;
   r3 = r7 + carry;
84200fd4:	0f 00 59 04 	r3 = r7 + Null + Carry;
   r0 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FT + 0];
84200fd8:	cc 01 27 d1 	r0 = M[r5 + 460];
   r1 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FT + MK1];
84200fdc:	d0 01 37 d1 	r1 = M[r5 + 464];
   r0 = r0 - r2;
84200fe0:	00 00 24 23 	r0 = r0 - r2;
   r1 = r1 - r3 - borrow;
84200fe4:	00 00 35 27 	r1 = r1 - r3 - Borrow;
   if POS jump end;
84200fe8:	03 00 50 dd 	if POS jump $M.celt.ec_decode.end;
     r0 = 0;
84200fec:	00 00 20 01 	r0 = Null + 0;
     r1 = 0;
84200ff0:	00 00 30 01 	r1 = Null + 0;

84200ff4 <$M.celt.ec_decode.end>:
   end:
   // pop rLink from stack
   jump $pop_rLink_and_rts;
84200ff4:	03 00 00 fd 	jump (m) 0x3b020;
84200ff8:	21 b0 f0 dd 

84200ffc <$celt.ec_decode_bin>:

#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.EC_DECODE_BIN.PATCH_ID_0,r1)     // celt_patchers
#endif
   
   push rlink;
84200ffc:	00 00 d0 f3 	push rLink;
   r0 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_RNG + 0];
84201000:	a8 01 27 d1 	r0 = M[r5 + 424];
   r1 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_RNG + MK1];
84201004:	ac 01 37 d1 	r1 = M[r5 + 428];
#ifdef DEBUG_ON
#ifdef K32
if NZ call $error; // K32: high word should be zero
#endif
#endif  
   r0 = r0 LSHIFT -15;
84201008:	f1 00 22 8d 	r0 = r0 LSHIFT -15;
   r1 = r1 LSHIFT (24-15);
8420100c:	09 00 33 8d 	r1 = r1 LSHIFT 9;
   r6 = r0 + r1;
84201010:	3f 00 82 00 	r6 = r0 + r1;
   r0 = 32768;
84201014:	00 00 00 fd 	r0 = Null + 32768;
84201018:	00 80 20 01 
   M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FT + 0] = r0;
8420101c:	cc 01 27 d5 	M[r5 + 460] = r0;
   M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FT + MK1] = Null;
84201020:	d0 01 07 d5 	M[r5 + 464] = Null;
   r7 = 0;
84201024:	00 00 90 01 	r7 = Null + 0;
   jump $celt.ec_decode.bin_jump;
84201028:	e1 ff f0 dd 	jump $celt.ec_decode.bin_jump;

8420102c <$celt.ec_dec_update>:
#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.EC_DEC_UPDATE.PATCH_ID_0,r1)     // celt_patchers
#endif

   // push rLink onto stack
   push rlink;
8420102c:	00 00 d0 f3 	push rLink;

   r0 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FT + 0];
84201030:	cc 01 27 d1 	r0 = M[r5 + 460];
   r1 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FT + MK1];
84201034:	d0 01 37 d1 	r1 = M[r5 + 464];
   rMAC = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FH + 0];
84201038:	dc 01 17 d1 	rMAC = M[r5 + 476];
   rMACB = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FH + MK1];
8420103c:	e0 01 f7 d1 	rMACB = M[r5 + 480];
   r0 = r0 - rMAC;
84201040:	00 00 21 23 	r0 = r0 - rMAC;
   r1 = r1 - rMACB - borrow;
84201044:	00 00 3f 27 	r1 = r1 - rMACB - Borrow;
#ifdef DEBUG_ON
#ifdef K32
if NZ call $error; // K32: high word should be zero
#endif
#endif  
   r2 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_NRM + 0];
84201048:	b8 01 47 d1 	r2 = M[r5 + 440];
   r3 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_NRM + MK1];
8420104c:	bc 01 57 d1 	r3 = M[r5 + 444];

   //IMUL32 , TODO:BC7OPT
   rMAC = r0*r2(UU);
84201050:	4f 00 12 c0 	rMAC = r0 * r2 (UU);
   r6 = rMAC LSHIFT (DAWTH-1);
84201054:	1f 00 81 8d 	r6 = rMAC LSHIFT 31;
#ifdef K32
   r7 = 0;
84201058:	00 00 90 01 	r7 = Null + 0;
   rMAC = rMAC + r3*r0(SU);
   r7 = rMAC LSHIFT 23;
#endif

   //update dif
   r0 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_DIF + 0];
8420105c:	b0 01 27 d1 	r0 = M[r5 + 432];
   r1 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_DIF + MK1];
84201060:	b4 01 37 d1 	r1 = M[r5 + 436];
   r0 = r0 - r6;
84201064:	00 00 28 23 	r0 = r0 - r6;
   r1 = r1 - r7 -borrow;
84201068:	00 00 39 27 	r1 = r1 - r7 - Borrow;
#ifdef DEBUG_ON
#ifdef K32
if NZ call $error; // K32: high word should be zero
#endif
#endif   
   M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_DIF + 0] = r0;
8420106c:	b0 01 27 d5 	M[r5 + 432] = r0;
   M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_DIF + MK1] = r1;
84201070:	b4 01 37 d5 	M[r5 + 436] = r1;

   // update rng
   r0 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FL + 0];
84201074:	d4 01 27 d1 	r0 = M[r5 + 468];
   r1 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FL + MK1];
84201078:	d8 01 37 d1 	r1 = M[r5 + 472];
   NULL = r1 OR r0;
8420107c:	2f 00 03 84 	Null = r1 OR r0;
   if NZ jump calc_rng_norm;
84201080:	08 00 10 dd 	if NE jump $M.celt.ec_dec_update.calc_rng_norm;
      r0 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_RNG + 0];
84201084:	a8 01 27 d1 	r0 = M[r5 + 424];
      r1 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_RNG + MK1];
84201088:	ac 01 37 d1 	r1 = M[r5 + 428];
      r4 = r0 - r6;
8420108c:	8f 00 62 20 	r4 = r0 - r6;
      r6 = r1 - r7 - borrow;
84201090:	9f 00 83 24 	r6 = r1 - r7 - Borrow;
#ifdef DEBUG_ON
#ifdef K32
if NZ call $error; // K32: high word should be zero
#endif
#endif        
      M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_RNG + 0] = r4;
84201094:	a8 01 67 d5 	M[r5 + 424] = r4;
      M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_RNG + MK1] = r6;
84201098:	ac 01 87 d5 	M[r5 + 428] = r6;


      jump norm_dec;
8420109c:	0c 00 f0 dd 	jump $M.celt.ec_dec_update.norm_dec;

842010a0 <$M.celt.ec_dec_update.calc_rng_norm>:
   calc_rng_norm:
   r0 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FH + 0];
842010a0:	dc 01 27 d1 	r0 = M[r5 + 476];
   r1 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FH + MK1];
842010a4:	e0 01 37 d1 	r1 = M[r5 + 480];
   rMAC = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FL + 0];
842010a8:	d4 01 17 d1 	rMAC = M[r5 + 468];
   rMACB = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FL + MK1];
842010ac:	d8 01 f7 d1 	rMACB = M[r5 + 472];
   r0 = r0 - rMAC;
842010b0:	00 00 21 23 	r0 = r0 - rMAC;
   r1 = r1 - rMACB - borrow;
842010b4:	00 00 3f 27 	r1 = r1 - rMACB - Borrow;
#ifdef K32
if NZ call $error; // K32: high word should be zero
#endif
#endif     
   //IMUL32 , TODO:BC7OPT
   rMAC = r0*r2(UU);
842010b8:	4f 00 12 c0 	rMAC = r0 * r2 (UU);
   r6 = rMAC LSHIFT (DAWTH-1);
842010bc:	1f 00 81 8d 	r6 = rMAC LSHIFT 31;
#ifdef K32
   r7 = 0;
842010c0:	00 00 90 01 	r7 = Null + 0;
   rMAC = rMAC + r3*r0(SU);
   r7 = rMAC LSHIFT 23;
#endif

   //IMUL32
   M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_RNG + 0] = r6;
842010c4:	a8 01 87 d5 	M[r5 + 424] = r6;
   M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_RNG + MK1] = r7;
842010c8:	ac 01 97 d5 	M[r5 + 428] = r7;

842010cc <$M.celt.ec_dec_update.norm_dec>:
   norm_dec:
   // normalise
   call $celt.ec_dec_normalise;
842010cc:	98 ff f0 e1 	call $celt.ec_dec_normalise;

   // pop rLink from stack
   jump $pop_rLink_and_rts;
842010d0:	03 00 00 fd 	jump (m) 0x3b020;
842010d4:	21 b0 f0 dd 

842010d8 <$celt.ec_dec_bits>:
   
   // push rLink onto stack
   // r2=ftb
   .CONST TEMP_T               (0 + 2)*ADDR_PER_WORD;
   .CONST STACK_FRAME_SIZE     2*ADDR_PER_WORD;
   pushm <FP(=SP), rLink>;
842010d8:	01 20 00 f1 	pushm <FP(=SP), rLink>;
   SP = SP + STACK_FRAME_SIZE;
842010dc:	08 00 03 f1 	SP = SP + 8;
   M[FP + TEMP_T + 0] = Null;
842010e0:	08 00 0c f1 	M[FP + 0x8] = Null;
   M[FP + TEMP_T + MK1] =  Null;
842010e4:	0c 00 0c f1 	M[FP + 0xc] = Null;
   r2 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FTB];
842010e8:	e4 01 47 d1 	r2 = M[r5 + 484];

842010ec <$M.celt.ec_dec_bits.loop_check_ftp>:
   loop_check_ftp:
      Null = r2 - $celt.EC_UNIT_BITS;
842010ec:	08 00 04 21 	Null = r2 - 8;
      if NEG jump end_check_ftp;
842010f0:	11 00 40 dd 	if NEG jump $M.celt.ec_dec_bits.end_check_ftp;
      r8 = $celt.EC_UNIT_BITS;
842010f4:	08 00 a0 01 	r8 = Null + 8;
      call $celt.ec_decode_raw;
842010f8:	1e 00 f0 e1 	call $celt.ec_decode_raw;
      r2 = M[FP + TEMP_T + 0];
842010fc:	08 00 48 f1 	r2 = M[FP + 0x8];
      r3 = M[FP + TEMP_T + MK1];
84201100:	0c 00 58 f1 	r3 = M[FP + 0xc];
      r3 = r3 LSHIFT  $celt.EC_UNIT_BITS;
84201104:	08 00 55 8d 	r3 = r3 LSHIFT 8;
      r4 = r2  LSHIFT ($celt.EC_UNIT_BITS-24);
84201108:	f0 00 64 8d 	r4 = r2 LSHIFT -16;
      r3 = r3 + r4;
8420110c:	00 00 56 03 	r3 = r3 + r4;
      r2 = r2 LSHIFT  $celt.EC_UNIT_BITS;
84201110:	08 00 44 8d 	r2 = r2 LSHIFT 8;
      r2 = r2 OR r0;
84201114:	00 00 42 87 	r2 = r2 OR r0;
      r3 = r3 OR r1;
84201118:	00 00 53 87 	r3 = r3 OR r1;
      M[FP + TEMP_T + 0] = r2;
8420111c:	08 00 4c f1 	M[FP + 0x8] = r2;
      M[FP + TEMP_T + MK1] = r3;
84201120:	0c 00 5c f1 	M[FP + 0xc] = r3;
      r2 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FTB];
84201124:	e4 01 47 d1 	r2 = M[r5 + 484];
      r2 = r2 - $celt.EC_UNIT_BITS;
84201128:	08 00 44 21 	r2 = r2 - 8;
      M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FTB] = r2;
8420112c:	e4 01 47 d5 	M[r5 + 484] = r2;
  jump  loop_check_ftp;
84201130:	ef ff f0 dd 	jump $M.celt.ec_dec_bits.loop_check_ftp;

84201134 <$M.celt.ec_dec_bits.end_check_ftp>:
  end_check_ftp:
  r8 = r2;
84201134:	0f 00 a4 00 	r8 = r2 + Null;
  call $celt.ec_decode_raw;
84201138:	0e 00 f0 e1 	call $celt.ec_decode_raw;
  r2 = M[FP + TEMP_T + 0];
8420113c:	08 00 48 f1 	r2 = M[FP + 0x8];
  r3 = M[FP + TEMP_T + MK1];
84201140:	0c 00 58 f1 	r3 = M[FP + 0xc];
  r4 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FTB];
84201144:	e4 01 67 d1 	r4 = M[r5 + 484];
  r3 = r3 LSHIFT  r4;
84201148:	00 00 56 8f 	r3 = r3 LSHIFT r4;
  r6 = r4 - 24;
8420114c:	18 00 86 21 	r6 = r4 - 24;
  r6 = r2  LSHIFT r6;
84201150:	8f 00 84 8c 	r6 = r2 LSHIFT r6;
  r3 = r3 + r6;
84201154:	00 00 58 03 	r3 = r3 + r6;
  r2 = r2 LSHIFT  r4;
84201158:	00 00 46 8f 	r2 = r2 LSHIFT r4;
  r0 = r2 OR r0;
8420115c:	2f 00 24 84 	r0 = r2 OR r0;
  r1 = r3 OR r1;
84201160:	3f 00 35 84 	r1 = r3 OR r1;
  // pop rLink from stack
   SP = SP - STACK_FRAME_SIZE;
84201164:	f8 ff 03 f1 	SP = SP + -8;
   popm <FP,rLink>;
84201168:	01 20 04 f1 	popm <FP, rLink>;
   rts;
8420116c:	0f 00 0d dc 	rts;

84201170 <$celt.ec_decode_raw>:
#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.EC_DECODE_RAW.PATCH_ID_0,r4)     // celt_patchers
#endif
   
   // push rLink onto stack
   push rlink;
84201170:	00 00 d0 f3 	push rLink;
   //rMAC: value
   //r7: count
   //r2: bits(input)
   //r4:end_bits_left
   //r6:end_byte
   rMAC = 0;
84201174:	00 00 10 01 	rMAC = Null + 0;
   r7 = 0;
84201178:	00 00 90 01 	r7 = Null + 0;
   r4 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_END_BITS_LEFT];
8420117c:	c4 01 67 d1 	r4 = M[r5 + 452];
   r6 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_END_BYTE];
84201180:	c0 01 87 d1 	r6 = M[r5 + 448];
   r0 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_NB_END_BITS];
84201184:	c8 01 27 d1 	r0 = M[r5 + 456];
   r0 = r8 + r0;
84201188:	2f 00 2a 00 	r0 = r8 + r0;
   M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_NB_END_BITS] = r0;
8420118c:	c8 01 27 d5 	M[r5 + 456] = r0;

84201190 <$M.celt.ec_decode_raw.loop_until_bits_left>:
   loop_until_bits_left:
      Null = r8 - r4;
84201190:	6f 00 0a 20 	Null = r8 - r4;
      if NEG jump end_bits_loop;
84201194:	0b 00 40 dd 	if NEG jump $M.celt.ec_decode_raw.end_bits_loop;
         r0 = r4 - 8;
84201198:	08 00 26 21 	r0 = r4 - 8;
         r0 = r6 LSHIFT r0;
8420119c:	2f 00 28 8c 	r0 = r6 LSHIFT r0;
         r0 = r0 LSHIFT r7;
842011a0:	00 00 29 8f 	r0 = r0 LSHIFT r7;
         rMAC = rMAC OR r0;
842011a4:	00 00 12 87 	rMAC = rMAC OR r0;
         r7 = r7 + r4;
842011a8:	00 00 96 03 	r7 = r7 + r4;
         r8 = r8 - r4;
842011ac:	00 00 a6 23 	r8 = r8 - r4;
         call $celt.get1byte_from_end;
842011b0:	2f 0b f0 e1 	call $celt.get1byte_from_end;
         r6 = r1;
842011b4:	0f 00 83 00 	r6 = r1 + Null;
         r4 = 8;
842011b8:	08 00 60 01 	r4 = Null + 8;
   jump loop_until_bits_left;
842011bc:	f5 ff f0 dd 	jump $M.celt.ec_decode_raw.loop_until_bits_left;

842011c0 <$M.celt.ec_decode_raw.end_bits_loop>:
   end_bits_loop:
   r2 = 1 LSHIFT r8;
842011c0:	01 00 4a e9 	r2 = 0x1 LSHIFT r8;
   r2 = r2 - 1;
842011c4:	3f 00 44 e4 	r2 = r2 - 1;
   r0 = r4 - 8;
842011c8:	08 00 26 21 	r0 = r4 - 8;
   r0 = r6 LSHIFT r0;
842011cc:	2f 00 28 8c 	r0 = r6 LSHIFT r0;
   r0 = r0 AND r2;
842011d0:	00 00 24 83 	r0 = r0 AND r2;
   r0 = r0 LSHIFT r7;
842011d4:	00 00 29 8f 	r0 = r0 LSHIFT r7;
   r0 = rMAC OR r0;
842011d8:	2f 00 21 84 	r0 = rMAC OR r0;
   r4 = r4 - r8;
842011dc:	00 00 6a 23 	r4 = r4 - r8;
   M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_END_BITS_LEFT] = r4;
842011e0:	c4 01 67 d5 	M[r5 + 452] = r4;
   M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_END_BYTE] = r6;
842011e4:	c0 01 87 d5 	M[r5 + 448] = r6;
   r1 = 0;
842011e8:	00 00 30 01 	r1 = Null + 0;
   // pop rLink from stack
   jump $pop_rLink_and_rts;
842011ec:	03 00 00 fd 	jump (m) 0x3b020;
842011f0:	21 b0 f0 dd 

842011f4 <$celt.ec_dec_uint>:
#endif

   .CONST TEMP_FTB             (0 + 2)*ADDR_PER_WORD;
   .CONST TEMP_FT              (1 + 2)*ADDR_PER_WORD;
   .CONST STACK_FRAME_SIZE     3*ADDR_PER_WORD;
   pushm <FP(=SP), rLink>;
842011f4:	01 20 00 f1 	pushm <FP(=SP), rLink>;
   SP = SP + STACK_FRAME_SIZE;
842011f8:	0c 00 03 f1 	SP = SP + 12;

   r2 = r0 - 2;
842011fc:	cf 00 42 e4 	r2 = r0 - 2;
   r2 = r1 - borrow;
84201200:	0f 00 43 24 	r2 = r1 - Null - Borrow;
   if NEG call $error;
84201204:	03 00 00 fd 	if NEG call (m) 0x3ac3e;
84201208:	3f ac 40 e1 
   r0 = r0 - 1;
8420120c:	3f 00 22 e4 	r0 = r0 - 1;
   r1 = r1 - borrow;
84201210:	00 00 30 27 	r1 = r1 - Null - Borrow;
#ifdef DEBUG_ON
#ifdef K32
if NZ call $error; // K32: highword should be zero
#endif
#endif      
   M[FP + TEMP_FT + 0] = r0;
84201214:	0c 00 2c f1 	M[FP + 0xc] = r0;
   M[FP + TEMP_FT + MK1] = r1;
84201218:	10 00 3c f1 	M[FP + 0x10] = r1;
   // this is a macro
   $celt.EC_ILOG32(r0, r1, r2)
8420121c:	0f 00 13 00 	rMAC = r1 + Null;
84201220:	00 05 e2 8d 	rMAC0 = r0 LSHIFT 0;
84201224:	0f 00 41 d8 	r2 = SIGNDET rMAC;
84201228:	3f 00 44 65 	r2 = 63 - r2;
   M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FTB] = r2;
8420122c:	e4 01 47 d5 	M[r5 + 484] = r2;
   Null = r2 - $celt.EC_UNIT_BITS;
84201230:	08 00 04 21 	Null = r2 - 8;
   if LE jump inc_ft;
84201234:	2b 00 d0 dd 	if LE jump $M.celt.ec_dec_uint.inc_ft;
      r2 = $celt.EC_UNIT_BITS - r2;
84201238:	08 00 44 65 	r2 = 8 - r2;
      r3 = -r2;
8420123c:	4f 00 50 20 	r3 = Null - r2;
      M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FTB] = r3;
84201240:	e4 01 57 d5 	M[r5 + 484] = r3;
      M[FP + TEMP_FTB] = r3;
84201244:	08 00 5c f1 	M[FP + 0x8] = r3;
      M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FT + 0] = r0;
84201248:	cc 01 27 d5 	M[r5 + 460] = r0;
      M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FT + MK1] = r1;
8420124c:	d0 01 37 d5 	M[r5 + 464] = r1;
      // TODO:BC7OPT
      r3 = r2 + 24;
84201250:	18 00 54 01 	r3 = r2 + 24;
      r3 = r1 LSHIFT r3;
84201254:	5f 00 53 8c 	r3 = r1 LSHIFT r3;
      r0 = r0 LSHIFT r2;
84201258:	00 00 24 8f 	r0 = r0 LSHIFT r2;
      r0 = r0 OR r3;
8420125c:	00 00 25 87 	r0 = r0 OR r3;
      r1 = r1 LSHIFT r2;
84201260:	00 00 34 8f 	r1 = r1 LSHIFT r2;
      r0 = r0 + 1;
84201264:	2f 00 22 e4 	r0 = r0 + 1;
      r1 = r1 + carry;
84201268:	00 00 30 07 	r1 = r1 + Null + Carry;
#ifdef DEBUG_ON
#ifdef K32
if NZ call $error; // K32: highword should be zero
#endif
#endif  
      call $celt.ec_decode;
8420126c:	48 ff f0 e1 	call $celt.ec_decode;
      M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FL + 0] = r0;
84201270:	d4 01 27 d5 	M[r5 + 468] = r0;
      M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FL + MK1] = r1;
84201274:	d8 01 37 d5 	M[r5 + 472] = r1;
      r0 = r0 + 1;
84201278:	2f 00 22 e4 	r0 = r0 + 1;
      r1 = r1 + carry;
8420127c:	00 00 30 07 	r1 = r1 + Null + Carry;
      M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FH + MK1] = r1;
84201280:	e0 01 37 d5 	M[r5 + 480] = r1;
      M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FH + 0] = r0;
84201284:	dc 01 27 d5 	M[r5 + 476] = r0;

      call $celt.ec_dec_update;
84201288:	69 ff f0 e1 	call $celt.ec_dec_update;

      call $celt.ec_dec_bits;
8420128c:	93 ff f0 e1 	call $celt.ec_dec_bits;
      r2 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FL + 0];
84201290:	d4 01 47 d1 	r2 = M[r5 + 468];
      r3 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FL + MK1];
84201294:	d8 01 57 d1 	r3 = M[r5 + 472];
      r4 = M[FP + TEMP_FTB];
84201298:	08 00 68 f1 	r4 = M[FP + 0x8];

      // TODO:BC7OPT
      r3 = r3 LSHIFT r4;
8420129c:	00 00 56 8f 	r3 = r3 LSHIFT r4;
      r7 = r4 - 24;
842012a0:	18 00 96 21 	r7 = r4 - 24;
      r7 = r2 LSHIFT r7;
842012a4:	9f 00 94 8c 	r7 = r2 LSHIFT r7;
      r3 = r3 OR r7;
842012a8:	00 00 59 87 	r3 = r3 OR r7;
      r2 = r2 LSHIFT r4;
842012ac:	00 00 46 8f 	r2 = r2 LSHIFT r4;
      r0 = r0 OR r2;
842012b0:	00 00 24 87 	r0 = r0 OR r2;
#ifdef K32
      r1 = 0;  // 32-bit r1:r0 register pair with MSWord=0
842012b4:	00 00 30 01 	r1 = Null + 0;
#else
      r1 = r1 OR r3;
#endif
      r2 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FT + 0];
842012b8:	cc 01 47 d1 	r2 = M[r5 + 460];
      r3 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FT + MK1];
842012bc:	d0 01 57 d1 	r3 = M[r5 + 464];
      r4 = M[FP + TEMP_FT + 0];
842012c0:	0c 00 68 f1 	r4 = M[FP + 0xc];
      r10 = M[FP + TEMP_FT + MK1];
842012c4:	10 00 c8 f1 	r10 = M[FP + 0x10];
      NULL = r0 - r4;
842012c8:	6f 00 02 20 	Null = r0 - r4;
      NULL = r1 - r10 - borrow;
842012cc:	cf 00 03 24 	Null = r1 - r10 - Borrow;
      if LE jump end;
842012d0:	13 00 d0 dd 	if LE jump $M.celt.ec_dec_uint.end;
         r0 = r2;
842012d4:	0f 00 24 00 	r0 = r2 + Null;
#ifdef K32
         r1 = 0;  // 32-bit r1:r0 register pair with MSWord=0
842012d8:	00 00 30 01 	r1 = Null + 0;
#else
         r1 = r3;
#endif
      jump end;
842012dc:	10 00 f0 dd 	jump $M.celt.ec_dec_uint.end;

842012e0 <$M.celt.ec_dec_uint.inc_ft>:
   inc_ft:
   r0 = r0 + 1;
842012e0:	2f 00 22 e4 	r0 = r0 + 1;
   r1 = r1 + carry;
842012e4:	00 00 30 07 	r1 = r1 + Null + Carry;
#ifdef K32
if NZ call $error; // K32: highword should be zero
#endif
#endif     
#ifdef K32
   $celt.NATIVE_WORD32_CONVERT(r1,r0)
842012e8:	18 00 33 8d 	r1 = r1 LSHIFT 24;
842012ec:	00 00 23 87 	r0 = r0 OR r1;
842012f0:	00 00 30 01 	r1 = Null + 0;
#endif
   call $celt.ec_decode;
842012f4:	26 ff f0 e1 	call $celt.ec_decode;
   M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FL + 0] = r0;
842012f8:	d4 01 27 d5 	M[r5 + 468] = r0;
   M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FL + MK1] = r1;
842012fc:	d8 01 37 d5 	M[r5 + 472] = r1;
   r0 = r0 + 1;
84201300:	2f 00 22 e4 	r0 = r0 + 1;
   r1 = r1 + carry;
84201304:	00 00 30 07 	r1 = r1 + Null + Carry;
   M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FH + MK1] = r1;
84201308:	e0 01 37 d5 	M[r5 + 480] = r1;
   M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FH + 0] = r0;
8420130c:	dc 01 27 d5 	M[r5 + 476] = r0;
   call $celt.ec_dec_update;
84201310:	47 ff f0 e1 	call $celt.ec_dec_update;
   r0 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FL + 0];
84201314:	d4 01 27 d1 	r0 = M[r5 + 468];
   r1 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FL + MK1];
84201318:	d8 01 37 d1 	r1 = M[r5 + 472];

8420131c <$M.celt.ec_dec_uint.end>:

   end:
   // pop rLink from stack
   SP = SP - STACK_FRAME_SIZE;
8420131c:	f4 ff 03 f1 	SP = SP + -12;
   popm <FP,rLink>;
84201320:	01 20 04 f1 	popm <FP, rLink>;
   rts;
84201324:	0f 00 0d dc 	rts;

84201328 <$celt.ec_dec_tell>:
#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.EC_DEC_TELL.PATCH_ID_0,r3)     // celt_patchers
#endif

   // push rLink onto stack
   push rlink;
84201328:	00 00 d0 f3 	push rLink;

   // work out number of bits
   r3 = M[r5 + $celt.dec.CELT_CODEC_FRAME_SIZE_FIELD];
8420132c:	04 00 57 d1 	r3 = M[r5 + 4];
   r0 = M[r5 + $celt.dec.SCRATCHVAR_FRAME_BYTES_REMAINED];
84201330:	fc 01 27 d1 	r0 = M[r5 + 508];
   r3 = r3 - r0;
84201334:	00 00 52 23 	r3 = r3 - r0;
   r3 = r3 - (($celt.EC_CODE_BITS+$celt.EC_SYM_BITS-1)/$celt.EC_SYM_BITS);
84201338:	df 00 55 e4 	r3 = r3 - 4;
   r3 = r3 * $celt.EC_SYM_BITS (int);
8420133c:	08 00 55 99 	r3 = r3 * 8 (int);
   r0 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_NB_END_BITS];
84201340:	c8 01 27 d1 	r0 = M[r5 + 456];
   r3 = r3 + r0;
84201344:	00 00 52 03 	r3 = r3 + r0;
   r3 = r3 +($celt.EC_CODE_BITS+1);
84201348:	21 00 55 01 	r3 = r3 + 33;
   r3 = r3 LSHIFT r4;
8420134c:	00 00 56 8f 	r3 = r3 LSHIFT r4;
   r0 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_RNG + 0];
84201350:	a8 01 27 d1 	r0 = M[r5 + 424];
   r1 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_RNG + MK1];
84201354:	ac 01 37 d1 	r1 = M[r5 + 428];
   $celt.EC_ILOG32(r0, r1, r2)
84201358:	0f 00 13 00 	rMAC = r1 + Null;
8420135c:	00 05 e2 8d 	rMAC0 = r0 LSHIFT 0;
84201360:	0f 00 41 d8 	r2 = SIGNDET rMAC;
84201364:	3f 00 44 65 	r2 = 63 - r2;
   r6 = 16 - r2;
84201368:	10 00 84 65 	r6 = 16 - r2;
   r0 = r0 LSHIFT r6;
8420136c:	00 00 28 8f 	r0 = r0 LSHIFT r6;
   r6 = r6 + 24;
84201370:	18 00 88 01 	r6 = r6 + 24;
   r1 = r1 LSHIFT r6;
84201374:	00 00 38 8f 	r1 = r1 LSHIFT r6;
   r6 = r0 OR r1;
84201378:	3f 00 82 84 	r6 = r0 OR r1;
   r1 = -1;
8420137c:	3f 00 30 e4 	r1 = Null - 1;

84201380 <$M.celt.ec_dec_tell.tel_loop>:
   tel_loop:
      r4 = r4 - 1;
84201380:	3f 00 66 e4 	r4 = r4 - 1;
      if NEG jump end_tel_loop;
84201384:	08 00 40 dd 	if NEG jump $M.celt.ec_dec_tell.end_tel_loop;
         rMAC = r6 * r6;
84201388:	8f 00 18 cc 	rMAC = r6 * r6 (SS);
         r6 = rMAC LSHIFT (DAWTH-15-1);
8420138c:	10 00 81 8d 	r6 = rMAC LSHIFT 16;
         r0 = r6 LSHIFT -16;
84201390:	f0 00 28 8d 	r0 = r6 LSHIFT -16;
         if NZ r6 = r6 LSHIFT r1;
84201394:	31 00 88 8c 	if NE r6 = r6 LSHIFT r1;
         r2 = r2 + r2;
84201398:	00 00 44 03 	r2 = r2 + r2;
         r2 = r2 OR r0;
8420139c:	00 00 42 87 	r2 = r2 OR r0;
      jump tel_loop;
842013a0:	f8 ff f0 dd 	jump $M.celt.ec_dec_tell.tel_loop;

842013a4 <$M.celt.ec_dec_tell.end_tel_loop>:
   end_tel_loop:
   r0 = r3 - r2;
842013a4:	4f 00 25 20 	r0 = r3 - r2;

   // pop rLink from stack
   jump $pop_rLink_and_rts;
842013a8:	03 00 00 fd 	jump (m) 0x3b020;
842013ac:	21 b0 f0 dd 

842013b0 <$celt.ec_enc_carry_out>:
842013b0:	00 00 d0 f3 	push rLink;
#endif
   
   // push rLink onto stack
   push rlink;
   // r3 = carry
   Null = r3 - $celt.EC_SYM_MAX;
842013b4:	ff 00 05 21 	Null = r3 - 255;
   if NZ jump write_sym;
842013b8:	04 00 10 dd 	if NE jump $M.celt.ec_enc_carry_out.write_sym;
      r2 = M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_EXT];
842013bc:	b4 01 47 d1 	r2 = M[r5 + 436];
      r2 = r2 + 1;
842013c0:	2f 00 44 e4 	r2 = r2 + 1;
      jump end;
842013c4:	0f 00 f0 dd 	jump $M.celt.ec_enc_carry_out.end;

842013c8 <$M.celt.ec_enc_carry_out.write_sym>:
   write_sym:
   r2 = r3 LSHIFT (-$celt.EC_SYM_BITS);
842013c8:	f8 00 45 8d 	r2 = r3 LSHIFT -8;

   r1 = M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_REM];
842013cc:	a0 01 37 d1 	r1 = M[r5 + 416];
   if NEG jump end_writing_carry;
842013d0:	03 00 40 dd 	if NEG jump $M.celt.ec_enc_carry_out.end_writing_carry;
      r1 = r1 + r2; 
842013d4:	00 00 34 03 	r1 = r1 + r2;
      call $celt.put1byte;
842013d8:	6c 0b f0 e1 	call $celt.put1byte;

842013dc <$M.celt.ec_enc_carry_out.end_writing_carry>:
   end_writing_carry:
   r2 = r2 + $celt.EC_SYM_MAX;
842013dc:	ff 00 44 01 	r2 = r2 + 255;
   r1 = r2 AND $celt.EC_SYM_MAX;
842013e0:	ff 00 34 81 	r1 = r2 AND 0xff;
   r2 = M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_EXT];
842013e4:	b4 01 47 d1 	r2 = M[r5 + 436];

842013e8 <$M.celt.ec_enc_carry_out.loop_write_sym>:
   loop_write_sym:
      if LE jump end_write_loop;
842013e8:	04 00 d0 dd 	if LE jump $M.celt.ec_enc_carry_out.end_write_loop;
      call $celt.put1byte;
842013ec:	67 0b f0 e1 	call $celt.put1byte;
      r2 = r2 - 1;
842013f0:	3f 00 44 e4 	r2 = r2 - 1;
   jump loop_write_sym;
842013f4:	fd ff f0 dd 	jump $M.celt.ec_enc_carry_out.loop_write_sym;

842013f8 <$M.celt.ec_enc_carry_out.end_write_loop>:
   end_write_loop:
   r3 = r3 AND $celt.EC_SYM_MAX; 
842013f8:	ff 00 55 81 	r3 = r3 AND 0xff;
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_REM] = r3;
842013fc:	a0 01 57 d5 	M[r5 + 416] = r3;

84201400 <$M.celt.ec_enc_carry_out.end>:
   end:
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_EXT] = r2;
84201400:	b4 01 47 d5 	M[r5 + 436] = r2;
    // pop rLink from stack
   jump $pop_rLink_and_rts;
84201404:	03 00 00 fd 	jump (m) 0x3b020;
84201408:	21 b0 f0 dd 

8420140c <$celt.ec_enc_normalise>:
#if defined(PATCH_LIBS)
   LIBS_PUSH_REGS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.EC_ENC_NORMALISE.PATCH_ID_0)     // celt_patchers
#endif
   
   // push rLink onto stack
   push rlink;
8420140c:	00 00 d0 f3 	push rLink;
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_LOW + 1] = r8;
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_RNG + 0] = r4;
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_RNG + 1] = r6;
#else
    // K32 implementation
    r7 = M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_LOW];
84201410:	ac 01 97 d1 	r7 = M[r5 + 428];
    r4 = M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_RNG];
84201414:	a4 01 67 d1 	r4 = M[r5 + 420];

84201418 <$M.celt.ec_enc_normalise.retry>:
    retry:
       Null = $celt.EC_CODE_BOT - r4;
84201418:	80 00 00 fd 	Null = 8388608 - r4;
8420141c:	00 00 06 65 
       if NC jump end;
84201420:	08 00 30 dd 	if NC jump $M.celt.ec_enc_normalise.end;
          r3 = r7 LSHIFT (-$celt.EC_CODE_SHIFT);
84201424:	e9 00 59 8d 	r3 = r7 LSHIFT -23;
          call $celt.ec_enc_carry_out;
84201428:	e2 ff f0 e1 	call $celt.ec_enc_carry_out;
          r7 = r7 LSHIFT 8;
8420142c:	08 00 99 8d 	r7 = r7 LSHIFT 8;
          r7 = r7 AND 0x7FFFFFFF;
84201430:	ff 7f 00 fd 	r7 = r7 AND 0x7fffffff;
84201434:	ff ff 99 81 
          r4 = r4 LSHIFT 8;
84201438:	08 00 66 8d 	r4 = r4 LSHIFT 8;
    jump retry;
8420143c:	f7 ff f0 dd 	jump $M.celt.ec_enc_normalise.retry;

84201440 <$M.celt.ec_enc_normalise.end>:
    end:
    M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_LOW] = r7;
84201440:	ac 01 97 d5 	M[r5 + 428] = r7;
    M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_RNG] = r4;
84201444:	a4 01 67 d5 	M[r5 + 420] = r4;
#endif

   
    // pop rLink from stack
   jump $pop_rLink_and_rts;
84201448:	03 00 00 fd 	jump (m) 0x3b020;
8420144c:	21 b0 f0 dd 

84201450 <$celt.ec_encode>:
#if defined(PATCH_LIBS)
   LIBS_PUSH_REGS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.EC_ENCODE.PATCH_ID_0)     // celt_patchers
#endif
   
   // push rLink onto stack
   push rlink;
84201450:	00 00 d0 f3 	push rLink;
       M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_RNG + 1] = r1;
    end:
    call $celt.ec_enc_normalise;
#else // K32
   // K32 variant
   r0 = M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_RNG];
84201454:	a4 01 27 d1 	r0 = M[r5 + 420];
   r2 = M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FT];
84201458:	cc 01 47 d1 	r2 = M[r5 + 460];
   rMAC = 0;
8420145c:	00 00 10 01 	rMAC = Null + 0;
   rMAC0 = r0;
84201460:	00 05 e2 8d 	rMAC0 = r0 LSHIFT 0;
   Div = rMAC / r2; // r = rng / ft
84201464:	00 00 14 d9 	Div = rMAC / r2;
   r6 = DivResult;
84201468:	01 00 80 d9 	r6 = DivResult;

8420146c <$celt.ec_encode_bin_jump_point>:
   $celt.ec_encode_bin_jump_point:
   r4 = M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FL]; 
8420146c:	d4 01 67 d1 	r4 = M[r5 + 468];
   r4 = -r4;                                      // r4 = -fl
84201470:	6f 00 60 20 	r4 = Null - r4;
   if POS jump update_range_only;
84201474:	0c 00 50 dd 	if POS jump $M.celt.ec_encode.update_range_only;
      r2 = r4 + r2; // (ft + -fl)
84201478:	4f 00 46 00 	r2 = r4 + r2;
      r3 = r2*r6(int); // r*(ft-fl)
8420147c:	8f 00 54 98 	r3 = r2 * r6 (int);
      r0 = r0 - r3; // rng - r*(ft - fl)
84201480:	00 00 25 23 	r0 = r0 - r3;
      r2 = M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_LOW];
84201484:	ac 01 47 d1 	r2 = M[r5 + 428];
      r0 = r2 + r0; // low + rng - r*(ft - fl)
84201488:	2f 00 24 00 	r0 = r2 + r0;
      M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_LOW] = r0;
8420148c:	ac 01 27 d5 	M[r5 + 428] = r0;
      r2 = M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FH];
84201490:	dc 01 47 d1 	r2 = M[r5 + 476];
      r2 = r2 + r4;                             // (fh - fl)
84201494:	00 00 46 03 	r2 = r2 + r4;
      r0 = r2*r6(int); // (r*(fh-fl)
84201498:	8f 00 24 98 	r0 = r2 * r6 (int);
      M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_RNG] = r0;
8420149c:	a4 01 27 d5 	M[r5 + 420] = r0;
      jump end;
842014a0:	07 00 f0 dd 	jump $M.celt.ec_encode.end;

842014a4 <$M.celt.ec_encode.update_range_only>:
   update_range_only:
      r0 = M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FH];
842014a4:	dc 01 27 d1 	r0 = M[r5 + 476];
      r2 = r2 - r0;    // (ft - fh)
842014a8:	00 00 42 23 	r2 = r2 - r0;
      r0 = r2*r6(int); // r*(ft - fh)
842014ac:	8f 00 24 98 	r0 = r2 * r6 (int);
      r1 = M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_RNG];
842014b0:	a4 01 37 d1 	r1 = M[r5 + 420];
      r1 = r1 - r0;
842014b4:	00 00 32 23 	r1 = r1 - r0;
      M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_RNG] = r1;   // rng = rng - r*(ft - fh)
842014b8:	a4 01 37 d5 	M[r5 + 420] = r1;

842014bc <$M.celt.ec_encode.end>:
   end:
   call $celt.ec_enc_normalise;
842014bc:	d4 ff f0 e1 	call $celt.ec_enc_normalise;
#endif

        
    // pop rLink from stack
   jump $pop_rLink_and_rts;
842014c0:	03 00 00 fd 	jump (m) 0x3b020;
842014c4:	21 b0 f0 dd 

842014c8 <$celt.ec_encode_raw>:
#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.EC_ENCODE_RAW.PATCH_ID_0,r4)     // celt_patchers
#endif
   
   // push rLink onto stack
    push rlink;
842014c8:	00 00 d0 f3 	push rLink;
   //r8 = bits
   r0 = M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_NB_END_BITS];
842014cc:	c0 01 27 d1 	r0 = M[r5 + 448];
   r0 = r0 + r8;
842014d0:	00 00 2a 03 	r0 = r0 + r8;
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_NB_END_BITS] = r0;
842014d4:	c0 01 27 d5 	M[r5 + 448] = r0;

   r7 = M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_END_BYTE];
842014d8:	b8 01 97 d1 	r7 = M[r5 + 440];
   r4 = M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_END_BITS_LEFT];
842014dc:	bc 01 67 d1 	r4 = M[r5 + 444];
   r6 = M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FL + 0];
842014e0:	d4 01 87 d1 	r6 = M[r5 + 468];

842014e4 <$M.celt.ec_encode_raw.loop_until_bits_left>:
   loop_until_bits_left:
      Null = r8 - r4;
842014e4:	6f 00 0a 20 	Null = r8 - r4;
      if NEG jump end_bits_loop;
842014e8:	0c 00 40 dd 	if NEG jump $M.celt.ec_encode_raw.end_bits_loop;
         r1 = 8 - r4;
842014ec:	08 00 36 65 	r1 = 8 - r4;
         r1 = r6 LSHIFT r1;
842014f0:	3f 00 38 8c 	r1 = r6 LSHIFT r1;
         r1 = r1 AND 0xFF;
842014f4:	ff 00 33 81 	r1 = r1 AND 0xff;
         r1 = r1 OR r7;
842014f8:	00 00 39 87 	r1 = r1 OR r7;
         call $celt.put1byte_to_end;
842014fc:	42 0b f0 e1 	call $celt.put1byte_to_end;
         r4 = -r4;
84201500:	6f 00 60 20 	r4 = Null - r4;
         r6 = r6 LSHIFT r4;
84201504:	00 00 86 8f 	r6 = r6 LSHIFT r4;
         r8 = r8 + r4;
84201508:	00 00 a6 03 	r8 = r8 + r4;
         r4 = 8;
8420150c:	08 00 60 01 	r4 = Null + 8;
         r7 = 0;
84201510:	00 00 90 01 	r7 = Null + 0;
   jump loop_until_bits_left;
84201514:	f4 ff f0 dd 	jump $M.celt.ec_encode_raw.loop_until_bits_left;

84201518 <$M.celt.ec_encode_raw.end_bits_loop>:
   end_bits_loop: 
   r1 = 8 - r4;
84201518:	08 00 36 65 	r1 = 8 - r4;
   r1 = r6 LSHIFT r1;
8420151c:	3f 00 38 8c 	r1 = r6 LSHIFT r1;
   r1 = r1 AND 0xFF;
84201520:	ff 00 33 81 	r1 = r1 AND 0xff;
   r1 = r1 OR r7;
84201524:	00 00 39 87 	r1 = r1 OR r7;
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_END_BYTE] = r1;
84201528:	b8 01 37 d5 	M[r5 + 440] = r1;

   r4 = r4 - r8;
8420152c:	00 00 6a 23 	r4 = r4 - r8;
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_END_BITS_LEFT] = r4;
84201530:	bc 01 67 d5 	M[r5 + 444] = r4;


   // pop rLink from stack
   jump $pop_rLink_and_rts;
84201534:	03 00 00 fd 	jump (m) 0x3b020;
84201538:	21 b0 f0 dd 

8420153c <$celt.ec_enc_bits>:
#endif
   
   // push rLink onto stack
   .CONST TEMP_T               (0 + 2)*ADDR_PER_WORD;
   .CONST STACK_FRAME_SIZE     2*ADDR_PER_WORD;;
   pushm <FP(=SP), rLink>;
8420153c:	01 20 00 f1 	pushm <FP(=SP), rLink>;
   SP = SP + STACK_FRAME_SIZE;
84201540:	08 00 03 f1 	SP = SP + 8;
   r0 = r0 + 1;
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FH + 0] = r0;
   call $celt.ec_encode_raw;
#else
   // K32 variant
   r0 = M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FL];
84201544:	d4 01 27 d1 	r0 = M[r5 + 468];
   M[FP + TEMP_T] = r0;
84201548:	08 00 2c f1 	M[FP + 0x8] = r0;
   r2 = M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FTB];
8420154c:	e4 01 47 d1 	r2 = M[r5 + 484];

84201550 <$M.celt.ec_enc_bits.loop_check_ftb>:
   loop_check_ftb:
      r3 = $celt.EC_UNIT_BITS - r2;    
84201550:	08 00 54 65 	r3 = 8 - r2;
      if POS jump end_check_ftb;
84201554:	0b 00 50 dd 	if POS jump $M.celt.ec_enc_bits.end_check_ftb;
      r1 = -r3;
84201558:	5f 00 30 20 	r1 = Null - r3;
      M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FTB] = r1;
8420155c:	e4 01 37 d5 	M[r5 + 484] = r1;
      r0 = r0 LSHIFT r3;
84201560:	00 00 25 8f 	r0 = r0 LSHIFT r3;
      r0 = r0 AND $celt.EC_UNIT_MASK;
84201564:	ff 00 22 81 	r0 = r0 AND 0xff;
      M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FL] = r0;
84201568:	d4 01 27 d5 	M[r5 + 468] = r0;
      r8 = $celt.EC_UNIT_BITS;
8420156c:	08 00 a0 01 	r8 = Null + 8;
      call $celt.ec_encode_raw;
84201570:	d6 ff f0 e1 	call $celt.ec_encode_raw;
      r0 = M[FP + TEMP_T];
84201574:	08 00 28 f1 	r0 = M[FP + 0x8];
      r2 = M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FTB];
84201578:	e4 01 47 d1 	r2 = M[r5 + 484];
   jump loop_check_ftb;
8420157c:	f5 ff f0 dd 	jump $M.celt.ec_enc_bits.loop_check_ftb;

84201580 <$M.celt.ec_enc_bits.end_check_ftb>:
   end_check_ftb:
   r8 = r2;
84201580:	0f 00 a4 00 	r8 = r2 + Null;
   r2 = 1 LSHIFT r2;
84201584:	01 00 44 e9 	r2 = 0x1 LSHIFT r2;
   r2 = r2 - 1;
84201588:	3f 00 44 e4 	r2 = r2 - 1;
   r0 = r0 AND r2;
8420158c:	00 00 24 83 	r0 = r0 AND r2;
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FL] = r0;
84201590:	d4 01 27 d5 	M[r5 + 468] = r0;
   r0 = r0 + 1;
84201594:	2f 00 22 e4 	r0 = r0 + 1;
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FH] = r0;
84201598:	dc 01 27 d5 	M[r5 + 476] = r0;
   call $celt.ec_encode_raw;
8420159c:	cb ff f0 e1 	call $celt.ec_encode_raw;
#endif
  
   SP = SP - STACK_FRAME_SIZE;
842015a0:	f8 ff 03 f1 	SP = SP + -8;
   popm <FP,rLink>;
842015a4:	01 20 04 f1 	popm <FP, rLink>;
   rts;
842015a8:	0f 00 0d dc 	rts;

842015ac <$celt.ec_enc_uint>:
#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.EC_ENC_UINT.PATCH_ID_0,r1)     // celt_patchers
#endif
   
   // push rLink onto stack
   push rlink;
842015ac:	00 00 d0 f3 	push rLink;
   r1 = r1 + Carry;
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FH + 1] = r1;
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FH + 0] = r0;
   call $celt.ec_encode;
#else // K32 variant
   r0 = M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FT];
842015b0:	cc 01 27 d1 	r0 = M[r5 + 460];
   r0 = r0 - 1;
842015b4:	3f 00 22 e4 	r0 = r0 - 1;
#ifdef K32_BITEXACT
   r1 = 0;
842015b8:	00 00 30 01 	r1 = Null + 0;
   $celt.EC_ILOG32(r0, r1, r2)
842015bc:	0f 00 13 00 	rMAC = r1 + Null;
842015c0:	00 05 e2 8d 	rMAC0 = r0 LSHIFT 0;
842015c4:	0f 00 41 d8 	r2 = SIGNDET rMAC;
842015c8:	3f 00 44 65 	r2 = 63 - r2;
#else   
   r2 = signdet r0;
   r2 = 31 - r2;
#endif   
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FTB] = r2;
842015cc:	e4 01 47 d5 	M[r5 + 484] = r2;
   //r0 = _ft, r2 = ftb
   r3 = $celt.EC_UNIT_BITS -r2;
842015d0:	08 00 54 65 	r3 = 8 - r2;
   if GT jump inc_ft;
842015d4:	12 00 c0 dd 	if GT jump $M.celt.ec_enc_uint.inc_ft;
     r1 = -r3;
842015d8:	5f 00 30 20 	r1 = Null - r3;
     M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FTB] = r1;
842015dc:	e4 01 37 d5 	M[r5 + 484] = r1;
     r0 = r0 LSHIFT r3;
842015e0:	00 00 25 8f 	r0 = r0 LSHIFT r3;
     r0 = r0 + 1;
842015e4:	2f 00 22 e4 	r0 = r0 + 1;
     M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FT] = r0;
842015e8:	cc 01 27 d5 	M[r5 + 460] = r0;
     r0 = M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FL];
842015ec:	d4 01 27 d1 	r0 = M[r5 + 468];
     push r0;
842015f0:	00 00 20 f3 	push r0;
     r0 = r0 LSHIFT r3;
842015f4:	00 00 25 8f 	r0 = r0 LSHIFT r3;
     M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FL] = r0;
842015f8:	d4 01 27 d5 	M[r5 + 468] = r0;
     r0 = r0 + 1;
842015fc:	2f 00 22 e4 	r0 = r0 + 1;
     M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FH] = r0;
84201600:	dc 01 27 d5 	M[r5 + 476] = r0;
     call $celt.ec_encode;
84201604:	93 ff f0 e1 	call $celt.ec_encode;
     pop r0;
84201608:	00 00 24 f3 	pop r0;
     M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FL] = r0;
8420160c:	d4 01 27 d5 	M[r5 + 468] = r0;
     call $celt.ec_enc_bits;
84201610:	cb ff f0 e1 	call $celt.ec_enc_bits;
     jump $pop_rLink_and_rts;
84201614:	03 00 00 fd 	jump (m) 0x3b020;
84201618:	21 b0 f0 dd 

8420161c <$M.celt.ec_enc_uint.inc_ft>:
   inc_ft:
   r0 = M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FL];
8420161c:	d4 01 27 d1 	r0 = M[r5 + 468];
   r0 = r0 + 1;
84201620:	2f 00 22 e4 	r0 = r0 + 1;
   M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FH] = r0;
84201624:	dc 01 27 d5 	M[r5 + 476] = r0;
   call $celt.ec_encode;
84201628:	8a ff f0 e1 	call $celt.ec_encode;
#endif
   
   jump $pop_rLink_and_rts;
8420162c:	03 00 00 fd 	jump (m) 0x3b020;
84201630:	21 b0 f0 dd 

84201634 <$celt.decode_pulses32>:
84201634:	01 20 00 f1 	pushm <FP(=SP), rLink>;
#endif
   
   .CONST TEMP                 (0 + 2)*ADDR_PER_WORD;
   .CONST STACK_FRAME_SIZE     4*ADDR_PER_WORD;
   pushm <FP(=SP), rLink>;
   SP = SP + STACK_FRAME_SIZE;
84201638:	10 00 03 f1 	SP = SP + 16;
#ifndef CELT_USE_EXTERNAL_MEMORY
   .VAR jump_table[5]  = &n_1, &n_2, &n_3, &n_4, n_5;
#endif     
   // save nr of pulses and bins
   M[FP + TEMP + 0] = r4;
8420163c:	08 00 6c f1 	M[FP + 0x8] = r4;
   M[FP + TEMP + MK1] = r3;
84201640:	0c 00 5c f1 	M[FP + 0xc] = r3;

#if defined (KAL_ARCH4) || defined (KAL_ARCH5)
   r3 = r3 ASHIFT 2;
84201644:	02 00 55 91 	r3 = r3 ASHIFT 2;
   Null = r3 - 6*4; // ARCH4/5: 4 AU per program word
84201648:	18 00 05 21 	Null = r3 - 24;
#else
   Null = r3 - 6; // else: 1 AU per program word
#endif
   if POS jump default;
8420164c:	5c 00 50 dd 	if POS jump $M.celt.decode_pulses32.default;
   Null = r3 - 1;
84201650:	3f 00 05 e4 	Null = r3 - 1;
   if NEG call $error;
84201654:	03 00 00 fd 	if NEG call (m) 0x3ac3e;
84201658:	3f ac 40 e1 
   // jump to proper function based on number of outputs
   // all can be processed using default (takes more cycles)
#ifdef CELT_USE_EXTERNAL_MEMORY
   r0 = M[r5 + $celt.dec.DEC_JUMP_TABLE_FIELD];
8420165c:	24 02 27 d1 	r0 = M[r5 + 548];
   r0 = r0 - MK1;
84201660:	df 00 22 e4 	r0 = r0 - 4;
   r0 = M[r3 + r0];
84201664:	2f 00 25 d0 	r0 = M[r3 + r0];
#else
   r0 = M[r3 + (jump_table-MK1)];
#endif   
   jump r0;
84201668:	0f 00 02 dc 	jump r0;

8420166c <$M.celt.decode_pulses32.n_1>:

   // -- process n = 1
   n_1:
      r0 = 1;
8420166c:	2f 00 20 e4 	r0 = Null + 1;
      M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FTB] = r0;
84201670:	e4 01 27 d5 	M[r5 + 484] = r0;
      call $celt.ec_dec_bits;
84201674:	99 fe f0 e1 	call $celt.ec_dec_bits;
      r4 = M[FP + TEMP + 0];
84201678:	08 00 68 f1 	r4 = M[FP + 0x8];
      $celt.cwrsi1(r2, r0, r1)
8420167c:	2f 00 30 20 	r1 = Null - r0;
84201680:	3f 00 14 00 	rMAC = r2 + r1;
84201684:	00 00 31 8b 	r1 = r1 XOR rMAC;
      M[I7, 0] = r1;
84201688:	bc 00 00 03 	Null = Null + Null, M[I7,0] = r1;
   jump end;
8420168c:	62 00 f0 dd 	jump $M.celt.decode_pulses32.end;

84201690 <$M.celt.decode_pulses32.n_2>:

   // -- process n = 2
   n_2:
      $celt.ncwrs2(r4, r0)
84201690:	2f 00 20 e4 	r0 = Null + 1;
84201694:	0f 00 06 00 	Null = r4 + Null;
84201698:	61 00 26 00 	if NE r0 = r4 + r4;
8420169c:	21 00 22 00 	if NE r0 = r0 + r0;
      r1 = 0;
842016a0:	00 00 30 01 	r1 = Null + 0;
      call $celt.ec_dec_uint;
842016a4:	d4 fe f0 e1 	call $celt.ec_dec_uint;
      r4 = M[FP + TEMP + 0];
842016a8:	08 00 68 f1 	r4 = M[FP + 0x8];
      r6 = r0;
842016ac:	0f 00 82 00 	r6 = r0 + Null;
      r7 = r1;
842016b0:	0f 00 93 00 	r7 = r1 + Null;
      call $celt.cwrsi2;
842016b4:	95 00 f0 e1 	call $celt.cwrsi2;
   jump end;
842016b8:	57 00 f0 dd 	jump $M.celt.decode_pulses32.end;

842016bc <$M.celt.decode_pulses32.n_3>:

   // -- process n = 3
   n_3:
      $celt.ncwrs3(r4, r0, r1, decode_pulses32_n_3_lb1)
842016bc:	2f 00 20 e4 	r0 = Null + 1;
842016c0:	00 00 30 01 	r1 = Null + 0;
842016c4:	0f 00 16 00 	rMAC = r4 + Null;
842016c8:	07 00 00 dd 	if EQ jump $M.celt.decode_pulses32.decode_pulses32_n_3_lb1;
842016cc:	00 00 11 03 	rMAC = rMAC + rMAC;
842016d0:	1f 00 16 cc 	rMAC = r4 * rMAC (SS);
842016d4:	20 00 21 8d 	r0 = rMAC LSHIFT 32;
842016d8:	00 00 31 8d 	r1 = rMAC LSHIFT 0;
842016dc:	af 00 22 e4 	r0 = r0 + 2;
842016e0:	00 00 30 07 	r1 = r1 + Null + Carry;

842016e4 <$M.celt.decode_pulses32.decode_pulses32_n_3_lb1>:
      call $celt.ec_dec_uint;
842016e4:	c4 fe f0 e1 	call $celt.ec_dec_uint;
      r4 = M[FP + TEMP + 0];
842016e8:	08 00 68 f1 	r4 = M[FP + 0x8];
      r6 = r0;
842016ec:	0f 00 82 00 	r6 = r0 + Null;
      r7 = r1;
842016f0:	0f 00 93 00 	r7 = r1 + Null;
      call $celt.cwrsi3;
842016f4:	9b 00 f0 e1 	call $celt.cwrsi3;
   jump end;
842016f8:	47 00 f0 dd 	jump $M.celt.decode_pulses32.end;

842016fc <$M.celt.decode_pulses32.n_4>:

   // -- process n = 4
   n_4:
      $celt.ncwrs4(r4, r0, r1, r2, decode_pulses32_n_4_lb1)
842016fc:	2f 00 20 e4 	r0 = Null + 1;
84201700:	00 00 30 01 	r1 = Null + 0;
84201704:	aa 2a 00 fd 	r2 = Null + 715827883;
84201708:	ab aa 40 01 
8420170c:	04 00 16 99 	rMAC = r4 * 4 (int);
84201710:	0c 00 00 dd 	if EQ jump $M.celt.decode_pulses32.decode_pulses32_n_4_lb1;
84201714:	6f 00 26 98 	r0 = r4 * r4 (int);
84201718:	af 00 22 e4 	r0 = r0 + 2;
8420171c:	4f 00 31 94 	r1 = rMAC * r2 (frac);
84201720:	03 00 33 99 	r1 = r1 * 3 (int);
84201724:	1f 00 03 20 	Null = r1 - rMAC;
84201728:	41 00 22 94 	if NE r0 = r0 * r2 (frac);
8420172c:	1f 00 03 20 	Null = r1 - rMAC;
84201730:	40 00 11 94 	if EQ rMAC = rMAC * r2 (frac);
84201734:	2f 00 11 cc 	rMAC = rMAC * r0 (SS);
84201738:	20 00 21 8d 	r0 = rMAC LSHIFT 32;
8420173c:	00 00 31 8d 	r1 = rMAC LSHIFT 0;

84201740 <$M.celt.decode_pulses32.decode_pulses32_n_4_lb1>:
      call $celt.ec_dec_uint;
84201740:	ad fe f0 e1 	call $celt.ec_dec_uint;
      r4 = M[FP + TEMP + 0];
84201744:	08 00 68 f1 	r4 = M[FP + 0x8];
      r6 = r0;
84201748:	0f 00 82 00 	r6 = r0 + Null;
      r7 = r1;
8420174c:	0f 00 93 00 	r7 = r1 + Null;
      call $celt.cwrsi4;
84201750:	d2 00 f0 e1 	call $celt.cwrsi4;
   jump end;
84201754:	30 00 f0 dd 	jump $M.celt.decode_pulses32.end;

84201758 <$M.celt.decode_pulses32.n_5>:

   // -- process n = 5
   n_5:
      $celt.ncwrs5(r4, r0, r1, r2, decode_pulses32_n_5_lb1)
84201758:	2f 00 20 e4 	r0 = Null + 1;
8420175c:	00 00 30 01 	r1 = Null + 0;
84201760:	aa 2a 00 fd 	r2 = Null + 715827883;
84201764:	ab aa 40 01 
84201768:	6f 00 16 98 	rMAC = r4 * r4 (int);
8420176c:	0e 00 00 dd 	if EQ jump $M.celt.decode_pulses32.decode_pulses32_n_5_lb1;
84201770:	05 00 21 01 	r0 = rMAC + 5;
84201774:	00 00 11 03 	rMAC = rMAC + rMAC;
84201778:	4f 00 31 94 	r1 = rMAC * r2 (frac);
8420177c:	03 00 33 99 	r1 = r1 * 3 (int);
84201780:	1f 00 03 20 	Null = r1 - rMAC;
84201784:	41 00 22 94 	if NE r0 = r0 * r2 (frac);
84201788:	1f 00 03 20 	Null = r1 - rMAC;
8420178c:	40 00 11 94 	if EQ rMAC = rMAC * r2 (frac);
84201790:	2f 00 11 cc 	rMAC = rMAC * r0 (SS);
84201794:	20 00 21 8d 	r0 = rMAC LSHIFT 32;
84201798:	00 00 31 8d 	r1 = rMAC LSHIFT 0;
8420179c:	af 00 22 e4 	r0 = r0 + 2;
842017a0:	00 00 30 07 	r1 = r1 + Null + Carry;

842017a4 <$M.celt.decode_pulses32.decode_pulses32_n_5_lb1>:
      call $celt.ec_dec_uint;
842017a4:	94 fe f0 e1 	call $celt.ec_dec_uint;
      r4 = M[FP + TEMP + 0];
842017a8:	08 00 68 f1 	r4 = M[FP + 0x8];
      r6 = r0;
842017ac:	0f 00 82 00 	r6 = r0 + Null;
      r7 = r1;
842017b0:	0f 00 93 00 	r7 = r1 + Null;
      call $celt.cwrsi5;
842017b4:	09 01 f0 e1 	call $celt.cwrsi5;
   jump end;
842017b8:	17 00 f0 dd 	jump $M.celt.decode_pulses32.end;

842017bc <$M.celt.decode_pulses32.default>:

   // -- process n > 5
   default:
      M[FP + TEMP + MK2] = r5;
842017bc:	10 00 7c f1 	M[FP + 0x10] = r5;
      push I7;
842017c0:	00 00 71 f3 	push I7;
      r0 = M[r5 + $celt.dec.UVECTOR_FIELD];
842017c4:	c8 00 27 d1 	r0 = M[r5 + 200];
      I7 = r0;//&$celt.dec.uvector;
842017c8:	2f 00 70 50 	I7 = Null + r0;
      M[FP + TEMP + 3*MK1] = r0;
842017cc:	14 00 2c f1 	M[FP + 0x14] = r0;
      push r5;
842017d0:	00 00 70 f3 	push r5;
      call $celt.ncwrs_urow;
842017d4:	8b 01 f0 e1 	call $celt.ncwrs_urow;
      pop r5;
842017d8:	00 00 74 f3 	pop r5;
      call $celt.ec_dec_uint;
842017dc:	86 fe f0 e1 	call $celt.ec_dec_uint;
      r4 = M[FP + TEMP + 3*MK1];
842017e0:	14 00 68 f1 	r4 = M[FP + 0x14];
      I5 = r4;
842017e4:	6f 00 50 50 	I5 = Null + r4;
      #if defined(KAL_ARCH3) || defined(KAL_ARCH4) || defined(KAL_ARCH5)
         I7 = M[SP - MK1];
842017e8:	fc ff 79 f1 	I7 = M[SP + -0x4];
      #else
         I7 = plook 0;
      #endif
      r4 = M[FP + TEMP + 0];
842017ec:	08 00 68 f1 	r4 = M[FP + 0x8];
      r3 = M[FP + TEMP + MK1];
842017f0:	0c 00 58 f1 	r3 = M[FP + 0xc];
      M3 = r3;
842017f4:	5f 00 b0 50 	M3 = Null + r3;
      r6 = r0;
842017f8:	0f 00 82 00 	r6 = r0 + Null;
      r7 = r1;
842017fc:	0f 00 93 00 	r7 = r1 + Null;
      push r5;
84201800:	00 00 70 f3 	push r5;
      call $celt.cwrsi;
84201804:	5b 01 f0 e1 	call $celt.cwrsi;
      pop r5;
84201808:	00 00 74 f3 	pop r5;
      r5 = M[FP + TEMP + MK2];
8420180c:	10 00 78 f1 	r5 = M[FP + 0x10];
      pop I7;
84201810:	00 00 75 f3 	pop I7;

84201814 <$M.celt.decode_pulses32.end>:
   end:
   r4 = M[FP + TEMP + 0];
84201814:	08 00 68 f1 	r4 = M[FP + 0x8];
   r3 = M[FP + TEMP + MK1];
84201818:	0c 00 58 f1 	r3 = M[FP + 0xc];
   SP = SP - STACK_FRAME_SIZE;
8420181c:	f0 ff 03 f1 	SP = SP + -16;
   popm <FP,rLink>;
84201820:	01 20 04 f1 	popm <FP, rLink>;
   rts;
84201824:	0f 00 0d dc 	rts;

84201828 <$celt.decode_pulses>:
#if defined(PATCH_LIBS)
   LIBS_PUSH_REGS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.DECODE_PULSES.PATCH_ID_0)     // celt_patchers
#endif

   // zero output for zero pulses
   Null = r4;
84201828:	0f 00 06 00 	Null = r4 + Null;
   if NZ jump decode;
8420182c:	07 00 10 dd 	if NE jump $M.celt.decode_pulses.decode;
      r10 = r3;
84201830:	0f 00 c5 00 	r10 = r3 + Null;
      r0 = 0;
84201834:	00 00 20 01 	r0 = Null + 0;
      I6 = I7;
84201838:	0f 00 67 58 	I6 = I7 + Null;
      do zero_k_lp;
8420183c:	02 00 f0 e5 	do $M.celt.decode_pulses.zero_k_lp;
         M[I6, MK1] = r0;
84201840:	a9 00 00 03 	Null = Null + Null, M[I6,4] = r0;

84201844 <$M.celt.decode_pulses.zero_k_lp>:
      zero_k_lp:
      rts;
84201844:	0f 00 0d dc 	rts;

84201848 <$M.celt.decode_pulses.decode>:
   decode:
   push rlink;
84201848:	00 00 d0 f3 	push rLink;
   // NOTE: no state should be below this point
   // does it fit into a 32-bit unsigned number?
   $celt.fits_in32(r3, r4, r0, decode_pulses_lb1, decode_pulses_lb2)
8420184c:	0e 00 05 21 	Null = r3 - 14;
84201850:	0b 00 40 dd 	if NEG jump $M.celt.decode_pulses.decode_pulses_lb1;
84201854:	0f 00 20 00 	r0 = Null + Null;
84201858:	0e 00 06 21 	Null = r4 - 14;
8420185c:	0e 00 50 dd 	if POS jump $M.celt.decode_pulses.decode_pulses_lb2;
84201860:	18 02 27 d1 	r0 = M[r5 + 536];
84201864:	02 00 66 91 	r4 = r4 ASHIFT 2;
84201868:	00 00 26 d3 	r0 = M[r0 + r4];
8420186c:	fe 00 66 91 	r4 = r4 ASHIFT -2;
84201870:	5f 00 02 20 	Null = r0 - r3;
84201874:	04 00 20 00 	if NEG r0 = Null + Null;
84201878:	07 00 f0 dd 	jump $M.celt.decode_pulses.decode_pulses_lb2;

8420187c <$M.celt.decode_pulses.decode_pulses_lb1>:
8420187c:	1c 02 27 d1 	r0 = M[r5 + 540];
84201880:	02 00 55 91 	r3 = r3 ASHIFT 2;
84201884:	00 00 25 d3 	r0 = M[r0 + r3];
84201888:	fe 00 55 91 	r3 = r3 ASHIFT -2;
8420188c:	6f 00 02 20 	Null = r0 - r4;
84201890:	04 00 20 00 	if NEG r0 = Null + Null;

84201894 <$M.celt.decode_pulses.decode_pulses_lb2>:
84201894:	0f 00 02 00 	Null = r0 + Null;
   if Z jump split_it;
84201898:	04 00 00 dd 	if EQ jump $M.celt.decode_pulses.split_it;
         // yes, it does
         call $celt.decode_pulses32;
8420189c:	66 ff f0 e1 	call $celt.decode_pulses32;
         jump $pop_rLink_and_rts;
842018a0:	03 00 00 fd 	jump (m) 0x3b020;
842018a4:	21 b0 f0 dd 

842018a8 <$M.celt.decode_pulses.split_it>:

   // No, it doesnt,
   split_it:
      push I7;
842018a8:	00 00 71 f3 	push I7;
      push r3;
842018ac:	00 00 50 f3 	push r3;
      push r4;
842018b0:	00 00 60 f3 	push r4;

      r1 = 0;
842018b4:	00 00 30 01 	r1 = Null + 0;
      r0 = r4 + 1;
842018b8:	2f 00 26 e4 	r0 = r4 + 1;
      call $celt.ec_dec_uint;
842018bc:	4e fe f0 e1 	call $celt.ec_dec_uint;
         r4 = r0;
         call $celt.decode_pulses;
         r0 = plook 0;
         r1 = plook 1;
      #else
         r3 = M[SP - MK2];
842018c0:	f8 ff 58 f1 	r3 = M[SP + -0x8];
         r3 = r3 + 1;
842018c4:	2f 00 55 e4 	r3 = r3 + 1;
         r3 = r3 LSHIFT -1;
842018c8:	ff 00 55 8d 	r3 = r3 LSHIFT -1;
         r4 = r0;
842018cc:	0f 00 62 00 	r4 = r0 + Null;
         call $celt.decode_pulses;
842018d0:	d6 ff f0 e1 	call $celt.decode_pulses;
         r0 = M[SP - MK1];
842018d4:	fc ff 28 f1 	r0 = M[SP + -0x4];
         r1 = M[SP - MK2];
842018d8:	f8 ff 38 f1 	r1 = M[SP + -0x8];
      #endif
      Words2Addr(r3);
842018dc:	02 00 55 91 	r3 = r3 ASHIFT 2;
      I7 = I7 + r3;
842018e0:	00 00 75 5b 	I7 = I7 + r3;
      Addr2Words(r3);
842018e4:	fe 00 55 91 	r3 = r3 ASHIFT -2;
      r4 = r0 - r4;
842018e8:	6f 00 62 20 	r4 = r0 - r4;
      r3 = r1 - r3;
842018ec:	5f 00 53 20 	r3 = r1 - r3;
      call $celt.decode_pulses;
842018f0:	ce ff f0 e1 	call $celt.decode_pulses;
      pop r4;
842018f4:	00 00 64 f3 	pop r4;
      pop r3;
842018f8:	00 00 54 f3 	pop r3;
      pop I7;
842018fc:	00 00 75 f3 	pop I7;
   jump $pop_rLink_and_rts;
84201900:	03 00 00 fd 	jump (m) 0x3b020;
84201904:	21 b0 f0 dd 

84201908 <$celt.cwrsi2>:

#if defined(PATCH_LIBS)
   LIBS_PUSH_REGS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.CWRSI2.PATCH_ID_0)     // celt_patchers
#endif
   
   r0 = r4 + 1;
84201908:	2f 00 26 e4 	r0 = r4 + 1;
   $celt.ucwrs2(r0, r3)
8420190c:	2f 00 52 00 	r3 = r0 + r0;
84201910:	3f 00 55 e4 	r3 = r3 - 1;
84201914:	04 00 50 00 	if NEG r3 = Null + Null;
   Null = r6 - r3;
84201918:	5f 00 08 20 	Null = r6 - r3;
   Null = r7 - Borrow;
8420191c:	0f 00 09 24 	Null = r7 - Null - Borrow;
   if NEG r3 = 0;
84201920:	04 00 50 00 	if NEG r3 = Null + Null;
   r6 = r6 - r3;
84201924:	00 00 85 23 	r6 = r6 - r3;
   r2 = r6 + 1;
84201928:	2f 00 48 e4 	r2 = r6 + 1;
   r2 = r2 LSHIFT -1;
8420192c:	ff 00 44 8d 	r2 = r2 LSHIFT -1;
   $celt.ucwrs2(r2, r1)
84201930:	4f 00 34 00 	r1 = r2 + r2;
84201934:	3f 00 33 e4 	r1 = r1 - 1;
84201938:	04 00 30 00 	if NEG r1 = Null + Null;
   r0 = r4 - r2;
8420193c:	4f 00 26 20 	r0 = r4 - r2;
   Null = r3;
84201940:	0f 00 05 00 	Null = r3 + Null;
   if NZ r0 = -r0;
84201944:	21 00 20 20 	if NE r0 = Null - r0;
   r6 = r6 - r1, M[I7, MK1] = r0;
84201948:	ad 00 83 23 	r6 = r6 - r1, M[I7,4] = r0;
   $celt.cwrsi1(r2, r6, r3)
8420194c:	8f 00 50 20 	r3 = Null - r6;
84201950:	5f 00 14 00 	rMAC = r2 + r3;
84201954:	00 00 51 8b 	r3 = r3 XOR rMAC;
   M[I7, -MK1] = r3;
84201958:	df 00 00 03 	Null = Null + Null, M[I7,-4] = r3;
   rts;
8420195c:	0f 00 0d dc 	rts;

84201960 <$celt.cwrsi3>:
#endif
  
   // push rLink onto stack
   .CONST TMP                  (0 + 2)*ADDR_PER_WORD;
   .CONST STACK_FRAME_SIZE     3*ADDR_PER_WORD;
   pushm <FP(=SP), rLink>;
84201960:	01 20 00 f1 	pushm <FP(=SP), rLink>;
   SP = SP + STACK_FRAME_SIZE;
84201964:	0c 00 03 f1 	SP = SP + 12;
   r3 = r4 + 1;
84201968:	2f 00 56 e4 	r3 = r4 + 1;
   $celt.ucwrs3(r3, r0, r1,  cwrsi3_lbl1)
8420196c:	00 00 20 01 	r0 = Null + 0;
84201970:	00 00 30 01 	r1 = Null + 0;
84201974:	3f 00 15 e4 	rMAC = r3 - 1;
84201978:	06 00 40 dd 	if NEG jump $M.celt.cwrsi3.cwrsi3_lbl1;
8420197c:	1f 00 15 cc 	rMAC = r3 * rMAC (SS);
84201980:	20 00 21 8d 	r0 = rMAC LSHIFT 32;
84201984:	00 00 31 8d 	r1 = rMAC LSHIFT 0;
84201988:	2f 00 22 e4 	r0 = r0 + 1;
8420198c:	00 00 30 07 	r1 = r1 + Null + Carry;

84201990 <$M.celt.cwrsi3.cwrsi3_lbl1>:
   M[FP + TMP + 0]  = r0;
84201990:	08 00 2c f1 	M[FP + 0x8] = r0;
   M[FP + TMP + MK1]  = r1;
84201994:	0c 00 3c f1 	M[FP + 0xc] = r1;
   M[FP + TMP + MK2]  = r4;
84201998:	10 00 6c f1 	M[FP + 0x10] = r4;
   M0 = 0;
8420199c:	00 00 80 51 	M0 = Null + 0;
   Null = r6 - r0;
842019a0:	2f 00 08 20 	Null = r6 - r0;
   Null = r7 - r1 - borrow;
842019a4:	3f 00 09 24 	Null = r7 - r1 - Borrow;
   if NEG jump chng1_end;
842019a8:	04 00 40 dd 	if NEG jump $M.celt.cwrsi3.chng1_end;
      M0 = 1;
842019ac:	01 00 80 51 	M0 = Null + 1;
      r6 = r6 - r0;
842019b0:	00 00 82 23 	r6 = r6 - r0;
      r7 = r7 - r1 - borrow;
842019b4:	00 00 93 27 	r7 = r7 - r1 - Borrow;

842019b8 <$M.celt.cwrsi3.chng1_end>:
   chng1_end:
   r2 = 0;
842019b8:	00 00 40 01 	r2 = Null + 0;
   Null = r6 - 1;
842019bc:	3f 00 08 e4 	Null = r6 - 1;
   Null = r7 - r1 - borrow;
842019c0:	3f 00 09 24 	Null = r7 - r1 - Borrow;
   if NEG jump chng2_end;
842019c4:	1f 00 40 dd 	if NEG jump $M.celt.cwrsi3.chng2_end;
      r0 = r6 + r6;
842019c8:	8f 00 28 00 	r0 = r6 + r6;
      r1 = r7 + r7 + Carry;
842019cc:	9f 00 39 04 	r1 = r7 + r7 + Carry;
      r0 = r0 - 1;
842019d0:	3f 00 22 e4 	r0 = r0 - 1;
      r1 = r1 - Borrow;
842019d4:	00 00 30 27 	r1 = r1 - Null - Borrow;
      M1 = r7;
842019d8:	9f 00 90 50 	M1 = Null + r7;
      $celt.ISQRT32(cwrsi3_lbl2, cwrsi3_lbl3)
842019dc:	0f 00 13 00 	rMAC = r1 + Null;
842019e0:	00 05 e2 8d 	rMAC0 = r0 LSHIFT 0;
842019e4:	0f 00 51 d8 	r3 = SIGNDET rMAC;
842019e8:	3e 00 55 65 	r3 = 62 - r3;
842019ec:	ff 00 55 8d 	r3 = r3 LSHIFT -1;
842019f0:	00 00 40 01 	r2 = Null + 0;
842019f4:	2f 00 c5 e4 	r10 = r3 + 1;
842019f8:	01 00 55 e9 	r3 = 0x1 LSHIFT r3;
842019fc:	0e 00 f0 e5 	do $M.celt.cwrsi3.cwrsi3_lbl2;
84201a00:	4f 00 64 00 	r4 = r2 + r2;
84201a04:	00 00 65 03 	r4 = r4 + r3;
84201a08:	19 00 ac 21 	r8 = r10 - 25;
84201a0c:	af 00 96 8c 	r7 = r4 LSHIFT r8;
84201a10:	3f 00 ac e4 	r8 = r10 - 1;
84201a14:	00 00 6a 8f 	r4 = r4 LSHIFT r8;
84201a18:	6f 00 02 20 	Null = r0 - r4;
84201a1c:	9f 00 03 24 	Null = r1 - r7 - Borrow;
84201a20:	04 00 40 dd 	if NEG jump $M.celt.cwrsi3.cwrsi3_lbl3;
84201a24:	00 00 45 03 	r2 = r2 + r3;
84201a28:	00 00 26 23 	r0 = r0 - r4;
84201a2c:	00 00 39 27 	r1 = r1 - r7 - Borrow;

84201a30 <$M.celt.cwrsi3.cwrsi3_lbl3>:
84201a30:	ff 00 55 8d 	r3 = r3 LSHIFT -1;

84201a34 <$M.celt.cwrsi3.cwrsi3_lbl2>:
      r2 = r2 + 1;
84201a34:	2f 00 44 e4 	r2 = r2 + 1;
      r2 = r2 LSHIFT -1;
84201a38:	ff 00 44 8d 	r2 = r2 LSHIFT -1;
      r7 = M1;
84201a3c:	9f 00 90 44 	r7 = Null + M1;

84201a40 <$M.celt.cwrsi3.chng2_end>:
   chng2_end:
   $celt.ucwrs3(r2, r0, r1,  cwrsi3_lbl4)
84201a40:	00 00 20 01 	r0 = Null + 0;
84201a44:	00 00 30 01 	r1 = Null + 0;
84201a48:	3f 00 14 e4 	rMAC = r2 - 1;
84201a4c:	06 00 40 dd 	if NEG jump $M.celt.cwrsi3.cwrsi3_lbl4;
84201a50:	1f 00 14 cc 	rMAC = r2 * rMAC (SS);
84201a54:	20 00 21 8d 	r0 = rMAC LSHIFT 32;
84201a58:	00 00 31 8d 	r1 = rMAC LSHIFT 0;
84201a5c:	2f 00 22 e4 	r0 = r0 + 1;
84201a60:	00 00 30 07 	r1 = r1 + Null + Carry;

84201a64 <$M.celt.cwrsi3.cwrsi3_lbl4>:
   r6 = r6 - r0;
84201a64:	00 00 82 23 	r6 = r6 - r0;
   r7 = r7 - r1 - borrow;
84201a68:	00 00 93 27 	r7 = r7 - r1 - Borrow;
   r0 = M[FP + TMP + MK2];
84201a6c:	10 00 28 f1 	r0 = M[FP + 0x10];
   r0 = r2 - r0;
84201a70:	2f 00 24 20 	r0 = r2 - r0;
   Null = M0;
84201a74:	00 00 08 47 	Null = Null + M0;
   if Z r0 = -r0;
84201a78:	20 00 20 20 	if EQ r0 = Null - r0;
   M[I7, MK1] = r0;
84201a7c:	ad 00 00 03 	Null = Null + Null, M[I7,4] = r0;
   r4 = r2;
84201a80:	0f 00 64 00 	r4 = r2 + Null;
   call $celt.cwrsi2;
84201a84:	a1 ff f0 e1 	call $celt.cwrsi2;
   r0 = M[I7, -MK1];
84201a88:	2f 00 00 03 	Null = Null + Null, r0 = M[I7,-4];
   SP = SP - STACK_FRAME_SIZE;
84201a8c:	f4 ff 03 f1 	SP = SP + -12;
   popm <FP,rLink>;
84201a90:	01 20 04 f1 	popm <FP, rLink>;
   rts;
84201a94:	0f 00 0d dc 	rts;

84201a98 <$celt.cwrsi4>:
#endif
   
   // push rLink onto stack
   .CONST TMP                  (0 + 2)*ADDR_PER_WORD;
   .CONST STACK_FRAME_SIZE     3*ADDR_PER_WORD;
   pushm <FP(=SP), rLink>;
84201a98:	01 20 00 f1 	pushm <FP(=SP), rLink>;
   SP = SP + STACK_FRAME_SIZE;
84201a9c:	0c 00 03 f1 	SP = SP + 12;
   r3 = r4 + 1;
84201aa0:	2f 00 56 e4 	r3 = r4 + 1;
   $celt.ucwrs4(r3, r0, r1, r2, cwrsi4_lbl1)
84201aa4:	00 00 30 01 	r1 = Null + 0;
84201aa8:	0f 00 25 00 	r0 = r3 + Null;
84201aac:	12 00 00 dd 	if EQ jump $M.celt.cwrsi4.cwrsi4_lbl1;
84201ab0:	aa 2a 00 fd 	r2 = Null + 715827883;
84201ab4:	ab aa 40 01 
84201ab8:	5f 00 15 00 	rMAC = r3 + r3;
84201abc:	03 00 11 21 	rMAC = rMAC - 3;
84201ac0:	00 00 15 9b 	rMAC = rMAC * r3 (int);
84201ac4:	bf 00 11 e4 	rMAC = rMAC + 4;
84201ac8:	4f 00 31 94 	r1 = rMAC * r2 (frac);
84201acc:	03 00 33 99 	r1 = r1 * 3 (int);
84201ad0:	1f 00 03 20 	Null = r1 - rMAC;
84201ad4:	41 00 22 94 	if NE r0 = r0 * r2 (frac);
84201ad8:	1f 00 03 20 	Null = r1 - rMAC;
84201adc:	40 00 11 94 	if EQ rMAC = rMAC * r2 (frac);
84201ae0:	2f 00 11 cc 	rMAC = rMAC * r0 (SS);
84201ae4:	20 00 21 8d 	r0 = rMAC LSHIFT 32;
84201ae8:	00 00 31 8d 	r1 = rMAC LSHIFT 0;
84201aec:	3f 00 22 e4 	r0 = r0 - 1;
84201af0:	00 00 30 27 	r1 = r1 - Null - Borrow;

84201af4 <$M.celt.cwrsi4.cwrsi4_lbl1>:
   M[FP + TMP + 0]  = r0;
84201af4:	08 00 2c f1 	M[FP + 0x8] = r0;
   M[FP + TMP + MK1]  = r1;
84201af8:	0c 00 3c f1 	M[FP + 0xc] = r1;
   M[FP + TMP + MK2]  = r4;
84201afc:	10 00 6c f1 	M[FP + 0x10] = r4;
   M0 = 0;
84201b00:	00 00 80 51 	M0 = Null + 0;
   Null = r6 - r0;
84201b04:	2f 00 08 20 	Null = r6 - r0;
   Null = r7 - r1 - borrow;
84201b08:	3f 00 09 24 	Null = r7 - r1 - Borrow;
   if NEG jump chng1_end;
84201b0c:	04 00 40 dd 	if NEG jump $M.celt.cwrsi4.chng1_end;
      M0 = 1;
84201b10:	01 00 80 51 	M0 = Null + 1;
      r6 = r6 - r0;
84201b14:	00 00 82 23 	r6 = r6 - r0;
      r7 = r7 - r1 - borrow;
84201b18:	00 00 93 27 	r7 = r7 - r1 - Borrow;

84201b1c <$M.celt.cwrsi4.chng1_end>:
   chng1_end:
   r10 = 0;
84201b1c:	00 00 c0 01 	r10 = Null + 0;
   r8 = r4;
84201b20:	0f 00 a6 00 	r8 = r4 + Null;

84201b24 <$M.celt.cwrsi4.cwrsi4_loop1>:
   cwrsi4_loop1:
      r4 = r10 + r8;
84201b24:	af 00 6c 00 	r4 = r10 + r8;
      r4 = r4 LSHIFT -1;
84201b28:	ff 00 66 8d 	r4 = r4 LSHIFT -1;
      $celt.ucwrs4(r4, r0, r1, r2, cwrsi4_lbl2)
84201b2c:	00 00 30 01 	r1 = Null + 0;
84201b30:	0f 00 26 00 	r0 = r4 + Null;
84201b34:	12 00 00 dd 	if EQ jump $M.celt.cwrsi4.cwrsi4_lbl2;
84201b38:	aa 2a 00 fd 	r2 = Null + 715827883;
84201b3c:	ab aa 40 01 
84201b40:	6f 00 16 00 	rMAC = r4 + r4;
84201b44:	03 00 11 21 	rMAC = rMAC - 3;
84201b48:	00 00 16 9b 	rMAC = rMAC * r4 (int);
84201b4c:	bf 00 11 e4 	rMAC = rMAC + 4;
84201b50:	4f 00 31 94 	r1 = rMAC * r2 (frac);
84201b54:	03 00 33 99 	r1 = r1 * 3 (int);
84201b58:	1f 00 03 20 	Null = r1 - rMAC;
84201b5c:	41 00 22 94 	if NE r0 = r0 * r2 (frac);
84201b60:	1f 00 03 20 	Null = r1 - rMAC;
84201b64:	40 00 11 94 	if EQ rMAC = rMAC * r2 (frac);
84201b68:	2f 00 11 cc 	rMAC = rMAC * r0 (SS);
84201b6c:	20 00 21 8d 	r0 = rMAC LSHIFT 32;
84201b70:	00 00 31 8d 	r1 = rMAC LSHIFT 0;
84201b74:	3f 00 22 e4 	r0 = r0 - 1;
84201b78:	00 00 30 27 	r1 = r1 - Null - Borrow;

84201b7c <$M.celt.cwrsi4.cwrsi4_lbl2>:
      r2 = r6 - r0;
84201b7c:	2f 00 48 20 	r2 = r6 - r0;
      r3 = r7 - r1 - Borrow;
84201b80:	3f 00 59 24 	r3 = r7 - r1 - Borrow;
      if NEG jump pos_part;
84201b84:	07 00 40 dd 	if NEG jump $M.celt.cwrsi4.pos_part;
         r2 = r3 OR r2;
84201b88:	4f 00 45 84 	r2 = r3 OR r2;
         if Z jump cwrsi4_loop1_end;
84201b8c:	07 00 00 dd 	if EQ jump $M.celt.cwrsi4.cwrsi4_loop1_end;
         Null = r4 - r8;
84201b90:	af 00 06 20 	Null = r4 - r8;
         if POS jump cwrsi4_loop1_end;
84201b94:	05 00 50 dd 	if POS jump $M.celt.cwrsi4.cwrsi4_loop1_end;
         r10 = r4 + 1;
84201b98:	2f 00 c6 e4 	r10 = r4 + 1;
      jump cwrsi4_loop1;
84201b9c:	e2 ff f0 dd 	jump $M.celt.cwrsi4.cwrsi4_loop1;

84201ba0 <$M.celt.cwrsi4.pos_part>:
      pos_part:
          r8 = r4 - 1;
84201ba0:	3f 00 a6 e4 	r8 = r4 - 1;
   jump cwrsi4_loop1;
84201ba4:	e0 ff f0 dd 	jump $M.celt.cwrsi4.cwrsi4_loop1;

84201ba8 <$M.celt.cwrsi4.cwrsi4_loop1_end>:
   cwrsi4_loop1_end:

   r6 = r6 - r0;
84201ba8:	00 00 82 23 	r6 = r6 - r0;
   r7 = r7 - r1 - borrow;
84201bac:	00 00 93 27 	r7 = r7 - r1 - Borrow;
   r0 = M[FP + TMP + MK2];
84201bb0:	10 00 28 f1 	r0 = M[FP + 0x10];
   r0 = r4 - r0;
84201bb4:	2f 00 26 20 	r0 = r4 - r0;
   Null = M0;
84201bb8:	00 00 08 47 	Null = Null + M0;
   if Z r0 = -r0;
84201bbc:	20 00 20 20 	if EQ r0 = Null - r0;
   M[I7, MK1] = r0;
84201bc0:	ad 00 00 03 	Null = Null + Null, M[I7,4] = r0;
   call $celt.cwrsi3;
84201bc4:	67 ff f0 e1 	call $celt.cwrsi3;
   r0 = M[I7, -MK1];
84201bc8:	2f 00 00 03 	Null = Null + Null, r0 = M[I7,-4];
   SP = SP - STACK_FRAME_SIZE;
84201bcc:	f4 ff 03 f1 	SP = SP + -12;
   popm <FP,rLink>;
84201bd0:	01 20 04 f1 	popm <FP, rLink>;
   rts;
84201bd4:	0f 00 0d dc 	rts;

84201bd8 <$celt.cwrsi5>:
#endif
  
     // push rLink onto stack
   .CONST TMP                 (0 + 2)*ADDR_PER_WORD;
   .CONST STACK_FRAME_SIZE     3*ADDR_PER_WORD;
   pushm <FP(=SP), rLink>;
84201bd8:	01 20 00 f1 	pushm <FP(=SP), rLink>;
   SP = SP + STACK_FRAME_SIZE;
84201bdc:	0c 00 03 f1 	SP = SP + 12;
   r3 = r4 + 1;
84201be0:	2f 00 56 e4 	r3 = r4 + 1;
   $celt.ucwrs5(r3, r0, r1, r2, cwrsi5_lbl1)
84201be4:	00 00 30 01 	r1 = Null + 0;
84201be8:	0f 00 25 00 	r0 = r3 + Null;
84201bec:	13 00 00 dd 	if EQ jump $M.celt.cwrsi5.cwrsi5_lbl1;
84201bf0:	aa 2a 00 fd 	r2 = Null + 715827883;
84201bf4:	ab aa 40 01 
84201bf8:	cf 00 15 e4 	rMAC = r3 - 2;
84201bfc:	00 00 15 9b 	rMAC = rMAC * r3 (int);
84201c00:	05 00 11 01 	rMAC = rMAC + 5;
84201c04:	00 00 15 9b 	rMAC = rMAC * r3 (int);
84201c08:	df 00 11 e4 	rMAC = rMAC - 4;
84201c0c:	4f 00 31 94 	r1 = rMAC * r2 (frac);
84201c10:	03 00 33 99 	r1 = r1 * 3 (int);
84201c14:	1f 00 03 20 	Null = r1 - rMAC;
84201c18:	41 00 22 94 	if NE r0 = r0 * r2 (frac);
84201c1c:	1f 00 03 20 	Null = r1 - rMAC;
84201c20:	40 00 11 94 	if EQ rMAC = rMAC * r2 (frac);
84201c24:	2f 00 11 cc 	rMAC = rMAC * r0 (SS);
84201c28:	20 00 21 8d 	r0 = rMAC LSHIFT 32;
84201c2c:	00 00 31 8d 	r1 = rMAC LSHIFT 0;
84201c30:	2f 00 22 e4 	r0 = r0 + 1;
84201c34:	00 00 30 07 	r1 = r1 + Null + Carry;

84201c38 <$M.celt.cwrsi5.cwrsi5_lbl1>:
   M[FP + TMP + 0]  = r0;
84201c38:	08 00 2c f1 	M[FP + 0x8] = r0;
   M[FP + TMP + MK1]  = r1;
84201c3c:	0c 00 3c f1 	M[FP + 0xc] = r1;
   M[FP + TMP + MK2]  = r4;
84201c40:	10 00 6c f1 	M[FP + 0x10] = r4;

   M0 = 0;
84201c44:	00 00 80 51 	M0 = Null + 0;
   Null = r6 - r0;
84201c48:	2f 00 08 20 	Null = r6 - r0;
   Null = r7 - r1 - borrow;
84201c4c:	3f 00 09 24 	Null = r7 - r1 - Borrow;
   if NEG jump chng1_end;
84201c50:	04 00 40 dd 	if NEG jump $M.celt.cwrsi5.chng1_end;
      M0 = 1;
84201c54:	01 00 80 51 	M0 = Null + 1;
      r6 = r6 - r0;
84201c58:	00 00 82 23 	r6 = r6 - r0;
      r7 = r7 - r1 - borrow;
84201c5c:	00 00 93 27 	r7 = r7 - r1 - Borrow;

84201c60 <$M.celt.cwrsi5.chng1_end>:
   chng1_end:
   r10 = 0;
84201c60:	00 00 c0 01 	r10 = Null + 0;
   r8 = r4;
84201c64:	0f 00 a6 00 	r8 = r4 + Null;

84201c68 <$M.celt.cwrsi5.cwrsi5_loop1>:
   cwrsi5_loop1:
      r4 = r10 + r8;
84201c68:	af 00 6c 00 	r4 = r10 + r8;
      r4 = r4 LSHIFT -1;
84201c6c:	ff 00 66 8d 	r4 = r4 LSHIFT -1;
      $celt.ucwrs5(r4, r0, r1, r2, cwrsi5_lbl2)
84201c70:	00 00 30 01 	r1 = Null + 0;
84201c74:	0f 00 26 00 	r0 = r4 + Null;
84201c78:	13 00 00 dd 	if EQ jump $M.celt.cwrsi5.cwrsi5_lbl2;
84201c7c:	aa 2a 00 fd 	r2 = Null + 715827883;
84201c80:	ab aa 40 01 
84201c84:	cf 00 16 e4 	rMAC = r4 - 2;
84201c88:	00 00 16 9b 	rMAC = rMAC * r4 (int);
84201c8c:	05 00 11 01 	rMAC = rMAC + 5;
84201c90:	00 00 16 9b 	rMAC = rMAC * r4 (int);
84201c94:	df 00 11 e4 	rMAC = rMAC - 4;
84201c98:	4f 00 31 94 	r1 = rMAC * r2 (frac);
84201c9c:	03 00 33 99 	r1 = r1 * 3 (int);
84201ca0:	1f 00 03 20 	Null = r1 - rMAC;
84201ca4:	41 00 22 94 	if NE r0 = r0 * r2 (frac);
84201ca8:	1f 00 03 20 	Null = r1 - rMAC;
84201cac:	40 00 11 94 	if EQ rMAC = rMAC * r2 (frac);
84201cb0:	2f 00 11 cc 	rMAC = rMAC * r0 (SS);
84201cb4:	20 00 21 8d 	r0 = rMAC LSHIFT 32;
84201cb8:	00 00 31 8d 	r1 = rMAC LSHIFT 0;
84201cbc:	2f 00 22 e4 	r0 = r0 + 1;
84201cc0:	00 00 30 07 	r1 = r1 + Null + Carry;

84201cc4 <$M.celt.cwrsi5.cwrsi5_lbl2>:
      r2 = r6 - r0;
84201cc4:	2f 00 48 20 	r2 = r6 - r0;
      r3 = r7 - r1 - Borrow;
84201cc8:	3f 00 59 24 	r3 = r7 - r1 - Borrow;
      if NEG jump pos_part;
84201ccc:	07 00 40 dd 	if NEG jump $M.celt.cwrsi5.pos_part;
         r2 = r3 OR r2;
84201cd0:	4f 00 45 84 	r2 = r3 OR r2;
         if Z jump cwrsi5_loop1_end;
84201cd4:	07 00 00 dd 	if EQ jump $M.celt.cwrsi5.cwrsi5_loop1_end;
         Null = r4 - r8;
84201cd8:	af 00 06 20 	Null = r4 - r8;
         if POS jump cwrsi5_loop1_end;
84201cdc:	05 00 50 dd 	if POS jump $M.celt.cwrsi5.cwrsi5_loop1_end;
         r10 = r4 + 1;
84201ce0:	2f 00 c6 e4 	r10 = r4 + 1;
      jump cwrsi5_loop1;
84201ce4:	e1 ff f0 dd 	jump $M.celt.cwrsi5.cwrsi5_loop1;

84201ce8 <$M.celt.cwrsi5.pos_part>:
      pos_part:
         r8 = r4 - 1;
84201ce8:	3f 00 a6 e4 	r8 = r4 - 1;
   jump cwrsi5_loop1;
84201cec:	df ff f0 dd 	jump $M.celt.cwrsi5.cwrsi5_loop1;

84201cf0 <$M.celt.cwrsi5.cwrsi5_loop1_end>:

   cwrsi5_loop1_end:
   r6 = r6 - r0;
84201cf0:	00 00 82 23 	r6 = r6 - r0;
   r7 = r7 - r1 - borrow;
84201cf4:	00 00 93 27 	r7 = r7 - r1 - Borrow;
   r0 = M[FP + TMP + MK2];
84201cf8:	10 00 28 f1 	r0 = M[FP + 0x10];
   r0 = r4 - r0;
84201cfc:	2f 00 26 20 	r0 = r4 - r0;
   Null = M0;
84201d00:	00 00 08 47 	Null = Null + M0;
   if Z r0 = -r0;
84201d04:	20 00 20 20 	if EQ r0 = Null - r0;
   M[I7, MK1] = r0;
84201d08:	ad 00 00 03 	Null = Null + Null, M[I7,4] = r0;
   call $celt.cwrsi4;
84201d0c:	63 ff f0 e1 	call $celt.cwrsi4;
   r0 = M[I7, -MK1];
84201d10:	2f 00 00 03 	Null = Null + Null, r0 = M[I7,-4];
   SP = SP - STACK_FRAME_SIZE;
84201d14:	f4 ff 03 f1 	SP = SP + -12;
   popm <FP,rLink>;
84201d18:	01 20 04 f1 	popm <FP, rLink>;
   rts;
84201d1c:	0f 00 0d dc 	rts;

84201d20 <$celt.uprev>:

#if defined(PATCH_LIBS)
   LIBS_PUSH_REGS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.UPREV.PATCH_ID_0)     // celt_patchers
#endif
  
  I2 = I3;
84201d20:	0f 00 23 58 	I2 = I3 + Null;
     r1 = r5,  r5 = M[I2, M0];
  uprev_loop:
  M[I3, M0] = r2;
  M[I3, M0] = r3;
#else // K32
  M0 = 2*ADDR_PER_WORD;
84201d24:	08 00 80 51 	M0 = Null + 8;
  r10 = r10 - 1,  r0 = M[I2, M0]; //0 ->1
84201d28:	3f 28 cc e4 	r10 = r10 - 1, r0 = M[I2,M0];
  r4 = M[I2, M0];  //2->3
84201d2c:	00 68 00 02 	Null = Null + Null, r4 = M[I2,M0];
  do uprev_loop;
84201d30:	04 00 f0 e5 	do $M.celt.uprev.uprev_loop;
     r6 = r4 - r0;
84201d34:	2f 00 86 20 	r6 = r4 - r0;
     r2 = r6 - r2, M[I3, M0] = r2;
84201d38:	4f cc 48 20 	r2 = r6 - r2, M[I3,M0] = r2;
     r0 = r4, r4 = M[I2, M0];
84201d3c:	0f 68 26 00 	r0 = r4 + Null, r4 = M[I2,M0];

84201d40 <$M.celt.uprev.uprev_loop>:
  uprev_loop:
  M[I3, M0] = r2;
84201d40:	00 cc 00 02 	Null = Null + Null, M[I3,M0] = r2;
#endif // K32

  rts;
84201d44:	0f 00 0d dc 	rts;

84201d48 <$celt.unext>:

#if defined(PATCH_LIBS)
   LIBS_PUSH_REGS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.UNEXT.PATCH_ID_0)     // celt_patchers
#endif
  
  I2 = I3;
84201d48:	0f 00 23 58 	I2 = I3 + Null;
     r1 = r5,  r5 = M[I2, M0];
  unext_loop:
  M[I3, M0] = r2;
  M[I3, M0] = r3;
#else // K32
  M0 = 2*ADDR_PER_WORD;
84201d4c:	08 00 80 51 	M0 = Null + 8;
  r10 = r10 - 1, r0 = M[I2, M0]; //0 ->1
84201d50:	3f 28 cc e4 	r10 = r10 - 1, r0 = M[I2,M0];
  r4 = M[I2, M0];  //2->3
84201d54:	00 68 00 02 	Null = Null + Null, r4 = M[I2,M0];
  do unext_loop;
84201d58:	04 00 f0 e5 	do $M.celt.unext.unext_loop;
     r6 = r4 + r0;
84201d5c:	2f 00 86 00 	r6 = r4 + r0;
     r2 = r6 + r2, M[I3, M0] = r2;
84201d60:	4f cc 48 00 	r2 = r6 + r2, M[I3,M0] = r2;
     r0 = r4, r4 = M[I2, M0];
84201d64:	0f 68 26 00 	r0 = r4 + Null, r4 = M[I2,M0];

84201d68 <$M.celt.unext.unext_loop>:
  unext_loop:
  M[I3, M0] = r2;  
84201d68:	00 cc 00 02 	Null = Null + Null, M[I3,M0] = r2;

#endif // K32
  rts;
84201d6c:	0f 00 0d dc 	rts;

84201d70 <$celt.cwrsi>:

   //r4 = k
   //I7 = y
   //I5 = u (32 bit
   //M3 = n
   push rlink;
84201d70:	00 00 d0 f3 	push rLink;
   Words2Addr(r4);
84201d74:	02 00 66 91 	r4 = r4 ASHIFT 2;
   r8 = I5 + r4;
84201d78:	6f 00 a5 48 	r8 = I5 + r4;
   r8 = r8 + r4;
84201d7c:	00 00 a6 03 	r8 = r8 + r4;
   Addr2Words(r4);
84201d80:	fe 00 66 91 	r4 = r4 ASHIFT -2;
      I3 = I5;
      pushm <r0, r1, r4, r6, r7>;
      call $celt.uprev;
      popm <r0, r1, r4, r6, r7>;
#else // K32
   M2 = -2*ADDR_PER_WORD;
84201d84:	f8 ff a0 51 	M2 = Null + -8;

84201d88 <$M.celt.cwrsi.cwrsi_loop>:
   cwrsi_loop:
      r0 = M[r8 + MK2];
84201d88:	08 00 2a d1 	r0 = M[r8 + 8];
      M0 = 0;
84201d8c:	00 00 80 51 	M0 = Null + 0;
      Null = r6 - r0;
84201d90:	2f 00 08 20 	Null = r6 - r0;
      if NC jump chng1_end;
84201d94:	03 00 30 dd 	if NC jump $M.celt.cwrsi.chng1_end;
         M0 = 1;
84201d98:	01 00 80 51 	M0 = Null + 1;
         r6 = r6 - r0;
84201d9c:	00 00 82 23 	r6 = r6 - r0;

84201da0 <$M.celt.cwrsi.chng1_end>:
      chng1_end:
      r0 = M[r8 + 0];
84201da0:	00 00 2a d1 	r0 = M[r8 + 0];
      I2 = r8 - 2*ADDR_PER_WORD;
84201da4:	08 00 2a 71 	I2 = r8 - 8;

84201da8 <$M.celt.cwrsi.cwrsi_loop2>:
      cwrsi_loop2:
        r2 = r6 - r0, r0 = M[I2, M2];
84201da8:	2f 2a 48 20 	r2 = r6 - r0, r0 = M[I2,M2];
      if NC jump cwrsi_loop2;
84201dac:	ff ff 30 dd 	if NC jump $M.celt.cwrsi.cwrsi_loop2;
      r8 = I2 + 4*ADDR_PER_WORD;
84201db0:	10 00 a2 49 	r8 = I2 + 16;
      r6 = r2;
84201db4:	0f 00 84 00 	r6 = r2 + Null;
      r3 = r8 - I5;
84201db8:	5f 00 5a 64 	r3 = r8 - I5;
      Addr2Words(r3);
84201dbc:	fe 00 55 91 	r3 = r3 ASHIFT -2;
      r3 = r3 LSHIFT -1;
84201dc0:	ff 00 55 8d 	r3 = r3 LSHIFT -1;
      r4 = r4 - r3;
84201dc4:	00 00 65 23 	r4 = r4 - r3;
      Null = M0;
84201dc8:	00 00 08 47 	Null = Null + M0;
      if NZ r4 = -r4;
84201dcc:	61 00 60 20 	if NE r4 = Null - r4;
      M[I7, MK1] = r4;
84201dd0:	ed 00 00 03 	Null = Null + Null, M[I7,4] = r4;
      r4 = r3;
84201dd4:	0f 00 65 00 	r4 = r3 + Null;
      r10 = r4 + 2;
84201dd8:	af 00 c6 e4 	r10 = r4 + 2;
      r2 = 0;
84201ddc:	00 00 40 01 	r2 = Null + 0;
      I3 = I5;
84201de0:	0f 00 35 58 	I3 = I5 + Null;
      pushm <r4, r6>;
84201de4:	40 01 00 f1 	pushm <r4, r6>;
      call $celt.uprev;
84201de8:	ce ff f0 e1 	call $celt.uprev;
      popm  <r4, r6>;
84201dec:	40 01 04 f1 	popm <r4, r6>;
#endif
     M3 = M3 - 1;
84201df0:	01 00 bb 79 	M3 = M3 - 1;

   if NZ jump cwrsi_loop;
84201df4:	e5 ff 10 dd 	if NE jump $M.celt.cwrsi.cwrsi_loop;


   jump $pop_rLink_and_rts;
84201df8:	03 00 00 fd 	jump (m) 0x3b020;
84201dfc:	21 b0 f0 dd 

84201e00 <$celt.ncwrs_urow>:
   //r4 = k
   //r3 = n
   //len=_k+2;
   .CONST TEMP                 (0 + 2)*ADDR_PER_WORD;
   .CONST STACK_FRAME_SIZE     4*ADDR_PER_WORD;
   pushm <FP(=SP), rLink>;
84201e00:	01 20 00 f1 	pushm <FP(=SP), rLink>;
   SP = SP + STACK_FRAME_SIZE;
84201e04:	10 00 03 f1 	SP = SP + 16;
   Words2Addr(r4);
84201e08:	02 00 66 91 	r4 = r4 ASHIFT 2;
   I6 = I7 + r4;
84201e0c:	6f 00 67 58 	I6 = I7 + r4;
   I6 = I6 + r4;
84201e10:	00 00 66 5b 	I6 = I6 + r4;
   r8 = I7;
84201e14:	7f 00 a0 44 	r8 = Null + I7;
   Addr2Words(r4);
84201e18:	fe 00 66 91 	r4 = r4 ASHIFT -2;
   M3 = r4 + 2;
84201e1c:	02 00 b6 51 	M3 = r4 + 2;
   M[r8 + 0] = Null;
84201e20:	00 00 0a d5 	M[r8 + 0] = Null;
   M[r8 + MK1] = Null;
84201e24:	04 00 0a d5 	M[r8 + 4] = Null;
   r0 = 1;
84201e28:	2f 00 20 e4 	r0 = Null + 1;
   M[r8 + MK2] = r0;
84201e2c:	08 00 2a d5 	M[r8 + 8] = r0;
   M[r8 + 3*MK1] = Null;
84201e30:	0c 00 0a d5 	M[r8 + 12] = Null;

   Addr2Words(r3);
84201e34:	fe 00 55 91 	r3 = r3 ASHIFT -2;
   Null = r3 - 7;
84201e38:	07 00 05 21 	Null = r3 - 7;
   if NEG jump path1;
84201e3c:	2b 00 40 dd 	if NEG jump $M.celt.ncwrs_urow.path1;
   Null = r4 - 256;
84201e40:	00 01 06 21 	Null = r4 - 256;
   if POS jump path1;
84201e44:	29 00 50 dd 	if POS jump $M.celt.ncwrs_urow.path1;

84201e48 <$M.celt.ncwrs_urow.path2>:
   path2: /*n>6 && k<=255*/
      r0 = r3 + r3;
84201e48:	5f 00 25 00 	r0 = r3 + r3;
      r0 = r0 - 1;
84201e4c:	3f 00 22 e4 	r0 = r0 - 1;
      M[r8 + 4*MK1] = r0;
84201e50:	10 00 2a d5 	M[r8 + 16] = r0;
      r1 = 0;
84201e54:	00 00 30 01 	r1 = Null + 0;
      M[r8 + 5*MK1] = r1;
84201e58:	14 00 3a d5 	M[r8 + 20] = r1;
      M3 = r4 + -1;
84201e5c:	ff ff b6 51 	M3 = r4 + -1;
      if LE jump end;
84201e60:	35 00 d0 dd 	if LE jump $M.celt.ncwrs_urow.end;
      I3 = r8 + 6*ADDR_PER_WORD;
84201e64:	18 00 3a 51 	I3 = r8 + 24;
      r4 = 1;
84201e68:	2f 00 60 e4 	r4 = Null + 1;
      r5 = 0;
84201e6c:	00 00 70 01 	r5 = Null + 0;
      r2 = r0;
84201e70:	0f 00 42 00 	r2 = r0 + Null;
      r3 = r1;
84201e74:	0f 00 53 00 	r3 = r1 + Null;
      M[FP + TEMP + 0] = r2;  //UM1
84201e78:	08 00 4c f1 	M[FP + 0x8] = r2;
      M[FP + TEMP + MK1] = r3;  //uM1
84201e7c:	0c 00 5c f1 	M[FP + 0xc] = r3;
      M[FP + TEMP + MK2] = r4;  //um2
84201e80:	10 00 6c f1 	M[FP + 0x10] = r4;
      M[FP + TEMP + 3*MK1] = r5;  //um2
84201e84:	14 00 7c f1 	M[FP + 0x14] = r5;
      r10 = FP + TEMP + 2*MK1;
84201e88:	10 00 c7 f1 	r10 = FP + 16;
      I2 = r10;
84201e8c:	cf 00 20 50 	I2 = Null + r10;
      r10 = 2; //is not a do loop
84201e90:	af 00 c0 e4 	r10 = Null + 2;
      M2 = 1;
84201e94:	01 00 a0 51 	M2 = Null + 1;

84201e98 <$M.celt.ncwrs_urow.path2_unext_loop>:
      path2_unext_loop:
         r4 = M[I2, MK1];                //um2 2 ->3
84201e98:	00 69 00 03 	Null = Null + Null, r4 = M[I2,4];
         r5 = M[I2, -MK1];               //um2 3->2
84201e9c:	00 7b 00 03 	Null = Null + Null, r5 = M[I2,-4];
         call $celt.imusdiv32;
84201ea0:	81 08 f0 e1 	call $celt.imusdiv32;
         r2 = r2 + r4;
84201ea4:	00 00 46 03 	r2 = r2 + r4;
         r3 = r3 + r5 + Carry, M[I2, MK1] = r2; //um2 2 ->3
84201ea8:	00 c9 57 07 	r3 = r3 + r5 + Carry, M[I2,4] = r2;
         M[I2, -MK1] = r3;                       //um2 3 ->2
84201eac:	00 db 00 03 	Null = Null + Null, M[I2,-4] = r3;
         r10 = r10 + M2, M[I3, MK1] = r2;
84201eb0:	00 cd ca 47 	r10 = r10 + M2, M[I3,4] = r2;
         M3 = M3 - M2, M[I3, MK1] = r3;
84201eb4:	00 dd ba 7f 	M3 = M3 - M2, M[I3,4] = r3;
         if Z jump end;
84201eb8:	1f 00 00 dd 	if EQ jump $M.celt.ncwrs_urow.end;
         r5 = M[I2, -MK1];               //2->1 dummy
84201ebc:	00 7b 00 03 	Null = Null + Null, r5 = M[I2,-4];
         r5 = M[I2, -MK1];               //um1 1->0
84201ec0:	00 7b 00 03 	Null = Null + Null, r5 = M[I2,-4];
         r4 = M[I2, 0];                //um1 0->0
84201ec4:	00 68 00 03 	Null = Null + Null, r4 = M[I2,0];
         call $celt.imusdiv32;
84201ec8:	77 08 f0 e1 	call $celt.imusdiv32;

         r2 = r2 + r4;
84201ecc:	00 00 46 03 	r2 = r2 + r4;
         r3 = r3 + r5 + Carry, M[I2, MK1] = r2;  //um2 0 ->1
84201ed0:	00 c9 57 07 	r3 = r3 + r5 + Carry, M[I2,4] = r2;
         M[I2, MK1] = r3;                        //um2 1 ->2
84201ed4:	00 d9 00 03 	Null = Null + Null, M[I2,4] = r3;
         r10 = r10 + M2, M[I3, MK1] = r2;
84201ed8:	00 cd ca 47 	r10 = r10 + M2, M[I3,4] = r2;
         M3 = M3 - M2, M[I3, MK1] = r3;
84201edc:	00 dd ba 7f 	M3 = M3 - M2, M[I3,4] = r3;
      if NZ jump path2_unext_loop;
84201ee0:	ee ff 10 dd 	if NE jump $M.celt.ncwrs_urow.path2_unext_loop;
      jump end;
84201ee4:	14 00 f0 dd 	jump $M.celt.ncwrs_urow.end;

84201ee8 <$M.celt.ncwrs_urow.path1>:
   path1: /*n<=6 || k>255*/
      r10 = r4 - 1;
84201ee8:	3f 00 c6 e4 	r10 = r4 - 1;
      I3 = r8 + 4*ADDR_PER_WORD;
84201eec:	10 00 3a 51 	I3 = r8 + 16;
      r0 = 3;
84201ef0:	03 00 20 01 	r0 = Null + 3;
      r1 = 2;
84201ef4:	af 00 30 e4 	r1 = Null + 2;
      r2 = 0;
84201ef8:	00 00 40 01 	r2 = Null + 0;
      do set_uk_2_plus_loop;
84201efc:	03 00 f0 e5 	do $M.celt.ncwrs_urow.set_uk_2_plus_loop;
         r0 = r0 + r1, M[I3, MK1] = r0;
84201f00:	00 ad 23 03 	r0 = r0 + r1, M[I3,4] = r0;
         M[I3, MK1] = r2;
84201f04:	00 cd 00 03 	Null = Null + Null, M[I3,4] = r2;

84201f08 <$M.celt.ncwrs_urow.set_uk_2_plus_loop>:
      set_uk_2_plus_loop:
      M[I3, MK1] = r0;
84201f08:	00 ad 00 03 	Null = Null + Null, M[I3,4] = r0;
      M[I3, MK2] = r2;
84201f0c:	00 ce 00 03 	Null = Null + Null, M[I3,8] = r2;
      M3 = r3 - 2;
84201f10:	02 00 b5 71 	M3 = r3 - 2;
      M2 = r4 + 1;
84201f14:	01 00 a6 51 	M2 = r4 + 1;

84201f18 <$M.celt.ncwrs_urow.path1_unext_loop>:
      path1_unext_loop:
         r10 = M2;
84201f18:	af 00 c0 44 	r10 = Null + M2;
         r3 = 0;
84201f1c:	00 00 50 01 	r3 = Null + 0;
         r2 = 1;
84201f20:	2f 00 40 e4 	r2 = Null + 1;
         I3 = I7 + 2*ADDR_PER_WORD;
84201f24:	08 00 37 59 	I3 = I7 + 8;
         call $celt.unext;
84201f28:	88 ff f0 e1 	call $celt.unext;
         M3 = M3 - 1;
84201f2c:	01 00 bb 79 	M3 = M3 - 1;
      if NZ jump path1_unext_loop;
84201f30:	fa ff 10 dd 	if NE jump $M.celt.ncwrs_urow.path1_unext_loop;

84201f34 <$M.celt.ncwrs_urow.end>:
   end:
   r0 = M[I6, MK1];
84201f34:	29 00 00 03 	Null = Null + Null, r0 = M[I6,4];
   r1 = M[I6, MK1];
84201f38:	39 00 00 03 	Null = Null + Null, r1 = M[I6,4];
   r2 = M[I6, MK1];
84201f3c:	49 00 00 03 	Null = Null + Null, r2 = M[I6,4];
   r3 = M[I6, MK1];
84201f40:	59 00 00 03 	Null = Null + Null, r3 = M[I6,4];
   r0 = r0 + r2;
84201f44:	00 00 24 03 	r0 = r0 + r2;
   r1 = r1 + r3 + Carry;
84201f48:	00 00 35 07 	r1 = r1 + r3 + Carry;
   SP = SP - STACK_FRAME_SIZE;
84201f4c:	f0 ff 03 f1 	SP = SP + -16;
   popm <FP,rLink>;
84201f50:	01 20 04 f1 	popm <FP, rLink>;
   rts;
84201f54:	0f 00 0d dc 	rts;

84201f58 <$celt.alg_unquant>:

#if defined(PATCH_LIBS)
   LIBS_PUSH_REGS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.ALG_UNQUANT.PATCH_ID_0)     // celt_patchers
#endif   

   r0 = M0;
84201f58:	8f 00 20 44 	r0 = Null + M0;
   .CONST TEMP                 (0 + 2)*ADDR_PER_WORD;
   .CONST STACK_FRAME_SIZE     4*ADDR_PER_WORD;
   pushm <FP(=SP), rLink>;
84201f5c:	01 20 00 f1 	pushm <FP(=SP), rLink>;
   SP = SP + STACK_FRAME_SIZE;
84201f60:	10 00 03 f1 	SP = SP + 16;
   M[FP + TEMP + 0] = r0;
84201f64:	08 00 2c f1 	M[FP + 0x8] = r0;
   r0 = I5;
84201f68:	5f 00 20 44 	r0 = Null + I5;
   M[FP + TEMP + MK1] = r0;
84201f6c:	0c 00 2c f1 	M[FP + 0xc] = r0;
   M[FP + TEMP + MK2] = r3;
84201f70:	10 00 5c f1 	M[FP + 0x10] = r3;
   $celt.get_pulses(r4, r1, get_pulses_lbl1)
84201f74:	fd 00 36 8d 	r1 = r4 LSHIFT -3;
84201f78:	05 00 00 dd 	if EQ jump $M.celt.alg_unquant.get_pulses_lbl1;
84201f7c:	3f 00 33 e4 	r1 = r1 - 1;
84201f80:	07 00 66 81 	r4 = r4 AND 0x7;
84201f84:	08 00 66 01 	r4 = r4 + 8;
84201f88:	00 00 63 8f 	r4 = r4 LSHIFT r1;

84201f8c <$M.celt.alg_unquant.get_pulses_lbl1>:
   M[FP + TEMP + 3*MK1] = r4;
84201f8c:	14 00 6c f1 	M[FP + 0x14] = r4;

   r0 = M[r5 + $celt.dec.ALG_UNQUANT_ST_FIELD];
84201f90:	c4 00 27 d1 	r0 = M[r5 + 196];
   I7 = r0;
84201f94:	2f 00 70 50 	I7 = Null + r0;
   call  $celt.decode_pulses;
84201f98:	24 fe f0 e1 	call $celt.decode_pulses;
   r3 = M[FP + TEMP + MK2];
84201f9c:	10 00 58 f1 	r3 = M[FP + 0x10];
   r4 = M[FP + TEMP + 3*MK1];
84201fa0:	14 00 68 f1 	r4 = M[FP + 0x14];

   // calc enrgy of output
   r10 = r3 - 1;
84201fa4:	3f 00 c5 e4 	r10 = r3 - 1;
   r0 = M[r5 + $celt.dec.ALG_UNQUANT_ST_FIELD];
84201fa8:	c4 00 27 d1 	r0 = M[r5 + 196];
   I7 = r0;
84201fac:	2f 00 70 50 	I7 = Null + r0;
   rMAC = 0, r0 = M[I7, MK1];
84201fb0:	2d 00 11 23 	rMAC = rMAC - rMAC, r0 = M[I7,4];
   do calc_en_lp;
84201fb4:	02 00 f0 e5 	do $M.celt.alg_unquant.calc_en_lp;
      rMAC = rMAC + r0 * r0, r0 = M[I7, MK1];
84201fb8:	2d 00 22 af 	rMAC = rMAC + r0 * r0 (SS), r0 = M[I7,4];

84201fbc <$M.celt.alg_unquant.calc_en_lp>:
   calc_en_lp:
   rMAC = rMAC + r0 * r0;
84201fbc:	2f 00 12 ac 	rMAC = rMAC + r0 * r0 (SS);

   // normalise residual
   r0 = M[FP + TEMP + MK1];
84201fc0:	0c 00 28 f1 	r0 = M[FP + 0xc];
   I5 = r0;
84201fc4:	2f 00 50 50 	I5 = Null + r0;
   r0 = M[r5 + $celt.dec.ALG_UNQUANT_ST_FIELD];
84201fc8:	c4 00 27 d1 	r0 = M[r5 + 196];
   I7 = r0;
84201fcc:	2f 00 70 50 	I7 = Null + r0;
   call $celt.normalise_residual;
84201fd0:	e7 05 f0 e1 	call $celt.normalise_residual;
   Null = M[FP + TEMP + 0];
84201fd4:	08 00 08 f1 	Null = M[FP + 0x8];
   if Z jump end;
84201fd8:	08 00 00 dd 	if EQ jump $M.celt.alg_unquant.end;

   // rotation if required
   r6 = M[FP + TEMP];
84201fdc:	08 00 88 f1 	r6 = M[FP + 0x8];
   r0 = M[FP + TEMP + MK1];
84201fe0:	0c 00 28 f1 	r0 = M[FP + 0xc];
   I5 = r0;
84201fe4:	2f 00 50 50 	I5 = Null + r0;
   r3 = M[FP + TEMP + MK2];
84201fe8:	10 00 58 f1 	r3 = M[FP + 0x10];
   r4 = M[FP + TEMP + 3*MK1];
84201fec:	14 00 68 f1 	r4 = M[FP + 0x14];
   r7 = -1;
84201ff0:	3f 00 90 e4 	r7 = Null - 1;
   call $celt.exp_rotation;
84201ff4:	06 06 f0 e1 	call $celt.exp_rotation;

84201ff8 <$M.celt.alg_unquant.end>:
   end:
   SP = SP - STACK_FRAME_SIZE;
84201ff8:	f0 ff 03 f1 	SP = SP + -16;
   popm <FP,rLink>;
84201ffc:	01 20 04 f1 	popm <FP, rLink>;
   rts;
84202000:	0f 00 0d dc 	rts;

84202004 <$celt.icwrs2>:

#if defined(PATCH_LIBS)
   LIBS_PUSH_REGS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.ICWRS2.PATCH_ID_0)     // celt_patchers
#endif  
   
   I7 = I7 + MK1;
84202004:	04 00 77 59 	I7 = I7 + 4;
   r0 = M[I7, -MK1];
84202008:	2f 00 00 03 	Null = Null + Null, r0 = M[I7,-4];
   $celt.icwrs1(r0, r4, r6)
8420200c:	2f 00 80 e4 	r6 = Null + 1;
84202010:	0f 00 62 00 	r4 = r0 + Null;
84202014:	05 00 80 00 	if POS r6 = Null + Null;
84202018:	61 00 60 20 	if NE r4 = Null - r4;
   $celt.ucwrs2(r4, r0)
8420201c:	6f 00 26 00 	r0 = r4 + r4;
84202020:	3f 00 22 e4 	r0 = r0 - 1;
84202024:	04 00 20 00 	if NEG r0 = Null + Null;
   r6 = r6 + r0, r1 = M[I7, 0];
84202028:	3c 00 82 03 	r6 = r6 + r0, r1 = M[I7,0];
   Null = r1;
8420202c:	0f 00 03 00 	Null = r1 + Null;
   if POS jump end;
84202030:	08 00 50 dd 	if POS jump $M.celt.icwrs2.end;
      r4 = r4 - r1;
84202034:	00 00 63 23 	r4 = r4 - r1;
      r0 = r4 + 1;
84202038:	2f 00 26 e4 	r0 = r4 + 1;
      $celt.ucwrs2(r0, r2)
8420203c:	2f 00 42 00 	r2 = r0 + r0;
84202040:	3f 00 44 e4 	r2 = r2 - 1;
84202044:	04 00 40 00 	if NEG r2 = Null + Null;
      r6 = r6 + r2;
84202048:	00 00 84 03 	r6 = r6 + r2;
      rts;
8420204c:	0f 00 0d dc 	rts;

84202050 <$M.celt.icwrs2.end>:
   end:
   r4 = r4 + r1;
84202050:	00 00 63 03 	r4 = r4 + r1;
   rts;
84202054:	0f 00 0d dc 	rts;

84202058 <$celt.icwrs3>:

#if defined(PATCH_LIBS)
   LIBS_PUSH_REGS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.ICWRS3.PATCH_ID_0)     // celt_patchers
#endif  
   
   push rlink;
84202058:	00 00 d0 f3 	push rLink;
   I7 = I7 + MK1;
8420205c:	04 00 77 59 	I7 = I7 + 4;
   call $celt.icwrs2;
84202060:	e9 ff f0 e1 	call $celt.icwrs2;
   I7 = I7 - MK1;
84202064:	04 00 77 79 	I7 = I7 - 4;
   $celt.ucwrs3(r4, r0, r1, icwrs3_lbl1)
84202068:	00 00 20 01 	r0 = Null + 0;
8420206c:	00 00 30 01 	r1 = Null + 0;
84202070:	3f 00 16 e4 	rMAC = r4 - 1;
84202074:	06 00 40 dd 	if NEG jump $M.celt.icwrs3.icwrs3_lbl1;
84202078:	1f 00 16 cc 	rMAC = r4 * rMAC (SS);
8420207c:	20 00 21 8d 	r0 = rMAC LSHIFT 32;
84202080:	00 00 31 8d 	r1 = rMAC LSHIFT 0;
84202084:	2f 00 22 e4 	r0 = r0 + 1;
84202088:	00 00 30 07 	r1 = r1 + Null + Carry;

8420208c <$M.celt.icwrs3.icwrs3_lbl1>:
   r6 = r6 + r0, r2 = M[I7, 0];
8420208c:	4c 00 82 03 	r6 = r6 + r0, r2 = M[I7,0];
   r7 = r1 + Carry;
84202090:	0f 00 93 04 	r7 = r1 + Null + Carry;
   Null = r2;
84202094:	0f 00 04 00 	Null = r2 + Null;
   if POS jump end;
84202098:	10 00 50 dd 	if POS jump $M.celt.icwrs3.end;
      r4 = r4 - r2;
8420209c:	00 00 64 23 	r4 = r4 - r2;
      r0 = r4 + 1;
842020a0:	2f 00 26 e4 	r0 = r4 + 1;
      $celt.ucwrs3(r0, r1, r2, icwrs3_lbl2)
842020a4:	00 00 30 01 	r1 = Null + 0;
842020a8:	00 00 40 01 	r2 = Null + 0;
842020ac:	3f 00 12 e4 	rMAC = r0 - 1;
842020b0:	06 00 40 dd 	if NEG jump $M.celt.icwrs3.icwrs3_lbl2;
842020b4:	1f 00 12 cc 	rMAC = r0 * rMAC (SS);
842020b8:	20 00 31 8d 	r1 = rMAC LSHIFT 32;
842020bc:	00 00 41 8d 	r2 = rMAC LSHIFT 0;
842020c0:	2f 00 33 e4 	r1 = r1 + 1;
842020c4:	00 00 40 07 	r2 = r2 + Null + Carry;

842020c8 <$M.celt.icwrs3.icwrs3_lbl2>:
      r6 = r6 + r1;
842020c8:	00 00 83 03 	r6 = r6 + r1;
      r7 = r7 + r2 + Carry;
842020cc:	00 00 94 07 	r7 = r7 + r2 + Carry;
      jump $pop_rLink_and_rts;
842020d0:	03 00 00 fd 	jump (m) 0x3b020;
842020d4:	21 b0 f0 dd 

842020d8 <$M.celt.icwrs3.end>:
   end:
   r4 = r4 + r2;
842020d8:	00 00 64 03 	r4 = r4 + r2;
   jump $pop_rLink_and_rts;
842020dc:	03 00 00 fd 	jump (m) 0x3b020;
842020e0:	21 b0 f0 dd 

842020e4 <$celt.icwrs4>:

#if defined(PATCH_LIBS)
   LIBS_PUSH_REGS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.ICWRS4.PATCH_ID_0)     // celt_patchers
#endif 
   
   push rlink;
842020e4:	00 00 d0 f3 	push rLink;
   I7 = I7 + MK1;
842020e8:	04 00 77 59 	I7 = I7 + 4;
   call $celt.icwrs3;
842020ec:	db ff f0 e1 	call $celt.icwrs3;
   I7 = I7 - MK1;
842020f0:	04 00 77 79 	I7 = I7 - 4;
   $celt.ucwrs4(r4, r0, r1, r2, icwrs4_lbl1)
842020f4:	00 00 30 01 	r1 = Null + 0;
842020f8:	0f 00 26 00 	r0 = r4 + Null;
842020fc:	12 00 00 dd 	if EQ jump $M.celt.icwrs4.icwrs4_lbl1;
84202100:	aa 2a 00 fd 	r2 = Null + 715827883;
84202104:	ab aa 40 01 
84202108:	6f 00 16 00 	rMAC = r4 + r4;
8420210c:	03 00 11 21 	rMAC = rMAC - 3;
84202110:	00 00 16 9b 	rMAC = rMAC * r4 (int);
84202114:	bf 00 11 e4 	rMAC = rMAC + 4;
84202118:	4f 00 31 94 	r1 = rMAC * r2 (frac);
8420211c:	03 00 33 99 	r1 = r1 * 3 (int);
84202120:	1f 00 03 20 	Null = r1 - rMAC;
84202124:	41 00 22 94 	if NE r0 = r0 * r2 (frac);
84202128:	1f 00 03 20 	Null = r1 - rMAC;
8420212c:	40 00 11 94 	if EQ rMAC = rMAC * r2 (frac);
84202130:	2f 00 11 cc 	rMAC = rMAC * r0 (SS);
84202134:	20 00 21 8d 	r0 = rMAC LSHIFT 32;
84202138:	00 00 31 8d 	r1 = rMAC LSHIFT 0;
8420213c:	3f 00 22 e4 	r0 = r0 - 1;
84202140:	00 00 30 27 	r1 = r1 - Null - Borrow;

84202144 <$M.celt.icwrs4.icwrs4_lbl1>:
   r6 = r6 + r0, r2 = M[I7, 0];
84202144:	4c 00 82 03 	r6 = r6 + r0, r2 = M[I7,0];
   r7 = r1 + Carry;
84202148:	0f 00 93 04 	r7 = r1 + Null + Carry;
   Null = r2;
8420214c:	0f 00 04 00 	Null = r2 + Null;
   if POS jump end;
84202150:	1b 00 50 dd 	if POS jump $M.celt.icwrs4.end;
      r4 = r4 - r2;
84202154:	00 00 64 23 	r4 = r4 - r2;
      r0 = r4 + 1;
84202158:	2f 00 26 e4 	r0 = r4 + 1;
      $celt.ucwrs4(r0, r1, r2, r3, icwrs4_lbl2)
8420215c:	00 00 40 01 	r2 = Null + 0;
84202160:	0f 00 32 00 	r1 = r0 + Null;
84202164:	12 00 00 dd 	if EQ jump $M.celt.icwrs4.icwrs4_lbl2;
84202168:	aa 2a 00 fd 	r3 = Null + 715827883;
8420216c:	ab aa 50 01 
84202170:	2f 00 12 00 	rMAC = r0 + r0;
84202174:	03 00 11 21 	rMAC = rMAC - 3;
84202178:	00 00 12 9b 	rMAC = rMAC * r0 (int);
8420217c:	bf 00 11 e4 	rMAC = rMAC + 4;
84202180:	5f 00 41 94 	r2 = rMAC * r3 (frac);
84202184:	03 00 44 99 	r2 = r2 * 3 (int);
84202188:	1f 00 04 20 	Null = r2 - rMAC;
8420218c:	51 00 33 94 	if NE r1 = r1 * r3 (frac);
84202190:	1f 00 04 20 	Null = r2 - rMAC;
84202194:	50 00 11 94 	if EQ rMAC = rMAC * r3 (frac);
84202198:	3f 00 11 cc 	rMAC = rMAC * r1 (SS);
8420219c:	20 00 31 8d 	r1 = rMAC LSHIFT 32;
842021a0:	00 00 41 8d 	r2 = rMAC LSHIFT 0;
842021a4:	3f 00 33 e4 	r1 = r1 - 1;
842021a8:	00 00 40 27 	r2 = r2 - Null - Borrow;

842021ac <$M.celt.icwrs4.icwrs4_lbl2>:
      r6 = r6 + r1;
842021ac:	00 00 83 03 	r6 = r6 + r1;
      r7 = r7 + r2 + Carry;
842021b0:	00 00 94 07 	r7 = r7 + r2 + Carry;
      jump $pop_rLink_and_rts;
842021b4:	03 00 00 fd 	jump (m) 0x3b020;
842021b8:	21 b0 f0 dd 

842021bc <$M.celt.icwrs4.end>:
   end:
   r4 = r4 + r2;
842021bc:	00 00 64 03 	r4 = r4 + r2;
   jump $pop_rLink_and_rts;
842021c0:	03 00 00 fd 	jump (m) 0x3b020;
842021c4:	21 b0 f0 dd 

842021c8 <$celt.icwrs5>:

#if defined(PATCH_LIBS)
   LIBS_PUSH_REGS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.ICWRS5.PATCH_ID_0)     // celt_patchers
#endif 
   
   push rlink;
842021c8:	00 00 d0 f3 	push rLink;
   I7 = I7 + MK1;
842021cc:	04 00 77 59 	I7 = I7 + 4;
   call $celt.icwrs4;
842021d0:	c5 ff f0 e1 	call $celt.icwrs4;
   I7 = I7 - MK1;
842021d4:	04 00 77 79 	I7 = I7 - 4;
   $celt.ucwrs5(r4, r0, r1, r2, icwrs5_lbl1)
842021d8:	00 00 30 01 	r1 = Null + 0;
842021dc:	0f 00 26 00 	r0 = r4 + Null;
842021e0:	13 00 00 dd 	if EQ jump $M.celt.icwrs5.icwrs5_lbl1;
842021e4:	aa 2a 00 fd 	r2 = Null + 715827883;
842021e8:	ab aa 40 01 
842021ec:	cf 00 16 e4 	rMAC = r4 - 2;
842021f0:	00 00 16 9b 	rMAC = rMAC * r4 (int);
842021f4:	05 00 11 01 	rMAC = rMAC + 5;
842021f8:	00 00 16 9b 	rMAC = rMAC * r4 (int);
842021fc:	df 00 11 e4 	rMAC = rMAC - 4;
84202200:	4f 00 31 94 	r1 = rMAC * r2 (frac);
84202204:	03 00 33 99 	r1 = r1 * 3 (int);
84202208:	1f 00 03 20 	Null = r1 - rMAC;
8420220c:	41 00 22 94 	if NE r0 = r0 * r2 (frac);
84202210:	1f 00 03 20 	Null = r1 - rMAC;
84202214:	40 00 11 94 	if EQ rMAC = rMAC * r2 (frac);
84202218:	2f 00 11 cc 	rMAC = rMAC * r0 (SS);
8420221c:	20 00 21 8d 	r0 = rMAC LSHIFT 32;
84202220:	00 00 31 8d 	r1 = rMAC LSHIFT 0;
84202224:	2f 00 22 e4 	r0 = r0 + 1;
84202228:	00 00 30 07 	r1 = r1 + Null + Carry;

8420222c <$M.celt.icwrs5.icwrs5_lbl1>:
   r6 = r6 + r0, r2 = M[I7, 0];
8420222c:	4c 00 82 03 	r6 = r6 + r0, r2 = M[I7,0];
   r7 = r1 + Carry;
84202230:	0f 00 93 04 	r7 = r1 + Null + Carry;
   Null = r2;
84202234:	0f 00 04 00 	Null = r2 + Null;
   if POS jump end;
84202238:	1c 00 50 dd 	if POS jump $M.celt.icwrs5.end;
      r4 = r4 - r2;
8420223c:	00 00 64 23 	r4 = r4 - r2;
      r0 = r4 + 1;
84202240:	2f 00 26 e4 	r0 = r4 + 1;
      $celt.ucwrs5(r0, r1, r2, r3, icwrs5_lbl2)
84202244:	00 00 40 01 	r2 = Null + 0;
84202248:	0f 00 32 00 	r1 = r0 + Null;
8420224c:	13 00 00 dd 	if EQ jump $M.celt.icwrs5.icwrs5_lbl2;
84202250:	aa 2a 00 fd 	r3 = Null + 715827883;
84202254:	ab aa 50 01 
84202258:	cf 00 12 e4 	rMAC = r0 - 2;
8420225c:	00 00 12 9b 	rMAC = rMAC * r0 (int);
84202260:	05 00 11 01 	rMAC = rMAC + 5;
84202264:	00 00 12 9b 	rMAC = rMAC * r0 (int);
84202268:	df 00 11 e4 	rMAC = rMAC - 4;
8420226c:	5f 00 41 94 	r2 = rMAC * r3 (frac);
84202270:	03 00 44 99 	r2 = r2 * 3 (int);
84202274:	1f 00 04 20 	Null = r2 - rMAC;
84202278:	51 00 33 94 	if NE r1 = r1 * r3 (frac);
8420227c:	1f 00 04 20 	Null = r2 - rMAC;
84202280:	50 00 11 94 	if EQ rMAC = rMAC * r3 (frac);
84202284:	3f 00 11 cc 	rMAC = rMAC * r1 (SS);
84202288:	20 00 31 8d 	r1 = rMAC LSHIFT 32;
8420228c:	00 00 41 8d 	r2 = rMAC LSHIFT 0;
84202290:	2f 00 33 e4 	r1 = r1 + 1;
84202294:	00 00 40 07 	r2 = r2 + Null + Carry;

84202298 <$M.celt.icwrs5.icwrs5_lbl2>:
      r6 = r6 + r1;
84202298:	00 00 83 03 	r6 = r6 + r1;
      r7 = r7 + r2 + Carry;
8420229c:	00 00 94 07 	r7 = r7 + r2 + Carry;
      jump $pop_rLink_and_rts;
842022a0:	03 00 00 fd 	jump (m) 0x3b020;
842022a4:	21 b0 f0 dd 

842022a8 <$M.celt.icwrs5.end>:
   end:
   r4 = r4 + r2;
842022a8:	00 00 64 03 	r4 = r4 + r2;
   jump $pop_rLink_and_rts;
842022ac:	03 00 00 fd 	jump (m) 0x3b020;
842022b0:	21 b0 f0 dd 

842022b4 <$celt.icwrs>:

#if defined(PATCH_LIBS)
   LIBS_PUSH_REGS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.ICWRS.PATCH_ID_0)     // celt_patchers
#endif 
   
   push rlink;
842022b4:	00 00 d0 f3 	push rLink;

   I2 = I5;
842022b8:	0f 00 25 58 	I2 = I5 + Null;
   M0 = MK1;
842022bc:	04 00 80 51 	M0 = Null + 4;
   r2 = 0;
842022c0:	00 00 40 01 	r2 = Null + 0;
   r10 = r4, M[I2, M0] = r2;
842022c4:	0f c8 c6 00 	r10 = r4 + Null, M[I2,M0] = r2;
   r0 = 1, M[I2, M0] = r2; 
842022c8:	2f c8 20 e4 	r0 = Null + 1, M[I2,M0] = r2;
   r1 = r0 + r0, M[I2, M0] = r0;
842022cc:	2f a8 32 00 	r1 = r0 + r0, M[I2,M0] = r0;
   do init_u_loop;
842022d0:	03 00 f0 e5 	do $M.celt.icwrs.init_u_loop;
      r0 = r0 + r1, M[I2, M0] = r2;
842022d4:	00 c8 23 02 	r0 = r0 + r1, M[I2,M0] = r2;
      M[I2, M0] = r0;
842022d8:	00 a8 00 02 	Null = Null + Null, M[I2,M0] = r0;

842022dc <$M.celt.icwrs.init_u_loop>:
   init_u_loop:
   I7 = I7 - MK1;
842022dc:	04 00 77 79 	I7 = I7 - 4;
   I7 = I7 + r3, M[I2, M0] = r2;
842022e0:	00 c8 75 5a 	I7 = I7 + r3, M[I2,M0] = r2;
   r2 = M[I7, -MK1];
842022e4:	4f 00 00 03 	Null = Null + Null, r2 = M[I7,-4];
   $celt.icwrs1(r2, r8, r6)
842022e8:	2f 00 80 e4 	r6 = Null + 1;
842022ec:	0f 00 a4 00 	r8 = r2 + Null;
842022f0:	05 00 80 00 	if POS r6 = Null + Null;
842022f4:	a1 00 a0 20 	if NE r8 = Null - r8;
   r8 = r8 + r8;
842022f8:	00 00 aa 03 	r8 = r8 + r8;
   Words2Addr(r8);
842022fc:	02 00 aa 91 	r8 = r8 ASHIFT 2;
   r8 = I5 + r8;
84202300:	af 00 a5 48 	r8 = I5 + r8;
   r0 = M[r8 + 0];
84202304:	00 00 2a d1 	r0 = M[r8 + 0];
   r6 = r6 + r0;
84202308:	00 00 82 03 	r6 = r6 + r0;
   r7 = 0, r0 = M[I7, -MK1];
8420230c:	2f 00 99 23 	r7 = r7 - r7, r0 = M[I7,-4];
   r1  = r0 + r0;
84202310:	2f 00 32 00 	r1 = r0 + r0;
   if POS jump index_up;
84202314:	06 00 50 dd 	if POS jump $M.celt.icwrs.index_up;
      r1 = -r1;
84202318:	3f 00 30 20 	r1 = Null - r1;
      r2 = r1 + 2;
8420231c:	af 00 43 e4 	r2 = r1 + 2;
      Words2Addr(r2);
84202320:	02 00 44 91 	r2 = r2 ASHIFT 2;
      r0 = M[r8 + r2];
84202324:	4f 00 2a d0 	r0 = M[r8 + r2];
      r6 = r6 + r0;
84202328:	00 00 82 03 	r6 = r6 + r0;

8420232c <$M.celt.icwrs.index_up>:
   index_up:
   Words2Addr(r1);
8420232c:	02 00 33 91 	r1 = r1 ASHIFT 2;
   r8 = r8 + r1;
84202330:	00 00 a3 03 	r8 = r8 + r1;
   M3 = r3 - 2*ADDR_PER_WORD;
84202334:	08 00 b5 71 	M3 = r3 - 8;
   M1 = r4 + 2;
84202338:	02 00 96 51 	M1 = r4 + 2;

8420233c <$M.celt.icwrs.index_up_loop>:
   index_up_loop:
       r2 = 0;
8420233c:	00 00 40 01 	r2 = Null + 0;
       r3 = 0;
84202340:	00 00 50 01 	r3 = Null + 0;
       r10 = M1;
84202344:	9f 00 c0 44 	r10 = Null + M1;
       I3 = I5;
84202348:	0f 00 35 58 	I3 = I5 + Null;
       pushm<r6, r7>;
8420234c:	00 03 00 f1 	pushm <r6, r7>;
       call $celt.unext;
84202350:	7e fe f0 e1 	call $celt.unext;
       popm<r6, r7>;
84202354:	00 03 04 f1 	popm <r6, r7>;
       r0 = M[r8 + 0];
84202358:	00 00 2a d1 	r0 = M[r8 + 0];
       r1 = M[r8 + MK1];
8420235c:	04 00 3a d1 	r1 = M[r8 + 4];
       r6 = r6 + r0;
84202360:	00 00 82 03 	r6 = r6 + r0;
       r7 = r7 + r1 + Carry, r5 = M[I7, -MK1];
84202364:	7f 00 93 07 	r7 = r7 + r1 + Carry, r5 = M[I7,-4];
       r5 = r5 + r5;
84202368:	00 00 77 03 	r5 = r5 + r5;
       if POS jump end_update;
8420236c:	09 00 50 dd 	if POS jump $M.celt.icwrs.end_update;
          r5 = -r5;
84202370:	7f 00 70 20 	r5 = Null - r5;
          r2 = r5 + 2; 
84202374:	af 00 47 e4 	r2 = r5 + 2;
          Words2Addr(r2);
84202378:	02 00 44 91 	r2 = r2 ASHIFT 2;
          r0 = M[r8 + r2]; 
8420237c:	4f 00 2a d0 	r0 = M[r8 + r2];
          r2 = r2 + ADDR_PER_WORD;
84202380:	bf 00 44 e4 	r2 = r2 + 4;
          r1 = M[r8 + r2];
84202384:	4f 00 3a d0 	r1 = M[r8 + r2];
          r6 = r6 + r0;
84202388:	00 00 82 03 	r6 = r6 + r0;
          r7 = r7 + r1 + Carry;
8420238c:	00 00 93 07 	r7 = r7 + r1 + Carry;

84202390 <$M.celt.icwrs.end_update>:
       end_update:
       Words2Addr(r5);
84202390:	02 00 77 91 	r5 = r5 ASHIFT 2;
       r8 = r8 + r5;
84202394:	00 00 a7 03 	r8 = r8 + r5;
       M3 = M3 - ADDR_PER_WORD;  //1
84202398:	04 00 bb 79 	M3 = M3 - 4;
  if NZ jump index_up_loop;
8420239c:	e8 ff 10 dd 	if NE jump $M.celt.icwrs.index_up_loop;
  r0 = M[r8 + 0];
842023a0:	00 00 2a d1 	r0 = M[r8 + 0];
  r1 = M[r8 +   MK1];
842023a4:	04 00 3a d1 	r1 = M[r8 + 4];
  r2 = M[r8 + 2*MK1];
842023a8:	08 00 4a d1 	r2 = M[r8 + 8];
  r3 = M[r8 + 3*MK1];
842023ac:	0c 00 5a d1 	r3 = M[r8 + 12];
  r0 = r0 + r2;
842023b0:	00 00 24 03 	r0 = r0 + r2;
  r1 = r1 + r3 + Carry;
842023b4:	00 00 35 07 	r1 = r1 + r3 + Carry;
  jump $pop_rLink_and_rts;
842023b8:	03 00 00 fd 	jump (m) 0x3b020;
842023bc:	21 b0 f0 dd 

842023c0 <$celt.encode_pulses32>:

#if defined(PATCH_LIBS)
   LIBS_PUSH_REGS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.ENCODE_PULSES32.PATCH_ID_0)     // celt_patchers
#endif 
   
   push rlink;
842023c0:	00 00 d0 f3 	push rLink;
#ifndef CELT_USE_EXTERNAL_MEMORY
   .VAR jump_table[5]  = &n_1, &n_2, &n_3, &n_4, n_5;
#endif   
   // save nr of pulses and bins
   pushm<r3, r4, r5>;
842023c4:	e0 00 00 f1 	pushm <r3, r4, r5>;
   push I7;
842023c8:	00 00 71 f3 	push I7;
   
#if defined (KAL_ARCH4) || defined (KAL_ARCH5)
   r3 = r3 ASHIFT 2;
842023cc:	02 00 55 91 	r3 = r3 ASHIFT 2;
   Null = r3 - 6*4; // ARCH4/5: 4 AU per program word
842023d0:	18 00 05 21 	Null = r3 - 24;
#else
   Null = r3 - 6; // else: 1 AU per program word
#endif   
   if POS jump default;
842023d4:	50 00 50 dd 	if POS jump $M.celt.encode_pulses32.default;
   Null = r3 - 1;
842023d8:	3f 00 05 e4 	Null = r3 - 1;
   if NEG call $error;
842023dc:	03 00 00 fd 	if NEG call (m) 0x3ac3e;
842023e0:	3f ac 40 e1 
   // jump to proper function based on number of outputs
   // all can be processed using default (takes more cycles)
#ifdef CELT_USE_EXTERNAL_MEMORY
   r0 = M[r5 + $celt.enc.ENC_JUMP_TABLE_FIELD];
842023e4:	24 02 27 d1 	r0 = M[r5 + 548];
   r0 = r0 - MK1;
842023e8:	df 00 22 e4 	r0 = r0 - 4;
   r0 = M[r3 + r0];
842023ec:	2f 00 25 d0 	r0 = M[r3 + r0];
#else
   r0 = M[r3 + (jump_table-MK1)];
#endif
   jump r0;
842023f0:	0f 00 02 dc 	jump r0;

842023f4 <$M.celt.encode_pulses32.n_1>:

   // -- process n = 1
   n_1:
      r0 = M[I7, 0];
842023f4:	2c 00 00 03 	Null = Null + Null, r0 = M[I7,0];
      $celt.icwrs1(r0, r4, r6)
842023f8:	2f 00 80 e4 	r6 = Null + 1;
842023fc:	0f 00 62 00 	r4 = r0 + Null;
84202400:	05 00 80 00 	if POS r6 = Null + Null;
84202404:	61 00 60 20 	if NE r4 = Null - r4;
      r0 = 1;
84202408:	2f 00 20 e4 	r0 = Null + 1;
      M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FTB + 0] = r0;
8420240c:	e4 01 27 d5 	M[r5 + 484] = r0;
      M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FL + 0] = r6;
84202410:	d4 01 87 d5 	M[r5 + 468] = r6;
      M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FL + MK1] = Null;
84202414:	d8 01 07 d5 	M[r5 + 472] = Null;
      
      call $celt.ec_enc_bits;
84202418:	49 fc f0 e1 	call $celt.ec_enc_bits;
   jump $pop_rLink_and_rts;
8420241c:	03 00 00 fd 	jump (m) 0x3b020;
84202420:	21 b0 f0 dd 

84202424 <$M.celt.encode_pulses32.n_2>:

   // -- process n = 2
   n_2:
      call $celt.icwrs2;
84202424:	f8 fe f0 e1 	call $celt.icwrs2;
      $celt.ncwrs2(r4, r0)
84202428:	2f 00 20 e4 	r0 = Null + 1;
8420242c:	0f 00 06 00 	Null = r4 + Null;
84202430:	61 00 26 00 	if NE r0 = r4 + r4;
84202434:	21 00 22 00 	if NE r0 = r0 + r0;
      r1 = 0;
84202438:	00 00 30 01 	r1 = Null + 0;
      r7 = 0;
8420243c:	00 00 90 01 	r7 = Null + 0;
   jump end;
84202440:	3a 00 f0 dd 	jump $M.celt.encode_pulses32.end;

84202444 <$M.celt.encode_pulses32.n_3>:

   // -- process n = 3
   n_3:
      call $celt.icwrs3;
84202444:	05 ff f0 e1 	call $celt.icwrs3;
      $celt.ncwrs3(r4, r0, r1, encode_pulses32_n_3_lb1)
84202448:	2f 00 20 e4 	r0 = Null + 1;
8420244c:	00 00 30 01 	r1 = Null + 0;
84202450:	0f 00 16 00 	rMAC = r4 + Null;
84202454:	07 00 00 dd 	if EQ jump $M.celt.encode_pulses32.encode_pulses32_n_3_lb1;
84202458:	00 00 11 03 	rMAC = rMAC + rMAC;
8420245c:	1f 00 16 cc 	rMAC = r4 * rMAC (SS);
84202460:	20 00 21 8d 	r0 = rMAC LSHIFT 32;
84202464:	00 00 31 8d 	r1 = rMAC LSHIFT 0;
84202468:	af 00 22 e4 	r0 = r0 + 2;
8420246c:	00 00 30 07 	r1 = r1 + Null + Carry;

84202470 <$M.celt.encode_pulses32.encode_pulses32_n_3_lb1>:
   jump end;
84202470:	2e 00 f0 dd 	jump $M.celt.encode_pulses32.end;

84202474 <$M.celt.encode_pulses32.n_4>:

   // -- process n = 4
   n_4:
      call $celt.icwrs4;
84202474:	1c ff f0 e1 	call $celt.icwrs4;
      $celt.ncwrs4(r4, r0, r1, r2, encode_pulses32_n_4_lb1)
84202478:	2f 00 20 e4 	r0 = Null + 1;
8420247c:	00 00 30 01 	r1 = Null + 0;
84202480:	aa 2a 00 fd 	r2 = Null + 715827883;
84202484:	ab aa 40 01 
84202488:	04 00 16 99 	rMAC = r4 * 4 (int);
8420248c:	0c 00 00 dd 	if EQ jump $M.celt.encode_pulses32.encode_pulses32_n_4_lb1;
84202490:	6f 00 26 98 	r0 = r4 * r4 (int);
84202494:	af 00 22 e4 	r0 = r0 + 2;
84202498:	4f 00 31 94 	r1 = rMAC * r2 (frac);
8420249c:	03 00 33 99 	r1 = r1 * 3 (int);
842024a0:	1f 00 03 20 	Null = r1 - rMAC;
842024a4:	41 00 22 94 	if NE r0 = r0 * r2 (frac);
842024a8:	1f 00 03 20 	Null = r1 - rMAC;
842024ac:	40 00 11 94 	if EQ rMAC = rMAC * r2 (frac);
842024b0:	2f 00 11 cc 	rMAC = rMAC * r0 (SS);
842024b4:	20 00 21 8d 	r0 = rMAC LSHIFT 32;
842024b8:	00 00 31 8d 	r1 = rMAC LSHIFT 0;

842024bc <$M.celt.encode_pulses32.encode_pulses32_n_4_lb1>:
   jump end;
842024bc:	1b 00 f0 dd 	jump $M.celt.encode_pulses32.end;

842024c0 <$M.celt.encode_pulses32.n_5>:

   // -- process n = 5
   n_5:
      call $celt.icwrs5;
842024c0:	42 ff f0 e1 	call $celt.icwrs5;
      $celt.ncwrs5(r4, r0, r1, r2, decode_pulses32_n_5_lb1)
842024c4:	2f 00 20 e4 	r0 = Null + 1;
842024c8:	00 00 30 01 	r1 = Null + 0;
842024cc:	aa 2a 00 fd 	r2 = Null + 715827883;
842024d0:	ab aa 40 01 
842024d4:	6f 00 16 98 	rMAC = r4 * r4 (int);
842024d8:	0e 00 00 dd 	if EQ jump $M.celt.encode_pulses32.decode_pulses32_n_5_lb1;
842024dc:	05 00 21 01 	r0 = rMAC + 5;
842024e0:	00 00 11 03 	rMAC = rMAC + rMAC;
842024e4:	4f 00 31 94 	r1 = rMAC * r2 (frac);
842024e8:	03 00 33 99 	r1 = r1 * 3 (int);
842024ec:	1f 00 03 20 	Null = r1 - rMAC;
842024f0:	41 00 22 94 	if NE r0 = r0 * r2 (frac);
842024f4:	1f 00 03 20 	Null = r1 - rMAC;
842024f8:	40 00 11 94 	if EQ rMAC = rMAC * r2 (frac);
842024fc:	2f 00 11 cc 	rMAC = rMAC * r0 (SS);
84202500:	20 00 21 8d 	r0 = rMAC LSHIFT 32;
84202504:	00 00 31 8d 	r1 = rMAC LSHIFT 0;
84202508:	af 00 22 e4 	r0 = r0 + 2;
8420250c:	00 00 30 07 	r1 = r1 + Null + Carry;

84202510 <$M.celt.encode_pulses32.decode_pulses32_n_5_lb1>:
   jump end;
84202510:	06 00 f0 dd 	jump $M.celt.encode_pulses32.end;

84202514 <$M.celt.encode_pulses32.default>:

   // -- process n > 5
   default:
      r0 = M[r5 + $celt.enc.UVECTOR_FIELD];
84202514:	c8 00 27 d1 	r0 = M[r5 + 200];
      I5 = r0;
84202518:	2f 00 50 50 	I5 = Null + r0;
      push r5; // r5 needs to be preserved
8420251c:	00 00 70 f3 	push r5;
      call $celt.icwrs;
84202520:	65 ff f0 e1 	call $celt.icwrs;
      pop r5;
84202524:	00 00 74 f3 	pop r5;

84202528 <$M.celt.encode_pulses32.end>:
   end:
      M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FT + 0] = r0;
84202528:	cc 01 27 d5 	M[r5 + 460] = r0;
      M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FT + MK1] = r1;
8420252c:	d0 01 37 d5 	M[r5 + 464] = r1;
      M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FL + 0] = r6;
84202530:	d4 01 87 d5 	M[r5 + 468] = r6;
      M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FL + MK1] = r7;
84202534:	d8 01 97 d5 	M[r5 + 472] = r7;
      call $celt.ec_enc_uint;
84202538:	1d fc f0 e1 	call $celt.ec_enc_uint;

      pop I7;
8420253c:	00 00 75 f3 	pop I7;
      popm<r3, r4, r5>;
84202540:	e0 00 04 f1 	popm <r3, r4, r5>;

   jump $pop_rLink_and_rts;
84202544:	03 00 00 fd 	jump (m) 0x3b020;
84202548:	21 b0 f0 dd 

8420254c <$celt.transient_synthesis>:
8420254c:	44 00 67 d1 	r4 = M[r5 + 68];
#if defined(PATCH_LIBS)
   LIBS_PUSH_R0_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.TRANSIENT_SYNTHESIS.PATCH_ID_0,r4)     // celt_patchers
#endif 
   
   r4 = M[r5 + $celt.dec.MODE_AUDIO_FRAME_SIZE_FIELD];
   r3 = M[r5 + $celt.dec.MODE_OVERLAP_FIELD];
84202550:	40 00 57 d1 	r3 = M[r5 + 64];
   
   // copy output to scratch
   r2 = M[r5 + $celt.dec.TRANSIENT_PROC_FIELD];
84202554:	f0 00 47 d1 	r2 = M[r5 + 240];
   M3 = r2;
84202558:	4f 00 b0 50 	M3 = Null + r2;
   I1 = r2; //scratch memory
8420255c:	4f 00 10 50 	I1 = Null + r2;
   r10 = r4;                  //r10 = N
84202560:	0f 00 c6 00 	r10 = r4 + Null;
   I4 = I5;                   //I4 = save(I5)
84202564:	0f 00 45 58 	I4 = I5 + Null;
   I3 = I0;                   //I3 = save(I0)
84202568:	0f 00 30 58 	I3 = I0 + Null;
   do read_buf_loop;
8420256c:	03 00 f0 e5 	do $M.celt.transient_synthesis.read_buf_loop;
      r2 = M[I5, MK1];
84202570:	45 00 00 03 	Null = Null + Null, r2 = M[I5,4];
      M[I1, MK1] = r2;   
84202574:	00 c5 00 03 	Null = Null + Null, M[I1,4] = r2;

84202578 <$M.celt.transient_synthesis.read_buf_loop>:
   read_buf_loop:
   
   // copy hist to scratch
   r10 = r3;
84202578:	0f 00 c5 00 	r10 = r3 + Null;
   do read_hist_loop;
8420257c:	03 00 f0 e5 	do $M.celt.transient_synthesis.read_hist_loop;
      r2 = M[I0, MK1];
84202580:	00 41 00 03 	Null = Null + Null, r2 = M[I0,4];
      M[I1, MK1] = r2;   
84202584:	00 c5 00 03 	Null = Null + Null, M[I1,4] = r2;

84202588 <$M.celt.transient_synthesis.read_hist_loop>:
   read_hist_loop:
   
   //apply transient window and shift to first 16 samples
   r2 = M[r5 + $celt.dec.TRANSIENT_TIME_FIELD];
84202588:	64 01 47 d1 	r2 = M[r5 + 356];
   Words2Addr(r2);
8420258c:	02 00 44 91 	r2 = r2 ASHIFT 2;
   I1 = M3 - (16*ADDR_PER_WORD);
84202590:	40 00 1b 79 	I1 = M3 - 64;
   I1 = I1 + r2;     //16 samples before t time
84202594:	00 00 14 5b 	I1 = I1 + r2;
   r10 = 16;                               //wlen
84202598:	10 00 c0 01 	r10 = Null + 16;
#ifdef CELT_USE_EXTERNAL_MEMORY
   r1 = M[r5 + $celt.dec.PTR_TRANSIENT_WINDOW_TABLE_FIELD];
8420259c:	0c 02 37 d1 	r1 = M[r5 + 524];
   I6 = r1;
842025a0:	3f 00 60 50 	I6 = Null + r1;
#else // CELT_USE_EXTERNAL_MEMORY
   I6 = &$celt.transientWindow;         //w
#endif // CELT_USE_EXTERNAL_MEMORY
   r6 = 1.0;                               
842025a4:	ff 7f 00 fd 	r6 = Null + 2147483647;
842025a8:	ff ff 80 01 
   do transient_win_loop;
842025ac:	07 00 f0 e5 	do $M.celt.transient_synthesis.transient_win_loop;
      r2 = M[I1, 0], r1 = M[I6, MK1];        //r2 = x , r1 = w
842025b0:	39 44 00 03 	Null = Null + Null, r2 = M[I1,0], r1 = M[I6,4];
      rMAC = r1*r2;                        //rMAC = x*w
842025b4:	4f 00 13 cc 	rMAC = r1 * r2 (SS);
      rMAC = rMAC ASHIFT r0 (56bit);               //rMAC = x*w<<n
842025b8:	00 00 12 93 	rMAC = rMAC ASHIFT r0 (56bit);
      rMAC = rMAC - r1*r2;                 //rMAC = x*w((1<<n) - 1)
842025bc:	4f 00 13 bc 	rMAC = rMAC - r1 * r2 (SS);
      rMAC = rMAC + r6*r2;                 //rMAC = x*(1+w*((1<<n) - 1)
842025c0:	4f 00 18 ac 	rMAC = rMAC + r6 * r2 (SS);
      M[I1, MK1] = rMAC;                     //save
842025c4:	00 95 00 03 	Null = Null + Null, M[I1,4] = rMAC;

842025c8 <$M.celt.transient_synthesis.transient_win_loop>:
   transient_win_loop:
   // apply transient shift to the rest of buffer
   r10 = r3 + r4;                           //r10 = N + O
842025c8:	6f 00 c5 00 	r10 = r3 + r4;
   r1 = M[r5 + $celt.dec.TRANSIENT_TIME_FIELD];
842025cc:	64 01 37 d1 	r1 = M[r5 + 356];
   r10 = r10 - r1; //r10 = N + O -t
842025d0:	00 00 c3 23 	r10 = r10 - r1;
   r10 = r10 - 1;
842025d4:	3f 00 cc e4 	r10 = r10 - 1;
   r1 = M[I1, 0];                           //x
842025d8:	00 34 00 03 	Null = Null + Null, r1 = M[I1,0];
   I6 = I1 + 1*ADDR_PER_WORD;                              
842025dc:	04 00 61 59 	I6 = I1 + 4;
   M0 = MK1;
842025e0:	04 00 80 51 	M0 = Null + 4;
   do shift_transient_loop;
842025e4:	03 00 f0 e5 	do $M.celt.transient_synthesis.shift_transient_loop;
      r1 = r1 ASHIFT r0, r2 = M[I6, MK1];    //r1=x<<n, r2 = next x
842025e8:	49 00 32 93 	r1 = r1 ASHIFT r0, r2 = M[I6,4];
      r1 = r2, M[I1, M0] = r1;             //save previous, x=next x
842025ec:	0f b4 34 00 	r1 = r2 + Null, M[I1,M0] = r1;

842025f0 <$M.celt.transient_synthesis.shift_transient_loop>:
   shift_transient_loop:
   r1 = r1 ASHIFT r0;
842025f0:	00 00 32 93 	r1 = r1 ASHIFT r0;
   M[I1, M0] = r1;
842025f4:	00 b4 00 02 	Null = Null + Null, M[I1,M0] = r1;
   
   //write back from processed buffer to output
   I1 = M3; //scratch memory
842025f8:	0f 00 1b 58 	I1 = M3 + Null;
   I5 = I4;
842025fc:	0f 00 54 58 	I5 = I4 + Null;
   I0 = I3;
84202600:	0f 00 03 58 	I0 = I3 + Null;
   r10 = r4;
84202604:	0f 00 c6 00 	r10 = r4 + Null;
   do write_buf_loop;
84202608:	03 00 f0 e5 	do $M.celt.transient_synthesis.write_buf_loop;
      r2 = M[I1, MK1];
8420260c:	00 45 00 03 	Null = Null + Null, r2 = M[I1,4];
      M[I5, MK1] = r2;   
84202610:	c5 00 00 03 	Null = Null + Null, M[I5,4] = r2;

84202614 <$M.celt.transient_synthesis.write_buf_loop>:
   write_buf_loop:
   //write back from processed buffer to hist buf
   r10 = r3;
84202614:	0f 00 c5 00 	r10 = r3 + Null;
   do write_hist_loop;
84202618:	03 00 f0 e5 	do $M.celt.transient_synthesis.write_hist_loop;
      r2 = M[I1, MK1];
8420261c:	00 45 00 03 	Null = Null + Null, r2 = M[I1,4];
      M[I0, MK1] = r2;   
84202620:	00 c1 00 03 	Null = Null + Null, M[I0,4] = r2;

84202624 <$M.celt.transient_synthesis.write_hist_loop>:
   write_hist_loop:
   rts;
84202624:	0f 00 0d dc 	rts;

84202628 <$celt.mdct_shape>:
#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.MDCT_SHAPE.PATCH_ID_0,r4)     // celt_patchers
#endif 
   
   // push rLink onto stack
   push rlink;
84202628:	00 00 d0 f3 	push rLink;
   
   r0 = M[r5 + $celt.dec.CELT_CHANNELS_FIELD];
8420262c:	08 00 27 d1 	r0 = M[r5 + 8];
   I6 = r0 + 1;
84202630:	01 00 62 51 	I6 = r0 + 1;
   r0 = M[r5 + $celt.dec.MODE_NB_SHORT_MDCTS_FIELD];
84202634:	58 00 27 d1 	r0 = M[r5 + 88];
   M0 = r0;
84202638:	2f 00 80 50 	M0 = Null + r0;
   Words2Addr(r0);
8420263c:	02 00 22 91 	r0 = r0 ASHIFT 2;
   M3 = r0;
84202640:	2f 00 b0 50 	M3 = Null + r0;
   r0 = M[r5 + $celt.dec.MODE_SHORT_MDCT_SIZE_FIELD];
84202644:	5c 00 27 d1 	r0 = M[r5 + 92];
   I7 = r0;
84202648:	2f 00 70 50 	I7 = Null + r0;
   r4 = M[r5 + $celt.dec.MDCT_WEIGHT_SHIFT_FIELD];
8420264c:	6c 01 67 d1 	r4 = M[r5 + 364];
   r4 = -r4;
84202650:	6f 00 60 20 	r4 = Null - r4;
   r0 = M[r5 + $celt.dec.MDCT_WEIGHT_POS_FIELD];
84202654:	70 01 27 d1 	r0 = M[r5 + 368];
   M1 = r0 + 1; //end point
84202658:	01 00 92 51 	M1 = r0 + 1;
   Words2Addr(r0);
8420265c:	02 00 22 91 	r0 = r0 ASHIFT 2;
   M2 = r0 + ADDR_PER_WORD;
84202660:	04 00 a2 51 	M2 = r0 + 4;
   r0 = M[r5 + $celt.dec.NORM_FREQ_FIELD];
84202664:	cc 00 27 d1 	r0 = M[r5 + 204];
   I3 = r0 + M2; //X
84202668:	af 00 32 54 	I3 = r0 + M2;
   NULL = r8;
8420266c:	0f 00 0a 00 	Null = r8 + Null;
   if Z jump setup_done;   
84202670:	03 00 00 dd 	if EQ jump $M.celt.mdct_shape.chan_shape_loop;
      I3 = r0 + M3;
84202674:	bf 00 32 54 	I3 = r0 + M3;
      M1 = M0 - M1;
84202678:	9f 00 98 7c 	M1 = M0 - M1;

8420267c <$M.celt.mdct_shape.chan_shape_loop>:
   setup_done:   
   chan_shape_loop:
      M2 = M1;
8420267c:	0f 00 a9 58 	M2 = M1 + Null;
      r0 = M2;
84202680:	af 00 20 44 	r0 = Null + M2;

84202684 <$M.celt.mdct_shape.block_loop>:
      block_loop: 
         r10 = I7 - 1;
84202684:	01 00 c7 69 	r10 = I7 - 1;
         Words2Addr(r0);
84202688:	02 00 22 91 	r0 = r0 ASHIFT 2;
         I4 = I3 - r0;
8420268c:	2f 00 43 78 	I4 = I3 - r0;
         I2 = I4;
84202690:	0f 00 24 58 	I2 = I4 + Null;
         r0 = M[I2, M3];
84202694:	00 2b 00 02 	Null = Null + Null, r0 = M[I2,M3];
         do shift_loop;
84202698:	03 00 f0 e5 	do $M.celt.mdct_shape.shift_loop;
            r1 = r0 ASHIFT r4, r0 = M[I2, M3];
8420269c:	6f 2b 32 90 	r1 = r0 ASHIFT r4, r0 = M[I2,M3];
            M[I4, M3] = r1;
842026a0:	b3 00 00 02 	Null = Null + Null, M[I4,M3] = r1;

842026a4 <$M.celt.mdct_shape.shift_loop>:
         shift_loop:
         r1 = r0 ASHIFT r4; 
842026a4:	6f 00 32 90 	r1 = r0 ASHIFT r4;
         M[I4, M3] = r1;
842026a8:	b3 00 00 02 	Null = Null + Null, M[I4,M3] = r1;
         M2 = M2 - 1;
842026ac:	01 00 aa 79 	M2 = M2 - 1;
	 r0 = M2;
842026b0:	af 00 20 44 	r0 = Null + M2;
      if NZ jump block_loop;
842026b4:	f4 ff 10 dd 	if NE jump $M.celt.mdct_shape.block_loop;
      r0 = M[r5 + $celt.dec.MODE_MDCT_SIZE_FIELD];
842026b8:	44 00 27 d1 	r0 = M[r5 + 68];
      Words2Addr(r0);
842026bc:	02 00 22 91 	r0 = r0 ASHIFT 2;
      I3 = I3 + r0;
842026c0:	00 00 32 5b 	I3 = I3 + r0;
      I6 = I6 - 1;
842026c4:	01 00 66 79 	I6 = I6 - 1;
   if NZ jump chan_shape_loop;
842026c8:	ed ff 10 dd 	if NE jump $M.celt.mdct_shape.chan_shape_loop;
   call $celt.renormalise_bands;
842026cc:	ae 03 f0 e1 	call $celt.renormalise_bands;
   // pop rLink from stack
   jump $pop_rLink_and_rts;
842026d0:	03 00 00 fd 	jump (m) 0x3b020;
842026d4:	21 b0 f0 dd 

842026d8 <$celt.unquant_coarse_energy>:
842026d8:	01 20 00 f1 	pushm <FP(=SP), rLink>;
   .CONST BETA                 (1 + 2)*ADDR_PER_WORD;
   .CONST PREV                 (2 + 2)*ADDR_PER_WORD;
   .CONST CH                   (4 + 2)*ADDR_PER_WORD;
   .CONST STACK_FRAME_SIZE     5*ADDR_PER_WORD;
   pushm <FP(=SP), rLink>;
   SP = SP + STACK_FRAME_SIZE;
842026dc:	14 00 03 f1 	SP = SP + 20;
   // calc budget
   r1 = M[r5 + $celt.dec.CELT_CODEC_FRAME_SIZE_FIELD];
842026e0:	04 00 37 d1 	r1 = M[r5 + 4];
   r1 = r1 LSHIFT 2;
842026e4:	02 00 33 8d 	r1 = r1 LSHIFT 2;
   I5 = r1 - 8; // I5:budget
842026e8:	08 00 53 71 	I5 = r1 - 8;
   
   // reset prev for both channels
   M[FP + PREV] = Null;
842026ec:	10 00 0c f1 	M[FP + 0x10] = Null;
   M[FP + PREV + MK1] = Null;
842026f0:	14 00 0c f1 	M[FP + 0x14] = Null;
   
   r1 = M[r5 + $celt.dec.MODE_PROB_ADDR_FIELD];
842026f4:	6c 00 37 d1 	r1 = M[r5 + 108];
   I2 = r1;
842026f8:	3f 00 20 50 	I2 = Null + r1;
   r0 = M[r5 + $celt.dec.MODE_NB_EBANDS_FIELD];
842026fc:	48 00 27 d1 	r0 = M[r5 + 72];
   Words2Addr(r0);
84202700:	02 00 22 91 	r0 = r0 ASHIFT 2;
   I6 = r0;
84202704:	2f 00 60 50 	I6 = Null + r0;
   r0 = M[r5 + $celt.dec.MODE_E_PRED_COEF_FIELD];
84202708:	50 00 27 d1 	r0 = M[r5 + 80];
   // calc coef
   Null = M[r5 + $celt.dec.INTRA_ENER_FIELD];
8420270c:	54 01 07 d1 	Null = M[r5 + 340];
   if Z jump intra_end;
84202710:	04 00 00 dd 	if EQ jump $M.celt.unquant_coarse_energy.intra_end;
      r0 = I6 + I6;
84202714:	6f 00 26 4c 	r0 = I6 + I6;
      I2 = I2 + r0;
84202718:	00 00 22 5b 	I2 = I2 + r0;
      r0 = 0;
8420271c:	00 00 20 01 	r0 = Null + 0;

84202720 <$M.celt.unquant_coarse_energy.intra_end>:
   intra_end:
   M[FP + COEF] = r0;
84202720:	08 00 2c f1 	M[FP + 0x8] = r0;
   r0 = r0 * 0.8 (frac);
84202724:	66 66 00 fd 	r0 = r0 * 0.799999999813735485076904296875 (frac);
84202728:	66 66 22 95 
   M[FP + BETA] = r0;
8420272c:	0c 00 2c f1 	M[FP + 0xc] = r0;
   r0 = M[r5 + $celt.dec.TEMP_VECT_FIELD];
84202730:	34 01 27 d1 	r0 = M[r5 + 308];
   I4 = r0;
84202734:	2f 00 40 50 	I4 = Null + r0;
   M3 = ADDR_PER_WORD;
84202738:	04 00 b0 51 	M3 = Null + 4;

8420273c <$M.celt.unquant_coarse_energy.get_q_loop>:
   get_q_loop:
      r4 = 0;
8420273c:	00 00 60 01 	r4 = Null + 0;
      call $celt.ec_dec_tell;
84202740:	fa fa f0 e1 	call $celt.ec_dec_tell;
      r1 = -M3, r2 = M[I2, M3];
84202744:	bf 4b 30 64 	r1 = Null - M3, r2 = M[I2,M3];
      Null = r0 - I5, r3 = M[I2, M3];
84202748:	5f 5b 02 64 	Null = r0 - I5, r3 = M[I2,M3];
      if LE call $celt.ec_laplace_decode_start;
8420274c:	db 05 d0 e1 	if LE call $celt.ec_laplace_decode_start;
      NULL = M[r5 + $celt.dec.CELT_CHANNELS_FIELD];      
84202750:	08 00 07 d1 	Null = M[r5 + 8];
      if Z jump ch_end_loop;
84202754:	07 00 00 dd 	if EQ jump $M.celt.unquant_coarse_energy.ch_end_loop;
         I2 = I2 - 2*ADDR_PER_WORD;
84202758:	08 00 22 79 	I2 = I2 - 8;
         r4 = 0, M[I4, MK1] = r1;
8420275c:	b1 00 66 23 	r4 = r4 - r4, M[I4,4] = r1;
         call $celt.ec_dec_tell;
84202760:	f2 fa f0 e1 	call $celt.ec_dec_tell;
         r1 = -M3, r2 = M[I2, M3];
84202764:	bf 4b 30 64 	r1 = Null - M3, r2 = M[I2,M3];
         Null = r0 - I5, r3 = M[I2, M3];
84202768:	5f 5b 02 64 	Null = r0 - I5, r3 = M[I2,M3];
         if LE call $celt.ec_laplace_decode_start;
8420276c:	d3 05 d0 e1 	if LE call $celt.ec_laplace_decode_start;

84202770 <$M.celt.unquant_coarse_energy.ch_end_loop>:
      ch_end_loop:
      I6 = I6 - M3, M[I4, M3] = r1;
84202770:	b3 00 6b 7e 	I6 = I6 - M3, M[I4,M3] = r1;
   if NZ jump get_q_loop; 
84202774:	f2 ff 10 dd 	if NE jump $M.celt.unquant_coarse_energy.get_q_loop;

//   M2 = 0;
#ifdef CELT_USE_EXTERNAL_MEMORY
   r0 = M[r5 + $celt.enc.PTR_EMEANS_TABLE_FIELD];
84202778:	14 02 27 d1 	r0 = M[r5 + 532];
   I2 = r0;
8420277c:	2f 00 20 50 	I2 = Null + r0;
#else // CELT_USE_EXTERNAL_MEMORY
   I2 = &$celt.eMeans;
#endif // CELT_USE_EXTERNAL_MEMORY
   r0 = M[r5 + $celt.dec.OLD_EBAND_LEFT_FIELD];
84202780:	8c 00 27 d1 	r0 = M[r5 + 140];
   I3 = r0; 
84202784:	2f 00 30 50 	I3 = Null + r0;
   r0 = FP + PREV;
84202788:	10 00 27 f1 	r0 = FP + 16;
   I4 = r0;
8420278c:	2f 00 40 50 	I4 = Null + r0;
   r0 = M[r5 + $celt.dec.TEMP_VECT_FIELD];
84202790:	34 01 27 d1 	r0 = M[r5 + 308];
   I5 = r0;
84202794:	2f 00 50 50 	I5 = Null + r0;
   r0 = M[r5 + $celt.dec.CELT_CHANNELS_FIELD];
84202798:	08 00 27 d1 	r0 = M[r5 + 8];
   Words2Addr(r0);
8420279c:	02 00 22 91 	r0 = r0 ASHIFT 2;
   M3 = r0 + ADDR_PER_WORD;
842027a0:	04 00 b2 51 	M3 = r0 + 4;
   M0 = ADDR_PER_WORD;
842027a4:	04 00 80 51 	M0 = Null + 4;
   r8 = (DAWTH-8);
842027a8:	18 00 a0 01 	r8 = Null + 24;
   r7 = M[FP + COEF];
842027ac:	08 00 98 f1 	r7 = M[FP + 0x8];
   r0 = FP + BETA;
842027b0:	0c 00 27 f1 	r0 = FP + 12;
   I7 = r0;
842027b4:	2f 00 70 50 	I7 = Null + r0;
   r0 = M[r5 + $celt.dec.CELT_CHANNELS_FIELD];
842027b8:	08 00 27 d1 	r0 = M[r5 + 8];
   I6 = r0;
842027bc:	2f 00 60 50 	I6 = Null + r0;

842027c0 <$M.celt.unquant_coarse_energy.loop_decode_coarse>:
   /* Decode at a fixed coarse resolution */
   loop_decode_coarse:
      r10 = M[r5 + $celt.dec.MODE_NB_EBANDS_FIELD];
842027c0:	48 00 c7 d1 	r10 = M[r5 + 72];
      do coarse_loop;
842027c4:	0c 00 f0 e5 	do $M.celt.unquant_coarse_energy.coarse_loop;
         r1 = M[I5, M3], r0 = M[I2, M0];      
842027c8:	37 28 00 02 	Null = Null + Null, r0 = M[I2,M0], r1 = M[I5,M3];
         r1 = r1 ASHIFT r8, r4 = M[I4, 0];                                      
842027cc:	60 00 3a 93 	r1 = r1 ASHIFT r8, r4 = M[I4,0];
         r4 = r4 + r0, r2 = M[I3, 0];              //r4 = m+ p, r2 =b
842027d0:	00 4c 62 03 	r4 = r4 + r0, r2 = M[I3,0];
         r4 = r4 + r1;                             //r4 = m+p+q
842027d4:	00 00 63 03 	r4 = r4 + r1;
         r3 = r2 - r0;                             //r3 = b -m
842027d8:	2f 00 54 20 	r3 = r2 - r0;
         r3 = r3 * r7 (frac);                      //r3 = (b-m)*c
842027dc:	00 00 59 97 	r3 = r3 * r7 (frac);
         r3 = r3 + r4;                             //r3 -->b
842027e0:	00 00 56 03 	r3 = r3 + r4;
         rMAC = r0*r7, r0 = M[I7, 0];
842027e4:	2c 00 29 cf 	rMAC = r0 * r7 (SS), r0 = M[I7,0];
         rMAC = rMAC + r1*r0, M[I3, MK1] = r3;       //save C-Energy
842027e8:	00 dd 32 af 	rMAC = rMAC + r1 * r0 (SS), M[I3,4] = r3;
         r4 = r4 - rMAC;
842027ec:	00 00 61 23 	r4 = r4 - rMAC;
         M[I4, 0] = r4;                            //save prev
842027f0:	e0 00 00 03 	Null = Null + Null, M[I4,0] = r4;

842027f4 <$M.celt.unquant_coarse_energy.coarse_loop>:
      coarse_loop:         
      I6 = I6 - 1;
842027f4:	01 00 66 79 	I6 = I6 - 1;
   if NEG jump cleanup;
842027f8:	0a 00 40 dd 	if NEG jump $M.celt.unquant_coarse_energy.cleanup;
#ifdef CELT_USE_EXTERNAL_MEMORY
   r0 = M[r5 + $celt.enc.PTR_EMEANS_TABLE_FIELD];
842027fc:	14 02 27 d1 	r0 = M[r5 + 532];
   I2 = r0;
84202800:	2f 00 20 50 	I2 = Null + r0;
#else // CELT_USE_EXTERNAL_MEMORY
   I2 = &$celt.eMeans;
#endif // CELT_USE_EXTERNAL_MEMORY
   r0 = M[r5 + $celt.dec.OLD_EBAND_LEFT_FIELD];
84202804:	8c 00 27 d1 	r0 = M[r5 + 140];
   I3 = r0 + ($celt.MAX_BANDS*ADDR_PER_WORD);
84202808:	64 00 32 51 	I3 = r0 + 100;

   r0 = FP + PREV;
8420280c:	10 00 27 f1 	r0 = FP + 16;
   I4 = r0 + ADDR_PER_WORD;
84202810:	04 00 42 51 	I4 = r0 + 4;
   r0 = M[r5 + $celt.dec.TEMP_VECT_FIELD];
84202814:	34 01 27 d1 	r0 = M[r5 + 308];
   I5 = r0 + ADDR_PER_WORD;
84202818:	04 00 52 51 	I5 = r0 + 4;
   jump loop_decode_coarse;
8420281c:	e9 ff f0 dd 	jump $M.celt.unquant_coarse_energy.loop_decode_coarse;

84202820 <$M.celt.unquant_coarse_energy.cleanup>:

cleanup:
   SP = SP - STACK_FRAME_SIZE;
84202820:	ec ff 03 f1 	SP = SP + -20;
   popm <FP,rLink>;
84202824:	01 20 04 f1 	popm <FP, rLink>;
   rts;
84202828:	0f 00 0d dc 	rts;

8420282c <$celt.unquant_fine_energy>:
#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.UNQUANT_FINE_ENERGY.PATCH_ID_0,r2)     // celt_patchers
#endif 
   
   // push rLink onto stack
   push rlink;
8420282c:	00 00 d0 f3 	push rLink;
   r0 = M[r5 + $celt.dec.MODE_NB_EBANDS_FIELD];
84202830:	48 00 27 d1 	r0 = M[r5 + 72];
   M3 = r0;
84202834:	2f 00 b0 50 	M3 = Null + r0;
   r0 = M[r5 + $celt.dec.FINE_QUANT_FIELD];
84202838:	08 01 27 d1 	r0 = M[r5 + 264];
   I2 = r0;
8420283c:	2f 00 20 50 	I2 = Null + r0;
   r0 = M[r5 + $celt.dec.OLD_EBAND_LEFT_FIELD];
84202840:	8c 00 27 d1 	r0 = M[r5 + 140];
   I3 = r0;
84202844:	2f 00 30 50 	I3 = Null + r0;
   I4 = r0 + ($celt.MAX_BANDS*ADDR_PER_WORD);
84202848:	64 00 42 51 	I4 = r0 + 100;
   M0 = 1;
8420284c:	01 00 80 51 	M0 = Null + 1;
   r0 = M[r5 + $celt.dec.CELT_CHANNELS_FIELD];
84202850:	08 00 27 d1 	r0 = M[r5 + 8];
   I6 = r0;
84202854:	2f 00 60 50 	I6 = Null + r0;

84202858 <$M.celt.unquant_fine_energy.fine_unquant_loop>:
   fine_unquant_loop:
      r2 = M[I2, MK1];
84202858:	00 49 00 03 	Null = Null + Null, r2 = M[I2,4];
      M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FTB] = r2;
8420285c:	e4 01 47 d5 	M[r5 + 484] = r2;
      if LE jump b_loop;
84202860:	17 00 d0 dd 	if LE jump $M.celt.unquant_fine_energy.b_loop;
         call $celt.ec_dec_bits;
84202864:	1d fa f0 e1 	call $celt.ec_dec_bits;
         r1 = r0 + r0;
84202868:	2f 00 32 00 	r1 = r0 + r0;
         r1 = r1 + 1;
8420286c:	2f 00 33 e4 	r1 = r1 + 1;
         r2 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FTB];
84202870:	e4 01 47 d1 	r2 = M[r5 + 484];
         r2 = (DAWTH-9) - r2;
84202874:	17 00 44 65 	r2 = 23 - r2;
         r1 = r1 ASHIFT r2, r0 = M[I3, 0];
84202878:	00 2c 34 93 	r1 = r1 ASHIFT r2, r0 = M[I3,0];
#ifdef K32
         r1 = r1 - 0x800000;
8420287c:	80 00 00 fd 	r1 = r1 - 8388608;
84202880:	00 00 33 21 
#else
         r1 = r1 - 0x8000;
#endif
         r0 = r0 + r1;
84202884:	00 00 23 03 	r0 = r0 + r1;
         Null = I6, M[I3, 0] = r0;
84202888:	00 ac 06 47 	Null = Null + I6, M[I3,0] = r0;
         if Z jump b_loop;
8420288c:	0c 00 00 dd 	if EQ jump $M.celt.unquant_fine_energy.b_loop;
            call $celt.ec_dec_bits;
84202890:	12 fa f0 e1 	call $celt.ec_dec_bits;
            r1 = r0 + r0;
84202894:	2f 00 32 00 	r1 = r0 + r0;
            r1 = r1 + 1;
84202898:	2f 00 33 e4 	r1 = r1 + 1;
            r2 = M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FTB];
8420289c:	e4 01 47 d1 	r2 = M[r5 + 484];
            r2 = (DAWTH-9) - r2;
842028a0:	17 00 44 65 	r2 = 23 - r2;
            r1 = r1 ASHIFT r2;
842028a4:	00 00 34 93 	r1 = r1 ASHIFT r2;
            r1 = r1 - M0, r0 = M[I4, 0];
842028a8:	20 00 38 67 	r1 = r1 - M0, r0 = M[I4,0];
#ifdef K32
         r1 = r1 - 0x800000;
842028ac:	80 00 00 fd 	r1 = r1 - 8388608;
842028b0:	00 00 33 21 
#else
         r1 = r1 - 0x8000;
#endif
            r0 = r0 + r1;
842028b4:	00 00 23 03 	r0 = r0 + r1;
            M[I4, 0] = r0;
842028b8:	a0 00 00 03 	Null = Null + Null, M[I4,0] = r0;

842028bc <$M.celt.unquant_fine_energy.b_loop>:
      b_loop:
      M3 = M3 - M0, r0 = M[I4, MK1], r1 = M[I3, MK1];
842028bc:	21 3d b8 7f 	M3 = M3 - M0, r1 = M[I3,4], r0 = M[I4,4];
   if NZ jump fine_unquant_loop;
842028c0:	e6 ff 10 dd 	if NE jump $M.celt.unquant_fine_energy.fine_unquant_loop;

   // pop rLink from stack
   jump $pop_rLink_and_rts;
842028c4:	03 00 00 fd 	jump (m) 0x3b020;
842028c8:	21 b0 f0 dd 

842028cc <$celt.quant_bands>:
   .CONST CUR_B      1*ADDR_PER_WORD;
   .CONST BAL        2*ADDR_PER_WORD;
   .CONST STACK_USED 3*ADDR_PER_WORD;

   // push rLink onto stack
   push rlink;
842028cc:	00 00 d0 f3 	push rLink;
   // save the frame pointer and reserve stack space here before the loop starts
   pushm<FP(=SP)>;
842028d0:	01 00 00 f1 	pushm <FP(=SP)>;
   SP = SP + STACK_USED;
842028d4:	0c 00 03 f1 	SP = SP + 12;

   r0 = M[r5 + $celt.dec.MODE_NB_EBANDS_FIELD];
842028d8:	48 00 27 d1 	r0 = M[r5 + 72];
   Words2Addr(r0);
842028dc:	02 00 22 91 	r0 = r0 ASHIFT 2;
   M3 = r0;
842028e0:	2f 00 b0 50 	M3 = Null + r0;
   I7 = M3;
842028e4:	0f 00 7b 58 	I7 = M3 + Null;
   //calc nr of Blocks
   r3 = M[r5 + $celt.dec.MODE_NB_SHORT_MDCTS_FIELD];
842028e8:	58 00 57 d1 	r3 = M[r5 + 88];
   r2 = 1;
842028ec:	2f 00 40 e4 	r2 = Null + 1;
   Null = M[r5 + $celt.dec.SHORT_BLOCKS_FIELD];
842028f0:	58 01 07 d1 	Null = M[r5 + 344];
   if NZ r2 = r3;
842028f4:	01 00 45 00 	if NE r2 = r3 + Null;
   M[FP + CUR_B] = r2;
842028f8:	04 00 4c f1 	M[FP + 0x4] = r2;
   r1 = 0;
842028fc:	00 00 30 01 	r1 = Null + 0;
   M[FP + BAL] = r1;
84202900:	08 00 3c f1 	M[FP + 0x8] = r1;

   r1 = M[r5 + $celt.dec.CELT_CODEC_FRAME_SIZE_FIELD];
84202904:	04 00 37 d1 	r1 = M[r5 + 4];
   r1 = r1 LSHIFT (3+$celt.BITRES);
84202908:	07 00 33 8d 	r1 = r1 LSHIFT 7;
   I6 = r1; //total bits in the frame (fractional)
8420290c:	3f 00 60 50 	I6 = Null + r1;
   r0 = M[r5 + $celt.dec.PULSES_FIELD];
84202910:	04 01 27 d1 	r0 = M[r5 + 260];
   I3 = r0;
84202914:	2f 00 30 50 	I3 = Null + r0;
   r0 = M[r5 + $celt.dec.MODE_EBANDS_ADDR_FIELD];
84202918:	60 00 27 d1 	r0 = M[r5 + 96];
   I2 = r0;
8420291c:	2f 00 20 50 	I2 = Null + r0;

84202920 <$M.celt.quant_bands.quant_bands_main_loop>:
   quant_bands_main_loop:
      // get bit used so far
      r4 = $celt.BITRES;
84202920:	bf 00 60 e4 	r4 = Null + 4;
      r0 = M[r5 + $celt.dec.TELL_FUNC_FIELD];
84202924:	30 00 27 d1 	r0 = M[r5 + 48];
      call r0;
84202928:	0f 00 02 e0 	call r0;

      // update balance
      r1 = M[FP + BAL];
8420292c:	08 00 38 f1 	r1 = M[FP + 0x8];
      r2 = I7 - M3;
84202930:	bf 00 47 6c 	r2 = I7 - M3;
      if Z r1 = r0;
84202934:	00 00 32 00 	if EQ r1 = r0 + Null;
      M[FP + BAL] = r1;
84202938:	08 00 3c f1 	M[FP + 0x8] = r1;
      r1 = r1 - r0;
8420293c:	00 00 32 23 	r1 = r1 - r0;

      // update remaining bits
      I5 = I6 - r0;
84202940:	2f 00 56 78 	I5 = I6 - r0;
      I5 = I5 - 1;
84202944:	01 00 55 79 	I5 = I5 - 1;

      //curr_balance = balance / curr_balance;
      r3 = 1;
84202948:	2f 00 50 e4 	r3 = Null + 1;
      Null = r1;
8420294c:	0f 00 03 00 	Null = r1 + Null;
      if NEG r3 = - r3;
84202950:	54 00 50 20 	if NEG r3 = Null - r3;
      r1 = r1 * r3(int);
84202954:	00 00 35 9b 	r1 = r1 * r3 (int);
      Null  =   M3 - 3*ADDR_PER_WORD; //TODO:BC7OPT-max
84202958:	0c 00 0b 69 	Null = M3 - 12;
      if NEG jump chk_2;
8420295c:	05 00 40 dd 	if NEG jump $M.celt.quant_bands.chk_2;
         r1 = r1 -1;
84202960:	3f 00 33 e4 	r1 = r1 - 1;
         r1 = r1 * (1.0/3.0)(frac);
84202964:	aa 2a 00 fd 	r1 = r1 * 0.3333333334885537624359130859375 (frac);
84202968:	ab aa 33 95 
         jump end_cur_calc;
8420296c:	04 00 f0 dd 	jump $M.celt.quant_bands.end_cur_calc;

84202970 <$M.celt.quant_bands.chk_2>:
      chk_2:
      Null = M3 - 2*ADDR_PER_WORD;
84202970:	08 00 0b 69 	Null = M3 - 8;
      if NZ jump end_cur_calc;
84202974:	02 00 10 dd 	if NE jump $M.celt.quant_bands.end_cur_calc;
         r1 = r1 ASHIFT -1;
84202978:	ff 00 33 91 	r1 = r1 ASHIFT -1;

8420297c <$M.celt.quant_bands.end_cur_calc>:
      end_cur_calc:
      r1 = r1 * r3(int);
8420297c:	00 00 35 9b 	r1 = r1 * r3 (int);

      //calc number of pulses for this band (n)
      r0 = M[r5 + $celt.dec.PULSES_FIELD];
84202980:	04 01 27 d1 	r0 = M[r5 + 260];
      r3 = r0 + I7;
84202984:	7f 00 52 44 	r3 = r0 + I7;
      r3 = r3 - M3;
84202988:	00 00 5b 67 	r3 = r3 - M3;
      r0 = M[FP + BAL];
8420298c:	08 00 28 f1 	r0 = M[FP + 0x8];
      r3 = M[r3];
84202990:	00 00 50 d3 	r3 = M[r3 + Null];
      push r3;
84202994:	00 00 50 f3 	push r3;
      r3 = r0 + r3;
84202998:	5f 00 52 00 	r3 = r0 + r3;
      M[FP + BAL] = r3;
8420299c:	08 00 5c f1 	M[FP + 0x8] = r3;
      pop r3;
842029a0:	00 00 54 f3 	pop r3;
      r1 = r1 + r3;
842029a4:	00 00 35 03 	r1 = r1 + r3;
      call $celt.bits2pulses;
842029a8:	41 02 f0 e1 	call $celt.bits2pulses;
      Words2Addr(r0);
842029ac:	02 00 22 91 	r0 = r0 ASHIFT 2;
      //r0 = n
      r2 = M[r4 + r0];
842029b0:	2f 00 46 d0 	r2 = M[r4 + r0];
      I5 = I5 - r2;
842029b4:	00 00 54 7b 	I5 = I5 - r2;

842029b8 <$M.celt.quant_bands.loop_rem_bits>:
      loop_rem_bits:
         Null = I5;
842029b8:	00 00 05 47 	Null = Null + I5;
         if POS jump end_loop_rem_bits;
842029bc:	08 00 50 dd 	if POS jump $M.celt.quant_bands.end_loop_rem_bits;
         Null = r0 - Null;
842029c0:	0f 00 02 20 	Null = r0 - Null;
         if LE jump end_loop_rem_bits;
842029c4:	06 00 d0 dd 	if LE jump $M.celt.quant_bands.end_loop_rem_bits;
            I5 = I5 + r2;
842029c8:	00 00 54 5b 	I5 = I5 + r2;
            r0 = r0 - ADDR_PER_WORD;
842029cc:	df 00 22 e4 	r0 = r0 - 4;
            r2 = M[r4 + r0];
842029d0:	2f 00 46 d0 	r2 = M[r4 + r0];
            I5 = I5 - r2;
842029d4:	00 00 54 7b 	I5 = I5 - r2;
         jump loop_rem_bits;
842029d8:	f8 ff f0 dd 	jump $M.celt.quant_bands.loop_rem_bits;

842029dc <$M.celt.quant_bands.end_loop_rem_bits>:
      end_loop_rem_bits:

      // save some registers into stack

      push r5;
842029dc:	00 00 70 f3 	push r5;
      pushm<I2, I5, I6, I7, M3>;
842029e0:	e4 08 01 f1 	pushm <I2, I5, I6, I7, M3>;

      r2 = M[FP + CUR_B];
842029e4:	04 00 48 f1 	r2 = M[FP + 0x4];
      r1 = M[I2, MK1];
842029e8:	00 39 00 03 	Null = Null + Null, r1 = M[I2,4];
      r3 = M[I2, -MK1];
842029ec:	00 5b 00 03 	Null = Null + Null, r3 = M[I2,-4];
      r3 = r3 - r1;
842029f0:	00 00 53 23 	r3 = r3 - r1;
      r4 = M[r5 + $celt.dec.NORM_FREQ_FIELD];
842029f4:	cc 00 67 d1 	r4 = M[r5 + 204];
      Words2Addr(r1);
842029f8:	02 00 33 91 	r1 = r1 ASHIFT 2;
      I5 = r4 + r1;//X+eBands[i]
842029fc:	3f 00 56 50 	I5 = r4 + r1;
      // I5 = start of band
      // r0 = number of pulses (AU)
      // r1 = start bin no (AU)
      // r3 = band width
      // r2 = nr of Blocks
      Addr2Words(r0);
84202a00:	fe 00 22 91 	r0 = r0 ASHIFT -2;
      r4 = r0 - Null;
84202a04:	0f 00 62 20 	r4 = r0 - Null;
      if LE jump intra_act;
84202a08:	07 00 d0 dd 	if LE jump $M.celt.quant_bands.intra_act;
         //calc spread
         M0 = r2;
84202a0c:	4f 00 80 50 	M0 = Null + r2;
         Null = M[r5 + $celt.dec.HAS_FOLD_FIELD];
84202a10:	60 01 07 d1 	Null = M[r5 + 352];
         if Z M0 = M0 - M0;
84202a14:	80 00 88 7c 	if EQ M0 = M0 - M0;
         //call  $celt.alg_unquant;
         r0 = M[r5 + $celt.dec.ALG_QUANT_FUNC_FIELD];
84202a18:	34 00 27 d1 	r0 = M[r5 + 52];
         call r0;
84202a1c:	0f 00 02 e0 	call r0;
         jump end_act;
84202a20:	05 00 f0 dd 	jump $M.celt.quant_bands.end_act;

84202a24 <$M.celt.quant_bands.intra_act>:
      intra_act:
         r0 = M[r5 + $celt.dec.NORM_FIELD];
84202a24:	10 01 27 d1 	r0 = M[r5 + 272];
         I3 = r0;
84202a28:	2f 00 30 50 	I3 = Null + r0;
         Addr2Words(r1);
84202a2c:	fe 00 33 91 	r1 = r1 ASHIFT -2;
         call $celt.intra_fold;
84202a30:	f5 02 f0 e1 	call $celt.intra_fold;

84202a34 <$M.celt.quant_bands.end_act>:
      end_act:

      // restore trashed register
       popm<I2, I5, I6, I7, M3>;
84202a34:	e4 08 05 f1 	popm <I2, I5, I6, I7, M3>;
       pop r5;
84202a38:	00 00 74 f3 	pop r5;

      // get start and end of band (again!)
      r1 = M[I2, MK1];
84202a3c:	00 39 00 03 	Null = Null + Null, r1 = M[I2,4];
      r3 = M[I2, 0];
84202a40:	00 58 00 03 	Null = Null + Null, r3 = M[I2,0];

      // calc norm for next folded band
      // calc only when needed!
      r0 = M[r5 + $celt.dec.MODE_NB_EBANDS_FIELD];
84202a44:	48 00 27 d1 	r0 = M[r5 + 72];
      Words2Addr(r0);
84202a48:	02 00 22 91 	r0 = r0 ASHIFT 2;
      r0 = r0 - M3;
84202a4c:	00 00 2b 67 	r0 = r0 - M3;
      r2 = M[r5 + $celt.dec.MODE_EBNADS_DIF_SQRT_ADDR_FIELD];
84202a50:	74 00 47 d1 	r2 = M[r5 + 116];
      r4 = M[r2 + 0]; //shift
84202a54:	00 00 64 d1 	r4 = M[r2 + 0];
      r2 = r2 + ADDR_PER_WORD;
84202a58:	bf 00 44 e4 	r2 = r2 + 4;
      r6 = M[r2 + r0]; //gain
84202a5c:	2f 00 84 d0 	r6 = M[r2 + r0];
      r10 = r3 - r1;
84202a60:	3f 00 c5 20 	r10 = r3 - r1;
      r10 = r10 - 1;
84202a64:	3f 00 cc e4 	r10 = r10 - 1;
      r0 = M[r5 + $celt.dec.NORM_FIELD];
84202a68:	10 01 27 d1 	r0 = M[r5 + 272];
      Words2Addr(r1);
84202a6c:	02 00 33 91 	r1 = r1 ASHIFT 2;
      I3  = r1 + r0;
84202a70:	2f 00 33 50 	I3 = r1 + r0;
      r0 = M[r5 + $celt.dec.NORM_FREQ_FIELD];
84202a74:	cc 00 27 d1 	r0 = M[r5 + 204];
      I4  = r0 + r1;
84202a78:	3f 00 42 50 	I4 = r0 + r1;
      r0 = M[I4, MK1];
84202a7c:	21 00 00 03 	Null = Null + Null, r0 = M[I4,4];
      rMAC = r0 * r6; //6 bit less than c TODO:
84202a80:	8f 00 12 cc 	rMAC = r0 * r6 (SS);
      do norm_loop;
84202a84:	03 00 f0 e5 	do $M.celt.quant_bands.norm_loop;
         rMAC = rMAC ASHIFT r4 (56bit), r0 = M[I4, MK1];
84202a88:	21 00 16 93 	rMAC = rMAC ASHIFT r4 (56bit), r0 = M[I4,4];
         rMAC = r0 * r6, M[I3, MK1] = rMAC;
84202a8c:	00 9d 28 cf 	rMAC = r0 * r6 (SS), M[I3,4] = rMAC;

84202a90 <$M.celt.quant_bands.norm_loop>:
      norm_loop:
      rMAC = rMAC ASHIFT r4 (56bit);
84202a90:	00 00 16 93 	rMAC = rMAC ASHIFT r4 (56bit);
      M[I3, MK1] = rMAC;
84202a94:	00 9d 00 03 	Null = Null + Null, M[I3,4] = rMAC;

      M3 = M3 - ADDR_PER_WORD;
84202a98:	04 00 bb 79 	M3 = M3 - 4;
   if NZ jump quant_bands_main_loop;
84202a9c:	a1 ff 10 dd 	if NE jump $M.celt.quant_bands.quant_bands_main_loop;

   // restore the stack pointer
   SP = SP - STACK_USED;
84202aa0:	f4 ff 03 f1 	SP = SP + -12;
   popm<FP>;
84202aa4:	00 40 06 f1 	popm <FP>;

   // pop rLink from stack
   jump $pop_rLink_and_rts;
84202aa8:	03 00 00 fd 	jump (m) 0x3b020;
84202aac:	21 b0 f0 dd 

84202ab0 <$celt.unquant_bands_stereo>:

#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.UNQUANT_BANDS_STEREO.PATCH_ID_0,r3)     // celt_patchers
#endif 

   r0 = $celt.CELT_DECODER;
84202ab0:	00 00 20 01 	r0 = Null + 0;
   jump set_codec;
84202ab4:	02 00 f0 dd 	jump $M.celt.unquant_bands_stereo.set_codec;

84202ab8 <$celt.quant_bands_stereo>:
   
   // -- entry point for quant (encoder)
   $celt.quant_bands_stereo:
   r0 = $celt.CELT_ENCODER;
84202ab8:	2f 00 20 e4 	r0 = Null + 1;

84202abc <$M.celt.unquant_bands_stereo.set_codec>:
   .CONST CODEC            22*ADDR_PER_WORD;
   .CONST STACK_USED       23*ADDR_PER_WORD;
   

   // push rLink onto stack
   push rlink;
84202abc:	00 00 d0 f3 	push rLink;
   // save the frame pointer and reserve stack space here before the loop starts
   pushm<FP(=SP)>; 
84202ac0:	01 00 00 f1 	pushm <FP(=SP)>;
   SP = SP + STACK_USED; 
84202ac4:	5c 00 03 f1 	SP = SP + 92;
   
   M[FP + CODEC] = r0;
84202ac8:	58 00 2c f1 	M[FP + 0x58] = r0;
   r0 = M[r5 + $celt.dec.MODE_NB_EBANDS_FIELD];
84202acc:	48 00 27 d1 	r0 = M[r5 + 72];
   Words2Addr(r0);
84202ad0:	02 00 22 91 	r0 = r0 ASHIFT 2;
   M3 = r0;
84202ad4:	2f 00 b0 50 	M3 = Null + r0;
   I7 = M3;
84202ad8:	0f 00 7b 58 	I7 = M3 + Null;

   //calc nr of Blocks
   r3 = M[r5 + $celt.dec.MODE_NB_SHORT_MDCTS_FIELD];
84202adc:	58 00 57 d1 	r3 = M[r5 + 88];
   r2 = 1;
84202ae0:	2f 00 40 e4 	r2 = Null + 1;
   Null = M[r5 + $celt.dec.SHORT_BLOCKS_FIELD];
84202ae4:	58 01 07 d1 	Null = M[r5 + 344];
   if NZ r2 = r3;
84202ae8:	01 00 45 00 	if NE r2 = r3 + Null;
   M[FP + CUR_B] = r2;
84202aec:	4c 00 4c f1 	M[FP + 0x4c] = r2;
   r1 = 0;
84202af0:	00 00 30 01 	r1 = Null + 0;
   M[FP + BAL] = r1;
84202af4:	50 00 3c f1 	M[FP + 0x50] = r1;
   r1 = M[r5 + $celt.dec.CELT_CODEC_FRAME_SIZE_FIELD];
84202af8:	04 00 37 d1 	r1 = M[r5 + 4];
   r1 = r1 LSHIFT (3+$celt.BITRES);
84202afc:	07 00 33 8d 	r1 = r1 LSHIFT 7;
   I6 = r1; //total bits in the frame (fractional)
84202b00:	3f 00 60 50 	I6 = Null + r1;
   r0 = M[r5 + $celt.dec.PULSES_FIELD];
84202b04:	04 01 27 d1 	r0 = M[r5 + 260];
   I3 = r0;
84202b08:	2f 00 30 50 	I3 = Null + r0;
   r0 = M[r5 + $celt.dec.MODE_EBANDS_ADDR_FIELD];
84202b0c:	60 00 27 d1 	r0 = M[r5 + 96];
   I2 = r0;
84202b10:	2f 00 20 50 	I2 = Null + r0;

84202b14 <$M.celt.unquant_bands_stereo.quant_bands_main_loop>:


quant_bands_main_loop:

      // get bit used so far
      r4 = $celt.BITRES;
84202b14:	bf 00 60 e4 	r4 = Null + 4;
      r0 = M[r5 + $celt.dec.TELL_FUNC_FIELD];
84202b18:	30 00 27 d1 	r0 = M[r5 + 48];
      call r0; 
84202b1c:	0f 00 02 e0 	call r0;

      // update balance
      r1 = M[FP + BAL];
84202b20:	50 00 38 f1 	r1 = M[FP + 0x50];
      r2 = I7 - M3;
84202b24:	bf 00 47 6c 	r2 = I7 - M3;
      if Z r1 = r0;
84202b28:	00 00 32 00 	if EQ r1 = r0 + Null;
      M[FP + BAL] = r1;
84202b2c:	50 00 3c f1 	M[FP + 0x50] = r1;
      r1 = r1 - r0;
84202b30:	00 00 32 23 	r1 = r1 - r0;

      // update remaining bits
      I5 = I6 - r0;
84202b34:	2f 00 56 78 	I5 = I6 - r0;
      I5 = I5 - 1;
84202b38:	01 00 55 79 	I5 = I5 - 1;

      //curr_balance = balance / curr_balance;
      r3 = 1;
84202b3c:	2f 00 50 e4 	r3 = Null + 1;
      Null = r1;
84202b40:	0f 00 03 00 	Null = r1 + Null;
      if NEG r3 = - r3;
84202b44:	54 00 50 20 	if NEG r3 = Null - r3;
      r1 = r1 * r3(int);
84202b48:	00 00 35 9b 	r1 = r1 * r3 (int);
      Null  =   M3 - 3*ADDR_PER_WORD; //TODO:BC7OPT-max
84202b4c:	0c 00 0b 69 	Null = M3 - 12;
      if NEG jump chk_2;
84202b50:	05 00 40 dd 	if NEG jump $M.celt.unquant_bands_stereo.chk_2;
         r1 = r1 -1;
84202b54:	3f 00 33 e4 	r1 = r1 - 1;
         r1 = r1 * (1.0/3.0)(frac);
84202b58:	aa 2a 00 fd 	r1 = r1 * 0.3333333334885537624359130859375 (frac);
84202b5c:	ab aa 33 95 
         jump end_cur_calc;
84202b60:	04 00 f0 dd 	jump $M.celt.unquant_bands_stereo.end_cur_calc;

84202b64 <$M.celt.unquant_bands_stereo.chk_2>:
      chk_2:
      Null = M3 - 2*ADDR_PER_WORD;
84202b64:	08 00 0b 69 	Null = M3 - 8;
      if NZ jump end_cur_calc;
84202b68:	02 00 10 dd 	if NE jump $M.celt.unquant_bands_stereo.end_cur_calc;
         r1 = r1 ASHIFT -1;
84202b6c:	ff 00 33 91 	r1 = r1 ASHIFT -1;

84202b70 <$M.celt.unquant_bands_stereo.end_cur_calc>:
      end_cur_calc:
      r1 = r1 * r3(int);
84202b70:	00 00 35 9b 	r1 = r1 * r3 (int);

      r0 = M[I2, MK1];
84202b74:	00 29 00 03 	Null = Null + Null, r0 = M[I2,4];
      M[FP + S_BAND] = r0;
84202b78:	20 00 2c f1 	M[FP + 0x20] = r0;
      r3 = M[I2, 0];
84202b7c:	00 58 00 03 	Null = Null + Null, r3 = M[I2,0];
      r0 = r3 - r0;
84202b80:	2f 00 25 20 	r0 = r3 - r0;
      rMAC = 0;
84202b84:	00 00 10 01 	rMAC = Null + 0;
      rMAC0 = r0;
84202b88:	00 05 e2 8d 	rMAC0 = r0 LSHIFT 0;
      M[FP + N_BAND] = r0;
84202b8c:	1c 00 2c f1 	M[FP + 0x1c] = r0;

      //calc number of pulses for this band (n)
      r0 = M[r5 + $celt.dec.PULSES_FIELD];
84202b90:	04 01 27 d1 	r0 = M[r5 + 260];
      r3 = r0 + I7;
84202b94:	7f 00 52 44 	r3 = r0 + I7;
      r3 = r3 - M3;
84202b98:	00 00 5b 67 	r3 = r3 - M3;
      r0 = M[FP + BAL];
84202b9c:	50 00 28 f1 	r0 = M[FP + 0x50];
      r3 = M[r3];       // r3 = pulses[I7-M3]
84202ba0:	00 00 50 d3 	r3 = M[r3 + Null];
      r0 = r0 + r3;     // r0 = r0 + pulses[I7-M3]
84202ba4:	00 00 25 03 	r0 = r0 + r3;
      M[FP + BAL] = r0;
84202ba8:	50 00 2c f1 	M[FP + 0x50] = r0;

      r8 = I5 + 1;
84202bac:	01 00 a5 49 	r8 = I5 + 1;
      r1 = r1 + r3;
84202bb0:	00 00 35 03 	r1 = r1 + r3;
      if NEG r1 = 0;
84202bb4:	04 00 30 00 	if NEG r1 = Null + Null;
      Null = r8 - r1;
84202bb8:	3f 00 0a 20 	Null = r8 - r1;
      if POS r8 = r1;
84202bbc:	05 00 a3 00 	if POS r8 = r1 + Null;
      M[FP + VB] = r8;
84202bc0:	38 00 ac f1 	M[FP + 0x38] = r8;

      r0 = $celt.BITRES;
84202bc4:	bf 00 20 e4 	r0 = Null + 4;
      call $celt.log2_frac;
84202bc8:	1c 05 f0 e1 	call $celt.log2_frac;
      r0 = $celt.QTHETA_OFFSET - r0;
84202bcc:	28 00 22 65 	r0 = 40 - r0;
      r1 = M[FP + N_BAND];
84202bd0:	1c 00 38 f1 	r1 = M[FP + 0x1c];
      r2 = r1 - 1;
84202bd4:	3f 00 43 e4 	r2 = r1 - 1;
      r1 = r2 + r2;
84202bd8:	4f 00 34 00 	r1 = r2 + r2;
      r1 = r1 * r0(int);
84202bdc:	00 00 32 9b 	r1 = r1 * r0 (int);
      r1 = r8 - r1;
84202be0:	3f 00 3a 20 	r1 = r8 - r1;
      if NEG r1 = 0;
84202be4:	04 00 30 00 	if NEG r1 = Null + Null;

      r2 = r2 LSHIFT 5;
84202be8:	05 00 44 8d 	r2 = r2 LSHIFT 5;
      rMAC = 0;
84202bec:	00 00 10 01 	rMAC = Null + 0;
      rMAC0 = r1;
84202bf0:	00 05 e3 8d 	rMAC0 = r1 LSHIFT 0;
      Div = rMAC / r2;
84202bf4:	00 00 14 d9 	Div = rMAC / r2;
      r7 = r8 LSHIFT (-$celt.BITRES);
84202bf8:	fc 00 9a 8d 	r7 = r8 LSHIFT -4;
      r7 = r7 - 1;
84202bfc:	3f 00 99 e4 	r7 = r7 - 1;
      if NEG r7 = 0;
84202c00:	04 00 90 00 	if NEG r7 = Null + Null;
      r0 = DivResult;
84202c04:	01 00 20 d9 	r0 = DivResult;
      Null = r0 - r7;
84202c08:	9f 00 02 20 	Null = r0 - r7;
      if POS r0 = r7;
84202c0c:	05 00 29 00 	if POS r0 = r7 + Null;
      r1 = r0 - 14;
84202c10:	0e 00 32 21 	r1 = r0 - 14;
      if POS r0 = r0 - r1;
84202c14:	35 00 22 20 	if POS r0 = r0 - r1;
      M[FP + QB] = r0;
84202c18:	54 00 2c f1 	M[FP + 0x54] = r0;
      r1 = 1 LSHIFT r0;
84202c1c:	01 00 32 e9 	r1 = 0x1 LSHIFT r0;
      r1 = r1 + 1;
84202c20:	2f 00 33 e4 	r1 = r1 + 1;
      rMAC = 0;
84202c24:	00 00 10 01 	rMAC = Null + 0;
      rMAC0 = r1;
84202c28:	00 05 e3 8d 	rMAC0 = r1 LSHIFT 0;
      r0 = $celt.BITRES;
84202c2c:	bf 00 20 e4 	r0 = Null + 4;
      call $celt.log2_frac;
84202c30:	02 05 f0 e1 	call $celt.log2_frac;
      M[FP + QALLOC] = r0;
84202c34:	24 00 2c f1 	M[FP + 0x24] = r0;

      // -- save some registers

      // to guaranteen we will always have the same push sequence for different chips, avoid using "pushm" here
      // I5, I6, I7, I2, M3, r5
      r3 = I5;
84202c38:	5f 00 50 44 	r3 = Null + I5;
      M[FP + RM_BITS] = r3;
84202c3c:	04 00 5c f1 	M[FP + 0x4] = r3;
      r3 = I6;
84202c40:	6f 00 50 44 	r3 = Null + I6;
      M[FP + TOTOAL_BITS] = r3;
84202c44:	08 00 5c f1 	M[FP + 0x8] = r3;
      r3 = I7;
84202c48:	7f 00 50 44 	r3 = Null + I7;
      M[FP + NB_EBAND] = r3;
84202c4c:	0c 00 5c f1 	M[FP + 0xc] = r3;
      r3 = I2;
84202c50:	2f 00 50 44 	r3 = Null + I2;
      M[FP + ADDR_EBAND] = r3;
84202c54:	10 00 5c f1 	M[FP + 0x10] = r3;
      r3 = M3;
84202c58:	bf 00 50 44 	r3 = Null + M3;
      M[FP + NB_EBAND_RM] = r3;
84202c5c:	14 00 5c f1 	M[FP + 0x14] = r3;
      M[FP + CODEC_STRUC] = r5;
84202c60:	18 00 7c f1 	M[FP + 0x18] = r5;

      // -- stereo processing required for encode
      Null = M[FP + CODEC];
84202c64:	58 00 08 f1 	Null = M[FP + 0x58];
      if Z jump is_dec1;
84202c68:	88 00 00 dd 	if EQ jump $M.celt.unquant_bands_stereo.is_dec1;

84202c6c <$M.celt.unquant_bands_stereo.is_enc1>:
      is_enc1:
         Null = M[FP + QB];
84202c6c:	54 00 08 f1 	Null = M[FP + 0x54];
         if NZ jump end_calc_st_coeff;
84202c70:	2a 00 10 dd 	if NE jump $M.celt.unquant_bands_stereo.end_calc_st_coeff;

            // -- calc mid/side coeffs
            r2 = I7 - M3;
84202c74:	bf 00 47 6c 	r2 = I7 - M3;
            r2 = r2 + r2;
84202c78:	00 00 44 03 	r2 = r2 + r2;
            r0 = M[r5 + $celt.enc.BANDE_FIELD];
84202c7c:	d0 00 27 d1 	r0 = M[r5 + 208];
            I4 = r0 + r2;
84202c80:	4f 00 42 50 	I4 = r0 + r2;
            r3 = M[I4, MK1];
84202c84:	51 00 00 03 	Null = Null + Null, r3 = M[I4,4];
            r4 = M[I4, MK1];
84202c88:	61 00 00 03 	Null = Null + Null, r4 = M[I4,4];

            I4 = I4 + ($celt.MAX_BANDS*2)*ADDR_PER_WORD;
84202c8c:	c8 00 44 59 	I4 = I4 + 200;
            r0 = M[I4, MK1];
84202c90:	21 00 00 03 	Null = Null + Null, r0 = M[I4,4];
            r1 = M[I4, MK1];
84202c94:	31 00 00 03 	Null = Null + Null, r1 = M[I4,4];
            r2 = r4 - r1;
84202c98:	3f 00 46 20 	r2 = r4 - r1;
            if POS r2 = 0;
84202c9c:	05 00 40 00 	if POS r2 = Null + Null;
            r1 = r1 - r4;
84202ca0:	00 00 36 23 	r1 = r1 - r4;
            if POS r1 = 0;
84202ca4:	05 00 30 00 	if POS r1 = Null + Null;
            r0 = r0 ASHIFT r1;
84202ca8:	00 00 23 93 	r0 = r0 ASHIFT r1;
            r3 = r3 ASHIFT r2;
84202cac:	00 00 54 93 	r3 = r3 ASHIFT r2;
            push r0;
84202cb0:	00 00 20 f3 	push r0;
            push r3;
84202cb4:	00 00 50 f3 	push r3;
            rMAC = r0 * r0;
84202cb8:	2f 00 12 cc 	rMAC = r0 * r0 (SS);
            rMAC = rMAC + r3 * r3;
84202cbc:	5f 00 15 ac 	rMAC = rMAC + r3 * r3 (SS);
            r0 = rMAC;
84202cc0:	0f 00 21 00 	r0 = rMAC + Null;
            $celt.sqrt
84202cc4:	01 10 01 f1 	pushm <I0, L0>;
84202cc8:	00 00 c0 51 	L0 = Null + 0;
84202ccc:	00 00 a2 f3 	push B0;
84202cd0:	00 00 00 f3 	push Null;
84202cd4:	00 00 a6 f3 	pop B0;
84202cd8:	07 00 00 fd 	call 0x74370;
84202cdc:	70 43 f0 e1 
84202ce0:	00 00 a6 f3 	pop B0;
84202ce4:	01 10 05 f1 	popm <I0, L0>;
            pop r4;
84202ce8:	00 00 64 f3 	pop r4;
            pop r2;
84202cec:	00 00 44 f3 	pop r2;
            r3 = r1;
84202cf0:	0f 00 53 00 	r3 = r1 + Null;
            if Z jump end_calc_st_coeff;
84202cf4:	09 00 00 dd 	if EQ jump $M.celt.unquant_bands_stereo.end_calc_st_coeff;
            rMAC = r2 ASHIFT -1;
84202cf8:	ff 00 e4 91 	rMAC = r2 ASHIFT -1 (MI);
            Div = rMAC / r3;
84202cfc:	00 00 15 d9 	Div = rMAC / r3;
            r0 = DivResult;
84202d00:	01 00 20 d9 	r0 = DivResult;
            rMAC = r4 ASHIFT -1;
84202d04:	ff 00 e6 91 	rMAC = r4 ASHIFT -1 (MI);
            Div = rMAC / r3;
84202d08:	00 00 15 d9 	Div = rMAC / r3;
            r1 = DivResult;
84202d0c:	01 00 30 d9 	r1 = DivResult;
            r1 = -r1;
84202d10:	3f 00 30 20 	r1 = Null - r1;
            jump st_mix_enc;
84202d14:	05 00 f0 dd 	jump $M.celt.unquant_bands_stereo.st_mix_enc;

84202d18 <$M.celt.unquant_bands_stereo.end_calc_st_coeff>:
         end_calc_st_coeff:
         r0 = -0.707106781186548;
84202d18:	7d a5 00 fd 	r0 = Null + -1518500250;
84202d1c:	66 86 20 01 
         r1 = 0.707106781186548;
84202d20:	82 5a 00 fd 	r1 = Null + 1518500250;
84202d24:	9a 79 30 01 

84202d28 <$M.celt.unquant_bands_stereo.st_mix_enc>:
         st_mix_enc:

         // -- ms stereo per band
         r3 = M[FP + S_BAND];
84202d28:	20 00 58 f1 	r3 = M[FP + 0x20];
         Words2Addr(r3);
84202d2c:	02 00 55 91 	r3 = r3 ASHIFT 2;
         r10 = M[FP + N_BAND];
84202d30:	1c 00 c8 f1 	r10 = M[FP + 0x1c];
         r10 = r10 - 1;
84202d34:	3f 00 cc e4 	r10 = r10 - 1;
         r2 = M[r5 + $celt.dec.NORM_FREQ_FIELD];
84202d38:	cc 00 47 d1 	r2 = M[r5 + 204];
         I3  = r3 + r2;
84202d3c:	4f 00 35 50 	I3 = r3 + r2;
         r4 = M[r5 +  $celt.dec.MODE_MDCT_SIZE_FIELD];
84202d40:	44 00 67 d1 	r4 = M[r5 + 68];
         Words2Addr(r4);
84202d44:	02 00 66 91 	r4 = r4 ASHIFT 2;
         I4 = I3 + r4;
84202d48:	6f 00 43 58 	I4 = I3 + r4;
         I6 = I3;
84202d4c:	0f 00 63 58 	I6 = I3 + Null;
         I7 = I4;
84202d50:	0f 00 74 58 	I7 = I4 + Null;
         r2 = M[I3, MK1], r3 = M[I4, MK1];
84202d54:	51 4d 00 03 	Null = Null + Null, r2 = M[I3,4], r3 = M[I4,4];
         r0 = r0 * 0.707106781186548;
84202d58:	82 5a 00 fd 	r0 = r0 * 0.707106781192123889923095703125 (SS);
84202d5c:	9a 79 22 cd 
         r1 = r1 * 0.707106781186548;
84202d60:	82 5a 00 fd 	r1 = r1 * 0.707106781192123889923095703125 (SS);
84202d64:	9a 79 33 cd 

         rMAC = r3 * r1;
84202d68:	3f 00 15 cc 	rMAC = r3 * r1 (SS);
         do mid_side_loop0;
84202d6c:	05 00 f0 e5 	do $M.celt.unquant_bands_stereo.mid_side_loop0;
            rMAC = rMAC - r2 * r0;
84202d70:	2f 00 14 bc 	rMAC = rMAC - r2 * r0 (SS);
            rMAC = r3 * r1, M[I6, MK1] = rMAC;
84202d74:	99 00 53 cf 	rMAC = r3 * r1 (SS), M[I6,4] = rMAC;
            rMAC = rMAC + r2 * r0, r2 = M[I3, MK1], r3 = M[I4, MK1];
84202d78:	51 4d 42 af 	rMAC = rMAC + r2 * r0 (SS), r2 = M[I3,4], r3 = M[I4,4];
            rMAC = r3 * r1, M[I7, MK1] = rMAC;
84202d7c:	9d 00 53 cf 	rMAC = r3 * r1 (SS), M[I7,4] = rMAC;

84202d80 <$M.celt.unquant_bands_stereo.mid_side_loop0>:
         mid_side_loop0:
         rMAC = rMAC - r2 * r0;
84202d80:	2f 00 14 bc 	rMAC = rMAC - r2 * r0 (SS);
         rMAC = r3 * r1, M[I6, MK1] = rMAC;
84202d84:	99 00 53 cf 	rMAC = r3 * r1 (SS), M[I6,4] = rMAC;
         rMAC = rMAC + r2 * r0;
84202d88:	2f 00 14 ac 	rMAC = rMAC + r2 * r0 (SS);
         M[I7, MK1] = rMAC;
84202d8c:	9d 00 00 03 	Null = Null + Null, M[I7,4] = rMAC;

         // -- renormalise left band
         r3= M[FP + N_BAND];
84202d90:	1c 00 58 f1 	r3 = M[FP + 0x1c];
         M3 = r3;
84202d94:	5f 00 b0 50 	M3 = Null + r3;
         r1 = M[FP + S_BAND];
84202d98:	20 00 38 f1 	r1 = M[FP + 0x20];
         Words2Addr(r1);
84202d9c:	02 00 33 91 	r1 = r1 ASHIFT 2;
         r0 = M[r5 + $celt.dec.NORM_FREQ_FIELD];
84202da0:	cc 00 27 d1 	r0 = M[r5 + 204];
         I5  = r1 + r0;
84202da4:	2f 00 53 50 	I5 = r1 + r0;
         M0 = 1;
84202da8:	01 00 80 51 	M0 = Null + 1;
         r7 = 1.0;
84202dac:	ff 7f 00 fd 	r7 = Null + 2147483647;
84202db0:	ff ff 90 01 
         call $celt.renormalise_vector;
84202db4:	38 02 f0 e1 	call $celt.renormalise_vector;
         push r1;
84202db8:	00 00 30 f3 	push r1;

         // -- renormalise right band
         r3 = M[FP + N_BAND];
84202dbc:	1c 00 58 f1 	r3 = M[FP + 0x1c];
         M3 = r3;
84202dc0:	5f 00 b0 50 	M3 = Null + r3;
         r1 = M[FP + S_BAND];
84202dc4:	20 00 38 f1 	r1 = M[FP + 0x20];
         Words2Addr(r1);
84202dc8:	02 00 33 91 	r1 = r1 ASHIFT 2;
         r0 = M[r5 + $celt.dec.NORM_FREQ_FIELD];
84202dcc:	cc 00 27 d1 	r0 = M[r5 + 204];
         I5  = r1 + r0;
84202dd0:	2f 00 53 50 	I5 = r1 + r0;
         r4 = M[r5 +  $celt.dec.MODE_MDCT_SIZE_FIELD];
84202dd4:	44 00 67 d1 	r4 = M[r5 + 68];
         Words2Addr(r4);
84202dd8:	02 00 66 91 	r4 = r4 ASHIFT 2;
         I5 = I5 + r4;
84202ddc:	00 00 56 5b 	I5 = I5 + r4;
         M0 = 1;
84202de0:	01 00 80 51 	M0 = Null + 1;
         r7 = 1.0;
84202de4:	ff 7f 00 fd 	r7 = Null + 2147483647;
84202de8:	ff ff 90 01 
         call $celt.renormalise_vector;
84202dec:	2a 02 f0 e1 	call $celt.renormalise_vector;

         // -- calc atan(E_L/E_R)
         r6 = r1;
84202df0:	0f 00 83 00 	r6 = r1 + Null;
         pop r1;
84202df4:	00 00 34 f3 	pop r1;
         r0 = M[FP + QB];
84202df8:	54 00 28 f1 	r0 = M[FP + 0x54];
         if Z jump qb_z;
84202dfc:	25 00 00 dd 	if EQ jump $M.celt.unquant_bands_stereo.qb_z;
         push r5;
84202e00:	00 00 70 f3 	push r5;

         // some optimisation
         r5 = 0;
84202e04:	00 00 70 01 	r5 = Null + 0;
         NULL = r1 OR r6;
84202e08:	8f 00 03 84 	Null = r1 OR r6;
         if Z jump calc_lr_ratio;
84202e0c:	08 00 00 dd 	if EQ jump $M.celt.unquant_bands_stereo.calc_lr_ratio;
         r5 = 0.25;
84202e10:	00 20 00 fd 	r5 = Null + 536870912;
84202e14:	00 00 70 01 
         Null = r1 - r6;
84202e18:	8f 00 03 20 	Null = r1 - r6;
         if Z jump calc_lr_ratio;
84202e1c:	04 00 00 dd 	if EQ jump $M.celt.unquant_bands_stereo.calc_lr_ratio;
         // now calc E_L/E_R
         r5 = r1;
84202e20:	0f 00 73 00 	r5 = r1 + Null;
         call $math.atan;
84202e24:	07 00 00 fd 	call 0x74698;
84202e28:	98 46 f0 e1 

84202e2c <$M.celt.unquant_bands_stereo.calc_lr_ratio>:
         calc_lr_ratio:
            r3 = r5 * 0.003906251396735(frac);
84202e2c:	80 00 00 fd 	r3 = r5 * 0.0039062513969838619232177734375 (frac);
84202e30:	03 00 57 95 
         pop r5;
84202e34:	00 00 74 f3 	pop r5;
         r0 = M[FP + QB];
84202e38:	54 00 28 f1 	r0 = M[FP + 0x54];
         if Z jump qb_z;
84202e3c:	15 00 00 dd 	if EQ jump $M.celt.unquant_bands_stereo.qb_z;
         r1 = r0 - 14;
84202e40:	0e 00 32 21 	r1 = r0 - 14;
         r2 = -r1;
84202e44:	3f 00 40 20 	r2 = Null - r1;
         r1 = 1.0 ASHIFT r1;
84202e48:	ff 7f 00 fd 	r1 = 0x7fffffff ASHIFT r1;
84202e4c:	ff ff 33 ed 
#ifdef K32
#ifdef K32_BITEXACT
         r1 = r1 ASHIFT -8;
84202e50:	f8 00 33 91 	r1 = r1 ASHIFT -8;
#endif	 
#endif
         r3 = r3 * r1(frac);
84202e54:	00 00 53 97 	r3 = r3 * r1 (frac);
         r2 = r3 ASHIFT r2;
84202e58:	4f 00 45 90 	r2 = r3 ASHIFT r2;
#ifdef K32         
#ifndef K32_BITEXACT
         r2 = r2 LSHIFT -8; 
#endif	 
#endif                      
         M[FP + ITHETA] = r2; // SGTBD: ITHETA big difference between ARCH3 and ARCH4
84202e5c:	34 00 4c f1 	M[FP + 0x34] = r2;
         r0 = 1 ASHIFT r0;
84202e60:	01 00 22 ed 	r0 = 0x1 ASHIFT r0;
         r0 = r0 + 1;         
84202e64:	2f 00 22 e4 	r0 = r0 + 1;
         M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FT + 0] = r0;
84202e68:	cc 01 27 d5 	M[r5 + 460] = r0;
         M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FT + 1*MK1] = Null;
84202e6c:	d0 01 07 d5 	M[r5 + 464] = Null;
#ifdef K32         
#ifndef K32_BITEXACT
         r3 = r3 LSHIFT -8; // .fl is a 24-bit integer
#endif	 
#endif                  
         M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FL + 0] = r3;
84202e70:	d4 01 57 d5 	M[r5 + 468] = r3;
         M[r5 + $celt.enc.SCRATCHVAR_EC_ENC_FL + 1*MK1] = Null;
84202e74:	d8 01 07 d5 	M[r5 + 472] = Null;
         r2 = M[r5 + $celt.dec.EC_UINT_FUNC_FIELD];
84202e78:	38 00 47 d1 	r2 = M[r5 + 56];
         call r2;
84202e7c:	0f 00 04 e0 	call r2;
         r0 = M[FP + ITHETA];
84202e80:	34 00 28 f1 	r0 = M[FP + 0x34];
         jump test_itheta;
84202e84:	14 00 f0 dd 	jump $M.celt.unquant_bands_stereo.test_itheta;

84202e88 <$M.celt.unquant_bands_stereo.is_dec1>:
      is_dec1:
      r0 = M[FP + QB];
84202e88:	54 00 28 f1 	r0 = M[FP + 0x54];
      if NZ jump nzqb_dec;
84202e8c:	07 00 10 dd 	if NE jump $M.celt.unquant_bands_stereo.nzqb_dec;

84202e90 <$M.celt.unquant_bands_stereo.qb_z>:
      qb_z:
         r0 = 0;
84202e90:	00 00 20 01 	r0 = Null + 0;
         M[FP + ITHETA] = r0;
84202e94:	34 00 2c f1 	M[FP + 0x34] = r0;

84202e98 <$M.celt.unquant_bands_stereo.is_ztheta>:
      is_ztheta:
         r0 = 32767;     //mid
84202e98:	ff 7f 20 01 	r0 = Null + 32767;
         r1 = 0;         //side
84202e9c:	00 00 30 01 	r1 = Null + 0;
         r2 = -10000;    //delta
84202ea0:	f0 d8 40 01 	r2 = Null + -10000;
      jump set_st;
84202ea4:	12 00 f0 dd 	jump $M.celt.unquant_bands_stereo.set_st;

84202ea8 <$M.celt.unquant_bands_stereo.nzqb_dec>:
      nzqb_dec:
         r0 = M[FP + QB];
84202ea8:	54 00 28 f1 	r0 = M[FP + 0x54];
         r1 = 14 - r0;
84202eac:	0e 00 32 65 	r1 = 14 - r0;
         push r1;
84202eb0:	00 00 30 f3 	push r1;
         r1 = 1 LSHIFT r0;
84202eb4:	01 00 32 e9 	r1 = 0x1 LSHIFT r0;
         r0 = r1 + 1;
84202eb8:	2f 00 23 e4 	r0 = r1 + 1;
         r1 = 0;
84202ebc:	00 00 30 01 	r1 = Null + 0;
         r2 = M[r5 + $celt.dec.EC_UINT_FUNC_FIELD];
84202ec0:	38 00 47 d1 	r2 = M[r5 + 56];
         call r2;
84202ec4:	0f 00 04 e0 	call r2;
         pop r1;
84202ec8:	00 00 34 f3 	pop r1;
         r0 = r0 LSHIFT r1;
84202ecc:	00 00 23 8f 	r0 = r0 LSHIFT r1;
         M[FP + ITHETA]  = r0;
84202ed0:	34 00 2c f1 	M[FP + 0x34] = r0;

84202ed4 <$M.celt.unquant_bands_stereo.test_itheta>:
         test_itheta:
         if Z jump is_ztheta;
84202ed4:	f1 ff 00 dd 	if EQ jump $M.celt.unquant_bands_stereo.is_ztheta;
         Null = r0 - 16384;
84202ed8:	00 40 02 21 	Null = r0 - 16384;
         if NZ jump calc_ims;
84202edc:	08 00 10 dd 	if NE jump $M.celt.unquant_bands_stereo.calc_ims;
             r0 = 0;     //mid
84202ee0:	00 00 20 01 	r0 = Null + 0;
             r1 = 32767; //side
84202ee4:	ff 7f 30 01 	r1 = Null + 32767;
             r2 = 10000; //delta
84202ee8:	10 27 40 01 	r2 = Null + 10000;

84202eec <$M.celt.unquant_bands_stereo.set_st>:
          set_st:
             M[FP + IMID] = r0;
84202eec:	28 00 2c f1 	M[FP + 0x28] = r0;
             M[FP + ISIDE] = r1;
84202ef0:	2c 00 3c f1 	M[FP + 0x2c] = r1;
             M[FP + DELTA] = r2;
84202ef4:	30 00 4c f1 	M[FP + 0x30] = r2;
         jump end_ims;
84202ef8:	17 00 f0 dd 	jump $M.celt.unquant_bands_stereo.end_ims;

84202efc <$M.celt.unquant_bands_stereo.calc_ims>:
         calc_ims:
         call $celt.bitexact_cos;
84202efc:	88 04 f0 e1 	call $celt.bitexact_cos;
         M[FP + IMID] = r2;
84202f00:	28 00 4c f1 	M[FP + 0x28] = r2;
         rMAC = 0;
84202f04:	00 00 10 01 	rMAC = Null + 0;
         rMAC0 = r2;
84202f08:	00 05 e4 8d 	rMAC0 = r2 LSHIFT 0;
         r0 = $celt.BITRES+2;
84202f0c:	06 00 20 01 	r0 = Null + 6;
         call $celt.log2_frac;
84202f10:	4a 04 f0 e1 	call $celt.log2_frac;
         push r0;
84202f14:	00 00 20 f3 	push r0;

         r0 = M[FP + ITHETA];
84202f18:	34 00 28 f1 	r0 = M[FP + 0x34];
         r0 = 16384 - r0;
84202f1c:	00 40 22 65 	r0 = 16384 - r0;
         call $celt.bitexact_cos;
84202f20:	7f 04 f0 e1 	call $celt.bitexact_cos;
         M[FP + ISIDE] = r2;
84202f24:	2c 00 4c f1 	M[FP + 0x2c] = r2;
         rMAC = 0;
84202f28:	00 00 10 01 	rMAC = Null + 0;
         rMAC0 = r2;
84202f2c:	00 05 e4 8d 	rMAC0 = r2 LSHIFT 0;
         r0 = $celt.BITRES+2;
84202f30:	06 00 20 01 	r0 = Null + 6;
         call $celt.log2_frac;
84202f34:	41 04 f0 e1 	call $celt.log2_frac;
         pop r1;
84202f38:	00 00 34 f3 	pop r1;
         r0 = r0 - r1;
84202f3c:	00 00 23 23 	r0 = r0 - r1;
         r1 = M[FP + N_BAND];
84202f40:	1c 00 38 f1 	r1 = M[FP + 0x1c];
         r1 = r1 - 1;
84202f44:	3f 00 33 e4 	r1 = r1 - 1;
         r0 = r0*r1(int);
84202f48:	00 00 23 9b 	r0 = r0 * r1 (int);
         r0 = r0 ASHIFT -2;
84202f4c:	fe 00 22 91 	r0 = r0 ASHIFT -2;
         M[FP + DELTA] = r0;
84202f50:	30 00 2c f1 	M[FP + 0x30] = r0;

84202f54 <$M.celt.unquant_bands_stereo.end_ims>:
      end_ims:

      // restore trashed registers
      // retrieve the values in I6, I7, M3
      r3 = M[FP + TOTOAL_BITS];
84202f54:	08 00 58 f1 	r3 = M[FP + 0x8];
      I6 = r3;
84202f58:	5f 00 60 50 	I6 = Null + r3;
      r3 = M[FP + NB_EBAND];
84202f5c:	0c 00 58 f1 	r3 = M[FP + 0xc];
      I7 = r3;
84202f60:	5f 00 70 50 	I7 = Null + r3;
      r3 = M[FP + NB_EBAND_RM];
84202f64:	14 00 58 f1 	r3 = M[FP + 0x14];
      M3 = r3;
84202f68:	5f 00 b0 50 	M3 = Null + r3;

      // -- calc pulses allocated to L and R
      r0 = M[FP + VB];
84202f6c:	38 00 28 f1 	r0 = M[FP + 0x38];
      r4 = M[FP + QALLOC];
84202f70:	24 00 68 f1 	r4 = M[FP + 0x24];
      r3 = M[FP + DELTA];
84202f74:	30 00 58 f1 	r3 = M[FP + 0x30];
      r2 = r0 - r4;
84202f78:	6f 00 42 20 	r2 = r0 - r4;
      r1 = r4 ASHIFT -1;
84202f7c:	ff 00 36 91 	r1 = r4 ASHIFT -1;
      r1 = r0 - r1;
84202f80:	3f 00 32 20 	r1 = r0 - r1;
      r1 = r1 - r3;
84202f84:	00 00 35 23 	r1 = r1 - r3;
      r1 = r1 ASHIFT -1;
84202f88:	ff 00 33 91 	r1 = r1 ASHIFT -1;
      if NEG r1 = 0;
84202f8c:	04 00 30 00 	if NEG r1 = Null + Null;
      Null = r1 - r2;
84202f90:	4f 00 03 20 	Null = r1 - r2;
      if POS r1 = r2;
84202f94:	05 00 34 00 	if POS r1 = r2 + Null;
      M[FP + MBITS] = r1;
84202f98:	44 00 3c f1 	M[FP + 0x44] = r1;
      r2 = r2 - r1;
84202f9c:	00 00 43 23 	r2 = r2 - r1;
      M[FP + SBITS] = r2;
84202fa0:	48 00 4c f1 	M[FP + 0x48] = r2;
      r2 = I7 - M3;
84202fa4:	bf 00 47 6c 	r2 = I7 - M3;
      call $celt.bits2pulses;
84202fa8:	c1 00 f0 e1 	call $celt.bits2pulses;
      M[FP + Q1] = r0;
84202fac:	3c 00 2c f1 	M[FP + 0x3c] = r0;
      r1 = M[FP + SBITS];
84202fb0:	48 00 38 f1 	r1 = M[FP + 0x48];
      r2 = I7 - M3;
84202fb4:	bf 00 47 6c 	r2 = I7 - M3;
      call $celt.bits2pulses;
84202fb8:	bd 00 f0 e1 	call $celt.bits2pulses;
      M[FP + Q2] = r0;               //q2=r0
84202fbc:	40 00 2c f1 	M[FP + 0x40] = r0;
      r2 = M[FP + Q1];               //q1=r2
84202fc0:	3c 00 48 f1 	r2 = M[FP + 0x3c];
      Words2Addr(r0);
84202fc4:	02 00 22 91 	r0 = r0 ASHIFT 2;
      r1 = M[r4 + r0];          //curbits=r3
84202fc8:	2f 00 36 d0 	r1 = M[r4 + r0];
      Addr2Words(r0);
84202fcc:	fe 00 22 91 	r0 = r0 ASHIFT -2;
      // restore I5
      r3 = M[FP + RM_BITS];
84202fd0:	04 00 58 f1 	r3 = M[FP + 0x4];
      I5 = r3;
84202fd4:	5f 00 50 50 	I5 = Null + r3;

      Words2Addr(r2);
84202fd8:	02 00 44 91 	r2 = r2 ASHIFT 2;
      r3 = M[r4 + r2];
84202fdc:	4f 00 56 d0 	r3 = M[r4 + r2];
      Addr2Words(r2);
84202fe0:	fe 00 44 91 	r2 = r2 ASHIFT -2;
      r3 = r3 + r1;
84202fe4:	00 00 53 03 	r3 = r3 + r1;
      r1 = M[FP + QALLOC];
84202fe8:	24 00 38 f1 	r1 = M[FP + 0x24];
      r3 = r3 + r1;
84202fec:	00 00 53 03 	r3 = r3 + r1;

84202ff0 <$M.celt.unquant_bands_stereo.rem_loop_start>:
      rem_loop_start:
      I5 = I5 - r3;
84202ff0:	00 00 55 7b 	I5 = I5 - r3;
      if POS jump end_rem_loop;
84202ff4:	14 00 50 dd 	if POS jump $M.celt.unquant_bands_stereo.end_rem_loop;
         Null = r0 + r2;
84202ff8:	4f 00 02 00 	Null = r0 + r2;
         if LE jump end_rem_loop;
84202ffc:	12 00 d0 dd 	if LE jump $M.celt.unquant_bands_stereo.end_rem_loop;
         I5 = I5 + r3;
84203000:	00 00 55 5b 	I5 = I5 + r3;
         r3 = 1;
84203004:	2f 00 50 e4 	r3 = Null + 1;
         Null = r2 - r0;  //q1-q2
84203008:	2f 00 04 20 	Null = r2 - r0;
         if LE r3 = 0;    //r3 = q>q2
8420300c:	0d 00 50 00 	if LE r3 = Null + Null;
         r1 = r3 XOR 1;   //r1 = q1<=q2
84203010:	01 00 35 89 	r1 = r3 XOR 0x1;
         r2 = r2 - r3;    //q1=q1 - q1>q2
84203014:	00 00 45 23 	r2 = r2 - r3;
         r0 = r0 - r1;    //q2=q2 - q1<=q2
84203018:	00 00 23 23 	r0 = r0 - r1;
         Words2Addr(r0);
8420301c:	02 00 22 91 	r0 = r0 ASHIFT 2;
         Words2Addr(r2);
84203020:	02 00 44 91 	r2 = r2 ASHIFT 2;
         r3 = M[r4 + r0];
84203024:	2f 00 56 d0 	r3 = M[r4 + r0];
         r1 = M[r4 + r2];
84203028:	4f 00 36 d0 	r1 = M[r4 + r2];
         Addr2Words(r0);
8420302c:	fe 00 22 91 	r0 = r0 ASHIFT -2;
         Addr2Words(r2);
84203030:	fe 00 44 91 	r2 = r2 ASHIFT -2;
         r3 = r3 + r1;
84203034:	00 00 53 03 	r3 = r3 + r1;
         r1 = M[FP + QALLOC];
84203038:	24 00 38 f1 	r1 = M[FP + 0x24];
         r3 = r3 + r1;
8420303c:	00 00 53 03 	r3 = r3 + r1;
         jump rem_loop_start;
84203040:	ec ff f0 dd 	jump $M.celt.unquant_bands_stereo.rem_loop_start;

84203044 <$M.celt.unquant_bands_stereo.end_rem_loop>:
      end_rem_loop:
      M[FP + Q2] = r0;
84203044:	40 00 2c f1 	M[FP + 0x40] = r0;
      r0 = r2;
84203048:	0f 00 24 00 	r0 = r2 + Null;
      // push I5
      r3 = I5;
8420304c:	5f 00 50 44 	r3 = Null + I5;
      M[FP + RM_BITS] = r3;
84203050:	04 00 5c f1 	M[FP + 0x4] = r3;

      // save some registers into stack
      r2 = M[FP + CUR_B];
84203054:	4c 00 48 f1 	r2 = M[FP + 0x4c];
      r1 = M[FP + S_BAND];
84203058:	20 00 38 f1 	r1 = M[FP + 0x20];
      r3 = M[FP + N_BAND];
8420305c:	1c 00 58 f1 	r3 = M[FP + 0x1c];
      r4 = M[r5 + $celt.dec.NORM_FREQ_FIELD];
84203060:	cc 00 67 d1 	r4 = M[r5 + 204];
      Words2Addr(r1);
84203064:	02 00 33 91 	r1 = r1 ASHIFT 2;
      I5 = r4 + r1;//X+eBands[i]
84203068:	3f 00 56 50 	I5 = r4 + r1;
      // I5 = start of band
      // r0 = number of pulses
      // r1 = start bin no
      // r3 = band width
      // r2 = nr of Blocks
      r4 = r0 - Null;
8420306c:	0f 00 62 20 	r4 = r0 - Null;
      if LE jump intra_act;
84203070:	07 00 d0 dd 	if LE jump $M.celt.unquant_bands_stereo.intra_act;
         //calc spread
         M0 = r2;
84203074:	4f 00 80 50 	M0 = Null + r2;
         Null = M[r5 + $celt.dec.HAS_FOLD_FIELD];
84203078:	60 01 07 d1 	Null = M[r5 + 352];
         if Z M0 = M0 - M0;
8420307c:	80 00 88 7c 	if EQ M0 = M0 - M0;
         r0 = M[r5 + $celt.dec.ALG_QUANT_FUNC_FIELD];
84203080:	34 00 27 d1 	r0 = M[r5 + 52];
         call r0;
84203084:	0f 00 02 e0 	call r0;
         jump end_act;
84203088:	05 00 f0 dd 	jump $M.celt.unquant_bands_stereo.end_act;

8420308c <$M.celt.unquant_bands_stereo.intra_act>:
      intra_act:
         r0 = M[r5 + $celt.dec.NORM_FIELD];
8420308c:	10 01 27 d1 	r0 = M[r5 + 272];
         I3 = r0;
84203090:	2f 00 30 50 	I3 = Null + r0;
         Addr2Words(r1);
84203094:	fe 00 33 91 	r1 = r1 ASHIFT -2;
         call $celt.intra_fold;
84203098:	5b 01 f0 e1 	call $celt.intra_fold;

8420309c <$M.celt.unquant_bands_stereo.end_act>:
      end_act:

      // restore I5, I6, I7, M3, r5
      r3 = M[FP + RM_BITS];
8420309c:	04 00 58 f1 	r3 = M[FP + 0x4];
      I5 = r3;
842030a0:	5f 00 50 50 	I5 = Null + r3;
      r3 = M[FP + TOTOAL_BITS];
842030a4:	08 00 58 f1 	r3 = M[FP + 0x8];
      I6 = r3;
842030a8:	5f 00 60 50 	I6 = Null + r3;
      r3 = M[FP + NB_EBAND];
842030ac:	0c 00 58 f1 	r3 = M[FP + 0xc];
      I7 = r3;
842030b0:	5f 00 70 50 	I7 = Null + r3;
      r3 = M[FP + NB_EBAND_RM];
842030b4:	14 00 58 f1 	r3 = M[FP + 0x14];
      M3 = r3;
842030b8:	5f 00 b0 50 	M3 = Null + r3;
      r5 = M[FP + CODEC_STRUC];
842030bc:	18 00 78 f1 	r5 = M[FP + 0x18];

842030c0 <$M.celt.unquant_bands_stereo.second_ch>:

      second_ch:
         r0 = M[FP + Q2];
842030c0:	40 00 28 f1 	r0 = M[FP + 0x40];
         // save I5, I6, I7, M3, r5 into stack
         r3 = I5;
842030c4:	5f 00 50 44 	r3 = Null + I5;
         M[FP + RM_BITS] = r3;
842030c8:	04 00 5c f1 	M[FP + 0x4] = r3;
         r3 = I6;
842030cc:	6f 00 50 44 	r3 = Null + I6;
         M[FP + TOTOAL_BITS] = r3;
842030d0:	08 00 5c f1 	M[FP + 0x8] = r3;
         r3 = I7;
842030d4:	7f 00 50 44 	r3 = Null + I7;
         M[FP + NB_EBAND] = r3;
842030d8:	0c 00 5c f1 	M[FP + 0xc] = r3;
         r3 = M3;
842030dc:	bf 00 50 44 	r3 = Null + M3;
         M[FP + NB_EBAND_RM] = r3;
842030e0:	14 00 5c f1 	M[FP + 0x14] = r3;
         M[FP + CODEC_STRUC] = r5;
842030e4:	18 00 7c f1 	M[FP + 0x18] = r5;

         r2 = M[FP + CUR_B];
842030e8:	4c 00 48 f1 	r2 = M[FP + 0x4c];
         r1 = M[FP + S_BAND];
842030ec:	20 00 38 f1 	r1 = M[FP + 0x20];
         r3 = M[FP + N_BAND];
842030f0:	1c 00 58 f1 	r3 = M[FP + 0x1c];
         r4 = M[r5 + $celt.dec.NORM_FREQ_FIELD];
842030f4:	cc 00 67 d1 	r4 = M[r5 + 204];
         Words2Addr(r1);
842030f8:	02 00 33 91 	r1 = r1 ASHIFT 2;
         I5 = r4 + r1;//X+eBands[i]
842030fc:	3f 00 56 50 	I5 = r4 + r1;
         r4 = M[r5 +  $celt.dec.MODE_MDCT_SIZE_FIELD];
84203100:	44 00 67 d1 	r4 = M[r5 + 68];
         Words2Addr(r4);
84203104:	02 00 66 91 	r4 = r4 ASHIFT 2;
         I5 = I5 + r4;
84203108:	00 00 56 5b 	I5 = I5 + r4;
         // I5 = start of band
         // r0 = number of pulses
         // r1 = start bin no (AU)
         // r3 = band width
         // r2 = nr of Blocks
         r4 = r0 - Null;
8420310c:	0f 00 62 20 	r4 = r0 - Null;
         if LE jump zeroside;
84203110:	07 00 d0 dd 	if LE jump $M.celt.unquant_bands_stereo.zeroside;
            //calc spread
            M0 = r2;
84203114:	4f 00 80 50 	M0 = Null + r2;
            Null = M[r5 + $celt.dec.HAS_FOLD_FIELD];
84203118:	60 01 07 d1 	Null = M[r5 + 352];
            if Z M0 = M0 - M0;
8420311c:	80 00 88 7c 	if EQ M0 = M0 - M0;
            //call  $celt.alg_unquant;
            r0 = M[r5 + $celt.dec.ALG_QUANT_FUNC_FIELD];
84203120:	34 00 27 d1 	r0 = M[r5 + 52];
            call r0;
84203124:	0f 00 02 e0 	call r0;
            jump end_act2;
84203128:	05 00 f0 dd 	jump $M.celt.unquant_bands_stereo.end_act2;

8420312c <$M.celt.unquant_bands_stereo.zeroside>:
         zeroside:
         r10 = r3;
8420312c:	0f 00 c5 00 	r10 = r3 + Null;
         r0 = 0;
84203130:	00 00 20 01 	r0 = Null + 0;
         do zers_loop;
84203134:	02 00 f0 e5 	do $M.celt.unquant_bands_stereo.end_act2;
            M[I5, MK1] = r0;
84203138:	a5 00 00 03 	Null = Null + Null, M[I5,4] = r0;

8420313c <$M.celt.unquant_bands_stereo.end_act2>:
         zers_loop:

      end_act2:

      // restore I5, r5
      r3 = M[FP + RM_BITS];
8420313c:	04 00 58 f1 	r3 = M[FP + 0x4];
      I5 = r3;
84203140:	5f 00 50 50 	I5 = Null + r3;
      r5 = M[FP + CODEC_STRUC];
84203144:	18 00 78 f1 	r5 = M[FP + 0x18];

      // get start and end of band (again!)
      r1 = M[FP + S_BAND];
84203148:	20 00 38 f1 	r1 = M[FP + 0x20];
      r10 = M[FP + N_BAND];
8420314c:	1c 00 c8 f1 	r10 = M[FP + 0x1c];
      // calc norm for next folded band
      r0 = M[r5 + $celt.dec.MODE_NB_EBANDS_FIELD];
84203150:	48 00 27 d1 	r0 = M[r5 + 72];
      r2 = M[FP + NB_EBAND_RM];  // M3
84203154:	14 00 48 f1 	r2 = M[FP + 0x14];
      Words2Addr(r0);
84203158:	02 00 22 91 	r0 = r0 ASHIFT 2;
      r0 = r0 - r2;
8420315c:	00 00 24 23 	r0 = r0 - r2;
      r2 = M[r5 + $celt.dec.MODE_EBNADS_DIF_SQRT_ADDR_FIELD];
84203160:	74 00 47 d1 	r2 = M[r5 + 116];
      r4 = M[r2 + 0]; //shift
84203164:	00 00 64 d1 	r4 = M[r2 + 0];
      r2 = r2 + ADDR_PER_WORD;
84203168:	bf 00 44 e4 	r2 = r2 + 4;
      r6 = M[r2 + r0]; //gain
8420316c:	2f 00 84 d0 	r6 = M[r2 + r0];
      r10 = r10 - 1;
84203170:	3f 00 cc e4 	r10 = r10 - 1;
      r0 = M[r5 + $celt.dec.NORM_FIELD];
84203174:	10 01 27 d1 	r0 = M[r5 + 272];
      Words2Addr(r1);
84203178:	02 00 33 91 	r1 = r1 ASHIFT 2;
      I3  = r1 + r0;
8420317c:	2f 00 33 50 	I3 = r1 + r0;
      r0 = M[r5 + $celt.dec.NORM_FREQ_FIELD];
84203180:	cc 00 27 d1 	r0 = M[r5 + 204];
      I4  = r0 + r1;
84203184:	3f 00 42 50 	I4 = r0 + r1;
      r0 = M[I4, MK1];
84203188:	21 00 00 03 	Null = Null + Null, r0 = M[I4,4];
      rMAC = r0 * r6; //6 bit less than c
8420318c:	8f 00 12 cc 	rMAC = r0 * r6 (SS);
      do norm_loop;
84203190:	03 00 f0 e5 	do $M.celt.unquant_bands_stereo.norm_loop;
         rMAC = rMAC ASHIFT r4 (56bit), r0 = M[I4, MK1];
84203194:	21 00 16 93 	rMAC = rMAC ASHIFT r4 (56bit), r0 = M[I4,4];
         rMAC = r0 * r6, M[I3, MK1] = rMAC;
84203198:	00 9d 28 cf 	rMAC = r0 * r6 (SS), M[I3,4] = rMAC;

8420319c <$M.celt.unquant_bands_stereo.norm_loop>:
      norm_loop:
      rMAC = rMAC ASHIFT r4 (56bit);
8420319c:	00 00 16 93 	rMAC = rMAC ASHIFT r4 (56bit);
      M[I3, MK1] = rMAC;
842031a0:	00 9d 00 03 	Null = Null + Null, M[I3,4] = rMAC;

      r1 = M[FP + S_BAND];
842031a4:	20 00 38 f1 	r1 = M[FP + 0x20];
      r10 = M[FP + N_BAND];
842031a8:	1c 00 c8 f1 	r10 = M[FP + 0x1c];
      r10 = r10 - 1;
842031ac:	3f 00 cc e4 	r10 = r10 - 1;
      r0 = M[r5 + $celt.dec.NORM_FREQ_FIELD];
842031b0:	cc 00 27 d1 	r0 = M[r5 + 204];
      Words2Addr(r1);
842031b4:	02 00 33 91 	r1 = r1 ASHIFT 2;
      I3  = r1 + r0;
842031b8:	2f 00 33 50 	I3 = r1 + r0;
      r4 = M[r5 +  $celt.dec.MODE_MDCT_SIZE_FIELD];
842031bc:	44 00 67 d1 	r4 = M[r5 + 68];
      Words2Addr(r4);
842031c0:	02 00 66 91 	r4 = r4 ASHIFT 2;
      I4 = I3 + r4;
842031c4:	6f 00 43 58 	I4 = I3 + r4;
      I6 = I3;
842031c8:	0f 00 63 58 	I6 = I3 + Null;
      I7 = I4;
842031cc:	0f 00 74 58 	I7 = I4 + Null;
      r0 = M[FP + IMID];
842031d0:	28 00 28 f1 	r0 = M[FP + 0x28];
      r1 = M[FP + ISIDE];
842031d4:	2c 00 38 f1 	r1 = M[FP + 0x2c];
      r0 = r0 ASHIFT (DAWTH-16);
842031d8:	10 00 22 91 	r0 = r0 ASHIFT 16;
      r1 = r1 ASHIFT (DAWTH-16);
842031dc:	10 00 33 91 	r1 = r1 ASHIFT 16;
      r0 = r0 * 0.707106781186548 (frac);
842031e0:	82 5a 00 fd 	r0 = r0 * 0.707106781192123889923095703125 (frac);
842031e4:	9a 79 22 95 
      r1 = r1 * 0.707106781186548 (frac);
842031e8:	82 5a 00 fd 	r1 = r1 * 0.707106781192123889923095703125 (frac);
842031ec:	9a 79 33 95 
      r2 = M[I3, MK1], r3 = M[I4, MK1];
842031f0:	51 4d 00 03 	Null = Null + Null, r2 = M[I3,4], r3 = M[I4,4];
      rMAC = r2 * r0;
842031f4:	2f 00 14 cc 	rMAC = r2 * r0 (SS);
      do mid_side_loop;
842031f8:	05 00 f0 e5 	do $M.celt.unquant_bands_stereo.mid_side_loop;
         rMAC = rMAC - r3 * r1;
842031fc:	3f 00 15 bc 	rMAC = rMAC - r3 * r1 (SS);
         rMAC = r3 * r1, M[I6, MK1] = rMAC;
84203200:	99 00 53 cf 	rMAC = r3 * r1 (SS), M[I6,4] = rMAC;
         rMAC = rMAC + r2 * r0, r2 = M[I3, MK1], r3 = M[I4, MK1];
84203204:	51 4d 42 af 	rMAC = rMAC + r2 * r0 (SS), r2 = M[I3,4], r3 = M[I4,4];
         rMAC = r2 * r0, M[I7, MK1] = rMAC;
84203208:	9d 00 42 cf 	rMAC = r2 * r0 (SS), M[I7,4] = rMAC;

8420320c <$M.celt.unquant_bands_stereo.mid_side_loop>:
      mid_side_loop:
      rMAC = rMAC - r3 * r1;
8420320c:	3f 00 15 bc 	rMAC = rMAC - r3 * r1 (SS);
      rMAC = r3 * r1, M[I6, MK1] = rMAC;
84203210:	99 00 53 cf 	rMAC = r3 * r1 (SS), M[I6,4] = rMAC;
      rMAC = rMAC + r2 * r0;
84203214:	2f 00 14 ac 	rMAC = rMAC + r2 * r0 (SS);
      M[I7, MK1] = rMAC;
84203218:	9d 00 00 03 	Null = Null + Null, M[I7,4] = rMAC;

      //  I5 = buffer address
      //  M3 = width of the current band
      //  M0 = strides (1)
      //  r7 = value (1.0)
      r3= M[FP + N_BAND];
8420321c:	1c 00 58 f1 	r3 = M[FP + 0x1c];
      M3 = r3;
84203220:	5f 00 b0 50 	M3 = Null + r3;
      r1 = M[FP + S_BAND];
84203224:	20 00 38 f1 	r1 = M[FP + 0x20];
      r0 = M[r5 + $celt.dec.NORM_FREQ_FIELD];
84203228:	cc 00 27 d1 	r0 = M[r5 + 204];
      Words2Addr(r1);
8420322c:	02 00 33 91 	r1 = r1 ASHIFT 2;
      I5  = r1 + r0;
84203230:	2f 00 53 50 	I5 = r1 + r0;
      M0 = 1;
84203234:	01 00 80 51 	M0 = Null + 1;
      r7 = 1.0;
84203238:	ff 7f 00 fd 	r7 = Null + 2147483647;
8420323c:	ff ff 90 01 
      call $celt.renormalise_vector;
84203240:	15 01 f0 e1 	call $celt.renormalise_vector;

      //  I5 = buffer address
      //  M3 = width of the current band
      //  M0 = strides (1)
      //  r7 = value (1.0)
      r3= M[FP + N_BAND];
84203244:	1c 00 58 f1 	r3 = M[FP + 0x1c];
      M3 = r3;
84203248:	5f 00 b0 50 	M3 = Null + r3;
      r1 = M[FP + S_BAND];
8420324c:	20 00 38 f1 	r1 = M[FP + 0x20];
      r0 = M[r5 + $celt.dec.NORM_FREQ_FIELD];
84203250:	cc 00 27 d1 	r0 = M[r5 + 204];
      Words2Addr(r1);
84203254:	02 00 33 91 	r1 = r1 ASHIFT 2;
      I5  = r1 + r0;
84203258:	2f 00 53 50 	I5 = r1 + r0;
      r4 = M[r5 +  $celt.dec.MODE_MDCT_SIZE_FIELD];
8420325c:	44 00 67 d1 	r4 = M[r5 + 68];
      Words2Addr(r4);
84203260:	02 00 66 91 	r4 = r4 ASHIFT 2;
      I5 = I5 + r4;
84203264:	00 00 56 5b 	I5 = I5 + r4;
      M0 = 1;
84203268:	01 00 80 51 	M0 = Null + 1;
      r7 = 1.0;
8420326c:	ff 7f 00 fd 	r7 = Null + 2147483647;
84203270:	ff ff 90 01 
      call $celt.renormalise_vector;
84203274:	08 01 f0 e1 	call $celt.renormalise_vector;

      // pop I6, I7, I2, M3
      r3 = M[FP + TOTOAL_BITS];
84203278:	08 00 58 f1 	r3 = M[FP + 0x8];
      I6 = r3;
8420327c:	5f 00 60 50 	I6 = Null + r3;
      r3 = M[FP + NB_EBAND];
84203280:	0c 00 58 f1 	r3 = M[FP + 0xc];
      I7 = r3;
84203284:	5f 00 70 50 	I7 = Null + r3;
      r3 = M[FP + ADDR_EBAND];
84203288:	10 00 58 f1 	r3 = M[FP + 0x10];
      I2 = r3;
8420328c:	5f 00 20 50 	I2 = Null + r3;
      r3 = M[FP + NB_EBAND_RM];
84203290:	14 00 58 f1 	r3 = M[FP + 0x14];
      M3 = r3 - ADDR_PER_WORD;
84203294:	04 00 b5 71 	M3 = r3 - 4;

   if NZ jump quant_bands_main_loop;
84203298:	1f fe 10 dd 	if NE jump $M.celt.unquant_bands_stereo.quant_bands_main_loop;

   // restore the stack pointer
   SP = SP - STACK_USED;
8420329c:	a4 ff 03 f1 	SP = SP + -92;
   popm<FP>;
842032a0:	00 40 06 f1 	popm <FP>;


   // pop rLink from stack
   jump $pop_rLink_and_rts;
842032a4:	03 00 00 fd 	jump (m) 0x3b020;
842032a8:	21 b0 f0 dd 

842032ac <$celt.bits2pulses>:

#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.BITS2PULSES.PATCH_ID_0,r4)     // celt_patchers
#endif
   
   r4 = M[r5 + $celt.dec.MODE_BITS_VECTORS_ADDR_FIELD];
842032ac:	70 00 67 d1 	r4 = M[r5 + 112];
   r0 = M[r4 + r2]; // AU units
842032b0:	4f 00 26 d0 	r0 = M[r4 + r2];
   r4 = r4 + r0;
842032b4:	00 00 62 03 	r4 = r4 + r0;
   r10 = $celt.MAX_PSEUDOLOG;
842032b8:	06 00 c0 01 	r10 = Null + 6;
   r6 = 0; //lo
842032bc:	00 00 80 01 	r6 = Null + 0;
   r7 = $celt.MAX_PSEUDO - 1;
842032c0:	27 00 90 01 	r7 = Null + 39;
   do find_lo_hi;
842032c4:	0a 00 f0 e5 	do $M.celt.bits2pulses.find_lo_hi;
      r0 = r6 + r7;
842032c8:	9f 00 28 00 	r0 = r6 + r7;
      r0 = r0 LSHIFT -1;
842032cc:	ff 00 22 8d 	r0 = r0 LSHIFT -1;
      Words2Addr(r0);
842032d0:	02 00 22 91 	r0 = r0 ASHIFT 2;
      r2 = M[r4 + r0];
842032d4:	2f 00 46 d0 	r2 = M[r4 + r0];
      Addr2Words(r0);
842032d8:	fe 00 22 91 	r0 = r0 ASHIFT -2;
      Null = r2 - r1;
842032dc:	3f 00 04 20 	Null = r2 - r1;
      if POS r7 = r0;
842032e0:	05 00 92 00 	if POS r7 = r0 + Null;
      Null = r2 - r1;
842032e4:	3f 00 04 20 	Null = r2 - r1;
      if NEG r6 = r0;
842032e8:	04 00 82 00 	if NEG r6 = r0 + Null;

842032ec <$M.celt.bits2pulses.find_lo_hi>:
   find_lo_hi:

   Words2Addr(r6);
842032ec:	02 00 88 91 	r6 = r6 ASHIFT 2;
   Words2Addr(r7);
842032f0:	02 00 99 91 	r7 = r7 ASHIFT 2;
   r2 = M[r4+r6];
842032f4:	8f 00 46 d0 	r2 = M[r4 + r6];
   r0 = M[r4+r7];
842032f8:	9f 00 26 d0 	r0 = M[r4 + r7];
   Addr2Words(r6);
842032fc:	fe 00 88 91 	r6 = r6 ASHIFT -2;
   Addr2Words(r7);
84203300:	fe 00 99 91 	r7 = r7 ASHIFT -2;
   r2 = r2+r0;
84203304:	00 00 42 03 	r2 = r2 + r0;
   r2 = r2 - r1;
84203308:	00 00 43 23 	r2 = r2 - r1;
   r0 = r6;
8420330c:	0f 00 28 00 	r0 = r6 + Null;
   r2 = r2 - r1;
84203310:	00 00 43 23 	r2 = r2 - r1;
   if NEG r0 = r7;
84203314:	04 00 29 00 	if NEG r0 = r7 + Null;
   rts;
84203318:	0f 00 0d dc 	rts;

8420331c <$celt.unquant_energy_finalise>:
#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.UNQUANT_ENERGY_FINALISE.PATCH_ID_0,r4)     // celt_patchers
#endif
   
   // push rLink onto stack
   push rlink;
8420331c:	00 00 d0 f3 	push rLink;

   // work out bits left
   r4 = 0;
84203320:	00 00 60 01 	r4 = Null + 0;
   call $celt.ec_dec_tell;
84203324:	01 f8 f0 e1 	call $celt.ec_dec_tell;
   r1 = M[r5 + $celt.dec.CELT_CODEC_FRAME_SIZE_FIELD];
84203328:	04 00 37 d1 	r1 = M[r5 + 4];
   r1 = r1 * 8(int);
8420332c:	08 00 33 99 	r1 = r1 * 8 (int);
   M2 = r1 - r0;
84203330:	2f 00 a3 70 	M2 = r1 - r0;

   r0 = M[r5 + $celt.dec.CELT_CHANNELS_FIELD];
84203334:	08 00 27 d1 	r0 = M[r5 + 8];
   I6 = r0;
84203338:	2f 00 60 50 	I6 = Null + r0;
   M3 = 1;
8420333c:	01 00 b0 51 	M3 = Null + 1;

84203340 <$M.celt.unquant_energy_finalise.prio_loop>:
   prio_loop:
      r10 = M[r5 + $celt.dec.MODE_NB_EBANDS_FIELD];
84203340:	48 00 c7 d1 	r10 = M[r5 + 72];
      r0 = M[r5 + $celt.dec.FINE_QUANT_FIELD];
84203344:	08 01 27 d1 	r0 = M[r5 + 264];
      I2 = r0;
84203348:	2f 00 20 50 	I2 = Null + r0;
      r0 = M[r5 + $celt.dec.OLD_EBAND_LEFT_FIELD];
8420334c:	8c 00 27 d1 	r0 = M[r5 + 140];
      I3 = r0;
84203350:	2f 00 30 50 	I3 = Null + r0;
      I4 = r0 + ($celt.MAX_BANDS*ADDR_PER_WORD);
84203354:	64 00 42 51 	I4 = r0 + 100;
      r0 = M[r5 + $celt.dec.FINE_PRIORITY_FIELD];
84203358:	0c 01 27 d1 	r0 = M[r5 + 268];
      I5 = r0;
8420335c:	2f 00 50 50 	I5 = Null + r0;
      do finalise_loop;
84203360:	1f 00 f0 e5 	do $M.celt.unquant_energy_finalise.end_finalise_loop;
         r0 = M[r5 + $celt.dec.CELT_CHANNELS_FIELD];
84203364:	08 00 27 d1 	r0 = M[r5 + 8];
         Null = M2 - r0;
84203368:	2f 00 0a 68 	Null = M2 - r0;
         if LE jump end_finalise_loop;
8420336c:	1c 00 d0 dd 	if LE jump $M.celt.unquant_energy_finalise.end_finalise_loop;
         r0 = M[I2, 0], r1 = M[I5, 0];
84203370:	34 28 00 03 	Null = Null + Null, r0 = M[I2,0], r1 = M[I5,0];
         Null = r0 - 7;
84203374:	07 00 02 21 	Null = r0 - 7;
         if POS jump next_fin;
84203378:	16 00 50 dd 	if POS jump $M.celt.unquant_energy_finalise.next_fin;
         Null = r1 - M3;
8420337c:	bf 00 03 64 	Null = r1 - M3;
         if Z jump next_fin;
84203380:	14 00 00 dd 	if EQ jump $M.celt.unquant_energy_finalise.next_fin;
            r2 = 1;
84203384:	2f 00 40 e4 	r2 = Null + 1;
            M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FTB] = r2;
84203388:	e4 01 47 d5 	M[r5 + 484] = r2;
            call $celt.ec_dec_bits;
8420338c:	53 f7 f0 e1 	call $celt.ec_dec_bits;
            //calc offset
            r0 = r0 + r0, r2 = M[I2, 0];
84203390:	00 48 22 03 	r0 = r0 + r0, r2 = M[I2,0];
            r0 = r0 - 1;
84203394:	3f 00 22 e4 	r0 = r0 - 1;
            r2 = (DAWTH-10) - r2;
84203398:	16 00 44 65 	r2 = 22 - r2;
            r0 = r0 ASHIFT r2, r1 = M[I3, 0];
8420339c:	00 3c 24 93 	r0 = r0 ASHIFT r2, r1 = M[I3,0];
            r0 = r0 + r1;
842033a0:	00 00 23 03 	r0 = r0 + r1;
            M2 = M2 -1;
842033a4:	01 00 aa 79 	M2 = M2 - 1;
            Null = I6, M[I3, 0] = r0;
842033a8:	00 ac 06 47 	Null = Null + I6, M[I3,0] = r0;
            if Z jump next_fin;
842033ac:	09 00 00 dd 	if EQ jump $M.celt.unquant_energy_finalise.next_fin;
            call $celt.ec_dec_bits;
842033b0:	4a f7 f0 e1 	call $celt.ec_dec_bits;
            r0 = r0 + r0, r2 = M[I2, 0];
842033b4:	00 48 22 03 	r0 = r0 + r0, r2 = M[I2,0];
            r0 = r0 - 1;
842033b8:	3f 00 22 e4 	r0 = r0 - 1;
            r2 = (DAWTH-10) - r2;
842033bc:	16 00 44 65 	r2 = 22 - r2;
            r0 = r0 ASHIFT r2, r1 = M[I4, 0];
842033c0:	30 00 24 93 	r0 = r0 ASHIFT r2, r1 = M[I4,0];
            r0 = r0 + r1;
842033c4:	00 00 23 03 	r0 = r0 + r1;
            M[I4, 0] = r0;
842033c8:	a0 00 00 03 	Null = Null + Null, M[I4,0] = r0;
            M2 = M2 -1;
842033cc:	01 00 aa 79 	M2 = M2 - 1;

842033d0 <$M.celt.unquant_energy_finalise.next_fin>:
            next_fin:
            r0 = M[I2, MK1], r1 = M[I5, MK1];
842033d0:	35 29 00 03 	Null = Null + Null, r0 = M[I2,4], r1 = M[I5,4];
            r0 = M[I3, MK1];
842033d4:	00 2d 00 03 	Null = Null + Null, r0 = M[I3,4];
            r1 = M[I4, MK1];
842033d8:	31 00 00 03 	Null = Null + Null, r1 = M[I4,4];

842033dc <$M.celt.unquant_energy_finalise.end_finalise_loop>:
        finalise_loop:
        end_finalise_loop:
   M3 = M3 - 1;
842033dc:	01 00 bb 79 	M3 = M3 - 1;
   if Z jump prio_loop;
842033e0:	d8 ff 00 dd 	if EQ jump $M.celt.unquant_energy_finalise.prio_loop;

   
   // calculate non-logarithmic bans Energies
   r0 = M[r5 + $celt.dec.OLD_EBAND_LEFT_FIELD];
842033e4:	8c 00 27 d1 	r0 = M[r5 + 140];
   I3 = r0;
842033e8:	2f 00 30 50 	I3 = Null + r0;
   r0 = M[r5 + $celt.dec.BANDE_FIELD];
842033ec:	d0 00 27 d1 	r0 = M[r5 + 208];
   I2 = r0;
842033f0:	2f 00 20 50 	I2 = Null + r0;
   I4 = I2 + ($celt.MAX_BANDS*ADDR_PER_WORD);
842033f4:	64 00 42 59 	I4 = I2 + 100;
   r0 = M[r5 + $celt.dec.CELT_CHANNELS_FIELD];
842033f8:	08 00 27 d1 	r0 = M[r5 + 8];
   M3 = r0 + 1;
842033fc:	01 00 b2 51 	M3 = r0 + 1;
   r8 = M[r5 + $celt.dec.CELT_MODE_OBJECT_FIELD];
84203400:	00 00 a7 d1 	r8 = M[r5 + 0];
   I7 = r5 + $celt.dec.SCRATCHVAR_MAX_SBAND;
84203404:	f0 01 77 51 	I7 = r5 + 496;

84203408 <$M.celt.unquant_energy_finalise.calc_ebands>:
   calc_ebands:
   I6 = -100;
84203408:	9c ff 60 51 	I6 = Null + -100;
   r10 = M[r5 + $celt.dec.MODE_NB_EBANDS_FIELD];
8420340c:	48 00 c7 d1 	r10 = M[r5 + 72];
   do comp_ebands_loop_ch;
84203410:	14 00 f0 e5 	do $M.celt.unquant_energy_finalise.comp_ebands_loop_ch;
      r0 = M[I3, 0];
84203414:	00 2c 00 03 	Null = Null + Null, r0 = M[I3,0];
      r4 = 0;
84203418:	00 00 60 01 	r4 = Null + 0;
      r1 = r0 ASHIFT -(DAWTH-8);
8420341c:	e8 00 32 91 	r1 = r0 ASHIFT -24;
      if NEG jump calc_log;
84203420:	04 00 40 dd 	if NEG jump $M.celt.unquant_energy_finalise.calc_log;
         r4 = r1 + 1;
84203424:	2f 00 63 e4 	r4 = r1 + 1;
         r1 = r4 ASHIFT (DAWTH-8);
84203428:	18 00 36 91 	r1 = r4 ASHIFT 24;
         r0 = r0 - r1;
8420342c:	00 00 23 23 	r0 = r0 - r1;

84203430 <$M.celt.unquant_energy_finalise.calc_log>:
      calc_log:
      call $math.pow2_table;
84203430:	07 00 00 fd 	call 0x74514;
84203434:	14 45 f0 e1 
      r4 = r4 - 12;
84203438:	0c 00 66 21 	r4 = r4 - 12;
      // store E in the form of a gain and a shift value
      M[I4, MK1] = r4;
8420343c:	e1 00 00 03 	Null = Null + Null, M[I4,4] = r4;
      M[I2, MK1] = r0;
84203440:	00 a9 00 03 	Null = Null + Null, M[I2,4] = r0;
      Null = r4 - I6;
84203444:	6f 00 06 64 	Null = r4 - I6;
      if POS I6 = r4;
84203448:	65 00 60 50 	if POS I6 = Null + r4;
      // minimum energy clipping
      r0 = M[I3, 0];
8420344c:	00 2c 00 03 	Null = Null + Null, r0 = M[I3,0];
      r1 = r0 + 0.0546875;
84203450:	00 07 00 fd 	r1 = r0 + 117440512;
84203454:	00 00 32 01 
      if NEG r0 = r0 - r1;
84203458:	34 00 22 20 	if NEG r0 = r0 - r1;
      M[I3, MK1] = r0;
8420345c:	00 ad 00 03 	Null = Null + Null, M[I3,4] = r0;

84203460 <$M.celt.unquant_energy_finalise.comp_ebands_loop_ch>:
   comp_ebands_loop_ch:
   r0 = I6;
84203460:	6f 00 20 44 	r0 = Null + I6;

   M[I7, MK1] = r0;
84203464:	ad 00 00 03 	Null = Null + Null, M[I7,4] = r0;

   r0 = M[r5 + $celt.dec.OLD_EBAND_LEFT_FIELD];
84203468:	8c 00 27 d1 	r0 = M[r5 + 140];
   I3 = r0 + ($celt.MAX_BANDS*ADDR_PER_WORD);
8420346c:	64 00 32 51 	I3 = r0 + 100;
   r0 = M[r5 + $celt.dec.BANDE_FIELD];
84203470:	d0 00 27 d1 	r0 = M[r5 + 208];
   I2 = r0 + (2*$celt.MAX_BANDS*ADDR_PER_WORD);
84203474:	c8 00 22 51 	I2 = r0 + 200;
   I4 = I2 + ($celt.MAX_BANDS*ADDR_PER_WORD);
84203478:	64 00 42 59 	I4 = I2 + 100;
   M3 = M3 - 1;
8420347c:	01 00 bb 79 	M3 = M3 - 1;
   if NZ jump calc_ebands;
84203480:	e2 ff 10 dd 	if NE jump $M.celt.unquant_energy_finalise.calc_ebands;

   // pop rLink from stack
   jump $pop_rLink_and_rts;
84203484:	03 00 00 fd 	jump (m) 0x3b020;
84203488:	21 b0 f0 dd 

8420348c <$celt.denormalise_bands>:
#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.DENORMALISE_BANDS.PATCH_ID_0,r6)     // celt_patchers
#endif
   
   // push rLink onto stack
   push rlink;
8420348c:	00 00 d0 f3 	push rLink;

   r0 = M[r5 + $celt.dec.CELT_CHANNELS_FIELD];
84203490:	08 00 27 d1 	r0 = M[r5 + 8];
   M3 = r0 + 1;
84203494:	01 00 b2 51 	M3 = r0 + 1;
   r0 = M[r5 + $celt.dec.MODE_NB_EBANDS_FIELD];
84203498:	48 00 27 d1 	r0 = M[r5 + 72];
   M0 = r0;
8420349c:	2f 00 80 50 	M0 = Null + r0;
   r0 = M[r5 + $celt.dec.MODE_EBANDS_ADDR_FIELD];
842034a0:	60 00 27 d1 	r0 = M[r5 + 96];
   I2 = r0;
842034a4:	2f 00 20 50 	I2 = Null + r0;
   r0 = M[r5 + $celt.dec.BANDE_FIELD];
842034a8:	d0 00 27 d1 	r0 = M[r5 + 208];
   I4 = r0;
842034ac:	2f 00 40 50 	I4 = Null + r0;
   I6 = I4 + ($celt.MAX_BANDS*ADDR_PER_WORD);
842034b0:	64 00 64 59 	I6 = I4 + 100;
   r0 = M[r5 + $celt.dec.NORM_FREQ_FIELD];
842034b4:	cc 00 27 d1 	r0 = M[r5 + 204];
   I3 = r0;
842034b8:	2f 00 30 50 	I3 = Null + r0;
   r0 = M[r5 + $celt.dec.FREQ_FIELD];
842034bc:	14 01 27 d1 	r0 = M[r5 + 276];
   I5 = r0;
842034c0:	2f 00 50 50 	I5 = Null + r0;
   M1 = MK1;
842034c4:	04 00 90 51 	M1 = Null + 4;
   r6 = 1;
842034c8:	2f 00 80 e4 	r6 = Null + 1;
#ifdef K32
   r7 = 0x40000000;
842034cc:	00 40 00 fd 	r7 = Null + 1073741824;
842034d0:	00 00 90 01 
#else
   r7 = 0x400000;
#endif   
   I7 = r5 + $celt.dec.SCRATCHVAR_MAX_SBAND;
842034d4:	f0 01 77 51 	I7 = r5 + 496;

842034d8 <$M.celt.denormalise_bands.chan_denorm_loop>:
   chan_denorm_loop:
      M2 = M0;
842034d8:	0f 00 a8 58 	M2 = M0 + Null;

842034dc <$M.celt.denormalise_bands.band_denorm_loop>:
      band_denorm_loop:
         // process band
         r2 = M[I6, MK1];
842034dc:	49 00 00 03 	Null = Null + Null, r2 = M[I6,4];
         r3 = M[I7, 0];
842034e0:	5c 00 00 03 	Null = Null + Null, r3 = M[I7,0];
         r2 = r2 - 1;
842034e4:	3f 00 44 e4 	r2 = r2 - 1;
         r2 = r2 - r3;
842034e8:	00 00 45 23 	r2 = r2 - r3;
         r8 = (2-DAWTH) - r2;
842034ec:	e2 ff a4 65 	r8 = -30 - r2;
         r8 = r7 ASHIFT r8;
842034f0:	af 00 a9 90 	r8 = r7 ASHIFT r8;
         r0 = M[I2, MK1];
842034f4:	00 29 00 03 	Null = Null + Null, r0 = M[I2,4];
         r1 = M[I2, 0];
842034f8:	00 38 00 03 	Null = Null + Null, r1 = M[I2,0];
         r10 = r1 - r0, r0 = M[I3, M1];
842034fc:	2f 2d c3 20 	r10 = r1 - r0, r0 = M[I3,M1];
         r10 = r10 - r6, r4 = M[I4, M1];
84203500:	61 00 c8 22 	r10 = r10 - r6, r4 = M[I4,M1];
         rMAC = r4 * r0;
84203504:	2f 00 16 cc 	rMAC = r4 * r0 (SS);
         rMAC = rMAC + r7*r8;
84203508:	af 00 19 ac 	rMAC = rMAC + r7 * r8 (SS);
         do denorm_band_loop;
8420350c:	04 00 f0 e5 	do $M.celt.denormalise_bands.denorm_band_loop;
            rMAC = rMAC ASHIFT r2 (56bit), r0 = M[I3, M1];
84203510:	00 2d 14 92 	rMAC = rMAC ASHIFT r2 (56bit), r0 = M[I3,M1];
            rMAC = r4 * r0,  M[I5, M1] = rMAC;
84203514:	95 00 62 ce 	rMAC = r4 * r0 (SS), M[I5,M1] = rMAC;
            rMAC = rMAC + r7*r8;
84203518:	af 00 19 ac 	rMAC = rMAC + r7 * r8 (SS);

8420351c <$M.celt.denormalise_bands.denorm_band_loop>:
         denorm_band_loop:
         rMAC = rMAC ASHIFT r2 (56bit);
8420351c:	00 00 14 93 	rMAC = rMAC ASHIFT r2 (56bit);
         M[I5, MK1] = rMAC;
84203520:	95 00 00 03 	Null = Null + Null, M[I5,4] = rMAC;
      M2 = M2 - 1;
84203524:	01 00 aa 79 	M2 = M2 - 1;
      if NZ jump band_denorm_loop;
84203528:	ed ff 10 dd 	if NE jump $M.celt.denormalise_bands.band_denorm_loop;
      // zero the rest
      r0 = M[I2, MK1];
8420352c:	00 29 00 03 	Null = Null + Null, r0 = M[I2,4];
      r1 = M[I2, 0];
84203530:	00 38 00 03 	Null = Null + Null, r1 = M[I2,0];
      r10 = r1 - r0;
84203534:	2f 00 c3 20 	r10 = r1 - r0;
      r0 = 0;
84203538:	00 00 20 01 	r0 = Null + 0;
      do zero_last_band_loop;
8420353c:	02 00 f0 e5 	do $M.celt.denormalise_bands.zero_last_band_loop;
         M[I5, MK1] = r0;
84203540:	a5 00 00 03 	Null = Null + Null, M[I5,4] = r0;

84203544 <$M.celt.denormalise_bands.zero_last_band_loop>:
      zero_last_band_loop:
      // set regs for next channel if necessary
      r0 = M[r5 + $celt.dec.BANDE_FIELD];
84203544:	d0 00 27 d1 	r0 = M[r5 + 208];
      I4 = r0 + (2*$celt.MAX_BANDS*ADDR_PER_WORD);
84203548:	c8 00 42 51 	I4 = r0 + 200;
      I6 = I4 + ($celt.MAX_BANDS*ADDR_PER_WORD);
8420354c:	64 00 64 59 	I6 = I4 + 100;
      r0 = M[r5 + $celt.dec.NORM_FREQ_FIELD];
84203550:	cc 00 27 d1 	r0 = M[r5 + 204];
      r1 = M[r5 + $celt.dec.MODE_AUDIO_FRAME_SIZE_FIELD];
84203554:	44 00 37 d1 	r1 = M[r5 + 68];
      Words2Addr(r1);
84203558:	02 00 33 91 	r1 = r1 ASHIFT 2;
      I3 = r0 + r1;
8420355c:	3f 00 32 50 	I3 = r0 + r1;
      r0 = M[r5 + $celt.dec.FREQ2_FIELD];
84203560:	18 01 27 d1 	r0 = M[r5 + 280];
      I5 = r0;
84203564:	2f 00 50 50 	I5 = Null + r0;
      r0 = M[r5 + $celt.dec.MODE_EBANDS_ADDR_FIELD];
84203568:	60 00 27 d1 	r0 = M[r5 + 96];
      I2 = r0;
8420356c:	2f 00 20 50 	I2 = Null + r0;
      r3 = M[I7, MK1];
84203570:	5d 00 00 03 	Null = Null + Null, r3 = M[I7,4];
   M3 = M3 - 1;
84203574:	01 00 bb 79 	M3 = M3 - 1;
   if NZ jump chan_denorm_loop;
84203578:	d8 ff 10 dd 	if NE jump $M.celt.denormalise_bands.chan_denorm_loop;

   // pop rLink from stack
   jump $pop_rLink_and_rts;
8420357c:	03 00 00 fd 	jump (m) 0x3b020;
84203580:	21 b0 f0 dd 

84203584 <$celt.renormalise_bands>:
#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.RENORMALISE_BANDS.PATCH_ID_0,r1)     // celt_patchers
#endif
   
   // push rLink onto stack
   push rlink;
84203584:	00 00 d0 f3 	push rLink;

   r0 = M[r5 + $celt.dec.MODE_NB_EBANDS_FIELD];
84203588:	48 00 27 d1 	r0 = M[r5 + 72];
   I7 = r0;
8420358c:	2f 00 70 50 	I7 = Null + r0;
   r0 = M[r5 + $celt.dec.MODE_EBANDS_ADDR_FIELD];
84203590:	60 00 27 d1 	r0 = M[r5 + 96];
   I3 = r0;
84203594:	2f 00 30 50 	I3 = Null + r0;
   r0 = M[r5 + $celt.dec.CELT_CHANNELS_FIELD];
84203598:	08 00 27 d1 	r0 = M[r5 + 8];
   I6 = r0 + 1;
8420359c:	01 00 62 51 	I6 = r0 + 1;
   r7 = 1.0;
842035a0:	ff 7f 00 fd 	r7 = Null + 2147483647;
842035a4:	ff ff 90 01 
   r0 = M[r5 + $celt.dec.NORM_FREQ_FIELD];
842035a8:	cc 00 27 d1 	r0 = M[r5 + 204];
   I5 = r0;
842035ac:	2f 00 50 50 	I5 = Null + r0;

842035b0 <$M.celt.renormalise_bands.chan_renorm_loop>:
   chan_renorm_loop:
      M2 = I7;
842035b0:	0f 00 a7 58 	M2 = I7 + Null;

842035b4 <$M.celt.renormalise_bands.band_norm_loop>:
      band_norm_loop:
         r0 = M[I3, MK1];
842035b4:	00 2d 00 03 	Null = Null + Null, r0 = M[I3,4];
         r1 = M[I3, 0];
842035b8:	00 3c 00 03 	Null = Null + Null, r1 = M[I3,0];
         r6 = r1 - r0;
842035bc:	2f 00 83 20 	r6 = r1 - r0;
         M3 = r6;
842035c0:	8f 00 b0 50 	M3 = Null + r6;
         Words2Addr(r6);
842035c4:	02 00 88 91 	r6 = r6 ASHIFT 2;
         M0 = 1;
842035c8:	01 00 80 51 	M0 = Null + 1;
         call $celt.renormalise_vector;
842035cc:	32 00 f0 e1 	call $celt.renormalise_vector;
         I5 = I5 + r6;
842035d0:	00 00 58 5b 	I5 = I5 + r6;
         M2 = M2 -1;
842035d4:	01 00 aa 79 	M2 = M2 - 1;
      if NZ jump band_norm_loop;
842035d8:	f7 ff 10 dd 	if NE jump $M.celt.renormalise_bands.band_norm_loop;
      r0 = M[r5 + $celt.dec.MODE_EBANDS_ADDR_FIELD];
842035dc:	60 00 27 d1 	r0 = M[r5 + 96];
      r1 = M[r5 + $celt.dec.MODE_MDCT_SIZE_FIELD];
842035e0:	44 00 37 d1 	r1 = M[r5 + 68];
      I3 = r0;
842035e4:	2f 00 30 50 	I3 = Null + r0;
      r0 = M[r5 + $celt.dec.NORM_FREQ_FIELD];
842035e8:	cc 00 27 d1 	r0 = M[r5 + 204];
      Words2Addr(r1);
842035ec:	02 00 33 91 	r1 = r1 ASHIFT 2;
      I5 = r0 + r1;
842035f0:	3f 00 52 50 	I5 = r0 + r1;
      I6 = I6 - 1;
842035f4:	01 00 66 79 	I6 = I6 - 1;
   if NZ jump chan_renorm_loop;
842035f8:	ee ff 10 dd 	if NE jump $M.celt.renormalise_bands.chan_renorm_loop;

   // pop rLink from stack
   jump $pop_rLink_and_rts;
842035fc:	03 00 00 fd 	jump (m) 0x3b020;
84203600:	21 b0 f0 dd 

84203604 <$celt.intra_fold>:
84203604:	00 00 d0 f3 	push rLink;
#endif
        
   push rlink;   
   //for this app B = 1 or 2 , //TODO: add support of 3 and 4 short blocks
#ifdef CELT_USE_EXTERNAL_MEMORY
   r4 = M[r5 + $celt.dec.PTR_INV2_TABLE_FIELD];
84203608:	20 02 67 d1 	r4 = M[r5 + 544];
   r4 = r4 - MK1;
8420360c:	df 00 66 e4 	r4 = r4 - 4;
#else
   .VAR inv2[] = 1.0, 1.0/2+(1.0e-7), 1.0/3+(1.0e-7), 1.0/4+(1.0e-7), 1.0/5+(1.0e-7), 1.0/6+(1.0e-7), 1.0/7+(1.0e-7), 1.0/8+(1.0e-7);
#endif
   r0 = r2 + 1;
84203610:	2f 00 24 e4 	r0 = r2 + 1;
   r0 = r0 LSHIFT -1;
84203614:	ff 00 22 8d 	r0 = r0 LSHIFT -1;
   r0 = r0 + r1;
84203618:	00 00 23 03 	r0 = r0 + r1;
   Words2Addr(r2);
8420361c:	02 00 44 91 	r2 = r2 ASHIFT 2;
#ifdef CELT_USE_EXTERNAL_MEMORY
   r4 = M[r2 + r4];
84203620:	6f 00 64 d0 	r4 = M[r2 + r4];
#else
   r4 = M[r2 + (inv2-MK1)];
#endif
   Addr2Words(r2);
84203624:	fe 00 44 91 	r2 = r2 ASHIFT -2;
   r0 = r0 * r4 (frac);
84203628:	00 00 26 97 	r0 = r0 * r4 (frac);
   r0 = r0 - 1;                  // nb=num_blocks=r2, sb=start_bin=r1, bw=width of band=r3
8420362c:	3f 00 22 e4 	r0 = r0 - 1;
   r0 = r0 * r2 (int);           // r0 = ( ( (nb+1)*2+sb )*inv2[nb] - 1) * nb
84203630:	00 00 24 9b 	r0 = r0 * r2 (int);
   r4 = r1 - r0;
84203634:	2f 00 63 20 	r4 = r1 - r0;
   I6 = I5;
84203638:	0f 00 65 58 	I6 = I5 + Null;
   r0 = r4 + r3;
8420363c:	5f 00 26 00 	r0 = r4 + r3;
   Words2Addr(r4);
84203640:	02 00 66 91 	r4 = r4 ASHIFT 2;
   I2 = I3 + r4; //y
84203644:	6f 00 23 58 	I2 = I3 + r4;
   Null = r0 - r1;
84203648:	3f 00 02 20 	Null = r0 - r1;
   if GT jump set_z;
8420364c:	07 00 c0 dd 	if GT jump $M.celt.intra_fold.set_z;
   r10 = r3 - 1;
84203650:	3f 00 c5 e4 	r10 = r3 - 1;
   
   // fold previous band into current band
   r0 = M[I2, MK1];
84203654:	00 29 00 03 	Null = Null + Null, r0 = M[I2,4];
   do fold_loop;
84203658:	02 00 f0 e5 	do $M.celt.intra_fold.fold_loop;
      r0 = M[I2, MK1], M[I6, MK1] = r0;
8420365c:	a9 29 00 03 	Null = Null + Null, r0 = M[I2,4], M[I6,4] = r0;

84203660 <$M.celt.intra_fold.fold_loop>:
   fold_loop:
   M[I6, MK1] = r0;
84203660:	a9 00 00 03 	Null = Null + Null, M[I6,4] = r0;
   jump end_fold;
84203664:	05 00 f0 dd 	jump $M.celt.intra_fold.end_fold;

84203668 <$M.celt.intra_fold.set_z>:
   
   // zero the band
   set_z:
   r10 = r3;
84203668:	0f 00 c5 00 	r10 = r3 + Null;
   r0 = 0;
8420366c:	00 00 20 01 	r0 = Null + 0;
   do z_loop;
84203670:	02 00 f0 e5 	do $M.celt.intra_fold.end_fold;
      M[I6, MK1] = r0;
84203674:	a9 00 00 03 	Null = Null + Null, M[I6,4] = r0;

84203678 <$M.celt.intra_fold.end_fold>:
   z_loop: 
   end_fold:
   
   // folding is done, now renormalise to band energy
   M3 = r3;
84203678:	5f 00 b0 50 	M3 = Null + r3;
   M0 = 1;
8420367c:	01 00 80 51 	M0 = Null + 1;
   r7 = 1.0;
84203680:	ff 7f 00 fd 	r7 = Null + 2147483647;
84203684:	ff ff 90 01 
   call $celt.renormalise_vector;
84203688:	03 00 f0 e1 	call $celt.renormalise_vector;
   jump $pop_rLink_and_rts;
8420368c:	03 00 00 fd 	jump (m) 0x3b020;
84203690:	21 b0 f0 dd 

84203694 <$celt.renormalise_vector>:

#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.RENORMALISE_VECTOR.PATCH_ID_0,r8)     // celt_patchers
#endif
   
   push rlink;
84203694:	00 00 d0 f3 	push rLink;
   rMAC = 0;  //TODO:check if rMAC0 = 1 can be enough
84203698:	00 00 10 01 	rMAC = Null + 0;
#ifdef K32
   r0 = M0;
8420369c:	8f 00 20 44 	r0 = Null + M0;
   Words2Addr(r0);
842036a0:	02 00 22 91 	r0 = r0 ASHIFT 2;
   M0 = r0;
842036a4:	2f 00 80 50 	M0 = Null + r0;
#endif
   r0 = 1;
842036a8:	2f 00 20 e4 	r0 = Null + 1;
   rMAC0 = r0;
842036ac:	00 05 e2 8d 	rMAC0 = r0 LSHIFT 0;
   r10 = M3 - 1;
842036b0:	01 00 cb 69 	r10 = M3 - 1;
   I2 = I5;
842036b4:	0f 00 25 58 	I2 = I5 + Null;
   r0 = M[I2, M0];
842036b8:	00 28 00 02 	Null = Null + Null, r0 = M[I2,M0];
   do calc_e_lp;
842036bc:	02 00 f0 e5 	do $M.celt.renormalise_vector.calc_e_lp;
      rMAC = rMAC + r0 * r0, r0 = M[I2, M0];      
842036c0:	2f 28 12 ac 	rMAC = rMAC + r0 * r0 (SS), r0 = M[I2,M0];

842036c4 <$M.celt.renormalise_vector.calc_e_lp>:
   calc_e_lp:
   rMAC = rMAC + r0 * r0;
842036c4:	2f 00 12 ac 	rMAC = rMAC + r0 * r0 (SS);
   r8 = signdet rMAC;
842036c8:	0f 00 a1 d8 	r8 = SIGNDET rMAC;
   r8 = r8 AND (-2);
842036cc:	ff ff 00 fd 	r8 = r8 AND 0xfffffffe;
842036d0:	fe ff aa 81 
   r8 = r8 - 2;
842036d4:	cf 00 aa e4 	r8 = r8 - 2;
   r0 = rMAC ASHIFT r8;
842036d8:	af 00 21 90 	r0 = rMAC ASHIFT r8;
   $celt.sqrt()
842036dc:	01 10 01 f1 	pushm <I0, L0>;
842036e0:	00 00 c0 51 	L0 = Null + 0;
842036e4:	00 00 a2 f3 	push B0;
842036e8:	00 00 00 f3 	push Null;
842036ec:	00 00 a6 f3 	pop B0;
842036f0:	07 00 00 fd 	call 0x74370;
842036f4:	70 43 f0 e1 
842036f8:	00 00 a6 f3 	pop B0;
842036fc:	01 10 05 f1 	popm <I0, L0>;
   push r1;
84203700:	00 00 30 f3 	push r1;
   r4 = 1.0;
84203704:	ff 7f 00 fd 	r4 = Null + 2147483647;
84203708:	ff ff 60 01 
   Null = r1 - 0.2;
8420370c:	99 19 00 fd 	Null = r1 - 429496730;
84203710:	9a 99 03 21 
   if NEG jump too_small;
84203714:	05 00 40 dd 	if NEG jump $M.celt.renormalise_vector.too_small;
      rMAC = 0.125;
84203718:	00 10 00 fd 	rMAC = Null + 268435456;
8420371c:	00 00 10 01 
      Div = rMAC / r1;
84203720:	00 00 13 d9 	Div = rMAC / r1;
      r4 = DivResult;
84203724:	01 00 60 d9 	r4 = DivResult;

84203728 <$M.celt.renormalise_vector.too_small>:
   too_small:
   r1 = r8 + 2;
84203728:	af 00 3a e4 	r1 = r8 + 2;
   r0 = r1 ASHIFT -1;
8420372c:	ff 00 23 91 	r0 = r1 ASHIFT -1;
   r8 = 1 - r0;
84203730:	01 00 a2 65 	r8 = 1 - r0;
   r1 = r4 * r7 (frac);
84203734:	9f 00 36 94 	r1 = r4 * r7 (frac);
   r10 = M3 - 1;
84203738:	01 00 cb 69 	r10 = M3 - 1;
   I2 = I5;
8420373c:	0f 00 25 58 	I2 = I5 + Null;
   I4 = I5, r4 = M[I2, M0];
84203740:	0f 68 45 58 	I4 = I5 + Null, r4 = M[I2,M0];
   rMAC = r4*r1;
84203744:	3f 00 16 cc 	rMAC = r4 * r1 (SS);
   do re_norm_lp;
84203748:	03 00 f0 e5 	do $M.celt.renormalise_vector.re_norm_lp;
      rMAC = rMAC ASHIFT r0 (56bit), r4 = M[I2, M0];
8420374c:	00 68 12 92 	rMAC = rMAC ASHIFT r0 (56bit), r4 = M[I2,M0];
      rMAC = r4*r1, M[I4, M0] = rMAC;
84203750:	90 00 63 ce 	rMAC = r4 * r1 (SS), M[I4,M0] = rMAC;

84203754 <$M.celt.renormalise_vector.re_norm_lp>:
   re_norm_lp:
   rMAC = rMAC ASHIFT r0 (56bit);
84203754:	00 00 12 93 	rMAC = rMAC ASHIFT r0 (56bit);
   M[I4, M0] = rMAC;
84203758:	90 00 00 02 	Null = Null + Null, M[I4,M0] = rMAC;
   pop r1;
8420375c:	00 00 34 f3 	pop r1;
   r1 = r1 ASHIFT r8;
84203760:	00 00 3a 93 	r1 = r1 ASHIFT r8;
   jump $pop_rLink_and_rts;
84203764:	03 00 00 fd 	jump (m) 0x3b020;
84203768:	21 b0 f0 dd 

8420376c <$celt.normalise_residual>:
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.NORMALISE_RESIDUAL.PATCH_ID_0,r8)     // celt_patchers
#endif
   
   .CONST TEMP                 (0 + 2)*ADDR_PER_WORD;
   .CONST STACK_FRAME_SIZE     1*ADDR_PER_WORD;
   pushm <FP(=SP), rLink>;
8420376c:	01 20 00 f1 	pushm <FP(=SP), rLink>;
   SP = SP + STACK_FRAME_SIZE;
84203770:	04 00 03 f1 	SP = SP + 4;
   M[FP + TEMP] = r3;
84203774:	08 00 5c f1 	M[FP + 0x8] = r3;
   r8 = signdet rMAC;
84203778:	0f 00 a1 d8 	r8 = SIGNDET rMAC;
   r8 = r8 AND 0xFE;
8420377c:	fe 00 aa 81 	r8 = r8 AND 0xfe;
   r8 = r8 - 2;
84203780:	cf 00 aa e4 	r8 = r8 - 2;
   r0 = rMAC ASHIFT r8;
84203784:	af 00 21 90 	r0 = rMAC ASHIFT r8;
   $celt.sqrt()
84203788:	01 10 01 f1 	pushm <I0, L0>;
8420378c:	00 00 c0 51 	L0 = Null + 0;
84203790:	00 00 a2 f3 	push B0;
84203794:	00 00 00 f3 	push Null;
84203798:	00 00 a6 f3 	pop B0;
8420379c:	07 00 00 fd 	call 0x74370;
842037a0:	70 43 f0 e1 
842037a4:	00 00 a6 f3 	pop B0;
842037a8:	01 10 05 f1 	popm <I0, L0>;
   r0 = 1.0;
842037ac:	ff 7f 00 fd 	r0 = Null + 2147483647;
842037b0:	ff ff 20 01 
   Null = r1 - 0.2;
842037b4:	99 19 00 fd 	Null = r1 - 429496730;
842037b8:	9a 99 03 21 
   if NEG jump too_small;
842037bc:	05 00 40 dd 	if NEG jump $M.celt.normalise_residual.too_small;
      rMAC = 0.125;
842037c0:	00 10 00 fd 	rMAC = Null + 268435456;
842037c4:	00 00 10 01 
      Div = rMAC / r1;
842037c8:	00 00 13 d9 	Div = rMAC / r1;
      r0 = DivResult;
842037cc:	01 00 20 d9 	r0 = DivResult;

842037d0 <$M.celt.normalise_residual.too_small>:
   too_small:
   r8 = r8 + 2;
842037d0:	af 00 aa e4 	r8 = r8 + 2;
   r8 = r8 ASHIFT -1;
842037d4:	ff 00 aa 91 	r8 = r8 ASHIFT -1;
   // r8 = shift
   // r0 = gain
   r3 = M[FP + TEMP];
842037d8:	08 00 58 f1 	r3 = M[FP + 0x8];
   r10 = r3 -1;
842037dc:	3f 00 c5 e4 	r10 = r3 - 1;
   I3 = I7;
842037e0:	0f 00 37 58 	I3 = I7 + Null;
   r1 = M[I3, MK1];
842037e4:	00 3d 00 03 	Null = Null + Null, r1 = M[I3,4];
   rMAC = r1 * r0;
842037e8:	2f 00 13 cc 	rMAC = r1 * r0 (SS);
   do normalise_residual_loop;
842037ec:	03 00 f0 e5 	do $M.celt.normalise_residual.normalise_residual_loop;
      rMAC = rMAC ASHIFT r8 (56bit),  r1 = M[I3, M0];     
842037f0:	00 3c 1a 92 	rMAC = rMAC ASHIFT r8 (56bit), r1 = M[I3,M0];
      rMAC = r1 * r0, M[I5, MK1] = rMAC;
842037f4:	95 00 32 cf 	rMAC = r1 * r0 (SS), M[I5,4] = rMAC;

842037f8 <$M.celt.normalise_residual.normalise_residual_loop>:
   normalise_residual_loop:
   rMAC = rMAC ASHIFT r8 (56bit);
842037f8:	00 00 1a 93 	rMAC = rMAC ASHIFT r8 (56bit);
   M[I5, MK1] = rMAC;     
842037fc:	95 00 00 03 	Null = Null + Null, M[I5,4] = rMAC;
   SP = SP - STACK_FRAME_SIZE;
84203800:	fc ff 03 f1 	SP = SP + -4;
   popm <FP,rLink>;
84203804:	01 20 04 f1 	popm <FP, rLink>;
   rts;
84203808:	0f 00 0d dc 	rts;

8420380c <$celt.exp_rotation>:
#endif
   
   //TODO: can devision, sin and cos calling be opimised?
   .CONST TEMP                 (0 + 2)*ADDR_PER_WORD;
   .CONST STACK_FRAME_SIZE     3*ADDR_PER_WORD;
   pushm <FP(=SP), rLink>;
8420380c:	01 20 00 f1 	pushm <FP(=SP), rLink>;
   SP = SP + STACK_FRAME_SIZE;
84203810:	0c 00 03 f1 	SP = SP + 12;

   M[FP + TEMP + 0] = r3;
84203814:	08 00 5c f1 	M[FP + 0x8] = r3;

   r0 = r6 LSHIFT 3;
84203818:	03 00 28 8d 	r0 = r6 LSHIFT 3;
   Null = r3 - r0;
8420381c:	2f 00 05 20 	Null = r3 - r0;
   if LE jump no_strike_update;
84203820:	06 00 d0 dd 	if LE jump $M.celt.exp_rotation.no_strike_update;
      rMAC = 0;
84203824:	00 00 10 01 	rMAC = Null + 0;
      rMAC0 = r3;
84203828:	00 05 e5 8d 	rMAC0 = r3 LSHIFT 0;
      Div = rMAC / r0;
8420382c:	00 00 12 d9 	Div = rMAC / r0;
      r0 = DivResult;
84203830:	01 00 20 d9 	r0 = DivResult;
      r6 = r6 * r0 (int);
84203834:	00 00 82 9b 	r6 = r6 * r0 (int);

84203838 <$M.celt.exp_rotation.no_strike_update>:
   no_strike_update:
   // calc gain
   rMAC = r3;           
84203838:	0f 00 15 00 	rMAC = r3 + Null;
   r0 = r4 * 6 (int);   
8420383c:	06 00 26 99 	r0 = r4 * 6 (int);
   r0 = r0 + r3;       
84203840:	00 00 25 03 	r0 = r0 + r3;
   r0 = r0 + 3;         
84203844:	03 00 22 01 	r0 = r0 + 3;
   r0 = r0 + r0;        
84203848:	00 00 22 03 	r0 = r0 + r0;
   Div = rMAC/r0;       
8420384c:	00 00 12 d9 	Div = rMAC / r0;
   r0 = DivResult;      
84203850:	01 00 20 d9 	r0 = DivResult;
   r0 = r0 * r0 (frac); 
84203854:	00 00 22 97 	r0 = r0 * r0 (frac);
   r0 = r0 * 0.25(frac); 
84203858:	00 20 22 95 	r0 = r0 * 0.25 (frac);
   r0 = 0.5 - r0;       
8420385c:	00 40 00 fd 	r0 = 1073741824 - r0;
84203860:	00 00 22 65 
   push I0;
84203864:	00 00 01 f3 	push I0;
   push L0;
84203868:	00 00 c1 f3 	push L0;
   L0 = 0;
8420386c:	00 00 c0 51 	L0 = Null + 0;
#ifdef BASE_REGISTER_MODE
   push B0;
84203870:	00 00 a2 f3 	push B0;
   push Null;
84203874:	00 00 00 f3 	push Null;
   pop B0;
84203878:	00 00 a6 f3 	pop B0;
#endif
   call $math.sin;
8420387c:	07 00 00 fd 	call 0x74280;
84203880:	80 42 f0 e1 
   r8 = r1;            
84203884:	0f 00 a3 00 	r8 = r1 + Null;
   r0 = 0.5 - r0;
84203888:	00 40 00 fd 	r0 = 1073741824 - r0;
8420388c:	00 00 22 65 
   call $math.sin;
84203890:	07 00 00 fd 	call 0x74280;
84203894:	80 42 f0 e1 
   //r8 = sin
   //r1 = cos
#ifdef BASE_REGISTER_MODE
   pop B0;
84203898:	00 00 a6 f3 	pop B0;
#endif
   pop L0;
8420389c:	00 00 c5 f3 	pop L0;
   pop I0;
842038a0:	00 00 05 f3 	pop I0;
   Null = r7;
842038a4:	0f 00 09 00 	Null = r7 + Null;
   if NEG r8 = -r8;
842038a8:	a4 00 a0 20 	if NEG r8 = Null - r8;
 
   // 1st rotation loop
   r10 = M[FP + TEMP + 0];
842038ac:	08 00 c8 f1 	r10 = M[FP + 0x8];
   r10 = r10 - r6;
842038b0:	00 00 c8 23 	r10 = r10 - r6;
   if LE jump end_rot_loop1;
842038b4:	0c 00 d0 dd 	if LE jump $M.celt.exp_rotation.end_rot_loop1;
   I3 = I5;
842038b8:	0f 00 35 58 	I3 = I5 + Null;
   Words2Addr(r6);
842038bc:	02 00 88 91 	r6 = r6 ASHIFT 2;
   I6 = I3 + r6;
842038c0:	8f 00 63 58 	I6 = I3 + r6;
   do exp_rot_lp1;
842038c4:	07 00 f0 e5 	do $M.celt.exp_rotation.exp_rot_lp1;
      r2 = M[I6, 0]; 
842038c8:	48 00 00 03 	Null = Null + Null, r2 = M[I6,0];
      rMAC = r2*r1, r0 = M[I3, 0];
842038cc:	00 2c 43 cf 	rMAC = r2 * r1 (SS), r0 = M[I3,0];
      rMAC = rMAC + r0*r8;
842038d0:	af 00 12 ac 	rMAC = rMAC + r0 * r8 (SS);
      rMAC = r0*r1, M[I6, MK1] = rMAC; 
842038d4:	99 00 23 cf 	rMAC = r0 * r1 (SS), M[I6,4] = rMAC;
      rMAC = rMAC - r8*r2;
842038d8:	4f 00 1a bc 	rMAC = rMAC - r8 * r2 (SS);
      M[I3, MK1] = rMAC;//, r2 = M[I6, 0];
842038dc:	00 9d 00 03 	Null = Null + Null, M[I3,4] = rMAC;

842038e0 <$M.celt.exp_rotation.exp_rot_lp1>:
   exp_rot_lp1:
   Addr2Words(r6);
842038e0:	fe 00 88 91 	r6 = r6 ASHIFT -2;

842038e4 <$M.celt.exp_rotation.end_rot_loop1>:
   end_rot_loop1:
   
   // 2nd rotation loop
   r0 = M[FP + TEMP + 0];
842038e4:	08 00 28 f1 	r0 = M[FP + 0x8];
   r2 = r6 + r6;
842038e8:	8f 00 48 00 	r2 = r6 + r6;
   r10 = r0 - r2;
842038ec:	4f 00 c2 20 	r10 = r0 - r2;
   if LE jump end_rot_loop2;
842038f0:	0d 00 d0 dd 	if LE jump $M.celt.exp_rotation.end_rot_loop2;
   r3 = r10 - 1;
842038f4:	3f 00 5c e4 	r3 = r10 - 1;
   Words2Addr(r3);
842038f8:	02 00 55 91 	r3 = r3 ASHIFT 2;
   I3 = I5 + r3;
842038fc:	5f 00 35 58 	I3 = I5 + r3;
   Words2Addr(r6);
84203900:	02 00 88 91 	r6 = r6 ASHIFT 2;
   I6 = I3 + r6;
84203904:	8f 00 63 58 	I6 = I3 + r6;
   do exp_rot_lp2;
84203908:	07 00 f0 e5 	do $M.celt.exp_rotation.end_rot_loop2;
      r2 = M[I6, 0];
8420390c:	48 00 00 03 	Null = Null + Null, r2 = M[I6,0];
      rMAC = r2*r1, r0 = M[I3, 0];
84203910:	00 2c 43 cf 	rMAC = r2 * r1 (SS), r0 = M[I3,0];
      rMAC = rMAC + r0*r8;
84203914:	af 00 12 ac 	rMAC = rMAC + r0 * r8 (SS);
      rMAC = r0*r1, M[I6, -MK1] = rMAC;
84203918:	9b 00 23 cf 	rMAC = r0 * r1 (SS), M[I6,-4] = rMAC;
      rMAC = rMAC - r8*r2;
8420391c:	4f 00 1a bc 	rMAC = rMAC - r8 * r2 (SS);
      M[I3, -MK1] = rMAC;//, r2 = M[I6, 0];
84203920:	00 9f 00 03 	Null = Null + Null, M[I3,-4] = rMAC;

84203924 <$M.celt.exp_rotation.end_rot_loop2>:
   exp_rot_lp2:
   end_rot_loop2:
   SP = SP - STACK_FRAME_SIZE;
84203924:	f4 ff 03 f1 	SP = SP + -12;
   popm <FP,rLink>;
84203928:	01 20 04 f1 	popm <FP, rLink>;
   rts;
8420392c:	0f 00 0d dc 	rts;

84203930 <$_celt_setup_thread_offload>:
84203930:	00 00 d0 f3 	push rLink;
$_celt_setup_thread_offload:
$celt_dec.setup_thread_offload:

   push rLink;
 
   r0 = &$fft.twiddle_real_address;
84203934:	7c 02 20 01 	r0 = Null + 636;
   call $_thread_offload_update_p1_dm_location;
84203938:	20 04 00 fd 	call (m) $_thread_offload_update_p1_dm_location;
8420393c:	49 49 f0 e1 

   r0 = &$fft.twiddle_imag_address;
84203940:	80 02 20 01 	r0 = Null + 640;
   call $_thread_offload_update_p1_dm_location;
84203944:	20 04 00 fd 	call (m) $_thread_offload_update_p1_dm_location;
84203948:	49 49 f0 e1 

   r0 = &$math.fft_twiddle.twiddle_size;
8420394c:	84 02 20 01 	r0 = Null + 644;
   call $_thread_offload_update_p1_dm_location;
84203950:	20 04 00 fd 	call (m) $_thread_offload_update_p1_dm_location;
84203954:	49 49 f0 e1 

   r0 = &$math.fft_twiddle.twiddle_user;
84203958:	88 02 20 01 	r0 = Null + 648;
   call $_thread_offload_update_p1_dm_location;
8420395c:	20 04 00 fd 	call (m) $_thread_offload_update_p1_dm_location;
84203960:	49 49 f0 e1 

   pop rLink;
84203964:	00 00 d4 f3 	pop rLink;
   rts;
84203968:	0f 00 0d dc 	rts;

8420396c <$celt.compute_allocation>:
8420396c:	00 00 d0 f3 	push rLink;
#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.COMPUTE_ALLOCATION.PATCH_ID_0,r4)     // celt_patchers
#endif

   // see how many bits used so far
   r4 = 0;
84203970:	00 00 60 01 	r4 = Null + 0;
   r0 = M[r5 + $celt.dec.TELL_FUNC_FIELD];
84203974:	30 00 27 d1 	r0 = M[r5 + 48];
   call r0;
84203978:	0f 00 02 e0 	call r0;

   // calc bits available
   r3 = M[r5 + $celt.dec.CELT_CODEC_FRAME_SIZE_FIELD];
8420397c:	04 00 57 d1 	r3 = M[r5 + 4];
   r3 = r3 * 8 (int);
84203980:	08 00 55 99 	r3 = r3 * 8 (int);
   r3 = r3 - r0;
84203984:	00 00 52 23 	r3 = r3 - r0;
   r3 = r3 - 1;
84203988:	3f 00 55 e4 	r3 = r3 - 1;
   r3 = r3 LSHIFT $celt.BITRES;
8420398c:	04 00 55 8d 	r3 = r3 LSHIFT 4;
   // init:  r6 = lo, r7 = hi
   r6 = 0;
84203990:	00 00 80 01 	r6 = Null + 0;
   r7 = M[r5 + $celt.dec.MODE_NB_ALLOC_VECTORS_FIELD];
84203994:	54 00 97 d1 	r7 = M[r5 + 84];
   r7 = r7 - 1;   
84203998:	3f 00 99 e4 	r7 = r7 - 1;

8420399c <$M.celt.compute_allocation.find_lo_hi_loop>:
   find_lo_hi_loop:
   r0 = r7 - r6;
8420399c:	8f 00 29 20 	r0 = r7 - r6;
   Null = r0 - 1;
842039a0:	3f 00 02 e4 	Null = r0 - 1;
   if Z jump end_bits_loop;
842039a4:	16 00 00 dd 	if EQ jump $M.celt.compute_allocation.end_bits_loop;
      r4 = r6 + r7;
842039a8:	9f 00 68 00 	r4 = r6 + r7;
      r4 = r4 LSHIFT -1;
842039ac:	ff 00 66 8d 	r4 = r4 LSHIFT -1;
      r10 = M[r5 + $celt.dec.MODE_NB_EBANDS_FIELD];
842039b0:	48 00 c7 d1 	r10 = M[r5 + 72];
      r0 = r10*r4(int);
842039b4:	6f 00 2c 98 	r0 = r10 * r4 (int);
      Words2Addr(r0);
842039b8:	02 00 22 91 	r0 = r0 ASHIFT 2;
      r10 = r10 - 1;
842039bc:	3f 00 cc e4 	r10 = r10 - 1;
      r1 = M[r5 + $celt.dec.MODE_ALLOC_VECTORS_ADDR_FIELD];
842039c0:	64 00 37 d1 	r1 = M[r5 + 100];
      I6 = r1 + r0;
842039c4:	2f 00 63 50 	I6 = r1 + r0;
      r1 = r1 - r1, r0 = M[I6, MK1];      
842039c8:	29 00 33 23 	r1 = r1 - r1, r0 = M[I6,4];
      do bits1_loop;
842039cc:	02 00 f0 e5 	do $M.celt.compute_allocation.bits1_loop;
         r1 = r1 + r0, r0 = M[I6, MK1];
842039d0:	29 00 32 03 	r1 = r1 + r0, r0 = M[I6,4];

842039d4 <$M.celt.compute_allocation.bits1_loop>:
      bits1_loop:
      r1 = r1 + r0;
842039d4:	00 00 32 03 	r1 = r1 + r0;
      r2 = (1<<$celt.BITRES);
842039d8:	10 00 40 01 	r2 = Null + 16;
      r0 = M[r5 + $celt.dec.CELT_CHANNELS_FIELD];
842039dc:	08 00 27 d1 	r0 = M[r5 + 8];
      if NZ r2 = r2 + r2;
842039e0:	41 00 44 00 	if NE r2 = r2 + r2;
      r1 = r1 * r2 (int);
842039e4:	00 00 34 9b 	r1 = r1 * r2 (int);
      Null = r1 - r3;
842039e8:	5f 00 03 20 	Null = r1 - r3;
      if GT r7 = r4;
842039ec:	0c 00 96 00 	if GT r7 = r4 + Null;
      Null = r1 - r3;
842039f0:	5f 00 03 20 	Null = r1 - r3;
      if LE r6 = r4;
842039f4:	0d 00 86 00 	if LE r6 = r4 + Null;
   jump find_lo_hi_loop;
842039f8:	e9 ff f0 dd 	jump $M.celt.compute_allocation.find_lo_hi_loop;

842039fc <$M.celt.compute_allocation.end_bits_loop>:
   end_bits_loop:
   r10 = M[r5 + $celt.dec.MODE_NB_EBANDS_FIELD];
842039fc:	48 00 c7 d1 	r10 = M[r5 + 72];
   r0 = r6*r10(int);
84203a00:	cf 00 28 98 	r0 = r6 * r10 (int);
   Words2Addr(r0);
84203a04:	02 00 22 91 	r0 = r0 ASHIFT 2;
   r1 = M[r5 + $celt.dec.MODE_ALLOC_VECTORS_ADDR_FIELD];
84203a08:	64 00 37 d1 	r1 = M[r5 + 100];
   I5 = r0 + r1;
84203a0c:	3f 00 52 50 	I5 = r0 + r1;
   r0 = r7*r10(int);
84203a10:	cf 00 29 98 	r0 = r7 * r10 (int);
   Words2Addr(r0);
84203a14:	02 00 22 91 	r0 = r0 ASHIFT 2;
   I6 = r0 + r1;
84203a18:	3f 00 62 50 	I6 = r0 + r1;
   r0 = M[r5 + $celt.dec.BITS1_FIELD];
84203a1c:	bc 00 27 d1 	r0 = M[r5 + 188];
   I2 = r0;
84203a20:	2f 00 20 50 	I2 = Null + r0;
   r0 = M[r5 + $celt.dec.BITS2_FIELD];
84203a24:	c0 00 27 d1 	r0 = M[r5 + 192];
   I3 = r0;
84203a28:	2f 00 30 50 	I3 = Null + r0;
   r2 = 1;
84203a2c:	2f 00 40 e4 	r2 = Null + 1;
   r0 = M[r5 + $celt.dec.CELT_CHANNELS_FIELD];
84203a30:	08 00 27 d1 	r0 = M[r5 + 8];
   if NZ r2 = r2 + r2;
84203a34:	41 00 44 00 	if NE r2 = r2 + r2;
   r10 = r10 - 1;
84203a38:	3f 00 cc e4 	r10 = r10 - 1;
   r1 = M[I6, MK1];
84203a3c:	39 00 00 03 	Null = Null + Null, r1 = M[I6,4];
   r1 = r1 * r2(int), r0 = M[I5, MK1];
84203a40:	25 00 34 9b 	r1 = r1 * r2 (int), r0 = M[I5,4];
   do bits_loop;
84203a44:	03 00 f0 e5 	do $M.celt.compute_allocation.bits_loop;
      r0 = r0 * r2(int), r1= M[I6, MK1], M[I3, MK1] = r1;
84203a48:	39 bd 24 9b 	r0 = r0 * r2 (int), M[I3,4] = r1, r1 = M[I6,4];
      r1 = r1 * r2(int), r0= M[I5, MK1], M[I2, MK1] = r0;
84203a4c:	25 a9 34 9b 	r1 = r1 * r2 (int), M[I2,4] = r0, r0 = M[I5,4];

84203a50 <$M.celt.compute_allocation.bits_loop>:
   bits_loop:
   r0 = r0 * r2(int), M[I3, MK1] = r1;
84203a50:	00 bd 24 9b 	r0 = r0 * r2 (int), M[I3,4] = r1;
   M[I2, MK1] = r0;
84203a54:	00 a9 00 03 	Null = Null + Null, M[I2,4] = r0;
   
   call  $celt.interp_bits2pulses;
84203a58:	03 00 f0 e1 	call $celt.interp_bits2pulses;

   // pop rLink from stack
   jump $pop_rLink_and_rts;
84203a5c:	03 00 00 fd 	jump (m) 0x3b020;
84203a60:	21 b0 f0 dd 

84203a64 <$celt.interp_bits2pulses>:
   .CODESEGMENT CELT_INTERP_BITS2PULSES_PM;
   .DATASEGMENT DM;
   
   $celt.interp_bits2pulses:
   // push rLink onto stack
   push rlink;
84203a64:	00 00 d0 f3 	push rLink;

#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.INTERP_BITS2PULSES.PATCH_ID_0,r6)     // celt_patchers
#endif
   
   r6 = 0;
84203a68:	00 00 80 01 	r6 = Null + 0;
   r7 = 1<<$celt.BITRES;
84203a6c:	10 00 90 01 	r7 = Null + 16;
   M0 = ADDR_PER_WORD;
84203a70:	04 00 80 51 	M0 = Null + 4;

84203a74 <$M.celt.interp_bits2pulses.find_hi_lo_loop>:
   find_hi_lo_loop:
   r0 = r7 - r6;
84203a74:	8f 00 29 20 	r0 = r7 - r6;
   Null = r0 - 1;
84203a78:	3f 00 02 e4 	Null = r0 - 1;
   if Z jump find_hi_lo_loop_end;
84203a7c:	17 00 00 dd 	if EQ jump $M.celt.interp_bits2pulses.find_hi_lo_loop_end;
      r4 = r6 + r7;
84203a80:	9f 00 68 00 	r4 = r6 + r7;
      r4 = r4 LSHIFT -1;
84203a84:	ff 00 66 8d 	r4 = r4 LSHIFT -1;
      r10 = M[r5 + $celt.dec.MODE_NB_EBANDS_FIELD];
84203a88:	48 00 c7 d1 	r10 = M[r5 + 72];
      r10 = r10 - 1;
84203a8c:	3f 00 cc e4 	r10 = r10 - 1;
      r2 = 1<<$celt.BITRES;
84203a90:	10 00 40 01 	r2 = Null + 16;
      r2 = r2 - r4;
84203a94:	00 00 46 23 	r2 = r2 - r4;
      r0 = M[r5 + $celt.dec.BITS1_FIELD];
84203a98:	bc 00 27 d1 	r0 = M[r5 + 188];
      I2 = r0;
84203a9c:	2f 00 20 50 	I2 = Null + r0;
      r0 = M[r5 + $celt.dec.BITS2_FIELD];
84203aa0:	c0 00 27 d1 	r0 = M[r5 + 192];
      I3 = r0;
84203aa4:	2f 00 30 50 	I3 = Null + r0;
      rMAC = 0, r0 = M[I2, MK1];
84203aa8:	00 29 11 23 	rMAC = rMAC - rMAC, r0 = M[I2,4];
      rMAC = rMAC + r0*r2, r0 = M[I3, MK1];
84203aac:	00 2d 24 af 	rMAC = rMAC + r0 * r2 (SS), r0 = M[I3,4];
      do avg_loop1;
84203ab0:	03 00 f0 e5 	do $M.celt.interp_bits2pulses.avg_loop1;
         rMAC = rMAC + r0*r4, r0 = M[I2, MK1];
84203ab4:	00 29 26 af 	rMAC = rMAC + r0 * r4 (SS), r0 = M[I2,4];
         rMAC = rMAC + r0*r2, r0 = M[I3, MK1];
84203ab8:	00 2d 24 af 	rMAC = rMAC + r0 * r2 (SS), r0 = M[I3,4];

84203abc <$M.celt.interp_bits2pulses.avg_loop1>:
      avg_loop1:
      rMAC = rMAC + r0*r4;
84203abc:	6f 00 12 ac 	rMAC = rMAC + r0 * r4 (SS);
      r0 = rMAC LSHIFT (DAWTH-1);
84203ac0:	1f 00 21 8d 	r0 = rMAC LSHIFT 31;
      Null = r0 - r3;
84203ac4:	5f 00 02 20 	Null = r0 - r3;
      if GT r7 = r4;
84203ac8:	0c 00 96 00 	if GT r7 = r4 + Null;
      Null = r0 - r3;
84203acc:	5f 00 02 20 	Null = r0 - r3;
      if LE r6 = r4;
84203ad0:	0d 00 86 00 	if LE r6 = r4 + Null;
   jump find_hi_lo_loop;
84203ad4:	e8 ff f0 dd 	jump $M.celt.interp_bits2pulses.find_hi_lo_loop;

84203ad8 <$M.celt.interp_bits2pulses.find_hi_lo_loop_end>:
   
   find_hi_lo_loop_end:
   r0 = M[r5 + $celt.dec.BITS1_FIELD];
84203ad8:	bc 00 27 d1 	r0 = M[r5 + 188];
   I2 = r0;
84203adc:	2f 00 20 50 	I2 = Null + r0;
   r0 = M[r5 + $celt.dec.BITS2_FIELD];
84203ae0:	c0 00 27 d1 	r0 = M[r5 + 192];
   I3 = r0;
84203ae4:	2f 00 30 50 	I3 = Null + r0;
   r0 = M[r5 + $celt.dec.PULSES_FIELD];
84203ae8:	04 01 27 d1 	r0 = M[r5 + 260];
   I4 = r0;
84203aec:	2f 00 40 50 	I4 = Null + r0;
   r10 = M[r5 + $celt.dec.MODE_NB_EBANDS_FIELD];
84203af0:	48 00 c7 d1 	r10 = M[r5 + 72];
   r2 = 1<<$celt.BITRES;
84203af4:	10 00 40 01 	r2 = Null + 16;
   r2 = r2 - r6;
84203af8:	00 00 48 23 	r2 = r2 - r6;
   rMAC = 0, r0 = M[I2, MK1];
84203afc:	00 29 11 23 	rMAC = rMAC - rMAC, r0 = M[I2,4];
   do avg_loop2;
84203b00:	05 00 f0 e5 	do $M.celt.interp_bits2pulses.avg_loop2;
      r0 = r0*r2 (int), r1 = M[I3, MK1];
84203b04:	00 3d 24 9b 	r0 = r0 * r2 (int), r1 = M[I3,4];
      r1 = r1 * r6 (int);
84203b08:	00 00 38 9b 	r1 = r1 * r6 (int);
      r4 = r1 + r0, r0 = M[I2, M0];
84203b0c:	2f 28 63 00 	r4 = r1 + r0, r0 = M[I2,M0];
      rMAC = rMAC + r4, M[I4, MK1] = r4;
84203b10:	e1 00 16 03 	rMAC = rMAC + r4, M[I4,4] = r4;

84203b14 <$M.celt.interp_bits2pulses.avg_loop2>:
   avg_loop2:   
   
   r10 = M[r5 + $celt.dec.MODE_NB_EBANDS_FIELD];
84203b14:	48 00 c7 d1 	r10 = M[r5 + 72];
   rMAC = r3 - rMAC;
84203b18:	1f 00 15 20 	rMAC = r3 - rMAC;
   rMAC0 = rMAC1;
84203b1c:	00 05 e1 8d 	rMAC0 = rMAC LSHIFT 0;
   rMAC12 = Null(ZP);
84203b20:	00 04 e0 8d 	rMAC12 = Null LSHIFT 0;
   Div = rMAC/r10;
84203b24:	00 00 1c d9 	Div = rMAC / r10;
   r0 = M[r5 + $celt.dec.PULSES_FIELD];
84203b28:	04 01 27 d1 	r0 = M[r5 + 260];
   I2 = r0;
84203b2c:	2f 00 20 50 	I2 = Null + r0;
   I3 = I2;
84203b30:	0f 00 32 58 	I3 = I2 + Null;
   r0 = M[I2, M0];   
84203b34:	00 28 00 02 	Null = Null + Null, r0 = M[I2,M0];
   r2 = DivResult;
84203b38:	01 00 40 d9 	r2 = DivResult;
   do add_per_band_loop;
84203b3c:	03 00 f0 e5 	do $M.celt.interp_bits2pulses.add_per_band_loop;
      r1 = r0 +  r2, r0 = M[I2, M0];
84203b40:	4f 28 32 00 	r1 = r0 + r2, r0 = M[I2,M0];
      M[I3, M0] = r1;
84203b44:	00 bc 00 02 	Null = Null + Null, M[I3,M0] = r1;

84203b48 <$M.celt.interp_bits2pulses.add_per_band_loop>:
   add_per_band_loop:
   
   r10 = DivRemainder;
84203b48:	02 00 c0 d9 	r10 = DivRemainder;
   r2 = 1;
84203b4c:	2f 00 40 e4 	r2 = Null + 1;
   r0 = M[r5 + $celt.dec.PULSES_FIELD];
84203b50:	04 01 27 d1 	r0 = M[r5 + 260];
   I2 = r0;
84203b54:	2f 00 20 50 	I2 = Null + r0;
   I3 = I2, r0 = M[I2, M0];   
84203b58:	0f 28 32 58 	I3 = I2 + Null, r0 = M[I2,M0];
   do add_reamin_loop;
84203b5c:	03 00 f0 e5 	do $M.celt.interp_bits2pulses.add_reamin_loop;
      r1 = r0 +  r2, r0 = M[I2, M0];
84203b60:	4f 28 32 00 	r1 = r0 + r2, r0 = M[I2,M0];
      M[I3, M0] = r1;
84203b64:	00 bc 00 02 	Null = Null + Null, M[I3,M0] = r1;

84203b68 <$M.celt.interp_bits2pulses.add_reamin_loop>:
   add_reamin_loop:  
   
   r3 = M[r5 + $celt.dec.MODE_NB_EBANDS_FIELD];
84203b68:	48 00 57 d1 	r3 = M[r5 + 72];
   Words2Addr(r3);
84203b6c:	02 00 55 91 	r3 = r3 ASHIFT 2;
   M3 = r3;
84203b70:	5f 00 b0 50 	M3 = Null + r3;
   M1 = 0;
84203b74:	00 00 90 51 	M1 = Null + 0;
   r0 = M[r5 + $celt.dec.MODE_EBANDS_ADDR_FIELD];
84203b78:	60 00 27 d1 	r0 = M[r5 + 96];
   I3 = r0;
84203b7c:	2f 00 30 50 	I3 = Null + r0;
   r0 = M[r5 + $celt.dec.PULSES_FIELD];
84203b80:	04 01 27 d1 	r0 = M[r5 + 260];
   I2 = r0;        
84203b84:	2f 00 20 50 	I2 = Null + r0;
   r0 = M[r5 + $celt.dec.FINE_QUANT_FIELD];
84203b88:	08 01 27 d1 	r0 = M[r5 + 264];
   I6 = r0;     
84203b8c:	2f 00 60 50 	I6 = Null + r0;
   r0 = M[r5 + $celt.dec.FINE_PRIORITY_FIELD];
84203b90:	0c 01 27 d1 	r0 = M[r5 + 268];
   I7 = r0;  //fine-pr
84203b94:	2f 00 70 50 	I7 = Null + r0;
   r0 = M[I3, MK1];   //ebands[j];
84203b98:	00 2d 00 03 	Null = Null + Null, r0 = M[I3,4];
   r1 = M[I3, 0];   
84203b9c:	00 3c 00 03 	Null = Null + Null, r1 = M[I3,0];

84203ba0 <$M.celt.interp_bits2pulses.loop_calc_bits>:
   //N=r1
   loop_calc_bits:
      r1 = r1 - r0; 
84203ba0:	00 00 32 23 	r1 = r1 - r0;
      push r1;         //save r1
84203ba4:	00 00 30 f3 	push r1;
      rMAC = 0;        //rMAC=N
84203ba8:	00 00 10 01 	rMAC = Null + 0;
      rMAC0 = r1;
84203bac:	00 05 e3 8d 	rMAC0 = r1 LSHIFT 0;
      r0 = $celt.BITRES; 
84203bb0:	bf 00 20 e4 	r0 = Null + 4;
      call $celt.log2_frac;       
84203bb4:	21 01 f0 e1 	call $celt.log2_frac;
      r3 = $celt.FINE_OFFSET - r0; 
84203bb8:	32 00 52 65 	r3 = 50 - r0;
      //offset = r3
      pop r1;
84203bbc:	00 00 34 f3 	pop r1;
      r0 = M[r5 + $celt.dec.CELT_CHANNELS_FIELD]; 
84203bc0:	08 00 27 d1 	r0 = M[r5 + 8];
      r4 = r0*r1(int);                            
84203bc4:	3f 00 62 98 	r4 = r0 * r1 (int);
      r4 = r4 + r1;                               
84203bc8:	00 00 63 03 	r4 = r4 + r1;
      r2 = r4 + r0;                               
84203bcc:	2f 00 46 00 	r2 = r4 + r0;
      r2 = r2 LSHIFT $celt.BITRES;                
84203bd0:	04 00 44 8d 	r2 = r2 LSHIFT 4;
      r4 = r4 *r3(int), r1 = M[I2, 0];            
84203bd4:	00 38 65 9b 	r4 = r4 * r3 (int), r1 = M[I2,0];
      r4 = r1 - r4;                               
84203bd8:	6f 00 63 20 	r4 = r1 - r4;
      r1 = r0 LSHIFT $celt.BITRES;                
84203bdc:	04 00 32 8d 	r1 = r0 LSHIFT 4;
      r4 = r4 - r1;                               
84203be0:	00 00 63 23 	r4 = r4 - r1;
      if NEG r4 = 0; 
84203be4:	04 00 60 00 	if NEG r4 = Null + Null;
      //r4 = offset
      r1 = r2 + r2;                               
84203be8:	4f 00 34 00 	r1 = r2 + r2;
      r6 = r4 + r4;                               
84203bec:	6f 00 86 00 	r6 = r4 + r4;
      r6 = r6 + r2;                               
84203bf0:	00 00 84 03 	r6 = r6 + r2;
      rMAC = 0;
84203bf4:	00 00 10 01 	rMAC = Null + 0;
      rMAC0 = r6;
84203bf8:	00 05 e8 8d 	rMAC0 = r6 LSHIFT 0;
      Div = rMAC / r1; 
84203bfc:	00 00 13 d9 	Div = rMAC / r1;
      r6 = DivResult;                             
84203c00:	01 00 80 d9 	r6 = DivResult;
      r3 = r6 * r2 (int);                         
84203c04:	4f 00 58 98 	r3 = r6 * r2 (int);
      r1 = 1;
84203c08:	2f 00 30 e4 	r1 = Null + 1;
      Null = r3 - r4;
84203c0c:	6f 00 05 20 	Null = r3 - r4;
      if NEG r1 = r1 - r1, r3 = M[I2, M1];
84203c10:	34 59 33 20 	if NEG r1 = r1 - r1, r3 = M[I2,M1];
      //r1 = fine-p
      r2 = r6 LSHIFT r0; //r7=eb(j)*C
84203c14:	2f 00 48 8c 	r2 = r6 LSHIFT r0;
      r4 = r3 LSHIFT (-$celt.BITRES);
84203c18:	fc 00 65 8d 	r4 = r3 LSHIFT -4;
      Null = r2 - r4;                     
84203c1c:	6f 00 04 20 	Null = r2 - r4;
      if GT r2 = r4;
84203c20:	0c 00 46 00 	if GT r2 = r4 + Null;
      r6 = -r0;
84203c24:	2f 00 80 20 	r6 = Null - r0;
      r2 = r2 LSHIFT r6, M[I7, MK1] = r1; 
84203c28:	bd 00 48 8f 	r2 = r2 LSHIFT r6, M[I7,4] = r1;
      r7 = r2 - 7;
84203c2c:	07 00 94 21 	r7 = r2 - 7;
      if POS r2 = r2 - r7;
84203c30:	95 00 44 20 	if POS r2 = r2 - r7;
      r0 = r0 + $celt.BITRES;
84203c34:	bf 00 22 e4 	r0 = r0 + 4;
      r2 = r2 LSHIFT r0, M[I6, MK1] = r2;
84203c38:	c9 00 42 8f 	r2 = r2 LSHIFT r0, M[I6,4] = r2;
      r3 = r3 - r2, r0 = M[I3, MK1];
84203c3c:	00 2d 54 23 	r3 = r3 - r2, r0 = M[I3,4];
      if NEG r3 = r3 - r3, r1 = M[I3, M1];
84203c40:	54 3d 55 20 	if NEG r3 = r3 - r3, r1 = M[I3,M1];
      M3 = M3 - M0, M[I2, MK1] = r3;
84203c44:	00 d9 b8 7f 	M3 = M3 - M0, M[I2,4] = r3;
   if NZ jump   loop_calc_bits;    
84203c48:	d6 ff 10 dd 	if NE jump $M.celt.interp_bits2pulses.loop_calc_bits;
   // pop rLink from stack
   jump $pop_rLink_and_rts;
84203c4c:	03 00 00 fd 	jump (m) 0x3b020;
84203c50:	21 b0 f0 dd 

84203c54 <$celt.decode_flags>:
84203c54:	01 20 00 f1 	pushm <FP(=SP), rLink>;

   // push rLink onto stack
   .CONST FLAG_BITS            (0 + 2)*ADDR_PER_WORD;
   .CONST STACK_FRAME_SIZE     1*ADDR_PER_WORD;
   pushm <FP(=SP), rLink>;
   SP = SP + STACK_FRAME_SIZE;
84203c58:	04 00 03 f1 	SP = SP + 4;
#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.DECODE_FLAGS.PATCH_ID_0,r1)     // celt_patchers
#endif   
   
   // read flags
   r0 = 4;
84203c5c:	bf 00 20 e4 	r0 = Null + 4;
   r1 = 0;
84203c60:	00 00 30 01 	r1 = Null + 0;
   call $celt.ec_dec_uint;
84203c64:	64 f5 f0 e1 	call $celt.ec_dec_uint;
   M[FP + FLAG_BITS] = r0;   
84203c68:	08 00 2c f1 	M[FP + 0x8] = r0;
   Null = r0 - 2;
84203c6c:	cf 00 02 e4 	Null = r0 - 2;
   if NZ jump test_for_fb3;
84203c70:	07 00 10 dd 	if NE jump $M.celt.decode_flags.test_for_fb3;
      // flag bits = 2
      r0 = 4;
84203c74:	bf 00 20 e4 	r0 = Null + 4;
      r1 = 0;
84203c78:	00 00 30 01 	r1 = Null + 0;
      call $celt.ec_dec_uint;
84203c7c:	5e f5 f0 e1 	call $celt.ec_dec_uint;
      r4 = M[FP + FLAG_BITS];
84203c80:	08 00 68 f1 	r4 = M[FP + 0x8];
      r4 = r4 LSHIFT 2;
84203c84:	02 00 66 8d 	r4 = r4 LSHIFT 2;
      r0 = r0 OR r4;
84203c88:	00 00 26 87 	r0 = r0 OR r4;

84203c8c <$M.celt.decode_flags.test_for_fb3>:
   test_for_fb3:
   Null = r0 - 3;
84203c8c:	03 00 02 21 	Null = r0 - 3;
   if NZ jump flag_list_ver;
84203c90:	06 00 10 dd 	if NE jump $M.celt.decode_flags.flag_list_ver;
      // flag bits = 3
      r0 = 2;
84203c94:	af 00 20 e4 	r0 = Null + 2;
      call $celt.ec_dec_uint;
84203c98:	57 f5 f0 e1 	call $celt.ec_dec_uint;
      r4 = M[FP + FLAG_BITS];
84203c9c:	08 00 68 f1 	r4 = M[FP + 0x8];
      r4 = r4 LSHIFT 1;
84203ca0:	01 00 66 8d 	r4 = r4 LSHIFT 1;
      r0 = r0 OR r4;
84203ca4:	00 00 26 87 	r0 = r0 OR r4;

84203ca8 <$M.celt.decode_flags.flag_list_ver>:
   flag_list_ver:    
   // verify it is a valid flag
   r10 = 8;
84203ca8:	08 00 c0 01 	r10 = Null + 8;
#ifdef CELT_USE_EXTERNAL_MEMORY
   r1 = M[r5 + $celt.dec.PTR_FLAGLIST_TABLE_FIELD];
84203cac:	10 02 37 d1 	r1 = M[r5 + 528];
   I2 = r1;
84203cb0:	3f 00 20 50 	I2 = Null + r1;
#else // CELT_USE_EXTERNAL_MEMORY
   I2 = &$celt.flaglist;
#endif // CELT_USE_EXTERNAL_MEMORY
   r1 = M[I2, MK1];
84203cb4:	00 39 00 03 	Null = Null + Null, r1 = M[I2,4];
   r2 = r1 AND 0xF;
84203cb8:	0f 00 43 81 	r2 = r1 AND 0xf;
   do ver_on_list_loop;
84203cbc:	04 00 f0 e5 	do $M.celt.decode_flags.ver_on_list_loop;
      r2 = r2 - r0, r1 = M[I2, MK1];
84203cc0:	00 39 42 23 	r2 = r2 - r0, r1 = M[I2,4];
      if Z jump break_ver_lp;
84203cc4:	05 00 00 dd 	if EQ jump $M.celt.decode_flags.break_ver_lp;
      r2 = r1 AND 0xF;
84203cc8:	0f 00 43 81 	r2 = r1 AND 0xf;

84203ccc <$M.celt.decode_flags.ver_on_list_loop>:
   ver_on_list_loop:
      // flag not found in the list
      // return error
      r0 = 1;
84203ccc:	2f 00 20 e4 	r0 = Null + 1;
      jump $pop_rLink_and_rts;
84203cd0:	03 00 00 fd 	jump (m) 0x3b020;
84203cd4:	21 b0 f0 dd 

84203cd8 <$M.celt.decode_flags.break_ver_lp>:
   break_ver_lp:
   
   // flags found in the list, set available features
   I2 = I2 - 2*ADDR_PER_WORD;
84203cd8:	08 00 22 79 	I2 = I2 - 8;
   r1 = M[I2, 0];
84203cdc:	00 38 00 03 	Null = Null + Null, r1 = M[I2,0];
   r0 = r1 AND $celt.FLAG_INTRA;
84203ce0:	00 20 23 81 	r0 = r1 AND 0x2000;
   M[r5 + $celt.dec.INTRA_ENER_FIELD] = r0;
84203ce4:	54 01 27 d5 	M[r5 + 340] = r0;
   r0 = r1 AND $celt.FLAG_PITCH;
84203ce8:	00 10 23 81 	r0 = r1 AND 0x1000;
   M[r5 + $celt.dec.HAS_PITCH_FIELD] = r0;
84203cec:	5c 01 27 d5 	M[r5 + 348] = r0;
   r0 = r1 AND $celt.FLAG_SHORT;
84203cf0:	00 08 23 81 	r0 = r1 AND 0x800;
   M[r5 + $celt.dec.SHORT_BLOCKS_FIELD] = r0;
84203cf4:	58 01 27 d5 	M[r5 + 344] = r0;
   r0 = r1 AND $celt.FLAG_FOLD;
84203cf8:	00 04 23 81 	r0 = r1 AND 0x400;
   M[r5 + $celt.dec.HAS_FOLD_FIELD] = r0;
84203cfc:	60 01 27 d5 	M[r5 + 352] = r0;
   
   // Extract more info for short blocks
   r0 = -1; //no transient time
84203d00:	3f 00 20 e4 	r0 = Null - 1;
   M[r5 + $celt.dec.TRANSIENT_SHIFT_FIELD] = 0;
84203d04:	68 01 07 d5 	M[r5 + 360] = Null;
   M[r5 + $celt.dec.MDCT_WEIGHT_SHIFT_FIELD] = 0;
84203d08:	6c 01 07 d5 	M[r5 + 364] = Null;
   M[r5 + $celt.dec.MDCT_WEIGHT_POS_FIELD] = 0;
84203d0c:	70 01 07 d5 	M[r5 + 368] = Null;
   Null = M[r5 + $celt.dec.SHORT_BLOCKS_FIELD];
84203d10:	58 01 07 d1 	Null = M[r5 + 344];
   if Z jump set_transient_time;
84203d14:	18 00 00 dd 	if EQ jump $M.celt.decode_flags.set_transient_time;
      r0 = 4;
84203d18:	bf 00 20 e4 	r0 = Null + 4;
      r1 = 0;
84203d1c:	00 00 30 01 	r1 = Null + 0;
      call $celt.ec_dec_uint;
84203d20:	35 f5 f0 e1 	call $celt.ec_dec_uint;
      Null = r0 - 3;
84203d24:	03 00 02 21 	Null = r0 - 3;
      if NZ jump check_mdct_weight;
84203d28:	08 00 10 dd 	if NE jump $M.celt.decode_flags.check_mdct_weight;
         M[r5 + $celt.dec.TRANSIENT_SHIFT_FIELD] = r0;
84203d2c:	68 01 27 d5 	M[r5 + 360] = r0;
         r1 = 0;
84203d30:	00 00 30 01 	r1 = Null + 0;
         r0 = M[r5 + $celt.dec.MODE_OVERLAP_FIELD];
84203d34:	40 00 27 d1 	r0 = M[r5 + 64];
         r2 = M[r5 + $celt.dec.MODE_MDCT_SIZE_FIELD];
84203d38:	44 00 47 d1 	r2 = M[r5 + 68];
         r0 = r0 + r2;
84203d3c:	00 00 24 03 	r0 = r0 + r2;
         call $celt.ec_dec_uint;
84203d40:	2d f5 f0 e1 	call $celt.ec_dec_uint;
         jump set_transient_time;
84203d44:	0c 00 f0 dd 	jump $M.celt.decode_flags.set_transient_time;

84203d48 <$M.celt.decode_flags.check_mdct_weight>:
         check_mdct_weight:
            M[r5 + $celt.dec.TRANSIENT_SHIFT_FIELD] = 0;
84203d48:	68 01 07 d5 	M[r5 + 360] = Null;
            M[r5 + $celt.dec.MDCT_WEIGHT_SHIFT_FIELD] = r0;
84203d4c:	6c 01 27 d5 	M[r5 + 364] = r0;
            if Z jump pos_calc_end;
84203d50:	08 00 00 dd 	if EQ jump $M.celt.decode_flags.pos_calc_end;
            r0 = M[r5 + $celt.dec.MODE_NB_SHORT_MDCTS_FIELD];
84203d54:	58 00 27 d1 	r0 = M[r5 + 88];
            Null = r0 - 3;
84203d58:	03 00 02 21 	Null = r0 - 3;
            if NEG jump pos_calc_end;
84203d5c:	05 00 40 dd 	if NEG jump $M.celt.decode_flags.pos_calc_end;
            r0 = r0 - 1;
84203d60:	3f 00 22 e4 	r0 = r0 - 1;
            r1 = 0;
84203d64:	00 00 30 01 	r1 = Null + 0;
            call $celt.ec_dec_uint;
84203d68:	23 f5 f0 e1 	call $celt.ec_dec_uint;
            M[r5 + $celt.dec.MDCT_WEIGHT_POS_FIELD] = r0;
84203d6c:	70 01 27 d5 	M[r5 + 368] = r0;

84203d70 <$M.celt.decode_flags.pos_calc_end>:
         pos_calc_end:
         r0 = 0;
84203d70:	00 00 20 01 	r0 = Null + 0;

84203d74 <$M.celt.decode_flags.set_transient_time>:
   set_transient_time:
   M[r5 + $celt.dec.TRANSIENT_TIME_FIELD] = r0;
84203d74:	64 01 27 d5 	M[r5 + 356] = r0;

   // output
   r0 = 0;
84203d78:	00 00 20 01 	r0 = Null + 0;

   // pop rLink from stack
   SP = SP - STACK_FRAME_SIZE;
84203d7c:	fc ff 03 f1 	SP = SP + -4;
   popm <FP,rLink>;
84203d80:	01 20 04 f1 	popm <FP, rLink>;
   rts;
84203d84:	0f 00 0d dc 	rts;

84203d88 <$celt.deemphasis>:
84203d88:	84 01 27 d1 	r0 = M[r5 + 388];
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.DEEMPHASIS.PATCH_ID_0,r1)     // celt_patchers
#endif

#ifdef BASE_REGISTER_MODE
   r0 = M[r5 + $celt.dec.SCRATCHVAR_LEFT_OBUF_START_ADDR];
   push r0;
84203d8c:	00 00 20 f3 	push r0;
   pop B5;
84203d90:	00 00 d6 f3 	pop B5;
#endif
   r0 = M[r5 + $celt.dec.SCRATCHVAR_LEFT_OBUF_ADDR];
84203d94:	7c 01 27 d1 	r0 = M[r5 + 380];
   r1 = M[r5 + $celt.dec.SCRATCHVAR_LEFT_OBUF_LEN];
84203d98:	80 01 37 d1 	r1 = M[r5 + 384];
   I5 = r0;
84203d9c:	2f 00 50 50 	I5 = Null + r0;
   L5 = r1;
84203da0:	3f 00 f0 50 	L5 = Null + r1;

   r3 = 1.0;//1.0/2.0; //scale factor 
84203da4:	ff 7f 00 fd 	r3 = Null + 2147483647;
84203da8:	ff ff 50 01 
   M2 = -MK1;
84203dac:	fc ff a0 51 	M2 = Null + -4;
   M3 = MK2;
84203db0:	08 00 b0 51 	M3 = Null + 8;
   r0 = M[r5 + $celt.dec.CELT_CHANNELS_FIELD];
84203db4:	08 00 27 d1 	r0 = M[r5 + 8];
   M0 = r0 + 1;
84203db8:	01 00 82 51 	M0 = r0 + 1;
   r0 = M[r5 + $celt.dec.MODE_E_PRED_COEF_FIELD];   //r0 = alpha
84203dbc:	50 00 27 d1 	r0 = M[r5 + 80];
   r6 = r5;
84203dc0:	0f 00 87 00 	r6 = r5 + Null;

84203dc4 <$M.celt.deemphasis.chan_loop>:
   chan_loop:
      r10 = M[r5 + $celt.dec.MODE_AUDIO_FRAME_SIZE_FIELD];
84203dc4:	44 00 c7 d1 	r10 = M[r5 + 68];
      r10 = r10 - 1;
84203dc8:	3f 00 cc e4 	r10 = r10 - 1;
      rMAC = M[r6 + $celt.dec.DEEMPH_HIST_SAMPLE_FIELD];                    
84203dcc:	9c 00 18 d1 	rMAC = M[r6 + 156];
      rMAC = rMAC * r0, r1 = M[I5, MK1];                                                             
84203dd0:	35 00 12 cf 	rMAC = rMAC * r0 (SS), r1 = M[I5,4];
      do deemphasis_loop;
84203dd4:	04 00 f0 e5 	do $M.celt.deemphasis.deemphasis_loop;
         rMAC = rMAC + r1 * r3, r1 = M[I5, M2];
84203dd8:	36 00 35 ae 	rMAC = rMAC + r1 * r3 (SS), r1 = M[I5,M2];
         r4 = rMAC ASHIFT 1;
84203ddc:	01 00 61 91 	r4 = rMAC ASHIFT 1;
         rMAC = rMAC * r0, M[I5, M3] = r4;
84203de0:	e7 00 12 ce 	rMAC = rMAC * r0 (SS), M[I5,M3] = r4;

84203de4 <$M.celt.deemphasis.deemphasis_loop>:
      deemphasis_loop:
      rMAC = rMAC + r1 * r3, r1 = M[I5, M2];
84203de4:	36 00 35 ae 	rMAC = rMAC + r1 * r3 (SS), r1 = M[I5,M2];
      r4 = rMAC ASHIFT 1;
84203de8:	01 00 61 91 	r4 = rMAC ASHIFT 1;
      M[I5, M3] = r4;
84203dec:	e7 00 00 02 	Null = Null + Null, M[I5,M3] = r4;
      M[r6 + $celt.dec.DEEMPH_HIST_SAMPLE_FIELD] = rMAC; 
84203df0:	9c 00 18 d5 	M[r6 + 156] = rMAC;

     // set up registers for second channel
#ifdef BASE_REGISTER_MODE
      r1 = M[r5 + $celt.dec.SCRATCHVAR_RIGHT_OBUF_START_ADDR];
84203df4:	90 01 37 d1 	r1 = M[r5 + 400];
      push r1;
84203df8:	00 00 30 f3 	push r1;
      pop B5;
84203dfc:	00 00 d6 f3 	pop B5;
#endif
      r1 = M[r5 + $celt.dec.SCRATCHVAR_RIGHT_OBUF_ADDR];
84203e00:	88 01 37 d1 	r1 = M[r5 + 392];
      I5 = r1;
84203e04:	3f 00 50 50 	I5 = Null + r1;
      r1 = M[r5 + $celt.dec.SCRATCHVAR_RIGHT_OBUF_LEN];
84203e08:	8c 01 37 d1 	r1 = M[r5 + 396];
      L5 = r1;
84203e0c:	3f 00 f0 50 	L5 = Null + r1;
      r6 = r6 + ADDR_PER_WORD;
84203e10:	bf 00 88 e4 	r6 = r6 + 4;

      // run for right channel if exisiting
      M0 = M0 - 1;
84203e14:	01 00 88 79 	M0 = M0 - 1;
   if NZ jump chan_loop;
84203e18:	eb ff 10 dd 	if NE jump $M.celt.deemphasis.chan_loop;

   L5 = 0;
84203e1c:	00 00 f0 51 	L5 = Null + 0;
#ifdef BASE_REGISTER_MODE
   push Null;
84203e20:	00 00 00 f3 	push Null;
   pop B5;
84203e24:	00 00 d6 f3 	pop B5;
#endif

   rts;   
84203e28:	0f 00 0d dc 	rts;

84203e2c <$celt.get1byte>:
84203e2c:	f8 01 27 d1 	r0 = M[r5 + 504];
#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.GET1BYTE.PATCH_ID_0,r1)     // celt_patchers
#endif
   
   r0 = M[r5 + $celt.dec.SCRATCHVAR_GET_BYTEPOS];           // calc amount of shift
   r0 = r0 * (-8) (int); 
84203e30:	f8 ff 22 99 	r0 = r0 * -8 (int);
   r1 = M[I0, 0];                           // r1 = the current word
84203e34:	00 30 00 03 	Null = Null + Null, r1 = M[I0,0];
   r1 = r1 LSHIFT r0;                       // shift current word
84203e38:	00 00 32 8f 	r1 = r1 LSHIFT r0;
   r1 = r1 AND 0xFF;                        // extract only the desired bits
84203e3c:	ff 00 33 81 	r1 = r1 AND 0xff;
   r0 = M[r5 + $celt.dec.SCRATCHVAR_GET_BYTEPOS];
84203e40:	f8 01 27 d1 	r0 = M[r5 + 504];
#ifdef DATAFORMAT_32
   r0 = r0 - 1;
84203e44:	3f 00 22 e4 	r0 = r0 - 1;
   if POS jump no_p_update;
84203e48:	03 00 50 dd 	if POS jump $M.celt.get1byte.no_p_update;
      r0 = M[I0, MK1]; // increment I0 to point to the next word
84203e4c:	00 21 00 03 	Null = Null + Null, r0 = M[I0,4];
      r0 = $celt.BYTE_POS_MAX_VALUE;
84203e50:	03 00 20 01 	r0 = Null + 3;

84203e54 <$M.celt.get1byte.no_p_update>:
   no_p_update:
   M[r5 + $celt.dec.SCRATCHVAR_GET_BYTEPOS] = r0;
84203e54:	f8 01 27 d5 	M[r5 + 504] = r0;
   M[r5 + $celt.dec.SCRATCHVAR_GET_BYTEPOS] = r0;
   if Z jump no_p_update;
      r0 = M[I0, MK1]; // increment I0 to point to the next word
   no_p_update:
#endif
   r0 = M[r5 + $celt.dec.SCRATCHVAR_FRAME_BYTES_REMAINED];
84203e58:	fc 01 27 d1 	r0 = M[r5 + 508];
   if LE r1 = 0;
84203e5c:	0d 00 30 00 	if LE r1 = Null + Null;
   r0 = r0 - 1;
84203e60:	3f 00 22 e4 	r0 = r0 - 1;
   M[r5 + $celt.dec.SCRATCHVAR_FRAME_BYTES_REMAINED] = r0;  // update number of frame bits read
84203e64:	fc 01 27 d5 	M[r5 + 508] = r0;
   rts;
84203e68:	0f 00 0d dc 	rts;

84203e6c <$celt.get1byte_from_end>:

#if defined(PATCH_LIBS)
   LIBS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.GET1BYTE_FROM_END.PATCH_ID_0,r1)     // celt_patchers
#endif
   
   r1 = -1;
84203e6c:	3f 00 30 e4 	r1 = Null - 1;
   r0 = M[r5 + $celt.dec.SCRATCHVAR_FRAME_BYTES_REMAINED_REVERSE];
84203e70:	04 02 27 d1 	r0 = M[r5 + 516];
   r0 = r0 - 1;
84203e74:	3f 00 22 e4 	r0 = r0 - 1;
   if NEG rts;
84203e78:	04 00 0d dc 	if NEG rts;
   M[r5 + $celt.dec.SCRATCHVAR_FRAME_BYTES_REMAINED_REVERSE] = r0;  // update number of frame bits read
84203e7c:	04 02 27 d5 	M[r5 + 516] = r0;
   r0 = M[r5 + $celt.dec.SCRATCHVAR_GET_BYTEPOS_REVERSE];           // calc amount of shift
84203e80:	00 02 27 d1 	r0 = M[r5 + 512];
#ifdef DATAFORMAT_32
   r0 = $celt.BYTE_POS_MAX_VALUE - r0;
84203e84:	03 00 22 65 	r0 = 3 - r0;
   if GT jump stay_in_this_word;
84203e88:	02 00 c0 dd 	if GT jump $M.celt.get1byte_from_end.stay_in_this_word;
      r1 = M[I1, -MK1];
84203e8c:	00 37 00 03 	Null = Null + Null, r1 = M[I1,-4];

84203e90 <$M.celt.get1byte_from_end.stay_in_this_word>:
   stay_in_this_word:
   r0 = r0 * (-8) (int);
84203e90:	f8 ff 22 99 	r0 = r0 * -8 (int);
   r1 = M[I1, 0];                                   // r1 = the current word
84203e94:	00 34 00 03 	Null = Null + Null, r1 = M[I1,0];
   r1 = r1 LSHIFT r0;                               // shift current word
84203e98:	00 00 32 8f 	r1 = r1 LSHIFT r0;
   r1 = r1 AND 0xFF;                                // extract only the desired bits
84203e9c:	ff 00 33 81 	r1 = r1 AND 0xff;
   r0 = M[r5 + $celt.dec.SCRATCHVAR_GET_BYTEPOS_REVERSE];
84203ea0:	00 02 27 d1 	r0 = M[r5 + 512];
   if NZ jump no_reset;
84203ea4:	02 00 10 dd 	if NE jump $M.celt.get1byte_from_end.no_reset;
      r0 = 4;
84203ea8:	bf 00 20 e4 	r0 = Null + 4;

84203eac <$M.celt.get1byte_from_end.no_reset>:
   no_reset:
   r0 = r0 - 1;
84203eac:	3f 00 22 e4 	r0 = r0 - 1;
   M[r5 + $celt.dec.SCRATCHVAR_GET_BYTEPOS_REVERSE] = r0;
84203eb0:	00 02 27 d5 	M[r5 + 512] = r0;
   r0 = r0 * (-8) (int); 
   r1 = M[I1, 0];                                   // r1 = the current word
   r1 = r1 LSHIFT r0;                               // shift current word
   r1 = r1 AND 0xFF;                                // extract only the desired bits
#endif
   rts;
84203eb4:	0f 00 0d dc 	rts;

84203eb8 <$celt.ec_laplace_decode_start>:
84203eb8:	00 00 d0 f3 	push rLink;
#endif
   
   // push rLink onto stack
   push rlink;
   
   push r3;
84203ebc:	00 00 50 f3 	push r3;
   push r2;
84203ec0:	00 00 40 f3 	push r2;
   call $celt.ec_decode_bin;
84203ec4:	4e f4 f0 e1 	call $celt.ec_decode_bin;
   pop r2;
84203ec8:	00 00 44 f3 	pop r2;
   pop r3;
84203ecc:	00 00 54 f3 	pop r3;
   r4 = 0;     //fl
84203ed0:	00 00 60 01 	r4 = Null + 0;
   r6 = 32768; //ft
84203ed4:	00 00 00 fd 	r6 = Null + 32768;
84203ed8:	00 80 80 01 
   r7 = r3;    //fh
84203edc:	0f 00 95 00 	r7 = r3 + Null;
   M0 = 0;     //val
84203ee0:	00 00 80 51 	M0 = Null + 0;
   M2 = 1;
84203ee4:	01 00 a0 51 	M2 = Null + 1;

84203ee8 <$M.celt.ec_laplace_decode_start.loop_start_laplace>:
   loop_start_laplace:
      Null = r0 -  r7;
84203ee8:	9f 00 02 20 	Null = r0 - r7;
      if NEG jump laplace_loop_end;
84203eec:	0e 00 40 dd 	if NEG jump $M.celt.ec_laplace_decode_start.laplace_loop_end;
      Null = r3;
84203ef0:	0f 00 05 00 	Null = r3 + Null;
      r4 = r7;
84203ef4:	0f 00 69 00 	r4 = r7 + Null;
      rMAC = r3*r2;
84203ef8:	4f 00 15 cc 	rMAC = r3 * r2 (SS);
      rMAC = rMAC LSHIFT (DAWTH-15);
84203efc:	11 00 e1 8d 	rMAC = rMAC LSHIFT 17 (MI);
      r3 = rMAC;
84203f00:	0f 00 51 00 	r3 = rMAC + Null;
      NULL = r7 - (32768-1);
84203f04:	ff 7f 09 21 	Null = r7 - 32767;
      if POS rMAC = 0;
84203f08:	05 00 10 00 	if POS rMAC = Null + Null;
      rMAC = rMAC OR r3;
84203f0c:	00 00 15 87 	rMAC = rMAC OR r3;
      if Z r3 = M2;
84203f10:	a0 00 50 44 	if EQ r3 = Null + M2;
      rMAC = r3 + r3;
84203f14:	5f 00 15 00 	rMAC = r3 + r3;
      r7 = r7 + rMAC;
84203f18:	00 00 91 03 	r7 = r7 + rMAC;
      M0 = M0 + 1;
84203f1c:	01 00 88 59 	M0 = M0 + 1;
   jump loop_start_laplace;
84203f20:	f2 ff f0 dd 	jump $M.celt.ec_laplace_decode_start.loop_start_laplace;

84203f24 <$M.celt.ec_laplace_decode_start.laplace_loop_end>:
            
   laplace_loop_end:    
   Null = r4 - 0;
84203f24:	00 00 06 21 	Null = r4 - 0;
   if LE jump end_flh_fix;
84203f28:	08 00 d0 dd 	if LE jump $M.celt.ec_laplace_decode_start.end_flh_fix;
      rMAC = r0 - r4;
84203f2c:	6f 00 12 20 	rMAC = r0 - r4;
      rMAC = rMAC - r3;
84203f30:	00 00 15 23 	rMAC = rMAC - r3;
      if NEG r7 = r7 - r3;
84203f34:	54 00 99 20 	if NEG r7 = r7 - r3;
      Null = rMAC;
84203f38:	0f 00 01 00 	Null = rMAC + Null;
      if NEG jump end_flh_fix;
84203f3c:	03 00 40 dd 	if NEG jump $M.celt.ec_laplace_decode_start.end_flh_fix;
      M0 = -M0;
84203f40:	8f 00 80 74 	M0 = Null - M0;
      r4 = r4 + r3;
84203f44:	00 00 65 03 	r4 = r4 + r3;

84203f48 <$M.celt.ec_laplace_decode_start.end_flh_fix>:
   end_flh_fix:
   Null = r4 - r7;
84203f48:	9f 00 06 20 	Null = r4 - r7;
   if Z r4 = r4 - M2;
84203f4c:	a0 00 66 64 	if EQ r4 = r4 - M2;
   M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FL + 0] = r4;
84203f50:	d4 01 67 d5 	M[r5 + 468] = r4;
   M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FL + MK1] = 0;
84203f54:	d8 01 07 d5 	M[r5 + 472] = Null;
   M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FH + 0] = r7;
84203f58:	dc 01 97 d5 	M[r5 + 476] = r7;
   M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FH + MK1] = 0; 
84203f5c:	e0 01 07 d5 	M[r5 + 480] = Null;
   M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FT + 0] = r6;
84203f60:	cc 01 87 d5 	M[r5 + 460] = r6;
   M[r5 + $celt.dec.SCRATCHVAR_EC_DEC_FT + MK1] = 0; 
84203f64:	d0 01 07 d5 	M[r5 + 464] = Null;
   push M0;
84203f68:	00 00 81 f3 	push M0;
   call $celt.ec_dec_update;
84203f6c:	30 f4 f0 e1 	call $celt.ec_dec_update;
   pop r1;
84203f70:	00 00 34 f3 	pop r1;
   // pop rLink from stack
   jump $pop_rLink_and_rts;
84203f74:	03 00 00 fd 	jump (m) 0x3b020;
84203f78:	21 b0 f0 dd 

84203f7c <$celt.idiv32>:
84203f7c:	00 04 e5 8d 	rMAC12 = r3 LSHIFT 0;
   LIBS_PUSH_REGS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.IDIV32.PATCH_ID_0)     // celt_patchers
#endif

   // normalise divisor  to DAWTH-1 bits
   rMAC12 = r3(ZP);
   rMAC0 = r2;
84203f80:	00 05 e4 8d 	rMAC0 = r2 LSHIFT 0;
   r10 = signdet rMAC;
84203f84:	0f 00 c1 d8 	r10 = SIGNDET rMAC;
   r4 = rMAC LSHIFT r10;
84203f88:	cf 00 61 8c 	r4 = rMAC LSHIFT r10;

   rMAC12 = r1(ZP);
84203f8c:	00 04 e3 8d 	rMAC12 = r1 LSHIFT 0;
   rMAC0 = r0;
84203f90:	00 05 e2 8d 	rMAC0 = r0 LSHIFT 0;
   r7 = signdet rMAC;
84203f94:	0f 00 91 d8 	r7 = SIGNDET rMAC;
   r7 = r7 - 2;
84203f98:	cf 00 99 e4 	r7 = r7 - 2;
   rMAC = rMAC LSHIFT r7 (56bit);
84203f9c:	00 00 19 8f 	rMAC = rMAC LSHIFT r7 (56bit);

   // divide normalised dividend/divisor
   Div = rMAC / r4;
84203fa0:	00 00 16 d9 	Div = rMAC / r4;

   // divisor truncated when normalise?
   r8 = r10 - DAWTH;
84203fa4:	20 00 ac 21 	r8 = r10 - 32;
   if NEG jump truncate_proc;
84203fa8:	12 00 40 dd 	if NEG jump $M.celt.idiv32.truncate_proc;
   r8 = r8 - r7;
84203fac:	00 00 a9 23 	r8 = r8 - r7;
   if POS jump div_rem;
84203fb0:	05 00 50 dd 	if POS jump $M.celt.idiv32.div_rem;
      r7 = 0;
84203fb4:	00 00 90 01 	r7 = Null + 0;
      r6 = DivResult;
84203fb8:	01 00 80 d9 	r6 = DivResult;
      r6 = r6 LSHIFT r8;
84203fbc:	00 00 8a 8f 	r6 = r6 LSHIFT r8;
     rts;
84203fc0:	0f 00 0d dc 	rts;

84203fc4 <$M.celt.idiv32.div_rem>:
   div_rem:
   // result might be more than DAWTH-1 bits
   r10 = r8 - (DAWTH);
84203fc4:	20 00 ca 21 	r10 = r8 - 32;
   r7 = DivResult;
84203fc8:	01 00 90 d9 	r7 = DivResult;
   r6 = r7 LSHIFT r8;
84203fcc:	af 00 89 8c 	r6 = r7 LSHIFT r8;
   r7 = r7 LSHIFT r10;
84203fd0:	00 00 9c 8f 	r7 = r7 LSHIFT r10;

   // divide the remainder to divisor
   rMAC = DivRemainder;
84203fd4:	02 00 10 d9 	rMAC = DivRemainder;
   rMAC = rMAC LSHIFT r10 (56bit);
84203fd8:	00 00 1c 8f 	rMAC = rMAC LSHIFT r10 (56bit);
   Div = rMAC / r4;
84203fdc:	00 00 16 d9 	Div = rMAC / r4;

   // add result to previous division result
   r4 = DivResult;
84203fe0:	01 00 60 d9 	r4 = DivResult;
   r6 = r6 + r4;
84203fe4:	00 00 86 03 	r6 = r6 + r4;
   r7 = r7 + carry;
84203fe8:	00 00 90 07 	r7 = r7 + Null + Carry;
   rts;
84203fec:	0f 00 0d dc 	rts;

84203ff0 <$M.celt.idiv32.truncate_proc>:
   truncate_proc:
      r8 = r8 - r7;
84203ff0:	00 00 a9 23 	r8 = r8 - r7;
      r7 = DivResult;
84203ff4:	01 00 90 d9 	r7 = DivResult;
      r6 = r7 LSHIFT r8;
84203ff8:	af 00 89 8c 	r6 = r7 LSHIFT r8;
      r8 = r8 - (DAWTH);
84203ffc:	20 00 aa 21 	r8 = r8 - 32;
      r7 = r7 LSHIFT r8;
84204000:	00 00 9a 8f 	r7 = r7 LSHIFT r8;
      rMAC = r6*r2 (UU);
84204004:	4f 00 18 c0 	rMAC = r6 * r2 (UU);
      r8 = rMAC LSHIFT (DAWTH-1);
84204008:	1f 00 a1 8d 	r8 = rMAC LSHIFT 31;
      rMAC0 = rMAC1;
8420400c:	00 05 e1 8d 	rMAC0 = rMAC LSHIFT 0;
      rMAC12 = rMAC2(ZP);
84204010:	e0 04 e1 8d 	rMAC12 = rMAC LSHIFT -32;
      rMAC = rMAC + r7*r2(SU);
84204014:	4f 00 19 a8 	rMAC = rMAC + r7 * r2 (SU);
      rMAC = rMAC + r6*r3(SU);
84204018:	5f 00 18 a8 	rMAC = rMAC + r6 * r3 (SU);
      r4 = rMAC LSHIFT (DAWTH-1);
8420401c:	1f 00 61 8d 	r4 = rMAC LSHIFT 31;
      Null = r0 - r8;
84204020:	af 00 02 20 	Null = r0 - r8;
      Null = r1 - r4 -borrow;
84204024:	6f 00 03 24 	Null = r1 - r4 - Borrow;
      if POS rts;
84204028:	05 00 0d dc 	if POS rts;
         r6 = r6 - 1;
8420402c:	3f 00 88 e4 	r6 = r6 - 1;
         r7 = r7 - borrow;
84204030:	00 00 90 27 	r7 = r7 - Null - Borrow;
   rts;
84204034:	0f 00 0d dc 	rts;

84204038 <$celt.log2_frac>:
   
#if defined(PATCH_LIBS)
   LIBS_PUSH_R0_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.LOG2_FRAC.PATCH_ID_0,r1)     // celt_patchers
#endif
   
   r1 = signdet rMAC;
84204038:	0f 00 31 d8 	r1 = SIGNDET rMAC;
   #if defined(KAL_ARCH3) || defined(KAL_ARCH4) || defined(KAL_ARCH5)
      r1 = r1 -(DAWTH-17);
8420403c:	0f 00 33 21 	r1 = r1 - 15;
      rMAC = rMAC ASHIFT r1(56bit);
84204040:	00 00 13 93 	rMAC = rMAC ASHIFT r1 (56bit);
      r1 = (DAWTH+16) -r1;
84204044:	30 00 33 65 	r1 = 48 - r1;
      r1 = r1 -6;
      rMAC = rMAC ASHIFT r1;
      rMAC = rMAC * 0.5 (frac);
      r1 = 41 - r1;
   #endif
   r2 = 1 LSHIFT r0;
84204048:	01 00 42 e9 	r2 = 0x1 LSHIFT r0;
   r1 = r1 - 1;
8420404c:	3f 00 33 e4 	r1 = r1 - 1;
   r10 = r0+1;
84204050:	2f 00 c2 e4 	r10 = r0 + 1;
   r6 = 0.5;
84204054:	00 40 00 fd 	r6 = Null + 1073741824;
84204058:	00 00 80 01 
   r0 = r1 LSHIFT r0;
8420405c:	2f 00 23 8c 	r0 = r1 LSHIFT r0;
#ifdef K32
   r7 = (0x7FFFFF);
84204060:	7f 00 00 fd 	r7 = Null + 8388607;
84204064:	ff ff 90 01 
#else
   r7 = (0x7FFF);
#endif
   r1 = 1;
84204068:	2f 00 30 e4 	r1 = Null + 1;
   do comp_loop;
8420406c:	0a 00 f0 e5 	do $M.celt.log2_frac.comp_loop;
      NULL = rMAC LSHIFT -16;
84204070:	f0 00 01 8d 	Null = rMAC LSHIFT -16;
      if NZ r0 = r0 + r2;
84204074:	41 00 22 00 	if NE r0 = r0 + r2;
      Null = rMAC LSHIFT -16;
84204078:	f0 00 01 8d 	Null = rMAC LSHIFT -16;
      if NZ rMAC = rMAC * r6 (frac);
8420407c:	81 00 11 94 	if NE rMAC = rMAC * r6 (frac);
      rMAC = rMAC * rMAC;
84204080:	1f 00 11 cc 	rMAC = rMAC * rMAC (SS);
#ifdef K32
      // Adjust rMAC72 to make rMAC0 and rMAC1 bit-exact with ARCH3 when retrieved
      rMAC = rMAC ASHIFT 8 (56bit);
84204084:	08 00 11 91 	rMAC = rMAC ASHIFT 8 (56bit);
#endif
      rMAC = rMAC + r1 * r7;
84204088:	9f 00 13 ac 	rMAC = rMAC + r1 * r7 (SS);
      rMAC = rMAC LSHIFT 8;
8420408c:	08 00 e1 8d 	rMAC = rMAC LSHIFT 8 (MI);
      r2 = r2 LSHIFT -1;
84204090:	ff 00 44 8d 	r2 = r2 LSHIFT -1;

84204094 <$M.celt.log2_frac.comp_loop>:
   comp_loop:
   rMAC = rMAC - 0x8000;
84204094:	00 00 00 fd 	rMAC = rMAC - 32768;
84204098:	00 80 11 21 
   if GT r0 = r0 + r1;
8420409c:	3c 00 22 00 	if GT r0 = r0 + r1;
   rts;
842040a0:	0f 00 0d dc 	rts;

842040a4 <$celt.imusdiv32>:
#if defined(PATCH_LIBS)
   LIBS_PUSH_REGS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.IMUSDIV32.PATCH_ID_0)     // celt_patchers
#endif

   // calc a*b
   rMAC = r0 * r2 (UU);
842040a4:	4f 00 12 c0 	rMAC = r0 * r2 (UU);
   r6 = rMAC LSHIFT (DAWTH-1);
842040a8:	1f 00 81 8d 	r6 = rMAC LSHIFT 31;
   rMAC0 = rMAC1;
842040ac:	00 05 e1 8d 	rMAC0 = rMAC LSHIFT 0;
   rMAC12 = rMAC2 (ZP);
842040b0:	e0 04 e1 8d 	rMAC12 = rMAC LSHIFT -32;
   rMAC = rMAC + r1 * r2 (SU);
842040b4:	4f 00 13 a8 	rMAC = rMAC + r1 * r2 (SU);
   rMAC = rMAC + r3 * r0 (SU);
842040b8:	2f 00 15 a8 	rMAC = rMAC + r3 * r0 (SU);
   r7 = rMAC LSHIFT (DAWTH-1);
842040bc:	1f 00 91 8d 	r7 = rMAC LSHIFT 31;
   rMAC0 = rMAC1;
842040c0:	00 05 e1 8d 	rMAC0 = rMAC LSHIFT 0;
   rMAC12 = rMAC2 (SE);
842040c4:	e0 04 e1 91 	rMAC12 = rMAC ASHIFT -32;
   rMAC = rMAC + r1 * r3 (SS);
842040c8:	5f 00 13 ac 	rMAC = rMAC + r1 * r3 (SS);
   r8 = rMAC LSHIFT (DAWTH-1);
842040cc:	1f 00 a1 8d 	r8 = rMAC LSHIFT 31;
   
   // r8:r7:r6 = a*b, calc a*b-c
   r6 = r6 - r4;
842040d0:	00 00 86 23 	r6 = r6 - r4;
   r7 = r7 - r5 - Borrow;
842040d4:	00 00 97 27 	r7 = r7 - r5 - Borrow;
   r8 = r8 - Borrow;
842040d8:	00 00 a0 27 	r8 = r8 - Null - Borrow;

   // divide to d (result can be up to 32 bits)
   rMAC  = r8;
842040dc:	0f 00 1a 00 	rMAC = r8 + Null;
   rMAC0 = r7;
842040e0:	00 05 e9 8d 	rMAC0 = r7 LSHIFT 0;
   Div = rMAC/r10;
842040e4:	00 00 1c d9 	Div = rMAC / r10;
   r3 = DivResult;
842040e8:	01 00 50 d9 	r3 = DivResult;
   r2 = DivRemainder;
842040ec:	02 00 40 d9 	r2 = DivRemainder;
   r8 = r10 LSHIFT 1;
842040f0:	01 00 ac 8d 	r8 = r10 LSHIFT 1;
   rMAC = r2;
842040f4:	0f 00 14 00 	rMAC = r2 + Null;
   rMAC0 = r6;
842040f8:	00 05 e8 8d 	rMAC0 = r6 LSHIFT 0;
   Div = rMAC/r8;
842040fc:	00 00 1a d9 	Div = rMAC / r8;
   r2 = DivResult;
84204100:	01 00 40 d9 	r2 = DivResult;
   r8 = DivRemainder;
84204104:	02 00 a0 d9 	r8 = DivRemainder;
   r2 = r2 + r2;
84204108:	00 00 44 03 	r2 = r2 + r2;
   r7 = 1;
8420410c:	2f 00 90 e4 	r7 = Null + 1;
   Null = r8 - r10;
84204110:	cf 00 0a 20 	Null = r8 - r10;
   if POS r2 = r2 + r7;
84204114:	95 00 44 00 	if POS r2 = r2 + r7;
   rts;
84204118:	0f 00 0d dc 	rts;

8420411c <$celt.bitexact_cos>:

#if defined(PATCH_LIBS)
   LIBS_PUSH_REGS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.BITEXACT_COS.PATCH_ID_0)     // celt_patchers
#endif
   
   rMAC = r0*r0;
8420411c:	2f 00 12 cc 	rMAC = r0 * r0 (SS);
   r3 = 1;
84204120:	2f 00 50 e4 	r3 = Null + 1;
   rMAC = rMAC + r3*4096;
84204124:	00 00 00 fd 	rMAC = rMAC + r3 * 1.9073486328125e-06 (SS);
84204128:	00 10 15 ad 
   r2 = rMAC ASHIFT (DAWTH-14);
8420412c:	12 00 41 91 	r2 = rMAC ASHIFT 18;
   rMAC = r2 - 32767;
84204130:	ff 7f 14 21 	rMAC = r2 - 32767;
   if POS r2 = r2 - rMAC;
84204134:	15 00 44 20 	if POS r2 = r2 - rMAC;

   rMAC = r2 * (-626);
84204138:	ff ff 00 fd 	rMAC = r2 * -2.91503965854644775390625e-07 (SS);
8420413c:	8e fd 14 cd 
   rMAC = rMAC + r3*16384;
84204140:	00 00 00 fd 	rMAC = rMAC + r3 * 7.62939453125e-06 (SS);
84204144:	00 40 15 ad 
   rMAC = rMAC ASHIFT (DAWTH-16);
84204148:	10 00 e1 91 	rMAC = rMAC ASHIFT 16 (MI);
   rMAC = rMAC + 8277;
8420414c:	55 20 11 01 	rMAC = rMAC + 8277;

   rMAC = r2 * rMAC;
84204150:	1f 00 14 cc 	rMAC = r2 * rMAC (SS);
   rMAC = rMAC + r3*16384;
84204154:	00 00 00 fd 	rMAC = rMAC + r3 * 7.62939453125e-06 (SS);
84204158:	00 40 15 ad 
   rMAC = rMAC ASHIFT (DAWTH-16);
8420415c:	10 00 e1 91 	rMAC = rMAC ASHIFT 16 (MI);
   rMAC = rMAC - 7651;
84204160:	e3 1d 11 21 	rMAC = rMAC - 7651;

   rMAC = r2 * rMAC;
84204164:	1f 00 14 cc 	rMAC = r2 * rMAC (SS);
   rMAC = rMAC + r3*16384;
84204168:	00 00 00 fd 	rMAC = rMAC + r3 * 7.62939453125e-06 (SS);
8420416c:	00 40 15 ad 
   rMAC = rMAC ASHIFT (DAWTH-16);
84204170:	10 00 e1 91 	rMAC = rMAC ASHIFT 16 (MI);
   r2 = rMAC - r2;
84204174:	4f 00 41 20 	r2 = rMAC - r2;
   if POS r2= -r3;
84204178:	55 00 40 20 	if POS r2 = Null - r3;
   r2 = r2 + 32768;
8420417c:	00 00 00 fd 	r2 = r2 + 32768;
84204180:	00 80 44 01 

   rts;
84204184:	0f 00 0d dc 	rts;

84204188 <$celt.put1byte>:
84204188:	ec 01 27 d1 	r0 = M[r5 + 492];
#if defined(PATCH_LIBS)
   LIBS_PUSH_REGS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.PUT1BYTE.PATCH_ID_0)     // celt_patchers
#endif  

   r0 = M[r5 + $celt.enc.SCRATCHVAR_FRAME_BYTES_REMAINED];
   if LE rts;
8420418c:	0d 00 0d dc 	if LE rts;
   r0 = r0 - 1;
84204190:	3f 00 22 e4 	r0 = r0 - 1;
   M[r5 + $celt.enc.SCRATCHVAR_FRAME_BYTES_REMAINED] = r0;
84204194:	ec 01 27 d5 	M[r5 + 492] = r0;
   r0 = M[r5 + $celt.enc.SCRATCHVAR_PUT_BYTEPOS];
84204198:	e8 01 27 d1 	r0 = M[r5 + 488];
#ifdef DATAFORMAT_32
   if Z jump anotherword;
8420419c:	12 00 00 dd 	if EQ jump $M.celt.put1byte.anotherword;
     push r1; //push unshifted byte to write
842041a0:	00 00 30 f3 	push r1;
     r0 = r0 LSHIFT 3;
842041a4:	03 00 22 8d 	r0 = r0 LSHIFT 3;
     r1 = r1 LSHIFT r0;
842041a8:	00 00 32 8f 	r1 = r1 LSHIFT r0;
     push r1;
842041ac:	00 00 30 f3 	push r1;
     r1 = 0xFF LSHIFT r0;
842041b0:	ff 00 32 e9 	r1 = 0xff LSHIFT r0;
     r1 = r1 XOR 0xFFFFFFFF;
842041b4:	ff ff 00 fd 	r1 = r1 XOR 0xffffffff;
842041b8:	ff ff 33 89 
     r0 = M[I0, 0];
842041bc:	00 20 00 03 	Null = Null + Null, r0 = M[I0,0];
     r0 = r0 AND r1;
842041c0:	00 00 23 83 	r0 = r0 AND r1;
     pop r1;
842041c4:	00 00 34 f3 	pop r1;
     r0 = r0 OR r1;
842041c8:	00 00 23 87 	r0 = r0 OR r1;
     M[I0, 0] = r0;
842041cc:	00 a0 00 03 	Null = Null + Null, M[I0,0] = r0;
     r0 = M[r5 + $celt.enc.SCRATCHVAR_PUT_BYTEPOS];
842041d0:	e8 01 27 d1 	r0 = M[r5 + 488];
     r0 = r0 - 1;
842041d4:	3f 00 22 e4 	r0 = r0 - 1;
     M[r5 + $celt.enc.SCRATCHVAR_PUT_BYTEPOS] = r0;
842041d8:	e8 01 27 d5 	M[r5 + 488] = r0;
     pop r1;  //restore written byte
842041dc:	00 00 34 f3 	pop r1;
     rts;
842041e0:	0f 00 0d dc 	rts;

842041e4 <$M.celt.put1byte.anotherword>:
   anotherword:
   r0 = M[I0, 0];
842041e4:	00 20 00 03 	Null = Null + Null, r0 = M[I0,0];
   r0 = r0 AND 0xFFFFFF00;
842041e8:	ff ff 00 fd 	r0 = r0 AND 0xffffff00;
842041ec:	00 ff 22 81 
   r0 = r0 OR r1;
842041f0:	00 00 23 87 	r0 = r0 OR r1;
   M[I0, MK1] = r0;
842041f4:	00 a1 00 03 	Null = Null + Null, M[I0,4] = r0;
   r0 = $celt.BYTE_POS_MAX_VALUE;
842041f8:	03 00 20 01 	r0 = Null + 3;
   M[r5 + $celt.enc.SCRATCHVAR_PUT_BYTEPOS] = r0;
842041fc:	e8 01 27 d5 	M[r5 + 488] = r0;
   rts;
84204200:	0f 00 0d dc 	rts;

84204204 <$celt.put1byte_to_end>:

#if defined(PATCH_LIBS)
   LIBS_PUSH_REGS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.PUT1BYTE_TO_END.PATCH_ID_0)     // celt_patchers
#endif
   
   r0 = M[r5 + $celt.enc.SCRATCHVAR_FRAME_BYTES_REMAINED_REVERSE];
84204204:	f4 01 27 d1 	r0 = M[r5 + 500];
   r0 = r0 - 1;
84204208:	3f 00 22 e4 	r0 = r0 - 1;
   if NEG rts;
8420420c:	04 00 0d dc 	if NEG rts;
   M[r5 + $celt.enc.SCRATCHVAR_FRAME_BYTES_REMAINED_REVERSE] = r0;
84204210:	f4 01 27 d5 	M[r5 + 500] = r0;
   r0 = M[r5 + $celt.enc.SCRATCHVAR_PUT_BYTEPOS_REVERSE];
84204214:	f0 01 27 d1 	r0 = M[r5 + 496];
#ifdef DATAFORMAT_32
   if Z jump anotherword;
84204218:	11 00 00 dd 	if EQ jump $M.celt.put1byte_to_end.anotherword;
     r0 = $celt.BYTE_POS_MAX_VALUE - r0; // Max byte count counting 0,1,2,3 and subtracting previously read byte count.
8420421c:	03 00 22 65 	r0 = 3 - r0;
     r0 = r0 LSHIFT 3;
84204220:	03 00 22 8d 	r0 = r0 LSHIFT 3;
     r1 = r1 LSHIFT r0;
84204224:	00 00 32 8f 	r1 = r1 LSHIFT r0;
     push r1;
84204228:	00 00 30 f3 	push r1;
     r1 = 0xFF LSHIFT r0;
8420422c:	ff 00 32 e9 	r1 = 0xff LSHIFT r0;
     r1 = r1 XOR 0xFFFFFFFF;
84204230:	ff ff 00 fd 	r1 = r1 XOR 0xffffffff;
84204234:	ff ff 33 89 
     r0 = M[I1, 0];
84204238:	00 24 00 03 	Null = Null + Null, r0 = M[I1,0];
     r0 = r0 AND r1;
8420423c:	00 00 23 83 	r0 = r0 AND r1;
     pop r1;
84204240:	00 00 34 f3 	pop r1;
     r0 = r0 OR r1;
84204244:	00 00 23 87 	r0 = r0 OR r1;
     M[I1, 0] = r0;
84204248:	00 a4 00 03 	Null = Null + Null, M[I1,0] = r0;
     r0 = M[r5 + $celt.enc.SCRATCHVAR_PUT_BYTEPOS_REVERSE];
8420424c:	f0 01 27 d1 	r0 = M[r5 + 496];
     r0 = r0 - 1;
84204250:	3f 00 22 e4 	r0 = r0 - 1;
     M[r5 + $celt.enc.SCRATCHVAR_PUT_BYTEPOS_REVERSE] = r0;
84204254:	f0 01 27 d5 	M[r5 + 496] = r0;
     rts;
84204258:	0f 00 0d dc 	rts;

8420425c <$M.celt.put1byte_to_end.anotherword>:
   anotherword:
   r0 = M[I1, 0];
8420425c:	00 24 00 03 	Null = Null + Null, r0 = M[I1,0];
   r0 = r0 AND 0x00FFFFFF;
84204260:	ff 00 00 fd 	r0 = r0 AND 0xffffff;
84204264:	ff ff 22 81 
   r1 = r1 LSHIFT 24;
84204268:	18 00 33 8d 	r1 = r1 LSHIFT 24;
   r0 = r0 OR r1;
8420426c:	00 00 23 87 	r0 = r0 OR r1;
   M[I1, -MK1] = r0;
84204270:	00 a7 00 03 	Null = Null + Null, M[I1,-4] = r0;
   r0 = $celt.BYTE_POS_MAX_VALUE;
84204274:	03 00 20 01 	r0 = Null + 3;
   M[r5 + $celt.enc.SCRATCHVAR_PUT_BYTEPOS_REVERSE] = r0;
84204278:	f0 01 27 d5 	M[r5 + 496] = r0;
   rts;
8420427c:	0f 00 0d dc 	rts;
Disassembly of section .text_minim:

84204280 <$_celt_decode_create>:
 * \return Whether the response_data field has been populated with a valid
 * response
 */
bool celt_decode_create(OPERATOR_DATA *op_data, void *message_data,
                                unsigned *response_id, void **response_data)
{
84204280:	f5 1d       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>, SP = SP + 0x10;
84204282:	11 09       	r7 = r0 + Null;
84204284:	18 09       	r6 = r1 + Null;
84204286:	27 00       	r5 = r2 + Null;
84204288:	2a 09       	r8 = r3 + Null;
Private Function Declarations
*/

static inline CELT_DEC_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (CELT_DEC_OP_DATA *) base_op_get_instance_data(op_data);
8420428a:	ef fd e1 ff 	call (m) 0x4e6;
8420428e:	3d e2 
84204290:	16 00       	r4 = r0 + Null;
#endif

    patch_fn_shared(celt_decode_wrapper);
    
    /* call base_op create, which also allocates and fills response message */
    if (!base_op_create(op_data, message_data, response_id, response_data))
84204292:	55 08       	r3 = r8 + Null;
84204294:	3c 00       	r2 = r5 + Null;
84204296:	43 08       	r1 = r6 + Null;
84204298:	4a 08       	r0 = r7 + Null;
8420429a:	ef fd e0 ff 	call (m) 0x35a;
8420429e:	21 e6 
842042a0:	10 04       	Null = r0 - Null;
842042a2:	03 62       	if NE jump (m) Lc_celt_decode_create_3;

842042a4 <Lc_celt_decode_create_2>:
    {
        return FALSE;
842042a4:	02 00       	r0 = Null + Null;
842042a6:	78 6e       	jump (m) Lc_celt_decode_create_15;

842042a8 <Lc_celt_decode_create_3>:
        return TRUE;
    }
#endif

#ifdef CELT_DECODE_OFFLOAD
    celt_data->offload_enabled = opmgr_op_thread_offload(op_data) && audio_thread_offload_is_active();
842042a8:	4a 08       	r0 = r7 + Null;
842042aa:	ef fd fa ff 	call (m) 0x385a;
842042ae:	31 ed 
842042b0:	10 04       	Null = r0 - Null;
842042b2:	09 60       	if EQ jump (m) Lc_celt_decode_create_5;

842042b4 <Lc_celt_decode_create_4>:
842042b4:	ff fd 7e f0 	call (m) 0x13ec2;
842042b8:	2f e0 
842042ba:	03 00       	r1 = Null + Null;
842042bc:	10 04       	Null = r0 - Null;
842042be:	21 f0 43 ce 	if NE r1 = Null + 1;
842042c2:	02 6e       	jump (m) Lc_celt_decode_create_6;

842042c4 <Lc_celt_decode_create_5>:
842042c4:	03 00       	r1 = Null + Null;

842042c6 <Lc_celt_decode_create_6>:
842042c6:	63 f0 ab 8e 	M[r4 + 684] = r1;

    L2_DBG_MSG1("CELT decode, offload_enabled = %d",  celt_data->offload_enabled);
842042ca:	01 f0 3c 91 	rMAC = MBS[Null + 0x33c];
842042ce:	88 24       	Null = rMAC - 2;
842042d0:	07 68       	if LT jump (m) Lc_celt_decode_create_8;

842042d2 <Lc_celt_decode_create_7>:
842042d2:	55 f1 02 f0 	r0 = Null + 357564416;
842042d6:	00 40 
842042d8:	ef fd e5 ff 	call (m) 0xcde;
842042dc:	27 e0 

842042de <Lc_celt_decode_create_8>:

    if (celt_data->offload_enabled)
842042de:	60 f0 ab 88 	Null = M[r4 + 684];
842042e2:	12 60       	if EQ jump (m) Lc_celt_decode_create_11;

842042e4 <Lc_celt_decode_create_9>:
    {
        /* Offload enabled, so use a shared allocation */
        if (!mem_table_zalloc_shared((void *)(&(celt_data->codec_data)),
                        celt_dec_offload_shared_malloc_table, CELT_OFFLOAD_MALLOC_TABLE_LENGTH,
                        &new_allocation))
842042e4:	c5 11       	r3 = FP + 28;
842042e6:	84 20       	r2 = Null + 2;
842042e8:	07 f0 03 f0 	r1 = Null + 7347920;
842042ec:	d0 7a 
842042ee:	62 f0 4c 20 	r0 = r4 + 76;
842042f2:	ef fd ec ff 	call (m) 0x1c4e;
842042f6:	3d ea 
842042f8:	10 04       	Null = r0 - Null;
842042fa:	11 62       	if NE jump (m) Lc_celt_decode_create_12;

842042fc <Lc_celt_decode_create_10>:
        {
            free_data_and_fail(op_data, response_data);
842042fc:	53 08       	r1 = r8 + Null;
842042fe:	4a 08       	r0 = r7 + Null;
84204300:	02 f0 3b ef 	call (m) Lc_free_data_and_fail_1;
84204304:	48 6e       	jump (m) Lc_celt_decode_create_14;

84204306 <Lc_celt_decode_create_11>:
    }
    else
    {
        /* No offload: can't use shared allocation */
        if (!mem_table_zalloc((void *)(&(celt_data->codec_data)),
                        celt_dec_offload_malloc_table, CELT_OFFLOAD_MALLOC_TABLE_LENGTH))
84204306:	84 20       	r2 = Null + 2;
84204308:	07 f0 03 f0 	r1 = Null + 7347936;
8420430c:	e0 7a 
8420430e:	62 f0 4c 20 	r0 = r4 + 76;
84204312:	ef fd ec ff 	call (m) 0x1bfe;
84204316:	2d e7 
84204318:	10 04       	Null = r0 - Null;
8420431a:	f1 61       	if EQ jump (m) Lc_celt_decode_create_10;

8420431c <Lc_celt_decode_create_12>:
    }
#endif

    /* now allocate the non-shareable memory */
    if(!mem_table_zalloc((uintptr_t *)(&(celt_data->codec_data)), celt_dec_malloc_table,
                                                CELT_DEC_MALLOC_TABLE_LENGTH))
8420431c:	04 21       	r2 = Null + 4;
8420431e:	07 f0 03 f0 	r1 = Null + 7347896;
84204322:	b8 7a 
84204324:	62 f0 4c 20 	r0 = r4 + 76;
84204328:	ef fd ec ff 	call (m) 0x1bfe;
8420432c:	37 e6 
8420432e:	10 04       	Null = r0 - Null;
84204330:	e6 61       	if EQ jump (m) Lc_celt_decode_create_10;

84204332 <Lc_celt_decode_create_13>:
#endif
            /* Successfully allocated everything! */
            /* Stage 2 populate the DECODER structure */

            /* Tell the codec structure where to find the celt codec data */
            celt_data->decoder_data.codec.decoder_data_object = &(celt_data->codec_data);
84204332:	61 f0 4c 20 	rMAC = r4 + 76;
84204336:	b1 8f       	M[r4 + 24] = rMAC;
            
            
            celt_data->codec_data.ptr_flaglist_table = celt_data->codec_common_data.celt_flaglist ;
84204338:	61 f0 a4 88 	rMAC = M[r4 + 656];
8420433c:	61 f0 97 8e 	M[r4 + 604] = rMAC;
            celt_data->codec_data.ptr_emeans_table =celt_data->codec_common_data.celt_emeans_table ;
84204340:	61 f0 a5 88 	rMAC = M[r4 + 660];
84204344:	61 f0 98 8e 	M[r4 + 608] = rMAC;
            celt_data->codec_data.ptr_max_n_table =celt_data->codec_common_data.celt_max_nfield ;
84204348:	61 f0 a6 88 	rMAC = M[r4 + 664];
8420434c:	61 f0 99 8e 	M[r4 + 612] = rMAC;
            celt_data->codec_data.ptr_max_k_table =celt_data->codec_common_data.celt_max_k_table ;
84204350:	61 f0 a7 88 	rMAC = M[r4 + 668];
84204354:	61 f0 9a 8e 	M[r4 + 616] = rMAC;
            celt_data->codec_data.ptr_inv2_table =celt_data->codec_common_data.celt_inv2_table ;
84204358:	61 f0 a8 88 	rMAC = M[r4 + 672];
8420435c:	61 f0 9b 8e 	M[r4 + 620] = rMAC;
            
            celt_data->codec_data.frame_size = 190;
84204360:	01 f0 be 40 	rMAC = Null + 190;
84204364:	31 af       	M[r4 + 80] = rMAC;
            celt_data->codec_data.channels =  CELT_STEREO_MODE;
84204366:	41 20       	rMAC = Null + 1;
84204368:	71 af       	M[r4 + 84] = rMAC;
            celt_data->codec_data.mdct_function =  (void*)celt_imdct_radix2;
8420436a:	42 f0 01 f0 	rMAC = Null + 69207236;
8420436e:	c4 48 
84204370:	b1 af       	M[r4 + 88] = rMAC;
            celt_data->codec_data.mdct_short_function = (void*)celt_imdct_radix2;
84204372:	f1 af       	M[r4 + 92] = rMAC;
            celt_data->codec_data.dec_mode = CELT_MODE;
84204374:	60 f0 a2 8e 	M[r4 + 648] = Null;
            
            /* Call the celt decoder init_decode and init_tables functions. */
            celt_decode_lib_init(&(celt_data->decoder_data.codec));
84204378:	32 00       	r0 = r4 + Null;
8420437a:	de ff 3a e7 	call $_celt_decode_lib_init;
8420437e:	61 f0 ab 88 	rMAC = M[r4 + 684];
84204382:	f1 ff fa ff 	if NE call $_celt_setup_thread_offload;
84204386:	2e ed 

            CELT_SETUP_OFFLOAD_IF_ENABLED();

            populate_celt_asm_funcs(&(celt_data->decoder_data.decode_frame),
                                    &(celt_data->decoder_data.silence));
84204388:	63 f0 44 20 	r1 = r4 + 68;
8420438c:	62 f0 40 20 	r0 = r4 + 64;
84204390:	02 f0 21 ed 	call (m) $_populate_celt_asm_funcs;

84204394 <Lc_celt_decode_create_14>:
        if (!mem_table_zalloc_shared((void *)(&(celt_data->codec_data)),
                        celt_dec_offload_shared_malloc_table, CELT_OFFLOAD_MALLOC_TABLE_LENGTH,
                        &new_allocation))
        {
            free_data_and_fail(op_data, response_data);
            return TRUE;
84204394:	42 20       	r0 = Null + 1;

84204396 <Lc_celt_decode_create_15>:
    }
    /* Clear up all the allocated memory. */
    free_data_and_fail(op_data, response_data);
    return TRUE;
#endif
}
84204396:	f5 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, r8, rLink>;
84204398:	d8 4c       	rts;

8420439a <$_celt_decode_destroy>:
 * \return Whether the response_data field has been populated with a valid
 * response
 */
bool celt_decode_destroy(OPERATOR_DATA *op_data, void *message_data,
                                    unsigned *response_id, void **response_data)
{
8420439a:	f4 1c       	pushm <FP(=SP), r4, r5, r6, r7, rLink>;
8420439c:	16 00       	r4 = r0 + Null;
8420439e:	19 09       	r7 = r1 + Null;
842043a0:	27 00       	r5 = r2 + Null;
842043a2:	28 09       	r6 = r3 + Null;
    patch_fn_shared(celt_decode_wrapper);
    /* check that we are not trying to destroy a running operator */
    if (opmgr_op_is_running(op_data))
842043a4:	ff fd 09 f0 	call (m) 0x5700;
842043a8:	3d ea 
842043aa:	10 04       	Null = r0 - Null;
842043ac:	09 60       	if EQ jump (m) Lc_celt_decode_destroy_3;

842043ae <Lc_celt_decode_destroy_2>:
    {
        /* We can't destroy a running operator. */
        return base_op_build_std_response_ex(op_data, STATUS_CMD_FAILED, response_data);
842043ae:	03 f0 00 60 	r1 = Null + 4096;
842043b2:	44 08       	r2 = r6 + Null;
842043b4:	32 00       	r0 = r4 + Null;
842043b6:	ef fd e0 ff 	call (m) 0x4bc;
842043ba:	27 e8 
842043bc:	10 6e       	jump (m) Lc_celt_decode_destroy_6;

842043be <Lc_celt_decode_destroy_3>:
    }
    else if(base_op_destroy(op_data, message_data, response_id, response_data))
842043be:	45 08       	r3 = r6 + Null;
842043c0:	3c 00       	r2 = r5 + Null;
842043c2:	4b 08       	r1 = r7 + Null;
842043c4:	32 00       	r0 = r4 + Null;
842043c6:	ef fd df ff 	call (m) 0x370;
842043ca:	2b ed 
842043cc:	10 04       	Null = r0 - Null;
842043ce:	06 60       	if EQ jump (m) Lc_celt_decode_destroy_5;

842043d0 <Lc_celt_decode_destroy_4>:
        /* Free all the scratch memory we reserved */
        scratch_deregister();
#endif
        /* Clear up the celt_decode specific work and then let base_op do
         * the grunt work. */
        free_data(op_data);
842043d0:	32 00       	r0 = r4 + Null;
842043d2:	02 f0 39 e6 	call (m) Lc_free_data_1;
        return TRUE;
842043d6:	42 20       	r0 = Null + 1;
842043d8:	02 6e       	jump (m) Lc_celt_decode_destroy_6;

842043da <Lc_celt_decode_destroy_5>:
    }

    return FALSE;
842043da:	02 00       	r0 = Null + Null;

842043dc <Lc_celt_decode_destroy_6>:
}
842043dc:	f4 48       	popm <FP, r4, r5, r6, r7, rLink>;
842043de:	d8 4c       	rts;

842043e0 <$_celt_decode_process_data>:
 * \param op_data Pointer to the operator instance data.
 * \param touched Structure to return the terminals which this operator wants kicked
 */

void celt_decode_process_data(OPERATOR_DATA *op_data, TOUCHED_TERMINALS *touched)
{
842043e0:	f6 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>;
842043e2:	4d 4c       	SP = SP + 52;
842043e4:	12 09       	r8 = r0 + Null;
842043e6:	1b 09       	r9 = r1 + Null;
Private Function Declarations
*/

static inline CELT_DEC_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (CELT_DEC_OP_DATA *) base_op_get_instance_data(op_data);
842043e8:	ef fd e0 ff 	call (m) 0x4e6;
842043ec:	3f e7 
842043ee:	16 00       	r4 = r0 + Null;
    CELT_DEC_OP_DATA *celt_data = get_instance_data(op_data);
    unsigned output_samples;
#ifdef CELT_DECODE_OFFLOAD
    A2DP_DECODER_PARAMS *decoder_data = &celt_data->decoder_data;
    unsigned op_offset_pre_dec, op_offset_post_dec;
    INT_OP_ID opid = base_op_get_int_op_id(op_data);
842043f0:	52 08       	r0 = r8 + Null;
842043f2:	ef fd e0 ff 	call (m) 0x4f0;
842043f6:	3f e7 
842043f8:	17 00       	r5 = r0 + Null;
842043fa:	b1 f1 17 7b 	rMAC = Null + 229143;
842043fe:	5f de       	M[FP + 44] = r5;
84204400:	61 de       	M[FP + 48] = rMAC;
84204402:	6e de       	M[FP + 52] = r4;
84204404:	31 a8       	rMAC = M[r4 + 64];
84204406:	71 de       	M[FP + 56] = rMAC;
84204408:	78 de       	M[FP + 60] = Null;
8420440a:	71 98       	rMAC = M[r4 + 36];
8420440c:	81 de       	M[FP + 64] = rMAC;
8420440e:	42 f0 21 f0 	rMAC = Null + 69224717;
84204412:	0d 51 
84204414:	89 de       	M[FP + 68] = rMAC;
84204416:	ea f0 12 8e 	M[FP + 72] = r8;
        (uintptr_t)CODEC_NORMAL_DECODE,
        (uintptr_t)celt_data->decoder_data.a2dp_header,
        celt_dec_offload_callback, op_data
    };
#endif /* CELT_DECODE_OFFLOAD */
    bool input_full = FALSE;
8420441a:	40 de       	M[FP + 32] = Null;
    stereo_ptrs write_ptrs = {NULL, NULL};
8420441c:	07 f0 01 f0 	rMAC = Null + 7347948;
84204420:	ec 7a 
84204422:	c2 14       	r0 = FP + 76;
84204424:	0b e8       	r1 = M[rMAC + Null];
84204426:	4c 88       	r2 = M[rMAC + 4];
84204428:	13 ee       	M[r0 + Null] = r1;
8420442a:	54 8e       	M[r0 + 4] = r2;

    if (!cbuffer_calc_amount_space_in_words(celt_data->decoder_data.codec.in_buffer))
8420442c:	32 e8       	r0 = M[r4 + Null];
8420442e:	ff fd ac f1 	call (m) 0x39d88;
84204432:	3b ea 
84204434:	10 04       	Null = r0 - Null;
84204436:	03 62       	if NE jump (m) Lc_celt_decode_process_data_3;

84204438 <Lc_celt_decode_process_data_2>:
    {
        input_full = TRUE;
84204438:	41 20       	rMAC = Null + 1;
8420443a:	41 de       	M[FP + 32] = rMAC;

8420443c <Lc_celt_decode_process_data_3>:
    }

#ifdef CELT_DECODE_OFFLOAD

    if (audio_thread_rpc_is_queued(opid))
8420443c:	3a 00       	r0 = r5 + Null;
8420443e:	ff fd 7d f0 	call (m) 0x13f5e;
84204442:	21 e9 
84204444:	10 04       	Null = r0 - Null;
84204446:	05 60       	if EQ jump (m) Lc_celt_decode_process_data_5;

84204448 <Lc_celt_decode_process_data_4>:
    {
        celt_data->kicks_pending = TRUE;
84204448:	41 20       	rMAC = Null + 1;
8420444a:	61 f0 aa 8e 	M[r4 + 680] = rMAC;
        return;
8420444e:	c4 6e       	jump (m) Lc_celt_decode_process_data_45;

84204450 <Lc_celt_decode_process_data_5>:
    }

    op_offset_pre_dec = cbuffer_get_write_offset(decoder_data->op_out_left);
84204450:	f2 89       	r0 = M[r4 + 28];
84204452:	ff fd 7f f0 	call (m) 0x14420;
84204456:	2f ee 
84204458:	10 09       	r6 = r0 + Null;

    celt_data->clone_input->read_ptr = decoder_data->codec.in_buffer->read_ptr;
8420445a:	31 e8       	rMAC = M[r4 + Null];
8420445c:	62 f0 a9 88 	r0 = M[r4 + 676];
84204460:	49 88       	rMAC = M[rMAC + 4];
84204462:	51 8e       	M[r0 + 4] = rMAC;

    decoder_data->op_out_left->write_ptr = decoder_data->codec.out_left_buffer->write_ptr;
84204464:	71 88       	rMAC = M[r4 + 4];
84204466:	f2 89       	r0 = M[r4 + 28];
84204468:	89 88       	rMAC = M[rMAC + 8];
8420446a:	91 8e       	M[r0 + 8] = rMAC;
    if (decoder_data->op_out_right != NULL)
8420446c:	31 98       	rMAC = M[r4 + 32];
8420446e:	04 60       	if EQ jump (m) Lc_celt_decode_process_data_7;

84204470 <Lc_celt_decode_process_data_6>:
    {
        decoder_data->op_out_right->write_ptr = decoder_data->codec.out_right_buffer->write_ptr;
84204470:	b2 88       	r0 = M[r4 + 8];
84204472:	92 88       	r0 = M[r0 + 8];
84204474:	8a 8e       	M[rMAC + 8] = r0;

84204476 <Lc_celt_decode_process_data_7>:
    }

    decoder_data->codec.in_buffer->write_ptr = celt_data->clone_input->write_ptr;
84204476:	61 f0 a9 88 	rMAC = M[r4 + 676];
8420447a:	32 e8       	r0 = M[r4 + Null];
8420447c:	89 88       	rMAC = M[rMAC + 8];
8420447e:	91 8e       	M[r0 + 8] = rMAC;

    if ((BUF_DESC_IN_PLACE(decoder_data->op_out_left->descriptor) != 0) && (decoder_data->op_out_left->aux_ptr != NULL))
84204480:	f2 89       	r0 = M[r4 + 28];
84204482:	51 89       	rMAC = M[r0 + 20];
84204484:	c9 c6       	rMAC = rMAC AND 0x10000;
84204486:	07 60       	if EQ jump (m) Lc_celt_decode_process_data_10;

84204488 <Lc_celt_decode_process_data_8>:
84204488:	11 89       	rMAC = M[r0 + 16];
8420448a:	05 60       	if EQ jump (m) Lc_celt_decode_process_data_10;

8420448c <Lc_celt_decode_process_data_9>:
    {
        tCbuffer *tail = (tCbuffer *)decoder_data->op_out_left->aux_ptr;
        decoder_data->codec.out_left_buffer->read_ptr = tail->read_ptr;
8420448c:	49 88       	rMAC = M[rMAC + 4];
8420448e:	72 88       	r0 = M[r4 + 4];
84204490:	51 8e       	M[r0 + 4] = rMAC;
84204492:	04 6e       	jump (m) Lc_celt_decode_process_data_11;

84204494 <Lc_celt_decode_process_data_10>:
    }
    else
    {
        decoder_data->codec.out_left_buffer->read_ptr = decoder_data->op_out_left->read_ptr;
84204494:	51 88       	rMAC = M[r0 + 4];
84204496:	72 88       	r0 = M[r4 + 4];
84204498:	51 8e       	M[r0 + 4] = rMAC;

8420449a <Lc_celt_decode_process_data_11>:
    }

    if (decoder_data->op_out_right != NULL)
8420449a:	32 98       	r0 = M[r4 + 32];
8420449c:	0d 60       	if EQ jump (m) Lc_celt_decode_process_data_16;

8420449e <Lc_celt_decode_process_data_12>:
    {
        if ((BUF_DESC_IN_PLACE(decoder_data->op_out_right->descriptor) != 0) && (decoder_data->op_out_right->aux_ptr != NULL))
8420449e:	51 89       	rMAC = M[r0 + 20];
842044a0:	c9 c6       	rMAC = rMAC AND 0x10000;
842044a2:	07 60       	if EQ jump (m) Lc_celt_decode_process_data_15;

842044a4 <Lc_celt_decode_process_data_13>:
842044a4:	11 89       	rMAC = M[r0 + 16];
842044a6:	05 60       	if EQ jump (m) Lc_celt_decode_process_data_15;

842044a8 <Lc_celt_decode_process_data_14>:
        {
            tCbuffer *tail = (tCbuffer *)decoder_data->op_out_right->aux_ptr;
            decoder_data->codec.out_right_buffer->read_ptr = tail->read_ptr;
842044a8:	49 88       	rMAC = M[rMAC + 4];
842044aa:	b2 88       	r0 = M[r4 + 8];
842044ac:	51 8e       	M[r0 + 4] = rMAC;
842044ae:	04 6e       	jump (m) Lc_celt_decode_process_data_16;

842044b0 <Lc_celt_decode_process_data_15>:
        }
        else
        {
            decoder_data->codec.out_right_buffer->read_ptr = decoder_data->op_out_right->read_ptr;
842044b0:	51 88       	rMAC = M[r0 + 4];
842044b2:	b2 88       	r0 = M[r4 + 8];
842044b4:	51 8e       	M[r0 + 4] = rMAC;

842044b6 <Lc_celt_decode_process_data_16>:
        }
    }

    op_offset_post_dec = cbuffer_get_write_offset(decoder_data->op_out_left);
842044b6:	f2 89       	r0 = M[r4 + 28];
842044b8:	ff fd 7f f0 	call (m) 0x14420;
842044bc:	29 eb 
842044be:	17 00       	r5 = r0 + Null;
#endif

    /* Checks for enough data and enough output space are done at the top of
     * this function so it's not done in this C code as well. */

    a2dp_decode_buffer_get_write_ptrs(&(celt_data->decoder_data), &write_ptrs);
842044c0:	c3 14       	r1 = FP + 76;
842044c2:	32 00       	r0 = r4 + Null;
842044c4:	ef fd de ff 	call (m) 0x24a;
842044c8:	27 ec 
    /* Checks for enough data and enough output space are done at the top of
     * this function so it's not done in this C code as well. */


#ifdef CELT_DECODE_OFFLOAD
    if (celt_data->offload_enabled)
842044ca:	60 f0 ab 88 	Null = M[r4 + 684];
842044ce:	06 60       	if EQ jump (m) Lc_celt_decode_process_data_18;

842044d0 <Lc_celt_decode_process_data_17>:
    {
        thread_offload_queue_rpc(&rpc_data);
842044d0:	c2 12       	r0 = FP + 44;
842044d2:	ff fd 7d f0 	call (m) 0x13fa6;
842044d6:	35 e6 
842044d8:	08 6e       	jump (m) Lc_celt_decode_process_data_19;

842044da <Lc_celt_decode_process_data_18>:
    else
    {
        a2dp_decoder_decode(&(celt_data->decoder_data.codec),
                             celt_data->decoder_data.decode_frame,
                             CODEC_NORMAL_DECODE,
                             celt_data->decoder_data.a2dp_header);
842044da:	75 98       	r3 = M[r4 + 36];
842044dc:	33 a8       	r1 = M[r4 + 64];
842044de:	04 00       	r2 = Null + Null;
842044e0:	32 00       	r0 = r4 + Null;
842044e2:	ff fd 9d f1 	call (m) 0x37f16;
842044e6:	35 e1 

842044e8 <Lc_celt_decode_process_data_19>:
    }

    /* total data processed on the input */
    if (op_offset_post_dec >= op_offset_pre_dec)
842044e8:	8f f7 00 c2 	Null = r5 - r6;
842044ec:	04 64       	if NC jump (m) Lc_celt_decode_process_data_21;

842044ee <Lc_celt_decode_process_data_20>:
    {
        output_samples = op_offset_post_dec - op_offset_pre_dec;
842044ee:	00 f8 37 c2 	r5 = r5 - r6;
842044f2:	08 6e       	jump (m) Lc_celt_decode_process_data_22;

842044f4 <Lc_celt_decode_process_data_21>:
    }
    else
    {
        unsigned buffsize = cbuffer_get_size_in_words(decoder_data->op_out_left);
842044f4:	f2 89       	r0 = M[r4 + 28];
842044f6:	ff fd 7f f0 	call (m) 0x14450;
842044fa:	3b ea 
        output_samples = buffsize + op_offset_post_dec - op_offset_pre_dec;
842044fc:	d1 01       	rMAC = r0 + r5;
842044fe:	8f f1 07 c2 	r5 = rMAC - r6;

84204502 <Lc_celt_decode_process_data_22>:
                            CODEC_NORMAL_DECODE,
                            celt_data->decoder_data.a2dp_header);
    output_samples = celt_data->decoder_data.codec.num_output_samples;
#endif /* CELT_DECODE_OFFLOAD */

    if (output_samples > 0)
84204502:	38 04       	Null = r5 - Null;
84204504:	4f 60       	if EQ jump (m) Lc_celt_decode_process_data_40;

84204506 <Lc_celt_decode_process_data_23>:
    {
        /* Source 0 is always touched */
        unsigned touched_sources = TOUCHED_SOURCE_0;
84204506:	09 71       	r7 = Null + 1;
        unsigned b4idx, afteridx;
        metadata_tag *mtag;
        tCbuffer *src, *dst;

#ifdef CELT_DECODE_OFFLOAD
        src = celt_data->clone_input;
84204508:	62 f0 a9 88 	r0 = M[r4 + 676];
#else
        src = celt_data->decoder_data.codec.in_buffer;
#endif

        dst = celt_data->decoder_data.metadata_op_buffer;
8420450c:	68 f0 12 88 	r6 = M[r4 + 72];
        processed = celt_data->codec_data.frame_size;
84204510:	33 a9       	r1 = M[r4 + 80];

        mtag = buff_metadata_remove(src, processed, &b4idx, &afteridx);
84204512:	85 12       	r3 = FP + 40;
84204514:	44 12       	r2 = FP + 36;
84204516:	ff fd 82 f0 	call (m) 0x149ca;
8420451a:	35 e5 
 *
 * \return TRUE if the buffer supports metadata. FALSE if it doesn't.
 */
static inline bool buff_has_metadata(tCbuffer *buff)
{
    if (buff->metadata != NULL)
8420451c:	81 f0 06 88 	rMAC = M[r6 + 24];
84204520:	56 60       	if EQ jump (m) Lc_celt_decode_process_data_44;

84204522 <Lc_celt_decode_process_data_24>:
            unsigned output_octets;
            /* TODO In the current implementation of timestamp insertion (RTP decode) each packet
             * will have a tag (with timestamp) so it makes sense to check if this condition
             * is not true. In the future the decoder should support timestamp insertion
             * in case if not all packet has tags.*/
            if (mtag != NULL)
84204522:	10 04       	Null = r0 - Null;
84204524:	1b 60       	if EQ jump (m) Lc_celt_decode_process_data_31;

84204526 <Lc_celt_decode_process_data_25>:
            {
                if ( IS_TIMESTAMPED_TAG(mtag))
84204526:	51 88       	rMAC = M[r0 + 4];
84204528:	13 f0 30 00 	r1 = rMAC AND 0x30;
8420452c:	1a 60       	if EQ jump (m) Lc_celt_decode_process_data_32;

8420452e <Lc_celt_decode_process_data_26>:
8420452e:	c9 c2       	rMAC = rMAC AND 0x40;
84204530:	18 62       	if NE jump (m) Lc_celt_decode_process_data_32;

84204532 <Lc_celt_decode_process_data_27>:
                {
                    PL_ASSERT(b4idx == 0);
84204532:	48 d8       	Null = M[FP + 36];
84204534:	09 60       	if EQ jump (m) Lc_celt_decode_process_data_29;

84204536 <Lc_celt_decode_process_data_28>:
84204536:	03 f0 5a 43 	r1 = Null + 858;
8420453a:	02 f0 13 60 	r0 = Null + 4115;
8420453e:	ff fd 95 f0 	call (m) 0x16ff0;
84204542:	33 e5 
84204544:	49 6e       	jump (m) Lc_celt_decode_process_data_45;

84204546 <Lc_celt_decode_process_data_29>:
                    PL_ASSERT(mtag->next == NULL);
84204546:	11 e8       	rMAC = M[r0 + Null];
84204548:	0c 60       	if EQ jump (m) Lc_celt_decode_process_data_32;

8420454a <Lc_celt_decode_process_data_30>:
8420454a:	03 f0 5b 43 	r1 = Null + 859;
8420454e:	02 f0 13 60 	r0 = Null + 4115;
84204552:	ff fd 95 f0 	call (m) 0x16ff0;
84204556:	3f e4 
84204558:	3f 6e       	jump (m) Lc_celt_decode_process_data_45;

8420455a <Lc_celt_decode_process_data_31>:
            else
            {
                /* produce one tag per frame
                   NB. this is an invented tag, no timestamps, nor other private data,
                   it only serves the purpose of removing at audio EP TODO TTP */
                mtag = buff_metadata_new_tag();
8420455a:	ff fd 7f f0 	call (m) 0x1454e;
8420455e:	35 ef 

84204560 <Lc_celt_decode_process_data_32>:
            }
            /* decoded output will have different frame lengths */
            output_octets = output_samples * OCTETS_PER_SAMPLE;
84204560:	7d 54       	r3 = r5 LSHIFT 2;
            if (mtag != NULL)
84204562:	10 04       	Null = r0 - Null;
84204564:	06 60       	if EQ jump (m) Lc_celt_decode_process_data_34;

84204566 <Lc_celt_decode_process_data_33>:
            {
                mtag->length = output_octets;
84204566:	d5 8e       	M[r0 + 12] = r3;
                METADATA_PACKET_START_SET(mtag);
84204568:	51 88       	rMAC = M[r0 + 4];
8420456a:	c9 c8       	rMAC = rMAC OR 0x4;
                METADATA_PACKET_END_SET(mtag);
8420456c:	49 c9       	rMAC = rMAC OR 0x8;
8420456e:	51 8e       	M[r0 + 4] = rMAC;

84204570 <Lc_celt_decode_process_data_34>:
            }
            buff_metadata_append(dst, mtag, 0, output_octets);
84204570:	04 00       	r2 = Null + Null;
84204572:	13 00       	r1 = r0 + Null;
84204574:	42 08       	r0 = r6 + Null;
84204576:	ff fd 81 f0 	call (m) 0x147b8;
8420457a:	23 e2 

8420457c <Lc_celt_decode_process_data_35>:
            buff_metadata_delete_tag(mtag, TRUE);
        }
#endif      /* INSTALL_METADATA */

        /* Handle mono/stereo fade-out */
        if (a2dp_decode_check_and_perform_fadeout(&(celt_data->decoder_data), output_samples, &write_ptrs))
8420457c:	c4 14       	r2 = FP + 76;
8420457e:	3b 00       	r1 = r5 + Null;
84204580:	32 00       	r0 = r4 + Null;
84204582:	ef fd de ff 	call (m) 0x27a;
84204586:	39 e7 
84204588:	10 04       	Null = r0 - Null;
8420458a:	07 60       	if EQ jump (m) Lc_celt_decode_process_data_37;

8420458c <Lc_celt_decode_process_data_36>:
        {
                common_send_simple_unsolicited_message(op_data, OPMSG_REPLY_ID_FADEOUT_DONE);
8420458c:	13 f0 00 40 	r1 = Null + 8192;
84204590:	52 08       	r0 = r8 + Null;
84204592:	ef fd df ff 	call (m) 0x586;
84204596:	35 ef 

84204598 <Lc_celt_decode_process_data_37>:
            }

       /* If stereo outputs are connected then source 1 was touched as well */
       if (celt_data->decoder_data.codec.out_right_buffer != NULL)
84204598:	b1 88       	rMAC = M[r4 + 8];
8420459a:	02 60       	if EQ jump (m) Lc_celt_decode_process_data_39;

8420459c <Lc_celt_decode_process_data_38>:
       {
           touched_sources |= TOUCHED_SOURCE_1;
8420459c:	19 71       	r7 = Null + 3;

8420459e <Lc_celt_decode_process_data_39>:
       }

       /* Source(s) touched */
       touched->sources = touched_sources;
8420459e:	b9 f0 00 ee 	M[r9 + Null] = r7;

842045a2 <Lc_celt_decode_process_data_40>:
         * after having consumed from a full buffer. In cases where the endpoint should kick an
         * upstream entity this is useful so the upstream entity can be notified of more space.
         * In other cases it helps to get data into the decoder as quickly as possible.
         */
    if ((cbuffer_calc_amount_data_in_words(celt_data->decoder_data.codec.in_buffer) < MAX_CELT_FRAME_SIZE_IN_WORDS) ||
        (input_full && cbuffer_calc_amount_space_in_words(celt_data->decoder_data.codec.in_buffer)))
842045a2:	32 e8       	r0 = M[r4 + Null];
842045a4:	ff fd ac f1 	call (m) 0x39dd4;
842045a8:	31 e1 
842045aa:	20 f0 00 2c 	Null = r0 - 1024;
842045ae:	09 64       	if NC jump (m) Lc_celt_decode_process_data_43;

842045b0 <Lc_celt_decode_process_data_41>:
842045b0:	41 d8       	rMAC = M[FP + 32];
842045b2:	12 60       	if EQ jump (m) Lc_celt_decode_process_data_45;

842045b4 <Lc_celt_decode_process_data_42>:
842045b4:	32 e8       	r0 = M[r4 + Null];
842045b6:	ff fd ab f1 	call (m) 0x39d88;
842045ba:	33 ee 
842045bc:	10 04       	Null = r0 - Null;
842045be:	0c 60       	if EQ jump (m) Lc_celt_decode_process_data_45;

842045c0 <Lc_celt_decode_process_data_43>:
    {
        touched->sinks |= TOUCHED_SINK_0;
842045c0:	b1 f0 01 88 	rMAC = M[r9 + 4];
842045c4:	09 c8       	rMAC = rMAC OR 0x1;
842045c6:	b1 f0 01 8e 	M[r9 + 4] = rMAC;
842045ca:	06 6e       	jump (m) Lc_celt_decode_process_data_45;

842045cc <Lc_celt_decode_process_data_44>:
            }
            buff_metadata_append(dst, mtag, 0, output_octets);
        }
        else
        {
            buff_metadata_delete_tag(mtag, TRUE);
842045cc:	4b 08       	r1 = r7 + Null;
842045ce:	ff fd 7f f0 	call (m) 0x1459c;
842045d2:	2f ee 
842045d4:	d4 6f       	jump (m) Lc_celt_decode_process_data_35;

842045d6 <Lc_celt_decode_process_data_45>:

#ifdef INSTALL_CELT_DATA_TEST
    /* Kick the input to get it going */
    touched->sinks |= TOUCHED_SINK_0;
#endif
}
842045d6:	73 4c       	SP = SP + -52;
842045d8:	f6 48       	popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
842045da:	d8 4c       	rts;

842045dc <$_celt_decode_buffer_details>:
 * response
 */

bool celt_decode_buffer_details(OPERATOR_DATA *op_data, void *message_data,
                                    unsigned *response_id, void **response_data)
{
842045dc:	c8 1c       	pushm <FP(=SP), rLink>;
    patch_fn_shared(celt_decode_wrapper);

    return a2dp_decode_buffer_details_core(op_data, message_data,response_id, response_data,CELT_DECODE_INPUT_BUFFER_SIZE,CELT_DECODE_OUTPUT_BUFFER_SIZE,0);
842045de:	00 f0 30 cf 	push Null;
842045e2:	04 f0 50 e0 	push Null + 1024;
842045e6:	04 f0 50 e0 	push Null + 1024;
842045ea:	ef fd dd ff 	call (m) 0x186;
842045ee:	3d ec 
842045f0:	7d 4c       	SP = SP + -12;

842045f2 <Lc_celt_decode_buffer_details_2>:
}
842045f2:	c8 48       	popm <FP, rLink>;
842045f4:	d8 4c       	rts;

842045f6 <$_celt_decode_connect>:
    return TRUE;
}

bool celt_decode_connect(OPERATOR_DATA *op_data, void *message_data,
                                unsigned *response_id, void **response_data)
{
842045f6:	f4 1c       	pushm <FP(=SP), r4, r5, r6, r7, rLink>;
842045f8:	17 00       	r5 = r0 + Null;
842045fa:	18 09       	r6 = r1 + Null;
842045fc:	29 09       	r7 = r3 + Null;
Private Function Declarations
*/

static inline CELT_DEC_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (CELT_DEC_OP_DATA *) base_op_get_instance_data(op_data);
842045fe:	ef fd df ff 	call (m) 0x4e6;
84204602:	29 e7 
84204604:	16 00       	r4 = r0 + Null;
    CELT_DEC_OP_DATA *celt_data = get_instance_data(op_data);
    A2DP_DECODER_PARAMS *decoder_data = &celt_data->decoder_data;
    unsigned terminal_id;

    /* Check that the capability is not running */
    if (opmgr_op_is_running(op_data))
84204606:	3a 00       	r0 = r5 + Null;
84204608:	ff fd 08 f0 	call (m) 0x5700;
8420460c:	39 e7 
8420460e:	10 04       	Null = r0 - Null;
84204610:	09 60       	if EQ jump (m) Lc_celt_decode_connect_3;

84204612 <Lc_celt_decode_connect_2>:
    {
        return base_op_build_std_response_ex(op_data, STATUS_CMD_FAILED, response_data);
84204612:	03 f0 00 60 	r1 = Null + 4096;
84204616:	4c 08       	r2 = r7 + Null;
84204618:	3a 00       	r0 = r5 + Null;
8420461a:	ef fd df ff 	call (m) 0x4bc;
8420461e:	23 e5 
84204620:	2c 6e       	jump (m) Lc_celt_decode_connect_16;

84204622 <Lc_celt_decode_connect_3>:
    }

    if (!base_op_build_std_response_ex(op_data, STATUS_OK, response_data))
84204622:	03 00       	r1 = Null + Null;
84204624:	4c 08       	r2 = r7 + Null;
84204626:	3a 00       	r0 = r5 + Null;
84204628:	ef fd df ff 	call (m) 0x4bc;
8420462c:	35 e4 
8420462e:	10 04       	Null = r0 - Null;
84204630:	03 62       	if NE jump (m) Lc_celt_decode_connect_5;

84204632 <Lc_celt_decode_connect_4>:
    {
        return FALSE;
84204632:	02 00       	r0 = Null + Null;
84204634:	22 6e       	jump (m) Lc_celt_decode_connect_16;

84204636 <Lc_celt_decode_connect_5>:
    }

    terminal_id = ((unsigned *)message_data)[0];

    switch (terminal_id)
84204636:	81 f0 00 e8 	rMAC = M[r6 + Null];
8420463a:	0d 60       	if EQ jump (m) Lc_celt_decode_connect_10;

8420463c <Lc_celt_decode_connect_6>:
8420463c:	48 24       	Null = rMAC - 1;
8420463e:	14 60       	if EQ jump (m) Lc_celt_decode_connect_13;

84204640 <Lc_celt_decode_connect_7>:
84204640:	00 f2 10 f0 	Null = rMAC - 8388608;
84204644:	00 24 
84204646:	05 62       	if NE jump (m) Lc_celt_decode_connect_9;

84204648 <Lc_celt_decode_connect_8>:
    {
        case INPUT_TERMINAL_ID:
            celt_data->clone_input = (tCbuffer*)(((uintptr_t *)message_data)[1]);
84204648:	81 f0 01 88 	rMAC = M[r6 + 4];
8420464c:	61 f0 a9 8e 	M[r4 + 676] = rMAC;

84204650 <Lc_celt_decode_connect_9>:
#endif /* INSTALL_METADATA */

            break;
        /* NB No default as can't happen */
    }
    return TRUE;
84204650:	42 20       	r0 = Null + 1;
84204652:	13 6e       	jump (m) Lc_celt_decode_connect_16;

84204654 <Lc_celt_decode_connect_10>:
    {
        case INPUT_TERMINAL_ID:
            celt_data->clone_input = (tCbuffer*)(((uintptr_t *)message_data)[1]);
            break;
        case LEFT_OUT_TERMINAL_ID:
            decoder_data->op_out_left = (tCbuffer*)(((uintptr_t *)message_data)[1]);
84204654:	81 f0 01 88 	rMAC = M[r6 + 4];
84204658:	f1 8f       	M[r4 + 28] = rMAC;
#ifdef INSTALL_METADATA
            if (decoder_data->metadata_op_buffer == NULL)
8420465a:	b2 a8       	r0 = M[r4 + 72];
8420465c:	fa 63       	if NE jump (m) Lc_celt_decode_connect_9;

8420465e <Lc_celt_decode_connect_11>:
8420465e:	8a 89       	r0 = M[rMAC + 24];
84204660:	f8 61       	if EQ jump (m) Lc_celt_decode_connect_9;

84204662 <Lc_celt_decode_connect_12>:
            {
                if (buff_has_metadata(decoder_data->op_out_left))
                {
                    decoder_data->metadata_op_buffer = decoder_data->op_out_left;
84204662:	b1 ae       	M[r4 + 72] = rMAC;
84204664:	f6 6f       	jump (m) Lc_celt_decode_connect_9;

84204666 <Lc_celt_decode_connect_13>:
            }
#endif /* INSTALL_METADATA */

            break;
        case RIGHT_OUT_TERMINAL_ID:
            decoder_data->op_out_right = (tCbuffer*)(((uintptr_t *)message_data)[1]);
84204666:	81 f0 01 88 	rMAC = M[r6 + 4];
8420466a:	31 9e       	M[r4 + 32] = rMAC;
#ifdef INSTALL_METADATA
            if (decoder_data->metadata_op_buffer == NULL)
8420466c:	b2 a8       	r0 = M[r4 + 72];
8420466e:	f1 63       	if NE jump (m) Lc_celt_decode_connect_9;

84204670 <Lc_celt_decode_connect_14>:
84204670:	8a 89       	r0 = M[rMAC + 24];
84204672:	ef 61       	if EQ jump (m) Lc_celt_decode_connect_9;

84204674 <Lc_celt_decode_connect_15>:
            {
                if (buff_has_metadata(decoder_data->op_out_right))
                {
                    decoder_data->metadata_op_buffer = decoder_data->op_out_right;
84204674:	b1 ae       	M[r4 + 72] = rMAC;
84204676:	ed 6f       	jump (m) Lc_celt_decode_connect_9;

84204678 <Lc_celt_decode_connect_16>:

            break;
        /* NB No default as can't happen */
    }
    return TRUE;
}
84204678:	f4 48       	popm <FP, r4, r5, r6, r7, rLink>;
8420467a:	d8 4c       	rts;

8420467c <$_celt_decode_disconnect>:

bool celt_decode_disconnect(OPERATOR_DATA *op_data, void *message_data,
                                    unsigned *response_id, void **response_data)
{
8420467c:	f4 1c       	pushm <FP(=SP), r4, r5, r6, r7, rLink>;
8420467e:	10 09       	r6 = r0 + Null;
84204680:	1f 00       	r5 = r1 + Null;
84204682:	29 09       	r7 = r3 + Null;
Private Function Declarations
*/

static inline CELT_DEC_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (CELT_DEC_OP_DATA *) base_op_get_instance_data(op_data);
84204684:	ef fd df ff 	call (m) 0x4e6;
84204688:	23 e3 
8420468a:	16 00       	r4 = r0 + Null;
bool celt_decode_disconnect(OPERATOR_DATA *op_data, void *message_data,
                                    unsigned *response_id, void **response_data)
{
    CELT_DEC_OP_DATA *celt_data = get_instance_data(op_data);
    A2DP_DECODER_PARAMS *decoder_data = &celt_data->decoder_data;
    unsigned terminal_id = ((unsigned *)message_data)[0];
8420468c:	3f e8       	r5 = M[r5 + Null];

    /* Check that the capability is not running, Only the sink can be
     * disconnected whilst running!*/
    if (opmgr_op_is_running(op_data))
8420468e:	42 08       	r0 = r6 + Null;
84204690:	ff fd 08 f0 	call (m) 0x5700;
84204694:	31 e3 
84204696:	10 04       	Null = r0 - Null;
84204698:	0d 60       	if EQ jump (m) Lc_celt_decode_disconnect_4;

8420469a <Lc_celt_decode_disconnect_2>:
    {
        if (terminal_id != INPUT_TERMINAL_ID )
8420469a:	00 f2 70 f0 	Null = r5 - 8388608;
8420469e:	00 24 
842046a0:	09 60       	if EQ jump (m) Lc_celt_decode_disconnect_4;

842046a2 <Lc_celt_decode_disconnect_3>:
        {
            return base_op_build_std_response_ex(op_data, STATUS_CMD_FAILED, response_data);
842046a2:	03 f0 00 60 	r1 = Null + 4096;
842046a6:	4c 08       	r2 = r7 + Null;
842046a8:	42 08       	r0 = r6 + Null;
842046aa:	ef fd df ff 	call (m) 0x4bc;
842046ae:	33 e0 
842046b0:	24 6e       	jump (m) Lc_celt_decode_disconnect_17;

842046b2 <Lc_celt_decode_disconnect_4>:
        }
    }

    if (!base_op_build_std_response_ex(op_data, STATUS_OK, response_data))
842046b2:	03 00       	r1 = Null + Null;
842046b4:	4c 08       	r2 = r7 + Null;
842046b6:	42 08       	r0 = r6 + Null;
842046b8:	ef fd df ff 	call (m) 0x4bc;
842046bc:	25 e0 
842046be:	10 04       	Null = r0 - Null;
842046c0:	03 62       	if NE jump (m) Lc_celt_decode_disconnect_6;

842046c2 <Lc_celt_decode_disconnect_5>:
    {
        return FALSE;
842046c2:	02 00       	r0 = Null + Null;
842046c4:	1a 6e       	jump (m) Lc_celt_decode_disconnect_17;

842046c6 <Lc_celt_decode_disconnect_6>:
    }

    switch (terminal_id)
842046c6:	38 04       	Null = r5 - Null;
842046c8:	0a 60       	if EQ jump (m) Lc_celt_decode_disconnect_10;

842046ca <Lc_celt_decode_disconnect_7>:
842046ca:	78 24       	Null = r5 - 1;
842046cc:	0f 60       	if EQ jump (m) Lc_celt_decode_disconnect_13;

842046ce <Lc_celt_decode_disconnect_8>:
842046ce:	00 f2 70 f0 	Null = r5 - 8388608;
842046d2:	00 24 
842046d4:	11 62       	if NE jump (m) Lc_celt_decode_disconnect_16;

842046d6 <Lc_celt_decode_disconnect_9>:
    {
        case INPUT_TERMINAL_ID:
            celt_data->clone_input = NULL;
842046d6:	60 f0 a9 8e 	M[r4 + 676] = Null;
            break;
842046da:	0e 6e       	jump (m) Lc_celt_decode_disconnect_16;

842046dc <Lc_celt_decode_disconnect_10>:
        case LEFT_OUT_TERMINAL_ID:
#ifdef INSTALL_METADATA
            if (decoder_data->metadata_op_buffer == decoder_data->op_out_left)
842046dc:	b1 a8       	rMAC = M[r4 + 72];
842046de:	f2 89       	r0 = M[r4 + 28];
842046e0:	88 04       	Null = rMAC - r0;
842046e2:	02 62       	if NE jump (m) Lc_celt_decode_disconnect_12;

842046e4 <Lc_celt_decode_disconnect_11>:
            {
                decoder_data->metadata_op_buffer = NULL;
842046e4:	b0 ae       	M[r4 + 72] = Null;

842046e6 <Lc_celt_decode_disconnect_12>:
            }
#endif /* INSTALL_METADATA */

            decoder_data->op_out_left = NULL;
842046e6:	f0 8f       	M[r4 + 28] = Null;
            break;
842046e8:	07 6e       	jump (m) Lc_celt_decode_disconnect_16;

842046ea <Lc_celt_decode_disconnect_13>:
        case RIGHT_OUT_TERMINAL_ID:
#ifdef INSTALL_METADATA
            if (decoder_data->metadata_op_buffer == decoder_data->op_out_right)
842046ea:	b1 a8       	rMAC = M[r4 + 72];
842046ec:	32 98       	r0 = M[r4 + 32];
842046ee:	88 04       	Null = rMAC - r0;
842046f0:	02 62       	if NE jump (m) Lc_celt_decode_disconnect_15;

842046f2 <Lc_celt_decode_disconnect_14>:
            {
                decoder_data->metadata_op_buffer = NULL;
842046f2:	b0 ae       	M[r4 + 72] = Null;

842046f4 <Lc_celt_decode_disconnect_15>:
            }
#endif /* INSTALL_METADATA */


            decoder_data->op_out_right = NULL;
842046f4:	30 9e       	M[r4 + 32] = Null;

842046f6 <Lc_celt_decode_disconnect_16>:
            break;
        /* NB No default as can't happen */
    }
    return TRUE;
842046f6:	42 20       	r0 = Null + 1;

842046f8 <Lc_celt_decode_disconnect_17>:
}
842046f8:	f4 48       	popm <FP, r4, r5, r6, r7, rLink>;
842046fa:	d8 4c       	rts;

842046fc <$_celt_decode_start>:
}

#ifdef CELT_DECODE_OFFLOAD

bool celt_decode_start(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
842046fc:	f4 1c       	pushm <FP(=SP), r4, r5, r6, r7, rLink>;
842046fe:	17 00       	r5 = r0 + Null;
84204700:	20 09       	r6 = r2 + Null;
84204702:	29 09       	r7 = r3 + Null;
Private Function Declarations
*/

static inline CELT_DEC_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (CELT_DEC_OP_DATA *) base_op_get_instance_data(op_data);
84204704:	ef fd de ff 	call (m) 0x4e6;
84204708:	23 ef 
8420470a:	16 00       	r4 = r0 + Null;
{
    CELT_DEC_OP_DATA *celt_data = get_instance_data(op_data);
    A2DP_DECODER_PARAMS *decoder_data = &celt_data->decoder_data;
    unsigned buffer_flags;

    *response_id = OPCMD_START;
8420470c:	81 20       	rMAC = Null + 2;
8420470e:	81 f0 00 ee 	M[r6 + Null] = rMAC;

    /* Create the response. If there aren't sufficient resources for this fail
     * early. */
    if (!base_op_build_std_response_ex(op_data, STATUS_OK, response_data))
84204712:	03 00       	r1 = Null + Null;
84204714:	4c 08       	r2 = r7 + Null;
84204716:	3a 00       	r0 = r5 + Null;
84204718:	ef fd de ff 	call (m) 0x4bc;
8420471c:	25 ed 
8420471e:	10 04       	Null = r0 - Null;
84204720:	03 62       	if NE jump (m) Lc_celt_decode_start_3;

84204722 <Lc_celt_decode_start_2>:
    {
        return FALSE;
84204722:	02 00       	r0 = Null + Null;
84204724:	60 6e       	jump (m) Lc_celt_decode_start_12;

84204726 <Lc_celt_decode_start_3>:
    }

    if (opmgr_op_is_running(op_data))
84204726:	3a 00       	r0 = r5 + Null;
84204728:	ff fd 07 f0 	call (m) 0x5700;
8420472c:	39 ee 
8420472e:	10 04       	Null = r0 - Null;
84204730:	0b 62       	if NE jump (m) Lc_celt_decode_start_7;

84204732 <Lc_celt_decode_start_4>:
        return TRUE;
    }

    /* At least the sink and the 1st source need to be connected. TODO in
     * stereo mode 2 sources should be connected. */
    if (!(celt_data->clone_input != NULL && decoder_data->op_out_left != NULL))
84204732:	62 f0 a9 88 	r0 = M[r4 + 676];
84204736:	03 60       	if EQ jump (m) Lc_celt_decode_start_6;

84204738 <Lc_celt_decode_start_5>:
84204738:	f1 89       	rMAC = M[r4 + 28];
8420473a:	08 62       	if NE jump (m) Lc_celt_decode_start_8;

8420473c <Lc_celt_decode_start_6>:
 * \param  response_data Pointer to the pointer to message that is allocated in the function.
 * \param  new_status  A status ID that is to be sent in the message.
 */
inline static void base_op_change_response_status(void **response_data, STATUS_KYMERA new_status)
{
    (((OP_STD_RSP *)(*response_data))->status = new_status);
8420473c:	01 f0 00 60 	rMAC = Null + 4096;
84204740:	92 f0 00 e8 	r0 = M[r7 + Null];
84204744:	51 8e       	M[r0 + 4] = rMAC;

84204746 <Lc_celt_decode_start_7>:
    }

    if (opmgr_op_is_running(op_data))
    {
        /* Operator already started nothing to do. */
        return TRUE;
84204746:	42 20       	r0 = Null + 1;
84204748:	4e 6e       	jump (m) Lc_celt_decode_start_12;

8420474a <Lc_celt_decode_start_8>:
8420474a:	91 89       	rMAC = M[r0 + 24];
8420474c:	46 62       	if NE jump (m) Lc_celt_decode_start_11;

8420474e <Lc_celt_decode_start_9>:
#endif /* INSTALL_METADATA */

    /* Make copies of the connection buffers to give to the codec library
     * This runs asynchronously, so can't use the buffers visible externally 
     */
    buffer_flags = celt_data->clone_input->descriptor;
8420474e:	62 f0 a9 88 	r0 = M[r4 + 676];
84204752:	57 89       	r5 = M[r0 + 20];
    decoder_data->codec.in_buffer = cbuffer_create( celt_data->clone_input->base_addr,
                    cbuffer_get_size_in_words(celt_data->clone_input), buffer_flags);
84204754:	ff fd 7e f0 	call (m) 0x14450;
84204758:	3d e7 
8420475a:	13 00       	r1 = r0 + Null;
8420475c:	61 f0 a9 88 	rMAC = M[r4 + 676];
84204760:	ca 88       	r0 = M[rMAC + 12];
84204762:	3c 00       	r2 = r5 + Null;
84204764:	ff fd 7d f0 	call (m) 0x1429c;
84204768:	39 e9 
8420476a:	32 ee       	M[r4 + Null] = r0;

    decoder_data->codec.in_buffer->read_ptr = celt_data->clone_input->read_ptr;
8420476c:	61 f0 a9 88 	rMAC = M[r4 + 676];
84204770:	32 e8       	r0 = M[r4 + Null];
84204772:	49 88       	rMAC = M[rMAC + 4];
84204774:	51 8e       	M[r0 + 4] = rMAC;
    decoder_data->codec.in_buffer->write_ptr = celt_data->clone_input->write_ptr;
84204776:	61 f0 a9 88 	rMAC = M[r4 + 676];
8420477a:	32 e8       	r0 = M[r4 + Null];
8420477c:	89 88       	rMAC = M[rMAC + 8];
8420477e:	91 8e       	M[r0 + 8] = rMAC;

    buffer_flags = decoder_data->op_out_left->descriptor;
84204780:	f2 89       	r0 = M[r4 + 28];
84204782:	57 89       	r5 = M[r0 + 20];
    decoder_data->codec.out_left_buffer = cbuffer_create( decoder_data->op_out_left->base_addr,
                    cbuffer_get_size_in_words(decoder_data->op_out_left), buffer_flags);
84204784:	ff fd 7e f0 	call (m) 0x14450;
84204788:	2d e6 
8420478a:	13 00       	r1 = r0 + Null;
8420478c:	f1 89       	rMAC = M[r4 + 28];
8420478e:	ca 88       	r0 = M[rMAC + 12];
84204790:	3c 00       	r2 = r5 + Null;
84204792:	ff fd 7d f0 	call (m) 0x1429c;
84204796:	2b e8 
84204798:	72 8e       	M[r4 + 4] = r0;

    decoder_data->codec.out_left_buffer->read_ptr =  decoder_data->op_out_left->read_ptr;
8420479a:	f1 89       	rMAC = M[r4 + 28];
8420479c:	72 88       	r0 = M[r4 + 4];
8420479e:	49 88       	rMAC = M[rMAC + 4];
842047a0:	51 8e       	M[r0 + 4] = rMAC;
    decoder_data->codec.out_left_buffer->write_ptr =  decoder_data->op_out_left->write_ptr;
842047a2:	f1 89       	rMAC = M[r4 + 28];
842047a4:	72 88       	r0 = M[r4 + 4];
842047a6:	89 88       	rMAC = M[rMAC + 8];
842047a8:	91 8e       	M[r0 + 8] = rMAC;

    /* Right output doesn't need to be connected */
    if (decoder_data->op_out_right != NULL)
842047aa:	32 98       	r0 = M[r4 + 32];
842047ac:	cd 61       	if EQ jump (m) Lc_celt_decode_start_7;

842047ae <Lc_celt_decode_start_10>:
    {
        buffer_flags = decoder_data->op_out_right->descriptor;
842047ae:	57 89       	r5 = M[r0 + 20];
        decoder_data->codec.out_right_buffer = cbuffer_create( decoder_data->op_out_right->base_addr,
                        cbuffer_get_size_in_words(decoder_data->op_out_right), buffer_flags);
842047b0:	ff fd 7e f0 	call (m) 0x14450;
842047b4:	21 e5 
842047b6:	13 00       	r1 = r0 + Null;
842047b8:	31 98       	rMAC = M[r4 + 32];
842047ba:	ca 88       	r0 = M[rMAC + 12];
842047bc:	3c 00       	r2 = r5 + Null;
842047be:	ff fd 7d f0 	call (m) 0x1429c;
842047c2:	3f e6 
842047c4:	b2 8e       	M[r4 + 8] = r0;

        decoder_data->codec.out_right_buffer->read_ptr =  decoder_data->op_out_right->read_ptr;
842047c6:	31 98       	rMAC = M[r4 + 32];
842047c8:	b2 88       	r0 = M[r4 + 8];
842047ca:	49 88       	rMAC = M[rMAC + 4];
842047cc:	51 8e       	M[r0 + 4] = rMAC;
        decoder_data->codec.out_right_buffer->write_ptr =  decoder_data->op_out_right->write_ptr;
842047ce:	31 98       	rMAC = M[r4 + 32];
842047d0:	b2 88       	r0 = M[r4 + 8];
842047d2:	89 88       	rMAC = M[rMAC + 8];
842047d4:	91 8e       	M[r0 + 8] = rMAC;
842047d6:	b8 6f       	jump (m) Lc_celt_decode_start_7;

842047d8 <Lc_celt_decode_start_11>:
#ifdef INSTALL_METADATA
    /* Any input metadata should have been configured as 2 octets per sample by
     * the source. Refuse to start if metadata is present and this is not the case. */
    if (buff_has_metadata(celt_data->clone_input))
    {
        if(ENCODED_DATA_OCTETS_IN_WORD != cbuffer_get_usable_octets(celt_data->clone_input))
842047d8:	ff fd 7d f0 	call (m) 0x14384;
842047dc:	2d ed 
842047de:	10 25       	Null = r0 - 4;
842047e0:	ae 63       	if NE jump (m) Lc_celt_decode_start_6;

842047e2 <Lc__ite_3>:
842047e2:	b6 6f       	jump (m) Lc_celt_decode_start_9;

842047e4 <Lc_celt_decode_start_12>:
        decoder_data->codec.out_right_buffer->read_ptr =  decoder_data->op_out_right->read_ptr;
        decoder_data->codec.out_right_buffer->write_ptr =  decoder_data->op_out_right->write_ptr;
    }

    return TRUE;
}
842047e4:	f4 48       	popm <FP, r4, r5, r6, r7, rLink>;
842047e6:	d8 4c       	rts;

842047e8 <$_celt_decode_stop_reset>:

bool celt_decode_stop_reset(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
842047e8:	f4 1c       	pushm <FP(=SP), r4, r5, r6, r7, rLink>;
842047ea:	17 00       	r5 = r0 + Null;
842047ec:	29 09       	r7 = r3 + Null;
Private Function Declarations
*/

static inline CELT_DEC_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (CELT_DEC_OP_DATA *) base_op_get_instance_data(op_data);
842047ee:	ef fd de ff 	call (m) 0x4e6;
842047f2:	39 e7 
842047f4:	10 09       	r6 = r0 + Null;

bool celt_decode_stop_reset(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
    CELT_DEC_OP_DATA *celt_data = get_instance_data(op_data);
    A2DP_DECODER_PARAMS *decoder_data = &celt_data->decoder_data;
    INT_OP_ID opid = base_op_get_int_op_id(op_data);
842047f6:	3a 00       	r0 = r5 + Null;
842047f8:	ef fd de ff 	call (m) 0x4f0;
842047fc:	39 e7 
842047fe:	16 00       	r4 = r0 + Null;

    /* Create the response. If there aren't sufficient resources for this fail
     * early. */
    if (!base_op_build_std_response_ex(op_data, STATUS_OK, response_data))
84204800:	03 00       	r1 = Null + Null;
84204802:	4c 08       	r2 = r7 + Null;
84204804:	3a 00       	r0 = r5 + Null;
84204806:	ef fd de ff 	call (m) 0x4bc;
8420480a:	37 e5 
8420480c:	10 04       	Null = r0 - Null;
8420480e:	03 62       	if NE jump (m) Lc_celt_decode_stop_reset_3;

84204810 <Lc_celt_decode_stop_reset_2>:
    {
        return FALSE;
84204810:	02 00       	r0 = Null + Null;
84204812:	21 6e       	jump (m) Lc_celt_decode_stop_reset_6;

84204814 <Lc_celt_decode_stop_reset_3>:
    }

    /* Mark the operator as stopped. */
    base_op_stop_operator(op_data);
84204814:	3a 00       	r0 = r5 + Null;
84204816:	ef fd de ff 	call (m) 0x54a;
8420481a:	35 e9 

8420481c <Lc_celt_decode_stop_reset_4>:

    /* Wait for any processing to finish */
    while (audio_thread_rpc_is_queued(opid));
8420481c:	32 00       	r0 = r4 + Null;
8420481e:	ff fd 7b f0 	call (m) 0x13f5e;
84204822:	21 ea 
84204824:	10 04       	Null = r0 - Null;
84204826:	fb 63       	if NE jump (m) Lc_celt_decode_stop_reset_4;

84204828 <Lc_celt_decode_stop_reset_5>:

    /* Free the buffers that were allocated in the start handler */
    cbuffer_destroy_struct(decoder_data->codec.in_buffer);
84204828:	82 f0 00 e8 	r0 = M[r6 + Null];
8420482c:	ff fd 7d f0 	call (m) 0x143cc;
84204830:	21 ed 
    decoder_data->codec.in_buffer = NULL;
84204832:	80 f0 00 ee 	M[r6 + Null] = Null;

    cbuffer_destroy_struct(decoder_data->codec.out_left_buffer);
84204836:	82 f0 01 88 	r0 = M[r6 + 4];
8420483a:	ff fd 7d f0 	call (m) 0x143cc;
8420483e:	33 ec 
    decoder_data->codec.out_left_buffer = NULL;
84204840:	80 f0 01 8e 	M[r6 + 4] = Null;

    cbuffer_destroy_struct(decoder_data->codec.out_right_buffer);
84204844:	82 f0 02 88 	r0 = M[r6 + 8];
84204848:	ff fd 7d f0 	call (m) 0x143cc;
8420484c:	25 ec 
    decoder_data->codec.out_right_buffer = NULL;
8420484e:	80 f0 02 8e 	M[r6 + 8] = Null;
    
    return TRUE;
84204852:	42 20       	r0 = Null + 1;

84204854 <Lc_celt_decode_stop_reset_6>:
}
84204854:	f4 48       	popm <FP, r4, r5, r6, r7, rLink>;
84204856:	d8 4c       	rts;

84204858 <$_celt_dec_opmsg_set_encoding_params>:
    /* Kick the input to get it going */
    touched->sinks |= TOUCHED_SINK_0;
#endif
}
bool celt_dec_opmsg_set_encoding_params(OPERATOR_DATA *op_data, void *message_data, unsigned int *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84204858:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
8420485a:	17 00       	r5 = r0 + Null;
8420485c:	1e 00       	r4 = r1 + Null;
Private Function Declarations
*/

static inline CELT_DEC_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (CELT_DEC_OP_DATA *) base_op_get_instance_data(op_data);
8420485e:	ef fd de ff 	call (m) 0x4e6;
84204862:	29 e4 
84204864:	10 09       	r6 = r0 + Null;
{
 
   CELT_DEC_OP_DATA *celt_data = get_instance_data(op_data);
   patch_fn_shared(celt_decode_wrapper);
   
    if (opmgr_op_is_running(op_data))
84204866:	3a 00       	r0 = r5 + Null;
84204868:	ff fd 07 f0 	call (m) 0x5700;
8420486c:	39 e4 
8420486e:	10 04       	Null = r0 - Null;
84204870:	03 60       	if EQ jump (m) Lc_celt_dec_opmsg_set_encoding_params_3;

84204872 <Lc_celt_dec_opmsg_set_encoding_params_2>:
    {
     /* Can't change params while running */
       return (FALSE);
84204872:	02 00       	r0 = Null + Null;
84204874:	19 6e       	jump (m) Lc_celt_dec_opmsg_set_encoding_params_5;

84204876 <Lc_celt_dec_opmsg_set_encoding_params_3>:
    }

    /* Check that the message recieved is the correct length. No checking for
     * stupid configurations though this might be nice to have. */
    if (OPMGR_GET_OPMSG_LENGTH((OP_MSG_REQ *)message_data) != OPMSG_CELT_ENC_SET_ENCODING_PARAMS_WORD_SIZE)
84204876:	71 88       	rMAC = M[r4 + 4];
84204878:	08 25       	Null = rMAC - 4;
8420487a:	fc 63       	if NE jump (m) Lc_celt_dec_opmsg_set_encoding_params_2;

8420487c <Lc_celt_dec_opmsg_set_encoding_params_4>:
    {
        return FALSE;
    }

    /* Populate the CELT DEC  structure with the new fields */
    celt_data->codec_data.dec_mode = OPMSG_FIELD_GET(message_data, OPMSG_CELT_ENC_SET_ENCODING_PARAMS, MODE);
8420487c:	f1 88       	rMAC = M[r4 + 12];
8420487e:	89 c6       	rMAC = rMAC AND 0xffff;
84204880:	81 f0 a2 8e 	M[r6 + 648] = rMAC;
    celt_data->codec_data.frame_size = OPMSG_FIELD_GET(message_data, OPMSG_CELT_ENC_SET_ENCODING_PARAMS, FRAME_SIZE);
84204884:	31 89       	rMAC = M[r4 + 16];
84204886:	89 c6       	rMAC = rMAC AND 0xffff;
84204888:	81 f0 14 8e 	M[r6 + 80] = rMAC;
    celt_data->codec_data.channels = OPMSG_FIELD_GET(message_data, OPMSG_CELT_ENC_SET_ENCODING_PARAMS, CHANNELS);
8420488c:	71 89       	rMAC = M[r4 + 20];
8420488e:	89 c6       	rMAC = rMAC AND 0xffff;
84204890:	81 f0 15 8e 	M[r6 + 84] = rMAC;
    celt_decode_lib_init(&(celt_data->decoder_data.codec));
84204894:	42 08       	r0 = r6 + Null;
84204896:	db ff 3e ee 	call $_celt_decode_lib_init;
8420489a:	81 f0 ab 88 	rMAC = M[r6 + 684];
8420489e:	f1 ff f8 ff 	if NE call $_celt_setup_thread_offload;
842048a2:	32 e4 
    CELT_SETUP_OFFLOAD_IF_ENABLED();
   
    return TRUE;
842048a4:	42 20       	r0 = Null + 1;

842048a6 <Lc_celt_dec_opmsg_set_encoding_params_5>:
}
842048a6:	f3 48       	popm <FP, r4, r5, r6, rLink>;
842048a8:	d8 4c       	rts;

842048aa <Lc_free_data_1>:
 * CELT_decode capability.
 *
 * \param op_data Pointer to the operator instance data.
 */
static void free_data(OPERATOR_DATA *op_data)
{
842048aa:	f1 1c       	pushm <FP(=SP), r4, rLink>;
Private Function Declarations
*/

static inline CELT_DEC_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (CELT_DEC_OP_DATA *) base_op_get_instance_data(op_data);
842048ac:	ef fd de ff 	call (m) 0x4e6;
842048b0:	3b e1 
842048b2:	16 00       	r4 = r0 + Null;
    mem_table_free_shared((void *)(&(celt_data->codec_data)),
                    celt_dec_shared_malloc_table, CELT_DEC_SHARED_TABLE_LENGTH);
#endif

#ifdef CELT_DECODE_OFFLOAD
    if (celt_data->offload_enabled)
842048b4:	60 f0 ab 88 	Null = M[r4 + 684];
842048b8:	0b 60       	if EQ jump (m) Lc_free_data_3;

842048ba <Lc_free_data_2>:
    {
        mem_table_free_shared((void *)(&(celt_data->codec_data)),
                                celt_dec_offload_shared_malloc_table, CELT_OFFLOAD_MALLOC_TABLE_LENGTH);
842048ba:	84 20       	r2 = Null + 2;
842048bc:	07 f0 03 f0 	r1 = Null + 7347920;
842048c0:	d0 7a 
842048c2:	62 f0 4c 20 	r0 = r4 + 76;
842048c6:	ef fd e9 ff 	call (m) 0x1c5e;
842048ca:	39 ec 
842048cc:	0a 6e       	jump (m) Lc_free_data_4;

842048ce <Lc_free_data_3>:
    }
    else
    {
        mem_table_free((void *)(&(celt_data->codec_data)),
                                celt_dec_offload_malloc_table, CELT_OFFLOAD_MALLOC_TABLE_LENGTH);
842048ce:	84 20       	r2 = Null + 2;
842048d0:	07 f0 03 f0 	r1 = Null + 7347936;
842048d4:	e0 7a 
842048d6:	62 f0 4c 20 	r0 = r4 + 76;
842048da:	ef fd e9 ff 	call (m) 0x1c0c;
842048de:	33 e9 

842048e0 <Lc_free_data_4>:
    }
#endif

    /* free non-shared memory */
    mem_table_free((void *)(&(celt_data->codec_data)), celt_dec_malloc_table,
                                                CELT_DEC_MALLOC_TABLE_LENGTH);
842048e0:	04 21       	r2 = Null + 4;
842048e2:	07 f0 03 f0 	r1 = Null + 7347896;
842048e6:	b8 7a 
842048e8:	62 f0 4c 20 	r0 = r4 + 76;
842048ec:	ef fd e9 ff 	call (m) 0x1c0c;
842048f0:	21 e9 
    
    celt_free_decoder_twiddle();
842048f2:	dc ff 22 ec 	call $_celt_free_decoder_twiddle;

842048f6 <Lc_free_data_5>:

}
842048f6:	f1 48       	popm <FP, r4, rLink>;
842048f8:	d8 4c       	rts;

842048fa <Lc_free_data_and_fail_1>:
 *
 * \param op_data Pointer to the operator instance data.
 * \param response Pointer to the response message to give a failed status
 */
static void free_data_and_fail(OPERATOR_DATA *op_data, void **response)
{
842048fa:	f1 1c       	pushm <FP(=SP), r4, rLink>;
842048fc:	1e 00       	r4 = r1 + Null;
    patch_fn_shared(celt_decode_wrapper);

    /* Free the data and then override the response message status to fail */
    free_data(op_data);
842048fe:	d6 4f       	call (m) Lc_free_data_1;
84204900:	01 f0 00 60 	rMAC = Null + 4096;
84204904:	32 e8       	r0 = M[r4 + Null];
84204906:	51 8e       	M[r0 + 4] = rMAC;

84204908 <Lc_free_data_and_fail_2>:
    base_op_change_response_status(response, STATUS_CMD_FAILED);
}
84204908:	f1 48       	popm <FP, r4, rLink>;
8420490a:	d8 4c       	rts;

8420490c <Lc_celt_dec_offload_callback_1>:
 * to the data processing function. That then propagates metadata from the 
 * previous iteration and schedules a new one.
 */

static void celt_dec_offload_callback(void *context)
{
8420490c:	f1 1c       	pushm <FP(=SP), r4, rLink>;
8420490e:	16 00       	r4 = r0 + Null;
Private Function Declarations
*/

static inline CELT_DEC_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (CELT_DEC_OP_DATA *) base_op_get_instance_data(op_data);
84204910:	ef fd dd ff 	call (m) 0x4e6;
84204914:	37 ee 
static void celt_dec_offload_callback(void *context)
{
    OPERATOR_DATA *op_data = (OPERATOR_DATA*) context;
    CELT_DEC_OP_DATA *celt_data = get_instance_data(op_data);

    if ((celt_data->kicks_pending) || (celt_data->decoder_data.codec.num_output_samples > 0))
84204916:	20 f0 aa 88 	Null = M[r0 + 680];
8420491a:	03 62       	if NE jump (m) Lc_celt_dec_offload_callback_3;

8420491c <Lc_celt_dec_offload_callback_2>:
8420491c:	10 89       	Null = M[r0 + 16];
8420491e:	07 60       	if EQ jump (m) Lc_celt_dec_offload_callback_4;

84204920 <Lc_celt_dec_offload_callback_3>:
    {
        celt_data->kicks_pending = FALSE;
84204920:	20 f0 aa 8e 	M[r0 + 680] = Null;
        opmgr_kick_operator(op_data);
84204924:	32 00       	r0 = r4 + Null;
84204926:	ef fd f7 ff 	call (m) 0x374a;
8420492a:	25 e1 

8420492c <Lc_celt_dec_offload_callback_4>:
    }
}
8420492c:	f1 48       	popm <FP, r4, rLink>;
8420492e:	d8 4c       	rts;

84204930 <$_populate_celt_asm_funcs>:

$_populate_celt_asm_funcs:

   LIBS_PUSH_REGS_SLOW_SW_ROM_PATCH_POINT($CELT.CELT_ASM.CELT.POPULATE_CELT_ASM_FUNCS.PATCH_ID_0)     // celt_patchers

   r2 = $celt.frame_decode;
84204930:	42 f0 04 f0 	r2 = Null + 69206676;
84204934:	94 42 
   M[r0] = r2;
84204936:	84 ee       	M[Null + r0] = r2;
   r3 = NULL;
84204938:	05 00       	r3 = Null + Null;
   M[r1] = r2;
8420493a:	c4 ee       	M[Null + r1] = r2;
   rts;
8420493c:	d8 4c       	rts;

8420493e <$kdc_start>:
.MODULE $M.kdc_start;
.CODESEGMENT PM;
.DATASEGMENT DM;

$kdc_start:
r0 = $_celt_decode_cap_data;
8420493e:	07 f0 02 f0 	r0 = Null + 7347792;
84204942:	50 7a 
    /* Force this symbol to be exported in ELF */
    Null = $___kymera_debug_map_addr;
84204944:	20 f0 f8 42 	Null = Null + 17144;

84204948 <$_thread_offload_update_p1_dm_location>:
.CODESEGMENT PM;
.MINIM;

$_thread_offload_update_p1_dm_location:
#ifdef ENTRY_POINT_THREAD_OFFLOAD_UPDATE_P1_MEM_LOCATION
    rMAC = M[$_patched_fw_version];
84204948:	01 f1 00 88 	rMAC = M[Null + 0x2000];
    Null = rMAC - PATCH_BUILD_ID;
8420494c:	00 f0 10 f2 	Null = rMAC - 10276;
84204950:	24 34 
    if EQ jump ENTRY_POINT_THREAD_OFFLOAD_UPDATE_P1_MEM_LOCATION;
84204952:	fb ff b0 ff 	if EQ jump (m) 0x400215e;
84204956:	8d e0 

84204958 <$M.download_support_lib.thread_offload_update_p1_dm_location.L_pb_mismatch>:
#endif
L_pb_mismatch:
    /* Stub: return (uintptr_t 0); */
    r0 = 0;
84204958:	02 00       	r0 = Null + Null;
    rts;
8420495a:	d8 4c       	rts;
